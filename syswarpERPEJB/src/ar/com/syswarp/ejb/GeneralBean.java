package ar.com.syswarp.ejb;

import java.rmi.RemoteException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.ejb.CreateException;
import javax.ejb.Stateless;

import java.io.*;
import java.sql.*;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.SimpleDateFormat;

import javax.mail.Message;
import javax.sql.*;
import java.util.*;
import org.apache.log4j.*;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import java.lang.*;
import java.lang.reflect.Method;
import java.math.BigDecimal;

import net.sf.jasperreports.view.JasperViewer;
import net.sf.jasperreports.engine.*;

// lectura de xml
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;

import org.w3c.dom.Document;
import org.w3c.dom.DOMException;

import bsh.EvalError;
import bsh.Interpreter;

//--- security
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import sun.misc.BASE64Encoder;
import sun.misc.CharacterEncoder;

@Stateless
public class GeneralBean implements General {

	/** The session context */
	private SessionContext context;

	/* conexion a la base de datos */
	private Connection dbconn;

	static Logger log = Logger.getLogger(GeneralBean.class);

	private Connection conexion;

	private Properties props;

	private String url;

	private String db;

	private String clase;

	private String usuario;

	private String clave;

	// public
	private Long idayuda;

	private String referencia;

	private String ayuda;

	private String imagen;

	//
	private String imagenescustompath;

	private String imagencustomintro;

	private String imagencustommenu;

	private String imagenescustomapppath;

	private String imagenescustomapprelativepath;

	// 

	private String jaspercustompath;

	private String jaspercustomapppath;

	private String blobSqlPath;

	private String reportes;

	private String reportecsv;

	public GeneralBean() {
		super();
		try {
			props = new Properties();
			props.load(GeneralBean.class
					.getResourceAsStream("system.properties"));

			url = props.getProperty("conn.url").trim();
			clase = props.getProperty("conn.clase").trim();
			usuario = props.getProperty("conn.usuario").trim();
			clave = props.getProperty("conn.clave").trim();
			imagenescustompath = props.getProperty("imagenescustom.path")
					.trim();
			imagenescustomapppath = props.getProperty("imagenescustomapp.path")
					.trim();
			imagenescustomapprelativepath = props.getProperty(
					"imagenescustomapp.relativepath").trim();
			imagencustomintro = props.getProperty("imagencustom.intro").trim();
			imagencustommenu = props.getProperty("imagencustom.menu").trim();

			jaspercustompath = props.getProperty("jaspercustom.path").trim();
			jaspercustomapppath = props.getProperty("jaspercustomapp.path")
					.trim();

			blobSqlPath = props.getProperty("blob.sql.path").trim();

			reportes = props.getProperty("reportes.path").trim();

			reportecsv = props.getProperty("reportes.path").trim();

			// Mueve imagenes customizadas dentro la aplicaci�n.
			copyDir(imagenescustompath, imagenescustomapppath);

			// Mueve plantillas de reportes customizadas dentro la aplicaci�n.
			copyDir(jaspercustompath, jaspercustomapppath);

			Class.forName(clase);
			conexion = DriverManager.getConnection(url, usuario, clave);
			this.dbconn = conexion;
		} catch (java.lang.ClassNotFoundException cnfException) {
			log.error("Error driver : " + cnfException);
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (IOException IOException) {
			log.error("Error SQL: " + IOException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
	}

	public GeneralBean(Connection dbconn) {
		this.dbconn = dbconn;
	}

	public void SetDB(String db) {
		try {

		} catch (Exception ex) {
			log.error("SetDB( String db ) -  Salida por exception: " + ex);
		}
	}

	/**
	 * Set the associated session context. The container calls this method after
	 * the instance creation.
	 * 
	 * The enterprise bean instance should store the reference to the context
	 * object in an instance variable.
	 * 
	 * This method is called with no transaction context.
	 * 
	 * @throws EJBException
	 *             Thrown if method fails due to system-level error.
	 */
	public void setSessionContext(SessionContext newContext)
			throws EJBException {
		context = newContext;
	}

	public void ejbRemove() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbActivate() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbPassivate() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbCreate() throws CreateException {
		// TODO Add ejbCreate method implementation
	}

	public static Connection getTransaccionConn(String _class, String _url,
			String _user, String _clave) throws EJBException {

		// --> Intentar Generacion conexion aislada
		Connection conn = null;
		int r = 1;
		while (r < 6) {
			try {
				Class.forName(_class);
				conn = DriverManager.getConnection(_url, _user, _clave);
			} catch (Exception e) {
				log.warn("getTransaccionConn(): Intento de conexion nro. " + r
						+ " a base de datos  no concretado. ");
			}

			if (conn != null) {
				break;
			}
			r++;
		}
		// <--
		return conn;
	}

	public static BigDecimal setNull(BigDecimal valor, int umbral) {
		return valor.longValue() < umbral ? null : valor;
	}

	public static String setNull(String valor) {

		if (valor != null) {

			if (valor.trim().equals(""))
				valor = null;
			else if (valor.trim().equalsIgnoreCase("null"))
				valor = null;
		}

		return valor;
	}

	// TODO: revisar si es necesario sobrecargar getTotalEntidad con idempresa
	public long getTotalEntidad(String entidad) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidad()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidad()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidad()- Salida por exception: " + ex);
		}
		return total;
	}

	// private List getLista(String query) throws EJBException {
	private List getLista(String query) {
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(query);
			ResultSetMetaData md = rsSalida.getMetaData();
			// log.info("A-METODO LLAMADA:" + getCallingMethodName());
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
			if (rsSalida != null) {
				rsSalida.close();
				rsSalida = null;
				md = null;
			}
		} catch (SQLException sqlException) {
			log
					.error("(SQLE) getLista(String query) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName() + " : "
							+ sqlException);
			// throw new EJBException(
			// "getLista() - SQLException:  -- >: throw new EJBException ");
		} catch (Exception ex) {
			log.error("(EX) getLista(String query) - INVOCADO POR "
					+ GeneralBean.getCallingMethodName() + " : " + ex);

			// throw new EJBException(
			// "getLista() - Exception:  -- >: throw new EJBException ");
		}
		return vecSalida;
	}

	private static List getLista(String query, Connection conn) {
		List vecSalida = new ArrayList();
		try {

			Statement statement = conn.createStatement();
			ResultSet rsSalida = statement.executeQuery(query);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
			if (rsSalida != null) {
				rsSalida.close();
				rsSalida = null;
				md = null;
			}
		} catch (SQLException sqlException) {

			log.info("QUERY: " + query);
			log
					.error("(SQLE) getLista(String query, Connection conn) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName()
							+ " : "
							+ sqlException);

		} catch (Exception ex) {
			log.info("QUERY: " + query);
			log
					.error("(EX) getLista(String query, Connection conn) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName() + " : " + ex);

		}
		return vecSalida;
	}

	public long getTotalEntidadOcu(String entidad, String[] campos,
			String ocurrencia) throws EJBException {

		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += like;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadOcu()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadOcu()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadFiltro(String entidad, String filtro,
			BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " "
				+ filtro + " AND idempresa = " + idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadFiltro()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadFiltro()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadFiltro()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadRelacion(String entidad, String[] campos,
			String[] ocurrencia) throws EJBException {

		/**
		 * Entidad: ???????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad de registros desde una tabla de
		 *             relacion para un id en particualar.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String filtro = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				filtro += campos[i] + " = " + ocurrencia[i] + " ";
				if (i + 1 < len)
					filtro += " AND ";
			}
			cQuery += filtro;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadRelacion()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadRelacion()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadRelacion()- Salida por exception: " + ex);
		}
		return total;
	}

	public List getVariables(String idempresa) throws EJBException {
		/**
		 * Entidad: SetupVariables
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer todas las variables del sistema para
		 *             setearlas en session
		 */
		ResultSet rsSalida = null;
		String cQuery = "Select * from setupvariables where idempresa = "
				+ idempresa;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return vecSalida;
	}

	public int getPermisos(String usuario, String formulario) {
		/**
		 * Entidad:
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : Resolver el permiso de un usuario en una
		 *             determinada actividad.
		 * 
		 *             TODO: APUNTAR A LA TABLA QUE CORRESPONDA UNA VEZ QUE ESTE
		 *             LISTO!.
		 * 
		 */
		try {
			Statement statement = dbconn.createStatement();
			String cQuery = "Select * from setupvariables where variable ='"
					+ formulario + "'";
			ResultSet rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next()) {
				return rsSalida.getInt("valor");
			}
			return -1;
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
			return -1;
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
			return -1;
		}
	}

	public byte[] getReporteSimplePDF(String cQuery, String cReporteXML,
			String pathReporte) throws EJBException {
		/**
		 * Entidad: General
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : realizar un pdf simple
		 */
		ResultSet rsReporte = null;
		byte[] bytes = null;
		try {
			Statement statement = dbconn.createStatement();
			rsReporte = statement.executeQuery(cQuery);
			JRResultSetDataSource jrRS = new JRResultSetDataSource(rsReporte);
			System.setProperty("jasper.reports.compile.class.path", pathReporte
					+ "/WEB-INF/lib/jasperreports-1.2.0.jar"
					+ System.getProperty("path.separator") + pathReporte
					+ "/WEB-INF/classes/");
			System.setProperty("jasper.reports.compile.temp", pathReporte
					+ "/reportes");
			JasperCompileManager.compileReportToFile(pathReporte + "/reportes/"
					+ cReporteXML + ".jrxml");
			File reportFile = new File(pathReporte + "/reportes/" + cReporteXML
					+ ".jasper");
			Map parameters = new HashMap();
			bytes = JasperRunManager.runReportToPdf(reportFile.getPath(),
					parameters, jrRS);
			/*
			 * esta parte va en la pagina
			 * response.setContentType("application/pdf");
			 * response.setContentLength(bytes.length); ServletOutputStream
			 * ouputStream = response.getOutputStream();
			 * ouputStream.write(bytes, 0, bytes.length); ouputStream.flush();
			 * ouputStream.close(); System.out.println("jasperPDF
			 * OK.............."); System.out.println("Fin del reporte
			 * ...........");
			 */

		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);

		} catch (JRException e) {
			System.out.println("Error:" + e.getMessage());

		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return bytes;
	}

	// -------------------------------------------------------------

	// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// todos los Meses
	public List getGlobalMeses() throws EJBException {
		/**
		 * Entidad: Contable Global Meses
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer todos los Meses existentes
		 */
		ResultSet rsSalida = null;
		String cQuery = "Select * from Globalmeses";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return vecSalida;
	}

	// Metodos de casteo de fechas

	public Timestamp StrToTimestampDDMMYYYY(String dateEntered) {
		SimpleDateFormat FORMAT = new SimpleDateFormat("dd'/'MM'/'yyyy");
		try {
			return new java.sql.Timestamp(FORMAT.parse(dateEntered).getTime());
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
			return null;
		}
	}

	public Timestamp StrToTimestampDDMMYYYYHHMISE(String dateEntered) {
		SimpleDateFormat FORMAT = new SimpleDateFormat(
				"yyyy'-'MM'-'dd hh':'mm':'ss");
		try {
			return new java.sql.Timestamp(FORMAT.parse(dateEntered).getTime());
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
			return null;
		}
	}

	public String TimestampToStrDDMMYYYY(Timestamp timestamp) {
		String str = "";
		Calendar date = new GregorianCalendar();
		date.setTime(timestamp);
		try {
			str = date.get(Calendar.DATE) < 10 ? ("0" + date.get(Calendar.DATE) + "/")
					: (date.get(Calendar.DATE) + "/");
			str += date.get(Calendar.MONTH) < 10 ? "0"
					+ (date.get(Calendar.MONTH) + 1 + "/") : (date
					.get(Calendar.MONTH) + 1)
					+ "/";
			str += date.get(Calendar.YEAR);

		} catch (Exception exT) {
			log.error(" Exception:   " + exT);
		}
		return str;
	}

	public static float Round(float Rval, int Rpl) {

		float p = (float) Math.pow(10, Rpl);
		Rval = Rval * p;
		float tmp = Math.round(Rval);

		return (float) tmp / p;
	}

	public String getNumeroFormateado(float numero, int enteros, int decimales) {
		String salida = "";
		String mask = "";

		for (int i = 0; i < enteros; i++)
			mask += "#";

		if (decimales > 0)
			mask += ".";
		for (int i = 0; i < decimales; i++)
			mask += "0";

		DecimalFormat df = new DecimalFormat(mask);
		DecimalFormatSymbols dfs = new DecimalFormatSymbols();
		dfs.setDecimalSeparator('.');
		df.setDecimalFormatSymbols(dfs);
		if (numero == 0)
			salida = "0";
		else
			salida = df.format(numero).toString();
		return salida;
	}

	public String colorSaldo(Object objeto, String clasePos, String claseNeg)
			throws EJBException {
		String clase = clasePos;
		try {
			if (objeto instanceof Float) {
				Float valor = (Float) objeto;
				if (valor.floatValue() < 0) {
					clase = claseNeg;
				}
			} else if (objeto instanceof Integer) {
				Integer valor = (Integer) objeto;
				if (valor.intValue() < 0) {
					clase = claseNeg;
				}
			} else {
				String valor = (String) objeto;
				if (Float.parseFloat(valor) < 0) {
					clase = claseNeg;
				}
			}
		} catch (Exception ex) {
			clase = "";
			log.info("salida por Exception [ colorSaldo() ]:" + ex);
		}
		return clase;
	}

	// ayudas

	public ResultSet getAyudaPk(Long pk) throws EJBException {
		ResultSet rsSalida = null;

		try {
			String _url = props.getProperty("connHelp.url").trim();
			String _class = props.getProperty("connHelp.clase").trim();
			String _usuario = props.getProperty("connHelp.usuario").trim();
			String _clave = props.getProperty("connHelp.clave").trim();
			String _help = props.getProperty("help").trim();
			String cQuery = "Select * from " + _help + " where idayuda = " + pk;
			Connection conexion;
			Class.forName(_class);
			conexion = DriverManager.getConnection(_url, _usuario, _clave);
			Statement statement = conexion.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next()) {
				setIdayuda(new Long(rsSalida.getLong("idayuda")));
				setReferencia(rsSalida.getString("referencia"));
				setAyuda(rsSalida.getString("ayuda"));
				setImagen(rsSalida.getString("imagen"));
			}

		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return rsSalida;
	}

	public Long getIdayuda() {
		return idayuda;
	}

	public String getReferencia() {
		return referencia;
	}

	public String getAyuda() {
		return ayuda;
	}

	public String getImagen() {
		return imagen;
	}

	public void setAyuda(String ayuda) {
		this.ayuda = ayuda;
	}

	public void setIdayuda(Long idayuda) {
		this.idayuda = idayuda;
	}

	public void setImagen(String imagen) {
		this.imagen = imagen;
	}

	public void setReferencia(String referencia) {
		this.referencia = referencia;
	}

	public int getAyudaMax() throws EJBException {
		int max = 9999;
		try {
			String _url = props.getProperty("connHelp.url").trim();
			String _class = props.getProperty("connHelp.clase").trim();
			String _usuario = props.getProperty("connHelp.usuario").trim();
			String _clave = props.getProperty("connHelp.clave").trim();
			String _help = props.getProperty("help").trim();
			String cQuery = "Select max(idAyuda) as max from " + _help;
			Connection conexion;
			Class.forName(_class);
			conexion = DriverManager.getConnection(_url, _usuario, _clave);
			Statement statement = conexion.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next()) {
				max = rsSalida.getInt("max");
			}

		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return max;
	}

	// ---------------------------------------------------------------------------------------------------------------

	public boolean esNumerico(String num) throws EJBException {
		try {
			Float.parseFloat(num);
			return true;
		} catch (Exception e) {
			// TODO: handle exception
			return false;
		}
	}

	public boolean esEntero(String num) throws EJBException {
		try {
			if (esNumerico(num)) {

				Long.parseLong(num);
				return true;
			} else
				return false;
		} catch (Exception e) {
			// TODO: handle exception
			return false;
		}
	}

	public static String setNotNull(String str) {
		try {
			if (str == null)
				return "";
			else if (str.equalsIgnoreCase("null"))
				return "";
			return str;
		} catch (Exception e) {
			log.error("setNotNull: " + e);
			return "";
		}
	}

	// 20120925 - CAMI - Gestion de Cobranzas
	/*
	 * Tuve que copiar del common esta funcion ya que se planteo una posible
	 * modificacion externa de los tickets, por lo que si modificase desde el
	 * abm,mandaria mails,pero si lo hago por fuera no, por ende estaria mal.
	 * ¿Esta bien que lo copie del common? Idem la funcion del setnotnull, ya
	 * que la usaba la funcion de send mail......
	 */
	public static boolean sendMail(String subject, String body, String to,
			String fromName) {

		boolean isSend = false;

		try {

			Properties props = new Properties();
			props.load(GeneralBean.class
					.getResourceAsStream("envios.properties"));
			String cMailSmtp = setNotNull(props.getProperty("mail.smtpServer"))
					.trim();
			// lo manda el robot
			String cMailFrom = setNotNull(props.getProperty("mail.from"))
					.trim();
			String cMailFromName = fromName == null ? setNotNull(props
					.getProperty("mail.from.name")) : fromName;
			//
			String cMailBCC = setNotNull(props.getProperty("mail.bcc")).trim();
			String cMailUsuario = setNotNull(props.getProperty("mail.usuario"))
					.trim();
			String cMailClave = setNotNull(props.getProperty("mail.clave"))
					.trim();

			String authSmtp = setNotNull(props.getProperty("mail.smtp.auth"))
					.trim();

			String mailer = "JavaMail API";
			// 20121003 - EJV -->
			// props.put("mail.smtp.auth", "true");

			log.info("authSmtp: " + authSmtp);

			props.put("mail.smtp.auth", authSmtp);
			// <--

			javax.mail.Session session = javax.mail.Session.getDefaultInstance(
					props, null);

			javax.mail.Message msg = new javax.mail.internet.MimeMessage(
					session);
			msg.setFrom(new javax.mail.internet.InternetAddress(cMailFrom,
					cMailFromName));

			msg.setRecipients(Message.RecipientType.TO,
					javax.mail.internet.InternetAddress.parse(to, false));

			// 20121003 - EJV -->
			msg.setRecipients(Message.RecipientType.BCC,
					javax.mail.internet.InternetAddress.parse(cMailBCC, false));
			// <--

			msg.setSubject(subject);
			msg.setText(body);
			msg.setHeader("X-Mailer", mailer);
			msg.setSentDate(new java.util.Date());
			javax.mail.Transport transporte = session.getTransport("smtp");
			transporte.connect(cMailSmtp, cMailUsuario, cMailClave);
			msg.saveChanges();
			transporte.sendMessage(msg, msg.getAllRecipients());
			props = null;
			transporte.close();
			isSend = true;

		} catch (IOException ioEx) {
			log.error("Error IO: " + ioEx);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}

		return isSend;
	}

	/**
	 * Por ID contador.
	 * 
	 * 
	 * @TODO: Este metodo deberia ser reemplazado en su totalidad por el que
	 *        recupra y actualiza recibiendo como parametro el NOMBRE del
	 *        contador. 20090317 - EJV.
	 */

	public static BigDecimal getContador(BigDecimal idcontador,
			BigDecimal idempresa, Connection conn) throws EJBException {
		BigDecimal contador = BigDecimal.valueOf(-1);
		ResultSet rsSalida = null;
		try {
			String cQuery = "SELECT valor FROM globalcontadores WHERE idcontador ="
					+ idcontador.toString()
					+ " AND idempresa = "
					+ idempresa.toString();

			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				contador = rsSalida.getBigDecimal("valor");

				cQuery = "UPDATE globalcontadores SET valor = (valor + 1) "
						+ "WHERE idcontador =" + idcontador.toString()
						+ " AND idempresa=" + idempresa.toString();

				int i = statement.executeUpdate(cQuery);
				if (i == 0) {
					contador = BigDecimal.valueOf(-1);
					log.warn("getContador(" + idcontador
							+ ") - Error al actualizar proximo nro contador. ");
				}

			} else {
				log.warn("getContador(" + idcontador
						+ ") - Error al recuperar proximo nro contador. ");
			}
		} catch (SQLException sqlException) {
			log.error("getContador(" + idcontador + ")- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getContador(" + idcontador + ")- Salida por exception: "
					+ ex);
		}
		return contador;
	}

	/**
	 * Por nombre contador ...
	 * 
	 */

	public static BigDecimal getContador(String contador, BigDecimal idempresa,
			Connection conn) throws EJBException {
		BigDecimal valorcontador = BigDecimal.valueOf(-1);
		ResultSet rsSalida = null;
		try {
			String cQuery = "SELECT valor FROM globalcontadores WHERE LOWER(contador) = '"
					+ contador.toLowerCase()
					+ "' AND idempresa = "
					+ idempresa.toString();

			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				valorcontador = rsSalida.getBigDecimal("valor");

				cQuery = "UPDATE globalcontadores SET valor = (valor + 1) "
						+ "WHERE LOWER(contador) ='" + contador.toLowerCase()
						+ "' AND idempresa=" + idempresa.toString();

				int i = statement.executeUpdate(cQuery);
				if (i == 0) {
					valorcontador = new BigDecimal(-1);
					log.warn("getContador(" + contador
							+ ") - Error al actualizar proximo nro contador. ");
				}

			} else {
				log.warn("getContador(" + contador
						+ ") - Error al recuperar proximo nro contador. ");
			}
		} catch (SQLException sqlException) {
			log.error("getContador(String " + contador + ")- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getContador(String " + contador
					+ ")- Salida por exception: " + ex);
		}
		return valorcontador;
	}

	/**
	 * 
	 */

	public static BigDecimal getContadorComprobante(BigDecimal num_cnt,
			BigDecimal sucursal, String tipo, BigDecimal idempresa,
			Connection conn) throws EJBException {
		BigDecimal numero_cnt = BigDecimal.valueOf(-1);
		ResultSet rsSalida = null;
		try {
			String cQuery = "" + "SELECT numero_cnt FROM clientescontaux"
					+ " WHERE num_cnt =" + num_cnt.toString()
					+ "   AND sucursal = " + sucursal.toString()
					+ "   AND tipo = '" + tipo + "' AND idempresa = "
					+ idempresa.toString();

			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				numero_cnt = rsSalida.getBigDecimal("numero_cnt");

				cQuery = "UPDATE clientescontaux "
						+ "  SET numero_cnt = (numero_cnt + 1) "
						+ "WHERE num_cnt =" + num_cnt.toString()
						+ "  AND sucursal = " + sucursal.toString()
						+ "  AND tipo = '" + tipo + "'  AND idempresa = "
						+ idempresa.toString();

				int i = statement.executeUpdate(cQuery);
				if (i == 0) {
					numero_cnt = BigDecimal.valueOf(-1);
					log
							.warn("getContadorComprobante(...) - Error al actualizar proximo nro contador. ");
				}

			} else {
				log
						.warn("getContadorComprobante(...) - Error al recuperar proximo nro contador. ");
			}
		} catch (SQLException sqlException) {
			log.error("getContador(getContadorComprobante(...) - Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getContador(getContadorComprobante(...) - Salida por exception: "
							+ ex);
		}
		return numero_cnt;
	}

	// GLOBAL contadores
	public List getGlobalContadoresAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idcontador,contador,valor,descripcion,nrosucursal FROM GLOBALCONTADORES where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalContadoresAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalContadoresAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalContadoresOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcontador,contador,valor,descripcion,nrosucursal FROM GLOBALCONTADORES "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcontador::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(contador) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalcontadoresOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalcontadoresOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalContadoresPK(BigDecimal idcontador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcontador,contador,valor,descripcion,nrosucursal FROM GLOBALCONTADORES WHERE idcontador="
				+ idcontador.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalcontadoresPK( BigDecimal idcontador ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalcontadoresPK( BigDecimal idcontador )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalContadoresXContador(String contador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT  idcontador,contador,valor,descripcion,nrosucursal "
				+ "  FROM GLOBALCONTADORES WHERE lower(contador)='"
				+ contador.toLowerCase() + "' and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalContadoresXContador( String contador ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalcontadoresPK( String contador )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalContadoresDelete(BigDecimal idcontador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALCONTADORES WHERE idcontador="
				+ idcontador.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALCONTADORES WHERE idcontador="
						+ idcontador.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalcontadoresDelete( BigDecimal idcontador ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalcontadoresDelete( BigDecimal idcontador )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalContadoresCreate(String contador, BigDecimal valor,
			String Descripcion, BigDecimal nrosucursal, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (contador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contador ";
		// 2. sin nada desde la pagina
		if (contador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contador ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALCONTADORES(contador,valor,descripcion,nrosucursal,idempresa,usuarioalt ) VALUES (?,?,?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, contador);
				insert.setBigDecimal(2, valor);
				insert.setString(3, Descripcion);
				insert.setBigDecimal(4, nrosucursal);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalcontadoresCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalcontadoresCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalContadoresCreateOrUpdate(BigDecimal idcontador,
			String contador, BigDecimal valor, String Descripcion,
			BigDecimal nrosucursal, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcontador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcontador ";
		if (contador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contador ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";

		// 2. sin nada desde la pagina
		if (contador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalcontadores WHERE idcontador = "
					+ idcontador.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALCONTADORES SET contador=?, valor=?, descripcion=?, nrosucursal=? WHERE idcontador=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, contador);
					insert.setBigDecimal(2, valor);
					insert.setString(3, Descripcion);
					insert.setBigDecimal(4, nrosucursal);
					insert.setBigDecimal(5, idcontador);
					insert.setBigDecimal(6, idempresa);
				} else {
					String ins = "INSERT INTO GLOBALCONTADORES(contador,valor,descripcion,nrosucursal,idempresa,usuarioalt ) VALUES (?,?,?,?,?,?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, contador);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalcontadoresCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalcontadoresCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalContadoresUpdate(BigDecimal idcontador,
			String contador, BigDecimal valor, String Descripcion,
			BigDecimal nrosucursal, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcontador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcontador ";
		if (contador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contador ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";

		// 2. sin nada desde la pagina
		if (contador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalcontadores WHERE idcontador = "
					+ idcontador.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALCONTADORES SET contador=?, valor=?, descripcion=?, nrosucursal=? WHERE idcontador=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, contador);
					insert.setBigDecimal(2, valor);
					insert.setString(3, Descripcion);
					insert.setBigDecimal(4, nrosucursal);
					insert.setBigDecimal(5, idcontador);
					insert.setBigDecimal(6, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalcontadoresUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalcontadoresUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// VALIDAR UN USUARIO

	public BigDecimal getUsuarioValidacion(String usuario, String clave)
			throws EJBException {
		/*
		 * Utilidad: devolver el idusuario validado Excepciones:
		 * 
		 * -1 usuario invalido -2 conexion a la base de datos -3 salida por
		 * excepcion -4 usuario inhabilitado 0 superusuario > 0 usuario CEP
		 * 10/08/2008 permito que este encriptada o no la clave para no tener
		 * lios.
		 */
		String claveSQL = encrypt(clave);
		ResultSet rsSalida = null;
		String cQuery = "select *, coalesce(fechaact,fechaalt) as fechaclave from globalusuarios where UPPER(usuario) = '"
				+ usuario.toUpperCase()
				+ "' and (UPPER(clave)='"
				+ claveSQL.toUpperCase()
				+ "' or UPPER(clave)='"
				+ clave.toUpperCase() + "')";
		BigDecimal salida = new BigDecimal(-1);

		try {
			// primero traigo el superusuario del sistema
			String superusuario = props.getProperty("sys.usuario").trim();
			String superusuarioc = props.getProperty("sys.clave").trim();
			if (superusuario.equalsIgnoreCase(usuario)
					&& superusuarioc.equalsIgnoreCase(clave)) {
				salida = new BigDecimal(0); // superusuario
			} else {
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
				while (rsSalida != null && rsSalida.next()) {
					if (rsSalida.getString("habilitado").equalsIgnoreCase("S")) {
						salida = rsSalida.getBigDecimal("idusuario");
					} else {
						salida = new BigDecimal(-4);
					}
				}
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getUsuarioValidacion( String  usuario, String clave ) "
							+ sqlException);
			salida = new BigDecimal(-2);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getUsuarioValidacion( String  usuario, String clave )  "
							+ ex);
			salida = new BigDecimal(-3);
		}
		return salida;
	}

	// MENUES DINAMICOS
	public String getMenuTreeJS(BigDecimal idusuario) throws EJBException {
		/*
		 * utilidad: armar el menu js que despliega el arbol de la izquierda.
		 * Autor: cep.
		 */
		// raiz
		String salida = "\n";
		try {
			String cQueryRaiz = "";
			if (idusuario.equals(new BigDecimal(0))) {
				cQueryRaiz = "select *, 777 as nivel from globalmenues  where idmenupadre is null order by menu";
			} else {
				cQueryRaiz += "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, V.image1, V.image2, V.idmenupadre, V.nivel";
				cQueryRaiz += " FROM vglobalmenues V WHERE V.idusuario = "
						+ idusuario
						+ " and V.nivel = (select max(nivel) from vglobalmenues where idusuario = V.idusuario) and v.idmenupadre is null order by V.menu";
			}

			ResultSet rsSalidaRaiz = null;
			Statement statementRaiz = dbconn.createStatement();
			rsSalidaRaiz = statementRaiz.executeQuery(cQueryRaiz);
			String aux1 = "";
			String aux2 = "";
			while (rsSalidaRaiz.next()) {
				String idmenuRaiz = rsSalidaRaiz.getString("idmenu");
				String menuRaiz = rsSalidaRaiz.getString("menu");
				String linkRaiz = rsSalidaRaiz.getString("link");
				String targetRaiz = rsSalidaRaiz.getString("target");
				String image1Raiz = rsSalidaRaiz.getString("image1");
				String image2Raiz = rsSalidaRaiz.getString("image2");
				String idmenupadreRaiz = rsSalidaRaiz.getString("idmenupadre");
				String nivelRaiz = rsSalidaRaiz.getString("nivel");
				// sin padre.
				if (idmenupadreRaiz == null) {
					salida += "aux1 = appendChild(foldersTree, folderNode(\""
							+ menuRaiz + "\"))\n";
					aux1 = idmenuRaiz;
				}

				// TALLO
				String cQueryTallo = "";
				if (idusuario.equals(new BigDecimal(0))) {
					cQueryTallo = "select *, 777 as nivel from globalmenues where idmenupadre is not null and link is null and idmenupadre = "
							+ idmenuRaiz + " order by menu";
				} else {
					cQueryTallo += "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, V.image1, V.image2, V.idmenupadre, V.nivel";
					cQueryTallo += " FROM vglobalmenues V WHERE V.idusuario = "
							+ idusuario
							+ " and V.nivel = (select max(nivel) from vglobalmenues where idusuario = V.idusuario) and  V.idmenupadre is not null and V.link is null and V.idmenupadre = "
							+ idmenuRaiz + " order by V.menu";
				}

				ResultSet rsSalidaTallo = null;
				Statement statementTallo = dbconn.createStatement();
				rsSalidaTallo = statementTallo.executeQuery(cQueryTallo);
				String aux1Tallo = "";
				String aux2Tallo = "";
				while (rsSalidaTallo.next()) {
					String idmenuTallo = rsSalidaTallo.getString("idmenu");
					String menuTallo = rsSalidaTallo.getString("menu");
					String linkTallo = rsSalidaTallo.getString("link");
					String targetTallo = rsSalidaTallo.getString("target");
					String image1Tallo = rsSalidaTallo.getString("image1");
					String image2Tallo = rsSalidaTallo.getString("image2");
					String idmenupadreTallo = rsSalidaTallo
							.getString("idmenupadre");
					String nivelTallo = rsSalidaTallo.getString("nivel");
					// con padre pero sin menu
					if (idmenupadreTallo != null
							&& aux1.equalsIgnoreCase(idmenupadreTallo)
							&& linkTallo == null) {
						salida += "aux2 = appendChild(aux1, leafNode(\""
								+ menuTallo + "\"))\n";
						aux2Tallo = idmenuTallo;
					}

					// HOJAS
					String cQueryHoja = "";
					if (idusuario.equals(new BigDecimal(0))) {
						cQueryHoja = "select *, 777 as nivel from globalmenues where idmenupadre is not null and link is not null and idmenupadre = "
								+ idmenuTallo + " order by menu";
					} else {
						cQueryHoja += "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, V.image1, V.image2, V.idmenupadre, V.nivel";
						cQueryHoja += " FROM vglobalmenues V WHERE V.idusuario = "
								+ idusuario
								+ " and V.nivel = (select max(nivel) from vglobalmenues where idusuario = V.idusuario) and  V.idmenupadre is not null and V.link is not null and V.idmenupadre = "
								+ idmenuTallo + " order by V.menu ";
					}

					ResultSet rsSalidaHoja = null;
					Statement statementHoja = dbconn.createStatement();
					rsSalidaHoja = statementHoja.executeQuery(cQueryHoja);
					String aux1Hoja = "";
					String aux2Hoja = "";
					while (rsSalidaHoja.next()) {
						String idmenuHoja = rsSalidaHoja.getString("idmenu");
						String menuHoja = rsSalidaHoja.getString("menu");
						String linkHoja = rsSalidaHoja.getString("link");
						String targetHoja = rsSalidaHoja.getString("target");
						String image1Hoja = rsSalidaHoja.getString("image1");
						String image2Hoja = rsSalidaHoja.getString("image2");
						String idmenupadreHoja = rsSalidaHoja
								.getString("idmenupadre");
						String nivelHoja = rsSalidaHoja.getString("nivel");

						// un punto de menu comun
						if (idmenupadreHoja != null
								&& aux2Tallo.equalsIgnoreCase(idmenupadreHoja)
								&& linkHoja != null) {
							salida += "appendChild(aux2, generateDocEntry(0, \""
									+ menuHoja
									+ "\", \""
									+ linkHoja
									+ "\", \""
									+ image1Hoja + "\", \"\"));  \n";
						}

					}// hoja
				} // tallo
			} // raiz
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getMenu() " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getMenu()  " + ex);
		}
		return salida;
	}

	// -------------------------------------------------------------------------------

	// anterior

	public String getMenuTreeJS_ant(BigDecimal idusuario) throws EJBException {
		/*
		 * utilidad: armar el menu js que despliega el arbol de la izquierda.
		 * Autor: cep.
		 */
		ResultSet rsSalida = null;
		String cQuery = "";
		if (idusuario.equals(new BigDecimal(0))) {
			cQuery = "select *, 777 as nivel from globalmenues order  by idmenu, idmenupadre";
		} else {
			cQuery += "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, V.image1, V.image2, V.idmenupadre, V.nivel";
			cQuery += " FROM vglobalmenues V WHERE V.idusuario = "
					+ idusuario
					+ " and V.nivel = (select max(nivel) from vglobalmenues where idusuario = V.idusuario)";
		}
		//
		String salida = "\n";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			String aux1 = "";
			String aux2 = "";
			while (rsSalida.next()) {
				String idmenu = rsSalida.getString("idmenu");
				String menu = rsSalida.getString("menu");
				String link = rsSalida.getString("link");
				String target = rsSalida.getString("target");
				String image1 = rsSalida.getString("image1");
				String image2 = rsSalida.getString("image2");
				String idmenupadre = rsSalida.getString("idmenupadre");
				String nivel = rsSalida.getString("nivel");
				// sin padre.
				if (idmenupadre == null) {
					salida += "aux1 = appendChild(foldersTree, folderNode(\""
							+ menu + "\"))\n";
					aux1 = idmenu;
				}
				// con padre pero sin menu
				if (idmenupadre != null && aux1.equalsIgnoreCase(idmenupadre)
						&& link == null) {
					salida += "aux2 = appendChild(aux1, leafNode(\"" + menu
							+ "\"))\n";
					aux2 = idmenu;
				}

				// un punto de menu comun
				if (idmenupadre != null && aux2.equalsIgnoreCase(idmenupadre)
						&& link != null) {
					salida += "appendChild(aux2, generateDocEntry(0, \"" + menu
							+ "\", \"" + link + "\", \"" + image1
							+ "\", \"\"));  \n";
				}

			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getMenu() " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getMenu()  " + ex);
		}
		return salida;
	}

	// -------------------------------------------------------------------------------

	// TEST NUEVO MENU EJV 20080718

	public String getMenuTreeJSScroll(BigDecimal idusuario) throws EJBException {
		/*
		 * utilidad: armar el menu js que despliega el arbol de la izquierda.
		 * Autor: cep.
		 */
		// raiz
		String salida = "\n";
		String folders = "";
		String nodos = "";
		String auxNodos = "";

		try {
			String cQueryRaiz = "";
			if (idusuario.equals(new BigDecimal(0))) {
				cQueryRaiz = ""
						+ "SELECT *, 777 AS nivel "
						+ "  FROM globalmenues  WHERE idmenupadre IS NULL ORDER BY menu";
			} else {
				cQueryRaiz += ""
						+ "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, "
						+ "       V.image1, V.image2, V.idmenupadre, V.nivel"
						+ " FROM vglobalmenues V WHERE V.idusuario = "
						+ idusuario
						+ " AND V.nivel = ("
						+ "        SELECT MAX(nivel) "
						+ "          FROM vglobalmenues "
						+ "         WHERE idusuario = V.idusuario) AND v.idmenupadre IS NULL "
						+ "         ORDER BY V.menu";
			}

			ResultSet rsSalidaRaiz = null;
			Statement statementRaiz = dbconn.createStatement();
			rsSalidaRaiz = statementRaiz.executeQuery(cQueryRaiz);
			String aux1 = "";
			String aux2 = "";

			while (rsSalidaRaiz.next()) {

				String idmenuRaiz = rsSalidaRaiz.getString("idmenu");
				String menuRaiz = rsSalidaRaiz.getString("menu");
				String linkRaiz = rsSalidaRaiz.getString("link");
				String targetRaiz = rsSalidaRaiz.getString("target");
				String image1Raiz = rsSalidaRaiz.getString("image1");
				String image2Raiz = rsSalidaRaiz.getString("image2");
				String idmenupadreRaiz = rsSalidaRaiz.getString("idmenupadre");
				String nivelRaiz = rsSalidaRaiz.getString("nivel");

				// sin padre.
				if (idmenupadreRaiz == null) {

					salida += "/* =============== [" + idmenuRaiz
							+ "] =============== */ \n\n";

					salida += "aux" + idmenuRaiz + " =  gFld(\"" + menuRaiz
							+ "\", \"javascript:parent.op()\");\n";
					salida += "aux" + idmenuRaiz + ".xID = \"f" + idmenuRaiz
							+ "\"; \n";
					aux1 = idmenuRaiz;

					folders += "aux" + idmenuRaiz + ",";

				}

				// TALLO
				String cQueryTallo = "";
				if (idusuario.equals(new BigDecimal(0))) {
					cQueryTallo = ""
							+ "SELECT *, 777 AS nivel "
							+ "  FROM globalmenues WHERE idmenupadre IS NOT NULL "
							+ "   AND (link IS NULL OR trim(link) = '' ) AND idmenupadre = "
							+ idmenuRaiz + " order by menu";
				} else {
					cQueryTallo += ""
							+ "SELECT DISTINCT V.idmenu AS idmenu, V.menu, "
							+ "       V.link, V.target, V.image1, V.image2, V.idmenupadre, V.nivel"
							+ "  FROM vglobalmenues V "
							+ " WHERE V.idusuario = "
							+ idusuario
							+ "   AND V.nivel = ("
							+ "                  SELECT MAX(nivel) "
							+ "                    FROM vglobalmenues "
							+ "                   WHERE idusuario = V.idusuario"
							+ "                  )"
							+ "   AND  V.idmenupadre IS NOT NULL AND (V.link IS NULL  OR trim(V.link) = '' ) AND V.idmenupadre = "
							+ idmenuRaiz + " ORDER BY V.menu";
				}

				ResultSet rsSalidaTallo = null;
				Statement statementTallo = dbconn.createStatement();
				rsSalidaTallo = statementTallo.executeQuery(cQueryTallo);
				String aux1Tallo = "";
				String aux2Tallo = "";
				int indiceTallo = 0;
				while (rsSalidaTallo.next()) {

					indiceTallo++;

					String idmenuTallo = rsSalidaTallo.getString("idmenu");
					String menuTallo = rsSalidaTallo.getString("menu");
					String linkTallo = rsSalidaTallo.getString("link");
					String targetTallo = rsSalidaTallo.getString("target");
					String image1Tallo = rsSalidaTallo.getString("image1");
					String image2Tallo = rsSalidaTallo.getString("image2");
					String idmenupadreTallo = rsSalidaTallo
							.getString("idmenupadre");
					String nivelTallo = rsSalidaTallo.getString("nivel");
					String tallo = "";

					// con padre pero sin menu
					if (idmenupadreTallo != null
							&& aux1.equalsIgnoreCase(idmenupadreTallo)
							&& linkTallo == null) {

						tallo = "aux" + idmenuRaiz + indiceTallo;
						aux2Tallo = idmenuTallo;

						salida += tallo + "  = gFld(\" " + menuTallo
								+ " \", \"javascript:parent.op()\", \""
								+ image1Tallo + "\", \"" + image2Tallo
								+ "\")\n";
						salida += tallo + ".xID = \"f" + idmenuRaiz
								+ indiceTallo + "\"\n";

					}

					// HOJAS
					String cQueryHoja = "";
					if (idusuario.equals(new BigDecimal(0))) {
						cQueryHoja = ""
								+ "SELECT *, 777 AS nivel "
								+ "  FROM globalmenues "
								+ "  WHERE idmenupadre IS NOT NULL AND link IS NOT NULL AND idmenupadre = "
								+ idmenuTallo + " order by menu";
					} else {
						cQueryHoja += ""
								+ "SELECT DISTINCT V.idmenu AS idmenu, V.menu, V.link, V.target, "
								+ "       V.image1, V.image2, V.idmenupadre, V.nivel"
								+ "  FROM vglobalmenues V "
								+ " WHERE V.idusuario = "
								+ idusuario
								+ "   AND V.nivel = ("
								+ "                SELECT MAX(nivel) "
								+ "                  FROM vglobalmenues "
								+ "                 WHERE idusuario = V.idusuario"
								+ "                ) "
								+ "   AND  V.idmenupadre IS NOT NULL "
								+ "   AND V.link IS NOT NULL AND V.idmenupadre = "
								+ idmenuTallo + " order by V.menu ";
					}

					ResultSet rsSalidaHoja = null;
					Statement statementHoja = dbconn.createStatement();
					rsSalidaHoja = statementHoja.executeQuery(cQueryHoja);
					String aux1Hoja = "";
					String aux2Hoja = "";
					int indexHoja = 0;
					if (rsSalidaHoja.next()) {

						salida += tallo + ".addChildren(\n";
						salida += "\t[\n";

						do {
							String idmenuHoja = rsSalidaHoja
									.getString("idmenu");
							String menuHoja = rsSalidaHoja.getString("menu");
							String linkHoja = rsSalidaHoja.getString("link");
							String targetHoja = rsSalidaHoja
									.getString("target");
							String image1Hoja = rsSalidaHoja
									.getString("image1");
							String image2Hoja = rsSalidaHoja
									.getString("image2");
							String idmenupadreHoja = rsSalidaHoja
									.getString("idmenupadre");
							String nivelHoja = rsSalidaHoja.getString("nivel");

							// un punto de menu comun
							if (idmenupadreHoja != null
									&& aux2Tallo
											.equalsIgnoreCase(idmenupadreHoja)
									&& linkHoja != null) {

								aux1Hoja += "\t\t[\"" + menuHoja + "\", \""
										+ linkHoja + "\",\"" + image1Hoja
										+ "\"],\n";

								aux2Hoja += tallo + ".children[" + indexHoja
										+ "].xID = \"d" + idmenuRaiz
										+ indiceTallo + (++indexHoja) + "\";\n";

							}

						} while (rsSalidaHoja.next());

						aux1Hoja = aux1Hoja.substring(0, aux1Hoja
								.lastIndexOf(","));

						aux1Hoja += "\n\t]\n";
						aux1Hoja += ");\n";
						salida += aux1Hoja + "\n";
						salida += aux2Hoja
								+ "\n/*--------------------------------------*/\n";

					}// hoja

					nodos += "aux" + idmenuRaiz + indiceTallo + ",";

				} // tallo

				auxNodos += "aux" + idmenuRaiz + ".addChildren(["
						+ nodos.substring(0, nodos.lastIndexOf(",")) + "]);\n";
				nodos = "";

			} // raiz

			salida += auxNodos;
			salida += "\nfoldersTree.addChildren(["
					+ folders.substring(0, folders.lastIndexOf(",")) + "]);\n";

		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getMenuTreeJSScroll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getMenuTreeJSScroll()  "
							+ ex);
		}
		return salida;
	}

	// -------------------------------------------------------------------------------

	// globalmonedas
	public List getGlobalmonedasAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALMONEDAS.idmoneda,GLOBALMONEDAS.moneda,globalpaises.pais,GLOBALMONEDAS.usuarioalt,GLOBALMONEDAS.usuarioact,GLOBALMONEDAS.fechaalt,GLOBALMONEDAS.fechaact FROM GLOBALMONEDAS,globalpaises where globalpaises.idpais = GLOBALMONEDAS.idpais ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalmonedas() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalmonedas()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getGlobalmonedasOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALMONEDAS.idmoneda,GLOBALMONEDAS.moneda,globalpaises.pais,GLOBALMONEDAS.usuarioalt,GLOBALMONEDAS.usuarioact,GLOBALMONEDAS.fechaalt,GLOBALMONEDAS.fechaact FROM GLOBALMONEDAS,globalpaises "
				+ " where globalpaises.idpais = GLOBALMONEDAS.idpais "
				+ " and (GLOBALMONEDAS.idmoneda::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(GLOBALMONEDAS.moneda) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalmonedasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalmonedasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalmonedasPK(BigDecimal idmoneda) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALMONEDAS.idmoneda,GLOBALMONEDAS.moneda,GLOBALMONEDAS.idpais,globalpaises.pais,GLOBALMONEDAS.usuarioalt,GLOBALMONEDAS.usuarioact,GLOBALMONEDAS.fechaalt,GLOBALMONEDAS.fechaact FROM GLOBALMONEDAS,globalpaises where globalpaises.idpais = GLOBALMONEDAS.idpais and GLOBALMONEDAS.idmoneda="
				+ idmoneda.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalmonedasPK( BigDecimal idmoneda ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalmonedasPK( BigDecimal idmoneda )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalmonedasDelete(BigDecimal idmoneda) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALMONEDAS WHERE idmoneda="
				+ idmoneda.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALMONEDAS WHERE idmoneda="
						+ idmoneda.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalmonedasDelete( BigDecimal idmoneda ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalmonedasDelete( BigDecimal idmoneda )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalmonedasCreate(String moneda, BigDecimal idpais,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (moneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: moneda ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (moneda.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Moneda ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";

		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALMONEDAS(moneda, idpais, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, moneda);
				insert.setBigDecimal(2, idpais);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalmonedasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalmonedasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalmonedasCreateOrUpdate(BigDecimal idmoneda,
			String moneda, BigDecimal idpais, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (moneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: moneda ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";

		// 2. sin nada desde la pagina
		if (moneda.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Moneda ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalmonedas WHERE idmoneda = "
					+ idmoneda.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALMONEDAS SET moneda=?, idpais=?, usuarioact=?, fechaact=? WHERE idmoneda=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, moneda);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idmoneda);
				} else {
					String ins = "INSERT INTO GLOBALMONEDAS(moneda, idpais, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, moneda);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalmonedasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalmonedasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalmonedasUpdate(BigDecimal idmoneda, String moneda,
			BigDecimal idpais, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (moneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: moneda ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";

		// 2. sin nada desde la pagina
		if (moneda.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Moneda ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalmonedas WHERE idmoneda = "
					+ idmoneda.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALMONEDAS SET moneda=?, idpais=?, usuarioact=?, fechaact=? WHERE idmoneda=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, moneda);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idmoneda);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalmonedasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalmonedasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov pais
	public List getPaisLovAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpais,pais,usuarioalt,usuarioact,fechaalt,fechaact FROM globalpaises ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getPaisLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getPaisLovAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPaisLovOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpais,pais,usuarioalt,usuarioact,fechaalt,fechaact FROM globalpaises "
				+ " where (idpais::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(pais) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPaisLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPaisLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// Pais
	public List getGlobalpaisesAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idpais,pais,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALPAISES ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalpaises() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getGlobalpaises()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getGlobalpaisesOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpais,pais,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALPAISES "
				+ " where (idpais::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(pais) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalpaisesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalpaisesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalpaisesPK(BigDecimal idpais) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpais,pais,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALPAISES WHERE idpais="
				+ idpais.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalpaisesPK( BigDecimal idpais ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalpaisesPK( BigDecimal idpais )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalpaisesDelete(BigDecimal idpais) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALPAISES WHERE idpais="
				+ idpais.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALPAISES WHERE idpais="
						+ idpais.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalpaisesDelete( BigDecimal idpais ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalpaisesDelete( BigDecimal idpais )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalpaisesCreate(String pais, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (pais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Pais ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (pais.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Pais ";

		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALPAISES(pais, usuarioalt ) VALUES (?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, pais);
				insert.setString(2, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalpaisesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String globalpaisesCreate(.....)"
					+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalpaisesCreateOrUpdate(BigDecimal idpais, String pais,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";
		if (pais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Pais ";

		// 2. sin nada desde la pagina
		if (pais.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Pais ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalpaises WHERE idpais = "
					+ idpais.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPAISES SET pais=?, usuarioact=?, fechaact=? WHERE idpais=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, pais);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpais);
				} else {
					String ins = "INSERT INTO GLOBALPAISES(pais, usuarioalt ) VALUES (?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, pais);
					insert.setString(2, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalpaisesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalpaisesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalpaisesUpdate(BigDecimal idpais, String pais,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";
		if (pais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Pais ";

		// 2. sin nada desde la pagina
		if (pais.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Pais ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalpaises WHERE idpais = "
					+ idpais.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPAISES SET pais=?, usuarioact=?, fechaact=? WHERE idpais=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, pais);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpais);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalpaisesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String globalpaisesUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	// provincias
	public List getGlobalprovinciasAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPROVINCIAS.idprovincia,GLOBALPROVINCIAS.provincia,globalpaises.pais,GLOBALPROVINCIAS.usuarioalt,GLOBALPROVINCIAS.usuarioact,GLOBALPROVINCIAS.fechaalt,GLOBALPROVINCIAS.fechaact FROM GLOBALPROVINCIAS,globalpaises where globalpaises.idpais = GLOBALPROVINCIAS.idpais ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalprovincias() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalprovincias()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalprovinciasOcu(long limit, long offset,
			String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPROVINCIAS.idprovincia,GLOBALPROVINCIAS.provincia,globalpaises.pais,GLOBALPROVINCIAS.usuarioalt,GLOBALPROVINCIAS.usuarioact,GLOBALPROVINCIAS.fechaalt,GLOBALPROVINCIAS.fechaact FROM GLOBALPROVINCIAS,globalpaises "
				+ " where globalpaises.idpais = GLOBALPROVINCIAS.idpais "
				+ " and (GLOBALPROVINCIAS.idprovincia::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(GLOBALPROVINCIAS.provincia) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalprovinciasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalprovinciasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalprovinciasPK(BigDecimal idprovincia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPROVINCIAS.idprovincia,GLOBALPROVINCIAS.provincia,globalpaises.idpais,globalpaises.pais,GLOBALPROVINCIAS.usuarioalt,GLOBALPROVINCIAS.usuarioact,GLOBALPROVINCIAS.fechaalt,GLOBALPROVINCIAS.fechaact FROM GLOBALPROVINCIAS,globalpaises where globalpaises.idpais = GLOBALPROVINCIAS.idpais and GLOBALPROVINCIAS.idprovincia="
				+ idprovincia.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalprovinciasPK( BigDecimal idprovincia ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalprovinciasPK( BigDecimal idprovincia )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalprovinciasDelete(BigDecimal idprovincia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALPROVINCIAS WHERE idprovincia="
				+ idprovincia.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALPROVINCIAS WHERE idprovincia="
						+ idprovincia.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalprovinciasDelete( BigDecimal idprovincia ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalprovinciasDelete( BigDecimal idprovincia )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalprovinciasCreate(String provincia, BigDecimal idpais,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (provincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: provincia ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (provincia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Provincia ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALPROVINCIAS(provincia, idpais, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, provincia);
				insert.setBigDecimal(2, idpais);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalprovinciasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalprovinciasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalprovinciasCreateOrUpdate(BigDecimal idprovincia,
			String provincia, BigDecimal idpais, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
		if (provincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: provincia ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";

		// 2. sin nada desde la pagina
		if (provincia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Provincia ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalprovincias WHERE idprovincia = "
					+ idprovincia.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPROVINCIAS SET provincia=?, idpais=?, usuarioact=?, fechaact=? WHERE idprovincia=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, provincia);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idprovincia);
				} else {
					String ins = "INSERT INTO GLOBALPROVINCIAS(provincia, idpais, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, provincia);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalprovinciasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalprovinciasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalprovinciasUpdate(BigDecimal idprovincia,
			String provincia, BigDecimal idpais, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
		if (provincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: provincia ";
		if (idpais == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpais ";

		// 2. sin nada desde la pagina
		if (provincia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Provincia ";
		if (idpais.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Pais";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalprovincias WHERE idprovincia = "
					+ idprovincia.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPROVINCIAS SET provincia=?, idpais=?, usuarioact=?, fechaact=? WHERE idprovincia=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, provincia);
					insert.setBigDecimal(2, idpais);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idprovincia);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalprovinciasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalprovinciasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// setup variables
	public List getSetupvariablesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT variable,valor,descripcion,validador,sistema,usuarioalt,usuarioact,fechaalt,fechaact FROM SETUPVARIABLES where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getSetupvariablesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSetupvariablesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSetupvariablesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  variable,valor,descripcion,validador,sistema,usuarioalt,usuarioact,fechaalt,fechaact FROM SETUPVARIABLES "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (UPPER(variable) LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(valor) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getSetupvariablesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSetupvariablesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSetupvariablesPK(String variable, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  variable,valor,descripcion,validador,sistema,usuarioalt,usuarioact,fechaalt,fechaact FROM SETUPVARIABLES "
				+ " WHERE variable = "
				+ "'"
				+ variable.toString()
				+ "'"
				+ " and idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getSetupvariablesPK( String variable ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSetupvariablesPK( String variable )  "
							+ ex);
		}
		return vecSalida;
	}

	public static String getValorSetupVariables(String variable,
			BigDecimal idempresa, Connection conn) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT valor FROM setupvariables WHERE UPPER(variable)=? AND idempresa=?;";
		String valor = null;

		try {

			PreparedStatement pstatement = conn.prepareStatement(cQuery);
			pstatement.setString(1, variable.toUpperCase());
			pstatement.setBigDecimal(2, idempresa);
			rsSalida = pstatement.executeQuery();

			if (rsSalida != null) {
				if (rsSalida.next()) {
					valor = rsSalida.getString("valor");
				} else {
					log
							.warn("getValorSetupVariables(....): variable no existe ["
									+ variable + "]");
				}
			} else {
				log
						.error("getValorSetupVariables(....): Imposible recuperar variable["
								+ variable + "]");
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getValorSetupVariables( String variable, BigDecimal idempresa, Connection conn ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getValorSetupVariables( String variable,  BigDecimal idempresa, Connection conn )  "
							+ ex);
		}
		return valor;
	}

	// Replicado para poder llamar desde los beans de pagina.
	public String getValorSetupVariablesNoStatic(String variable,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT valor FROM setupvariables WHERE UPPER(variable)=? AND idempresa=?;";
		String valor = null;

		try {

			PreparedStatement pstatement = dbconn.prepareStatement(cQuery);
			pstatement.setString(1, variable.toUpperCase());
			pstatement.setBigDecimal(2, idempresa);
			rsSalida = pstatement.executeQuery();

			if (rsSalida != null) {
				if (rsSalida.next()) {
					valor = rsSalida.getString("valor");
				} else {
					log
							.warn("getValorSetupVariables(....): variable no existe ["
									+ variable + "]");
				}
			} else {
				log
						.error("getValorSetupVariables(....): Imposible recuperar variable["
								+ variable + "]");
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getValorSetupVariablesNoStatic( String variable, BigDecimal idempresa, Connection conn ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getValorSetupVariablesNoStatic( String variable,  BigDecimal idempresa, Connection conn )  "
							+ ex);
		}
		return valor;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String setupvariablesDelete(String variable, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SETUPVARIABLES WHERE variable = "
				+ variable.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SETUPVARIABLES WHERE variable = "
						+ variable.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : setupvariablesDelete( String variable ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: setupvariablesDelete( String variable )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String setupvariablesCreate(String valor, String descripcion,
			String validador, String sistema, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (valor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: valor ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO SETUPVARIABLES(valor, descripcion, validador, sistema, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, valor);
				insert.setString(2, descripcion);
				insert.setString(3, validador);
				insert.setString(4, sistema);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String setupvariablesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String setupvariablesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String setupvariablesCreateOrUpdate(String variable, String valor,
			String descripcion, String validador, String sistema,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (variable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: variable ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";

		// 2. sin nada desde la pagina
		if (variable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: variable ";
		if (valor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: valor ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM setupvariables WHERE variable = "
					+ variable.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SETUPVARIABLES SET valor=?, descripcion=?, validador=?, sistema=?, usuarioact=?, fechaact=? WHERE variable=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, valor);
					insert.setString(2, descripcion);
					insert.setString(3, validador);
					insert.setString(4, sistema);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setString(7, variable);
					insert.setBigDecimal(8, idempresa);
				} else {
					String ins = "INSERT INTO SETUPVARIABLES(valor, descripcion, validador, sistema, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, valor);
					insert.setString(2, descripcion);
					insert.setString(3, validador);
					insert.setString(4, sistema);
					insert.setString(5, usuarioalt);
					insert.setBigDecimal(6, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String setupvariablesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String setupvariablesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String setupvariablesUpdate(String variable, String valor,
			String descripcion, String validador, String sistema,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (variable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: variable ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";

		// 2. sin nada desde la pagina
		if (variable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: variable ";
		if (valor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: valor ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM setupvariables WHERE variable = "
					+ "'"
					+ variable.toString()
					+ "'"
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SETUPVARIABLES SET valor=?, descripcion=?, validador=?, sistema=?, usuarioact=?, fechaact=? WHERE variable=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, valor);
					insert.setString(2, descripcion);
					insert.setString(3, validador);
					insert.setString(4, sistema);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setString(7, variable);
					insert.setBigDecimal(8, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String setupvariablesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String setupvariablesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String setupVariablesSetValor(String variable, String valor,
			String sistema, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";

		try {

			salida = setupVariablesSetValor(variable, valor, sistema,
					usuarioact, idempresa, dbconn);

			if (salida.equalsIgnoreCase("OK"))
				salida = "Actualizacion Correcta";
			else
				salida = "Imposible actualizar el registro.";

		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String setupVariablesSetValor(.....)"
							+ ex);
		}

		return salida;
	}

	public static String setupVariablesSetValor(String variable, String valor,
			String sistema, String usuarioact, BigDecimal idempresa,
			Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (variable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: variable ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";

		// 2. sin nada desde la pagina
		if (variable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: variable ";
		if (valor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: valor ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM setupvariables WHERE upper(variable) = "
					+ "'"
					+ variable.toUpperCase()
					+ "' AND sistema='"
					+ sistema.toUpperCase()
					+ "'"
					+ " AND idempresa = "
					+ idempresa.toString();
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SETUPVARIABLES SET valor=?, usuarioact=?, fechaact=? WHERE upper(variable)=? and  sistema=? and idempresa=? ;";
					insert = conn.prepareStatement(sql);
					insert.setString(1, valor);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setString(4, variable.toUpperCase());
					insert.setString(5, sistema);
					insert.setBigDecimal(6, idempresa);
					int i = insert.executeUpdate();
					if (i != 1)
						salida = "Variable " + variable.toUpperCase()
								+ " no actualizada .";

				} else
					salida = "No existe variable: " + variable.toUpperCase()
							+ ".";

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible actualizar variable: "
					+ variable.toUpperCase() + ".";
			log
					.error("Error SQL public static String setupVariablesSetValor(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible actualizar variable: "
					+ variable.toUpperCase() + ".";
			log
					.error("Error excepcion public static String setupVariablesSetValor(.....)"
							+ ex);
		}
		return salida;
	}

	// globalgrupos
	public List getGlobalgruposAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idgrupo,grupo,habilitado,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALGRUPOS ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalgrupos() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getGlobalgrupos()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getGlobalgruposOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idgrupo,grupo,habilitado,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALGRUPOS "
				+ " where (idgrupo::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(grupo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalgruposOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgruposOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalgruposPK(BigDecimal idgrupo) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idgrupo,grupo,habilitado,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALGRUPOS WHERE idgrupo="
				+ idgrupo.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalgruposPK( BigDecimal idgrupo ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgruposPK( BigDecimal idgrupo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalgruposDelete(BigDecimal idgrupo) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALGRUPOS WHERE idgrupo="
				+ idgrupo.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALGRUPOS WHERE idgrupo="
						+ idgrupo.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalgruposDelete( BigDecimal idgrupo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalgruposDelete( BigDecimal idgrupo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalgruposCreate(String grupo, String habilitado,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (grupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: grupo ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (grupo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Grupo ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Habilitado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALGRUPOS(grupo, habilitado, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, grupo);
				insert.setString(2, habilitado);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalgruposCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String globalgruposCreate(.....)"
					+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalgruposCreateOrUpdate(BigDecimal idgrupo, String grupo,
			String habilitado, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (grupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: grupo ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";

		// 2. sin nada desde la pagina
		if (grupo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Grupo ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Habilitado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalgrupos WHERE idgrupo = "
					+ idgrupo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALGRUPOS SET grupo=?, habilitado=?, usuarioact=?, fechaact=? WHERE idgrupo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, grupo);
					insert.setString(2, habilitado);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idgrupo);
				} else {
					String ins = "INSERT INTO GLOBALGRUPOS(grupo, habilitado, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, grupo);
					insert.setString(2, habilitado);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalgruposCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalgruposCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalgruposUpdate(BigDecimal idgrupo, String grupo,
			String habilitado, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (grupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: grupo ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";

		// 2. sin nada desde la pagina
		if (grupo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Grupo ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Habilitado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalgrupos WHERE idgrupo = "
					+ idgrupo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALGRUPOS SET grupo=?, habilitado=?, usuarioact=?, fechaact=? WHERE idgrupo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, grupo);
					insert.setString(2, habilitado);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idgrupo);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalgruposUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String globalgruposUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	// gruposmenues
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalgruposmenuesAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT globalgrupos.idgrupo ,globalmenues.idmenu, globalgrupos.grupo,globalmenues.menu,GLOBALGRUPOSMENUES.nivel,GLOBALGRUPOSMENUES.usuarioalt,GLOBALGRUPOSMENUES.usuarioact,GLOBALGRUPOSMENUES.fechaalt,GLOBALGRUPOSMENUES.fechaact FROM GLOBALGRUPOSMENUES,globalmenues,globalgrupos where globalmenues.idmenu = GLOBALGRUPOSMENUES.idmenu and globalgrupos.idgrupo = GLOBALGRUPOSMENUES.idgrupo ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalgruposmenues() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgruposmenues()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalgruposmenuesOcu(long limit, long offset,
			String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT globalgrupos.idgrupo ,globalmenues.idmenu, globalgrupos.grupo,globalmenues.menu,GLOBALGRUPOSMENUES.nivel,GLOBALGRUPOSMENUES.usuarioalt,GLOBALGRUPOSMENUES.usuarioact,GLOBALGRUPOSMENUES.fechaalt,GLOBALGRUPOSMENUES.fechaact FROM GLOBALGRUPOSMENUES,globalmenues,globalgrupos "
				+ " where globalmenues.idmenu = GLOBALGRUPOSMENUES.idmenu "
				+ " and globalgrupos.idgrupo = GLOBALGRUPOSMENUES.idgrupo"
				+ " and (UPPER(globalgrupos.grupo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(globalmenues.menu) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalgruposmenues(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgruposmenues(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalgruposmenuesPK(BigDecimal idgrupo, BigDecimal idmenu)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALGRUPOSMENUES.idgrupo,globalgrupos.grupo,GLOBALGRUPOSMENUES.idmenu,globalmenues.menu,GLOBALGRUPOSMENUES.nivel,GLOBALGRUPOSMENUES.usuarioalt,GLOBALGRUPOSMENUES.usuarioact,GLOBALGRUPOSMENUES.fechaalt,GLOBALGRUPOSMENUES.fechaact FROM GLOBALGRUPOSMENUES,globalmenues,globalgrupos where globalmenues.idmenu = GLOBALGRUPOSMENUES.idmenu and globalgrupos.idgrupo = GLOBALGRUPOSMENUES.idgrupo and GLOBALGRUPOSMENUES.idgrupo="
				+ idgrupo.toString()
				+ "and GLOBALGRUPOSMENUES.idmenu="
				+ idmenu.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalgruposmenuesPK( BigDecimal idgrupo ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgruposmenuesPK( BigDecimal idgrupo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalgruposmenuesDelete(BigDecimal idgrupo, BigDecimal idmenu)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALGRUPOSMENUES WHERE idgrupo="
				+ idgrupo.toString() + "and idmenu=" + idmenu.toString();
		log.error("el valor de  idgrupo es: " + idgrupo);
		log.error("el valor de  idmenu es: " + idmenu);
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALGRUPOSMENUES WHERE idgrupo="
						+ idgrupo.toString() + "and idmenu="
						+ idmenu.toString();

				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalgruposmenuesDelete( BigDecimal idgrupo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalgruposmenuesDelete( BigDecimal idgrupo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalgruposmenuesCreate(BigDecimal idgrupo,
			BigDecimal idmenu, BigDecimal nivel, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";

		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALGRUPOSMENUES(idgrupo, idmenu, nivel, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idgrupo);
				insert.setBigDecimal(2, idmenu);
				insert.setBigDecimal(3, nivel);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalgruposmenuesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalgruposmenuesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalgruposmenuesCreateOrUpdate(BigDecimal idgrupo,
			BigDecimal idmenu, BigDecimal nivel, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";

		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";

		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalgruposmenues WHERE idgrupo = "
					+ idgrupo.toString() + " and " + idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALGRUPOSMENUES SET idgrupo=?, idmenu=?, nivel=?, usuarioact=?, fechaact=? WHERE idgrupo=? and idmenu =? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idgrupo);
				} else {
					String ins = "INSERT INTO GLOBALGRUPOSMENUES(idgrupo, idmenu, nivel, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalgruposmenuesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalgruposmenuesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalgruposmenuesUpdate(BigDecimal idgrupo,
			BigDecimal idmenu, BigDecimal nivel, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";

		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";

		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalgruposmenues WHERE idgrupo = "
					+ idgrupo.toString() + " and idmenu = " + idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALGRUPOSMENUES SET idgrupo =?, idmenu=?, nivel=?, usuarioact=?, fechaact=? WHERE idgrupo=? and idmenu=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idgrupo);
					insert.setBigDecimal(7, idmenu);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalgruposmenuesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalgruposmenuesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov global menues
	public List getGlobalMenuesLovAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idmenu,menu,usuarioalt,usuarioact,fechaalt,fechaact FROM globalmenues ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalMenuesLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalMenuesLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalMenuesOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idmenu,menu,usuarioalt,usuarioact,fechaalt,fechaact FROM globalmenues "
				+ " where (idmenu::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(menu) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalMenuesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalMenuesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalgrupoLovAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idgrupo,grupo,usuarioalt,usuarioact,fechaalt,fechaact FROM globalgrupos ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalgrupoLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgrupoLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalgrupoOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idgrupo,grupo,usuarioalt,usuarioact,fechaalt,fechaact FROM globalgrupos where UPPER(grupo) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalgrupoOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalgrupoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// menues
	public List getGlobalmenuesAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idmenu,menu,link,target,image1,image2,idmenupadre,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALMENUES ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalmenues() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getGlobalmenues()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalmenuesOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idmenu,menu,link,target,image1,image2,idmenupadre,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALMENUES "
				+ " where (idmenu::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(menu) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalmenuesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalmenuesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalmenuesPK(BigDecimal idmenu) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idmenu,menu,link,target,image1,image2,idmenupadre,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALMENUES WHERE idmenu="
				+ idmenu.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalmenuesPK( BigDecimal idmenu ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalmenuesPK( BigDecimal idmenu )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalmenuesDelete(BigDecimal idmenu) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALMENUES WHERE idmenu="
				+ idmenu.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALMENUES WHERE idmenu="
						+ idmenu.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalmenuesDelete( BigDecimal idmenu ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalmenuesDelete( BigDecimal idmenu )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalmenuesCreate(String menu, String link, String target,
			String image1, String image2, String idmenupadre, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (menu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: menu ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (menu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: menu ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALMENUES(menu, link, target, image1, image2, idmenupadre, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, menu);
				insert.setString(2, link);
				insert.setString(3, target);
				insert.setString(4, image1);
				insert.setString(5, image2);
				if (idmenupadre != "" && !idmenupadre.equalsIgnoreCase("")) {
					insert.setBigDecimal(6, new BigDecimal(idmenupadre));
				} else {
					insert.setBigDecimal(6, null);
				}
				insert.setString(7, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalmenuesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String globalmenuesCreate(.....)"
					+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalmenuesCreateOrUpdate(BigDecimal idmenu, String menu,
			String link, String target, String image1, String image2,
			String idmenupadre, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (menu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: menu ";

		// 2. sin nada desde la pagina
		if (menu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: menu ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalmenues WHERE idmenu = "
					+ idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALMENUES SET menu=?, link=?, target=?, image1=?, image2=?, idmenupadre=?, usuarioact=?, fechaact=? WHERE idmenu=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, menu);
					insert.setString(2, link);
					insert.setString(3, target);
					insert.setString(4, image1);
					insert.setString(5, image2);
					if (idmenupadre != null
							&& !idmenupadre.equalsIgnoreCase("null")) {
						insert.setBigDecimal(6, new BigDecimal(idmenupadre));
					} else {
						insert.setBigDecimal(6, null);
					}
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idmenu);
				} else {
					String ins = "INSERT INTO GLOBALMENUES(menu, link, target, image1, image2, idmenupadre, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, menu);
					insert.setString(2, link);
					insert.setString(3, target);
					insert.setString(4, image1);
					insert.setString(5, image2);
					if (idmenupadre != "" && !idmenupadre.equalsIgnoreCase("")) {
						insert.setBigDecimal(6, new BigDecimal(idmenupadre));
					} else {
						insert.setBigDecimal(6, null);
					}
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalmenuesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalmenuesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalmenuesUpdate(BigDecimal idmenu, String menu,
			String link, String target, String image1, String image2,
			String idmenupadre, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (menu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: menu ";

		// 2. sin nada desde la pagina
		if (menu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: menu ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalmenues WHERE idmenu = "
					+ idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALMENUES SET menu=?, link=?, target=?, image1=?, image2=?, idmenupadre=?, usuarioact=?, fechaact=? WHERE idmenu=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, menu);
					insert.setString(2, link);
					insert.setString(3, target);
					insert.setString(4, image1);
					insert.setString(5, image2);
					if (idmenupadre != null
							&& !idmenupadre.equalsIgnoreCase("null")) {
						insert.setBigDecimal(6, new BigDecimal(idmenupadre));
					} else {
						insert.setBigDecimal(6, null);
					}
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idmenu);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalmenuesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String globalmenuesUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	// usuarios
	public List getGlobalusuariosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GU.idusuario,GU.usuario,GU.clave,GU.email,GU.nombre,GU.habilitado,GP.puesto,GU.usuarioalt,GU.usuarioact,GU.fechaalt,GU.fechaact FROM GLOBALUSUARIOS GU LEFT JOIN globalpuestos GP  ON (GU.idpuesto  = GP.idpuesto and GU.idempresa = GP.idempresa ) "
				+ " where GU.idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalusuariosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getGlobalusuariosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GU.idusuario,GU.usuario,GU.clave,GU.email,GU.nombre,GU.habilitado,GP.puesto,GU.usuarioalt,GU.usuarioact,GU.fechaalt,GU.fechaact FROM GLOBALUSUARIOS GU LEFT JOIN globalpuestos GP  ON (GU.idpuesto  = GP.idpuesto and GU.idempresa = GP.idempresa ) "
				+ " where GU.idempresa= "
				+ idempresa.toString()
				+ " and (GU.idusuario::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(GU.usuario) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public BigDecimal getGlobalUsuariosPuesto(BigDecimal idusuario) {
		BigDecimal salida = new BigDecimal(0);
		try {
			ResultSet rsSalida = null;
			// controlo la posibilidad de que se conecte el superusuario
			String cQuery = "";
			if (idusuario.compareTo(new BigDecimal(0)) == 0) {
				cQuery = "SELECT min(idpuesto) as idpuesto FROM globalpuestos ";
				// asigno
				// el
				// primer
				// puesto
			} else {
				cQuery = "SELECT GU.idpuesto as idpuesto FROM GLOBALUSUARIOS GU  WHERE GU.idusuario="
						+ idusuario.toString();
			}
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal("idpuesto");
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalUsuariosPuesto(BigDecimal idusuario) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalUsuariosPuesto(BigDecimal idusuario)  "
							+ ex);
		}
		return salida;
	}

	public static String strZero(String numero, int cantidadceros) {
		String salida = "" + numero;
		try {
			for (int i = salida.length(); i < cantidadceros; i++) {
				salida = "0" + salida;
			}
		} catch (Exception ex) {
			System.out
					.println("StrZero(numero, cantidadceros) salida por excepcion: "
							+ ex);
		}
		return salida;
	}

	public String getProximoNumeroDocumento(BigDecimal idcontador,
			BigDecimal idempresa) {
		String salida = "XXXX-XXXXXXXX";
		try {
			ResultSet rsSalida = null;
			// controlo la posibilidad de que se conecte el superusuario
			String cQuery = "SELECT *  FROM GLOBALcontadores WHERE idcontador ="
					+ idcontador.toString()
					+ " AND idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			while (rsSalida.next()) {
				String sucursal = rsSalida.getString("nrosucursal");
				String nrodoc = rsSalida.getString("valor");
				if (sucursal == null)
					sucursal = "0000";
				else
					sucursal = strZero(sucursal, 4);
				if (nrodoc == null)
					nrodoc = "00000000";
				else
					nrodoc = strZero(nrodoc, 8);
				salida = sucursal + " - " + nrodoc;
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getProximoNumeroDocumento( BigDecimal idcontador )"
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getProximoNumeroDocumento( BigDecimal idcontador ) "
							+ ex);
		}
		return salida;

	}

	public BigDecimal getContadorDocumentos(BigDecimal idpuesto,
			String documento) {
		// traer el contador por puesto que se corresponda con lo que se pide
		// por parametro
		BigDecimal salida = new BigDecimal(-1);
		try {
			ResultSet rsSalida = null;
			// controlo la posibilidad de que se conecte el superusuario
			String cQuery = "SELECT *  FROM GLOBALpuestos WHERE idpuesto ="
					+ idpuesto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal(documento);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getContadorDocumentos(BigDecimal idpuesto,String  documento) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getContadorDocumentos(BigDecimal idpuesto,String  documento) "
							+ ex);
		}
		return salida;
	}

	public static BigDecimal getSucursalComprobante(
			BigDecimal idcontadorcomprobante, BigDecimal idempresa,
			Connection conn) {

		BigDecimal sucursalcomprobante = new BigDecimal(-1);

		try {

			ResultSet rsSalida = null;
			String cQuery = "SELECT nrosucursal  FROM globalcontadores WHERE idcontador ="
					+ idcontadorcomprobante.toString()
					+ "AND idempresa = "
					+ idempresa.toString();
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {
				if (rsSalida.next()) {
					sucursalcomprobante = rsSalida.getBigDecimal(1);
				} else {
					log.warn("getSucursalComprobante: idcontador no existe.");
				}
			} else {
				log
						.warn("getSucursalComprobante: imposible recuperar datos para el contador.");
			}

		} catch (Exception e) {
			log.error("getSucursalComprobante:" + e);
		}

		return sucursalcomprobante;
	}

	public List getGlobalusuariosPK(BigDecimal idusuario, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GU.idusuario,GU.usuario,GU.clave,GU.email,GU.nombre,GU.habilitado,GU.idpuesto,GP.puesto,GU.usuarioalt,GU.usuarioact,GU.fechaalt,GU.fechaact FROM GLOBALUSUARIOS GU LEFT JOIN globalpuestos GP  ON (GU.idpuesto  = GP.idpuesto and GU.idempresa = GP.idempresa ) "
				+ " WHERE GU.idusuario = "
				+ idusuario.toString()
				+ " and GU.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosPK( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosPK( BigDecimal idusuario )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalusuariosXMail(String email, BigDecimal idempresa)
			throws EJBException {
		// IDEMPRESA POR EL MOMENTO NO SE USA COMO FILTRO.
		ResultSet rsSalida = null;
		String cQuery = " "
				+ " SELECT idusuario, usuario, clave, email, nombre,habilitado, "
				+ "              usuarioalt, usuarioact, fechaalt, fechaact, idpuesto, idempresa"
				+ "   FROM globalusuarios " + " WHERE  UPPER(email) = '"
				+ email.toUpperCase() + "'  ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosXMail( String email, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosPK( BigDecimal idusuario )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalusuariosDelete(BigDecimal idusuario,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALUSUARIOS WHERE idusuario = "
				+ idusuario.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALUSUARIOS WHERE idusuario="
						+ idusuario.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalusuariosDelete( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalusuariosDelete( BigDecimal idusuario )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalusuariosCreate(String usuario, String clave,
			String email, String nombre, String habilitado, String usuarioalt,
			String idpuesto, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (clave == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clave ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		if (clave.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clave ";
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: habilitado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALUSUARIOS(usuario, clave, email, nombre, habilitado, usuarioalt, idpuesto, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, usuario);
				insert.setString(2, clave);
				insert.setString(3, email);
				insert.setString(4, nombre);
				insert.setString(5, habilitado);
				insert.setString(6, usuarioalt);
				if (idpuesto != "" && !idpuesto.equalsIgnoreCase("")) {
					insert.setBigDecimal(7, new BigDecimal(idpuesto));
				} else {
					insert.setBigDecimal(7, null);
				}
				insert.setBigDecimal(8, idempresa);
				int n = insert.executeUpdate();
				if (n == 1) {
					salida = getValorSequencia("seq_globalusuarios", dbconn)
							+ "";
				} else {
					salida = "Error al generar usuario.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalusuariosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalusuariosCreateOrUpdate(BigDecimal idusuario,
			String usuario, String clave, String email, String nombre,
			String habilitado, String usuarioact, String idpuesto,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (clave == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clave ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";

		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		if (clave.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clave ";
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: habilitado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuarios WHERE idusuario = "
					+ idusuario.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOS SET usuario=?, clave=?, email=?, nombre=?, habilitado=?, usuarioact=?, fechaact=?, idpuesto =? WHERE idusuario=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, usuario);
					insert.setString(2, clave);
					insert.setString(3, email);
					insert.setString(4, nombre);
					insert.setString(5, habilitado);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					if (idpuesto != null && !idpuesto.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8, new BigDecimal(idpuesto));
					} else {
						insert.setBigDecimal(8, null);
					}
					insert.setBigDecimal(9, idusuario);
					insert.setBigDecimal(10, idempresa);
				} else {
					String ins = "INSERT INTO GLOBALUSUARIOS(usuario, clave, email, nombre, habilitado, usuarioalt, idpuesto,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, usuario);
					insert.setString(2, clave);
					insert.setString(3, email);
					insert.setString(4, nombre);
					insert.setString(5, habilitado);
					insert.setString(6, usuarioalt);
					if (idpuesto != "" && !idpuesto.equalsIgnoreCase("")) {
						insert.setBigDecimal(7, new BigDecimal(idpuesto));
					} else {
						insert.setBigDecimal(7, null);
					}
					insert.setBigDecimal(8, idempresa);
					insert.setBigDecimal(9, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalusuariosUpdate(BigDecimal idusuario, String usuario,
			String clave, String email, String nombre, String habilitado,
			String usuarioact, String idpuesto, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (clave == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clave ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (habilitado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: habilitado ";

		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		if (clave.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clave ";
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (habilitado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: habilitado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuarios WHERE idusuario = "
					+ idusuario.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOS SET usuario=?, clave=?, email=?, nombre=?, habilitado=?, usuarioact=?, fechaact=?, idpuesto=? WHERE idusuario=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, usuario);
					insert.setString(2, clave);
					insert.setString(3, email);
					insert.setString(4, nombre);
					insert.setString(5, habilitado);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					if (idpuesto != null && !idpuesto.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8, new BigDecimal(idpuesto));
					} else {
						insert.setBigDecimal(8, null);
					}
					insert.setBigDecimal(9, idusuario);
					insert.setBigDecimal(10, idempresa);
				}
				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalusuariosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalusuariosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// usuarios grupos
	public List getGlobalusuariosgruposAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSGRUPOS.idusuario,GLOBALUSUARIOSGRUPOS.idgrupo,globalusuarios.usuario,globalgrupos.grupo,GLOBALUSUARIOSGRUPOS.usuarioalt,GLOBALUSUARIOSGRUPOS.usuarioact,GLOBALUSUARIOSGRUPOS.fechaalt,GLOBALUSUARIOSGRUPOS.fechaact FROM GLOBALUSUARIOSGRUPOS,globalusuarios,globalgrupos where globalusuarios.idusuario = GLOBALUSUARIOSGRUPOS.idusuario and globalgrupos.idgrupo = GLOBALUSUARIOSGRUPOS.idgrupo ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalusuariosgrupos() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosgrupos()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalusuariosgruposOcu(long limit, long offset,
			String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSGRUPOS.idusuario,GLOBALUSUARIOSGRUPOS.idgrupo,globalusuarios.usuario,globalgrupos.grupo,GLOBALUSUARIOSGRUPOS.usuarioalt,GLOBALUSUARIOSGRUPOS.usuarioact,GLOBALUSUARIOSGRUPOS.fechaalt,GLOBALUSUARIOSGRUPOS.fechaact FROM GLOBALUSUARIOSGRUPOS,globalusuarios,globalgrupos "
				+ " where globalusuarios.idusuario = GLOBALUSUARIOSGRUPOS.idusuario "
				+ " and globalgrupos.idgrupo = GLOBALUSUARIOSGRUPOS.idgrupo "
				+ " and (globalgrupos.grupo LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(globalusuarios.usuario) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosgrupos(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosgrupos(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalusuariosgruposPK(BigDecimal idusuario,
			BigDecimal idgrupo) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSGRUPOS.idusuario,globalusuarios.usuario,GLOBALUSUARIOSGRUPOS.idgrupo,globalgrupos.grupo,GLOBALUSUARIOSGRUPOS.usuarioalt,GLOBALUSUARIOSGRUPOS.usuarioact,GLOBALUSUARIOSGRUPOS.fechaalt,GLOBALUSUARIOSGRUPOS.fechaact FROM GLOBALUSUARIOSGRUPOS,globalusuarios,globalgrupos where globalusuarios.idusuario = GLOBALUSUARIOSGRUPOS.idusuario and globalgrupos.idgrupo = GLOBALUSUARIOSGRUPOS.idgrupo and GLOBALUSUARIOSGRUPOS.idusuario="
				+ idusuario.toString()
				+ "and GLOBALUSUARIOSGRUPOS.idgrupo = "
				+ idgrupo.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosgruposPK( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosgruposPK( BigDecimal idusuario )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalusuariosgruposDelete(BigDecimal idusuario,
			BigDecimal idgrupo) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALUSUARIOSGRUPOS WHERE idusuario="
				+ idusuario.toString() + "and idgrupo = " + idgrupo.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALUSUARIOSGRUPOS WHERE idusuario="
						+ idusuario.toString() + "and idgrupo = "
						+ idgrupo.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalusuariosgruposDelete( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalusuariosgruposDelete( BigDecimal idusuario )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalusuariosgruposCreate(BigDecimal idusuario,
			BigDecimal idgrupo, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";

		if (idusuario.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Usuario";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALUSUARIOSGRUPOS(idusuario, idgrupo, usuarioalt ) VALUES (?, ? , ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:.
				insert.setBigDecimal(1, idusuario);
				insert.setBigDecimal(2, idgrupo);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosgruposCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosgruposCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalusuariosgruposCreateOrUpdate(BigDecimal idusuario,
			BigDecimal idgrupo, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";

		if (idusuario.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Usuario";
		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosgrupos WHERE idusuario = "
					+ idusuario.toString()
					+ "and  idgrupo = "
					+ idgrupo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSGRUPOS SET idusuario=?,idgrupo=?, usuarioact=?, fechaact=? WHERE idusuario=? and idgrupo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idgrupo);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idusuario);
					insert.setBigDecimal(6, idgrupo);
				} else {
					String ins = "INSERT INTO GLOBALUSUARIOSGRUPOS(idusuario, idgrupo, usuarioalt ) VALUES (?, ? , ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idgrupo);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosgruposCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosgruposCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalusuariosgruposUpdate(BigDecimal idusuario,
			BigDecimal idgrupo, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (idgrupo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgrupo ";
		if (idgrupo.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Grupo";
		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosgrupos WHERE idusuario = "
					+ idusuario.toString()
					+ "and idgrupo = "
					+ idgrupo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSGRUPOS SET idusuario=?, idgrupo=?, usuarioact=?, fechaact=? WHERE idusuario=? and idgrupo=? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idgrupo);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idusuario);
					insert.setBigDecimal(6, idgrupo);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalusuariosgruposUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalusuariosgruposUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// usuarios lov
	public List getUsuariosLovAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idusuario,usuario,usuarioalt,usuarioact,fechaalt,fechaact FROM globalusuarios ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getUsuariosLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getUsuariosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getUsuariosLovOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idusuario,usuario,usuarioalt,usuarioact,fechaalt,fechaact FROM globalusuarios "
				+ " where (idusuario::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(usuario) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getUsuariosLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getUsuariosLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// usuarios menues
	public List getGlobalusuariosmenuesAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSMENUES.idusuario,GLOBALUSUARIOSMENUES.idmenu,globalusuarios.usuario,globalmenues.menu,GLOBALUSUARIOSMENUES.nivel,GLOBALUSUARIOSMENUES.usuarioalt,GLOBALUSUARIOSMENUES.usuarioact,GLOBALUSUARIOSMENUES.fechaalt,GLOBALUSUARIOSMENUES.fechaact FROM GLOBALUSUARIOSMENUES,globalusuarios,globalmenues where globalusuarios.idusuario =GLOBALUSUARIOSMENUES.idusuario and globalmenues.idmenu = GLOBALUSUARIOSMENUES.idmenu ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalusuariosmenues() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosmenues()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalusuariosmenuesOcu(long limit, long offset,
			String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSMENUES.idusuario,GLOBALUSUARIOSMENUES.idmenu,globalusuarios.usuario,globalmenues.menu,GLOBALUSUARIOSMENUES.nivel,GLOBALUSUARIOSMENUES.usuarioalt,GLOBALUSUARIOSMENUES.usuarioact,GLOBALUSUARIOSMENUES.fechaalt,GLOBALUSUARIOSMENUES.fechaact FROM GLOBALUSUARIOSMENUES,globalusuarios,globalmenues "
				+ " where globalusuarios.idusuario = GLOBALUSUARIOSMENUES.idusuario "
				+ " and globalmenues.idmenu = GLOBALUSUARIOSMENUES.idmenu "
				+ " and (UPPER (globalusuarios.usuario) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(globalmenues.menu) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosmenues(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosmenues(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalusuariosmenuesPK(BigDecimal idusuario,
			BigDecimal idmenu) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALUSUARIOSMENUES.idusuario,globalusuarios.usuario,GLOBALUSUARIOSMENUES.idmenu,globalmenues.menu,GLOBALUSUARIOSMENUES.nivel,GLOBALUSUARIOSMENUES.usuarioalt,GLOBALUSUARIOSMENUES.usuarioact,GLOBALUSUARIOSMENUES.fechaalt,GLOBALUSUARIOSMENUES.fechaact FROM GLOBALUSUARIOSMENUES,globalusuarios,globalmenues where globalusuarios.idusuario = GLOBALUSUARIOSMENUES.idusuario and globalmenues.idmenu = GLOBALUSUARIOSMENUES.idmenu and GLOBALUSUARIOSMENUES.idusuario="
				+ idusuario.toString()
				+ "and GLOBALUSUARIOSMENUES.idmenu="
				+ idmenu.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosmenuesPK( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosmenuesPK( BigDecimal idusuario )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalusuariosmenuesDelete(BigDecimal idusuario,
			BigDecimal idmenu) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALUSUARIOSMENUES WHERE idusuario="
				+ idusuario.toString() + "and idmenu=" + idmenu.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALUSUARIOSMENUES WHERE idusuario="
						+ idusuario.toString() + "and idmenu="
						+ idmenu.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalusuariosmenuesDelete( BigDecimal idusuario ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalusuariosmenuesDelete( BigDecimal idusuario )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalusuariosmenuesCreate(BigDecimal idusuario,
			BigDecimal idmenu, BigDecimal nivel, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";
		if (idusuario.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Usuario";
		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALUSUARIOSMENUES(idusuario, idmenu, nivel, usuarioalt ) VALUES (?,?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idusuario);
				insert.setBigDecimal(2, idmenu);
				insert.setBigDecimal(3, nivel);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosmenuesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosmenuesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalusuariosmenuesCreateOrUpdate(BigDecimal idusuario,
			BigDecimal idmenu, BigDecimal nivel, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";
		if (idusuario.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Usuario";
		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosmenues WHERE idusuario = "
					+ idusuario.toString() + "and idmenu=" + idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSMENUES SET idusuario=?, idmenu=?, nivel=?, usuarioact=?, fechaact=? WHERE idusuario=? and idmenu=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idusuario);
					insert.setBigDecimal(7, idmenu);
				} else {
					String ins = "INSERT INTO GLOBALUSUARIOSMENUES(idusuario, idmenu, nivel, usuarioalt ) VALUES (?,?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosmenuesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosmenuesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalusuariosmenuesUpdate(BigDecimal idusuario,
			BigDecimal idmenu, BigDecimal nivel, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (idmenu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmenu ";
		if (nivel == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nivel ";

		if (idusuario.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Usuario";
		if (idmenu.compareTo(new BigDecimal(0)) == 0)
			salida = "Error: No se puede dejar vacio el campo: Menu";
		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosmenues WHERE idusuario = "
					+ idusuario.toString() + "and idmenu=" + idmenu.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSMENUES SET idusuario =?, idmenu=?, nivel=?, usuarioact=?, fechaact=? WHERE idusuario=? and idmenu =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, idmenu);
					insert.setBigDecimal(3, nivel);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idusuario);
					insert.setBigDecimal(7, idmenu);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalusuariosmenuesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalusuariosmenuesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// global plantas
	public List getGlobalplantasAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPLANTAS.idplanta,GLOBALPLANTAS.planta,GLOBALPLANTAS.domicilio,globallocalidades.localidad,GLOBALPLANTAS.codpostal,GLOBALPLANTAS.telefonos,GLOBALPLANTAS.fax,GLOBALPLANTAS.tareaquedesa,GLOBALPLANTAS.email,GLOBALPLANTAS.esheadquarter,GLOBALPLANTAS.usuarioalt,GLOBALPLANTAS.usuarioact,GLOBALPLANTAS.fechaalt,GLOBALPLANTAS.fechaact FROM GLOBALPLANTAS, globallocalidades where globallocalidades.idlocalidad = GLOBALPLANTAS.idlocalidad ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalplantas() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalplantas()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalplantasOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPLANTAS.idplanta,GLOBALPLANTAS.planta,GLOBALPLANTAS.domicilio,globallocalidades.localidad,GLOBALPLANTAS.codpostal,GLOBALPLANTAS.telefonos,GLOBALPLANTAS.fax,GLOBALPLANTAS.tareaquedesa,GLOBALPLANTAS.email,GLOBALPLANTAS.esheadquarter,GLOBALPLANTAS.usuarioalt,GLOBALPLANTAS.usuarioact,GLOBALPLANTAS.fechaalt,GLOBALPLANTAS.fechaact FROM GLOBALPLANTAS, globallocalidades "
				+ " where globallocalidades.idlocalidad = GLOBALPLANTAS.idlocalidad "
				+ " and (GLOBALPLANTAS.idplanta::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(GLOBALPLANTAS.planta) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalplantasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalplantasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalplantasPK(BigDecimal idplanta) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPLANTAS.idplanta,GLOBALPLANTAS.planta,GLOBALPLANTAS.domicilio,GLOBALPLANTAS.idlocalidad,globallocalidades.localidad,GLOBALPLANTAS.codpostal,GLOBALPLANTAS.telefonos,GLOBALPLANTAS.fax,GLOBALPLANTAS.tareaquedesa,GLOBALPLANTAS.email,GLOBALPLANTAS.esheadquarter,GLOBALPLANTAS.usuarioalt,GLOBALPLANTAS.usuarioact,GLOBALPLANTAS.fechaalt,GLOBALPLANTAS.fechaact FROM GLOBALPLANTAS, globallocalidades where globallocalidades.idlocalidad = GLOBALPLANTAS.idlocalidad and GLOBALPLANTAS.idplanta="
				+ idplanta.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalplantasPK( BigDecimal idplanta ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalplantasPK( BigDecimal idplanta )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalplantasDelete(BigDecimal idplanta) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALPLANTAS WHERE idplanta="
				+ idplanta.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALPLANTAS WHERE idplanta="
						+ idplanta.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalplantasDelete( BigDecimal idplanta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalplantasDelete( BigDecimal idplanta )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalplantasCreate(String planta, String domicilio,
			BigDecimal idlocalidad, String codpostal, String telefonos,
			String fax, String tareaquedesa, String email,
			String esheadquarter, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (planta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: planta ";
		if (domicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: domicilio ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (codpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codpostal ";
		if (tareaquedesa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tareaquedesa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (planta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: planta ";
		if (domicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: domicilio ";
		if (codpostal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codpostal ";
		if (tareaquedesa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tareaquedesa ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALPLANTAS(planta, domicilio, idlocalidad, codpostal, telefonos, fax, tareaquedesa, email, esheadquarter, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, planta);
				insert.setString(2, domicilio);
				insert.setBigDecimal(3, idlocalidad);
				insert.setString(4, codpostal);
				insert.setString(5, telefonos);
				insert.setString(6, fax);
				insert.setString(7, tareaquedesa);
				insert.setString(8, email);
				insert.setString(9, esheadquarter);
				insert.setString(10, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalplantasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalplantasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalplantasCreateOrUpdate(BigDecimal idplanta,
			String planta, String domicilio, BigDecimal idlocalidad,
			String codpostal, String telefonos, String fax,
			String tareaquedesa, String email, String esheadquarter,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idplanta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idplanta ";
		if (planta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: planta ";
		if (domicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: domicilio ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (codpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codpostal ";
		if (tareaquedesa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tareaquedesa ";

		// 2. sin nada desde la pagina
		if (planta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: planta ";
		if (domicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: domicilio ";
		if (codpostal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codpostal ";
		if (tareaquedesa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tareaquedesa ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalplantas WHERE idplanta = "
					+ idplanta.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPLANTAS SET planta=?, domicilio=?, idlocalidad=?, codpostal=?, telefonos=?, fax=?, tareaquedesa=?, email=?, esheadquarter=?, usuarioact=?, fechaact=? WHERE idplanta=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, planta);
					insert.setString(2, domicilio);
					insert.setBigDecimal(3, idlocalidad);
					insert.setString(4, codpostal);
					insert.setString(5, telefonos);
					insert.setString(6, fax);
					insert.setString(7, tareaquedesa);
					insert.setString(8, email);
					insert.setString(9, esheadquarter);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idplanta);
				} else {
					String ins = "INSERT INTO GLOBALPLANTAS(planta, domicilio, idlocalidad, codpostal, telefonos, fax, tareaquedesa, email, esheadquarter, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, planta);
					insert.setString(2, domicilio);
					insert.setBigDecimal(3, idlocalidad);
					insert.setString(4, codpostal);
					insert.setString(5, telefonos);
					insert.setString(6, fax);
					insert.setString(7, tareaquedesa);
					insert.setString(8, email);
					insert.setString(9, esheadquarter);
					insert.setString(10, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalplantasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalplantasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalplantasUpdate(BigDecimal idplanta, String planta,
			String domicilio, BigDecimal idlocalidad, String codpostal,
			String telefonos, String fax, String tareaquedesa, String email,
			String esheadquarter, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idplanta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idplanta ";
		if (planta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: planta ";
		if (domicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: domicilio ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (codpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codpostal ";
		if (tareaquedesa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tareaquedesa ";

		// 2. sin nada desde la pagina
		if (planta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: planta ";
		if (domicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: domicilio ";
		if (codpostal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codpostal ";
		if (tareaquedesa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tareaquedesa ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalplantas WHERE idplanta = "
					+ idplanta.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPLANTAS SET planta=?, domicilio=?, idlocalidad=?, codpostal=?, telefonos=?, fax=?, tareaquedesa=?, email=?, esheadquarter=?, usuarioact=?, fechaact=? WHERE idplanta=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, planta);
					insert.setString(2, domicilio);
					insert.setBigDecimal(3, idlocalidad);
					insert.setString(4, codpostal);
					insert.setString(5, telefonos);
					insert.setString(6, fax);
					insert.setString(7, tareaquedesa);
					insert.setString(8, email);
					insert.setString(9, esheadquarter);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idplanta);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalplantasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalplantasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// global puestos
	public List getGlobalpuestosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPUESTOS.idpuesto,GLOBALPUESTOS.puesto,GP.planta,CC1.contador,CC2.contador,CC3.contador,CC4.contador,CC5.contador,CC6.contador,CC7.contador,CC8.contador,GLOBALPUESTOS.usuarioalt,GLOBALPUESTOS.usuarioact,GLOBALPUESTOS.fechaalt,GLOBALPUESTOS.fechaact FROM GLOBALPUESTOS LEFT JOIN globalplantas GP  ON (GLOBALPUESTOS.idplanta  = GP.idplanta)LEFT JOIN globalcontadores CC1  ON (GLOBALPUESTOS.idconta_facturasa  = CC1.idcontador and  GLOBALPUESTOS.idempresa = CC1.idempresa)LEFT JOIN globalcontadores CC2  ON (GLOBALPUESTOS.idconta_facturasb  = CC2.idcontador and  GLOBALPUESTOS.idempresa = CC2.idempresa)LEFT JOIN globalcontadores CC3  ON (GLOBALPUESTOS.idconta_facturasc  = CC3.idcontador and  GLOBALPUESTOS.idempresa = CC3.idempresa)LEFT JOIN globalcontadores CC4  ON (GLOBALPUESTOS.idconta_recibos  = CC4.idcontador   and  GLOBALPUESTOS.idempresa = CC4.idempresa)LEFT JOIN globalcontadores CC5  ON (GLOBALPUESTOS.idconta_remitos1  = CC5.idcontador  and  GLOBALPUESTOS.idempresa = CC5.idempresa)LEFT JOIN globalcontadores CC6  ON (GLOBALPUESTOS.idconta_remitos2  = CC6.idcontador  and  GLOBALPUESTOS.idempresa = CC6.idempresa)LEFT JOIN globalcontadores CC7  ON (GLOBALPUESTOS.idconta_remitos3  = CC7.idcontador  and  GLOBALPUESTOS.idempresa = CC7.idempresa)LEFT JOIN globalcontadores CC8  ON (GLOBALPUESTOS.idconta_remitos4  = CC8.idcontador  and  GLOBALPUESTOS.idempresa = CC8.idempresa) "
				+ " where GLOBALPUESTOS.idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalpuestos() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalpuestos()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getGlobalpuestosOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALPUESTOS.idpuesto,GLOBALPUESTOS.puesto,GP.planta,CC1.contador,CC2.contador,CC3.contador,CC4.contador,CC5.contador,CC6.contador,CC7.contador,CC8.contador,GLOBALPUESTOS.usuarioalt,GLOBALPUESTOS.usuarioact,GLOBALPUESTOS.fechaalt,GLOBALPUESTOS.fechaact FROM GLOBALPUESTOS LEFT JOIN globalplantas GP  ON (GLOBALPUESTOS.idplanta  = GP.idplanta)LEFT JOIN globalcontadores CC1  ON (GLOBALPUESTOS.idconta_facturasa  = CC1.idcontador and  GLOBALPUESTOS.idempresa = CC1.idempresa)LEFT JOIN globalcontadores CC2  ON (GLOBALPUESTOS.idconta_facturasb  = CC2.idcontador and  GLOBALPUESTOS.idempresa = CC2.idempresa)LEFT JOIN globalcontadores CC3  ON (GLOBALPUESTOS.idconta_facturasc  = CC3.idcontador and  GLOBALPUESTOS.idempresa = CC3.idempresa)LEFT JOIN globalcontadores CC4  ON (GLOBALPUESTOS.idconta_recibos  = CC4.idcontador   and  GLOBALPUESTOS.idempresa = CC4.idempresa)LEFT JOIN globalcontadores CC5  ON (GLOBALPUESTOS.idconta_remitos1  = CC5.idcontador  and  GLOBALPUESTOS.idempresa = CC5.idempresa)LEFT JOIN globalcontadores CC6  ON (GLOBALPUESTOS.idconta_remitos2  = CC6.idcontador  and  GLOBALPUESTOS.idempresa = CC6.idempresa)LEFT JOIN globalcontadores CC7  ON (GLOBALPUESTOS.idconta_remitos3  = CC7.idcontador  and  GLOBALPUESTOS.idempresa = CC7.idempresa)LEFT JOIN globalcontadores CC8  ON (GLOBALPUESTOS.idconta_remitos4  = CC8.idcontador  and  GLOBALPUESTOS.idempresa = CC8.idempresa) "
				+ " where GLOBALPUESTOS.idempresa= "
				+ idempresa.toString()
				+ " and (GLOBALPUESTOS.idpuesto::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(GLOBALPUESTOS.puesto) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalpuestosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalpuestosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalpuestosPK(BigDecimal idpuesto, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GLOBALPUESTOS.idpuesto,GLOBALPUESTOS.puesto,GP.idplanta,GP.planta,CC1.idcontador,CC1.contador,CC2.idcontador,CC2.contador,CC3.idcontador,CC3.contador,CC4.idcontador,CC4.contador,CC5.idcontador,CC5.contador,CC6.idcontador,CC6.contador,CC7.idcontador,CC7.contador,CC8.idcontador,CC8.contador,GLOBALPUESTOS.usuarioalt,GLOBALPUESTOS.usuarioact,GLOBALPUESTOS.fechaalt,GLOBALPUESTOS.fechaact FROM GLOBALPUESTOS LEFT JOIN globalplantas GP  ON (GLOBALPUESTOS.idplanta  = GP.idplanta)LEFT JOIN globalcontadores CC1  ON (GLOBALPUESTOS.idconta_facturasa  = CC1.idcontador and  GLOBALPUESTOS.idempresa = CC1.idempresa)LEFT JOIN globalcontadores CC2  ON (GLOBALPUESTOS.idconta_facturasb  = CC2.idcontador and  GLOBALPUESTOS.idempresa = CC2.idempresa)LEFT JOIN globalcontadores CC3  ON (GLOBALPUESTOS.idconta_facturasc  = CC3.idcontador and  GLOBALPUESTOS.idempresa = CC3.idempresa)LEFT JOIN globalcontadores CC4  ON (GLOBALPUESTOS.idconta_recibos  = CC4.idcontador   and  GLOBALPUESTOS.idempresa = CC4.idempresa)LEFT JOIN globalcontadores CC5  ON (GLOBALPUESTOS.idconta_remitos1  = CC5.idcontador  and  GLOBALPUESTOS.idempresa = CC5.idempresa)LEFT JOIN globalcontadores CC6  ON (GLOBALPUESTOS.idconta_remitos2  = CC6.idcontador  and  GLOBALPUESTOS.idempresa = CC6.idempresa)LEFT JOIN globalcontadores CC7  ON (GLOBALPUESTOS.idconta_remitos3  = CC7.idcontador  and  GLOBALPUESTOS.idempresa = CC7.idempresa)LEFT JOIN globalcontadores CC8  ON (GLOBALPUESTOS.idconta_remitos4  = CC8.idcontador  and  GLOBALPUESTOS.idempresa = CC8.idempresa) "
				+ " WHERE GLOBALPUESTOS.idpuesto = "
				+ idpuesto.toString()
				+ " and GLOBALPUESTOS.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalpuestosPK( BigDecimal idpuesto ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalpuestosPK( BigDecimal idpuesto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalpuestosDelete(BigDecimal idpuesto, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALPUESTOS WHERE idpuesto="
				+ idpuesto.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALPUESTOS WHERE idpuesto = "
						+ idpuesto.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalpuestosDelete( BigDecimal idpuesto ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalpuestosDelete( BigDecimal idpuesto )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalpuestosCreate(String puesto, BigDecimal idplanta,
			String idconta_facturasa, String idconta_facturasb,
			String idconta_facturasc, String idconta_recibos,
			String idconta_remitos1, String idconta_remitos2,
			String idconta_remitos3, String idconta_remitos4,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (puesto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puesto ";
		if (idplanta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idplanta ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (puesto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: puesto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALPUESTOS(puesto, idplanta, idconta_facturasa, idconta_facturasb, idconta_facturasc, idconta_recibos, idconta_remitos1, idconta_remitos2, idconta_remitos3, idconta_remitos4, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, puesto);
				insert.setBigDecimal(2, idplanta);
				if (idconta_facturasa != ""
						&& !idconta_facturasa.equalsIgnoreCase("")) {
					insert.setBigDecimal(3, new BigDecimal(idconta_facturasa));
				} else {
					insert.setBigDecimal(3, null);
				}
				if (idconta_facturasb != ""
						&& !idconta_facturasb.equalsIgnoreCase("")) {
					insert.setBigDecimal(4, new BigDecimal(idconta_facturasb));
				} else {
					insert.setBigDecimal(4, null);
				}
				if (idconta_facturasc != ""
						&& !idconta_facturasc.equalsIgnoreCase("")) {
					insert.setBigDecimal(5, new BigDecimal(idconta_facturasc));
				} else {
					insert.setBigDecimal(5, null);
				}
				if (idconta_recibos != ""
						&& !idconta_recibos.equalsIgnoreCase("")) {
					insert.setBigDecimal(6, new BigDecimal(idconta_recibos));
				} else {
					insert.setBigDecimal(6, null);
				}
				if (idconta_remitos1 != ""
						&& !idconta_remitos1.equalsIgnoreCase("")) {
					insert.setBigDecimal(7, new BigDecimal(idconta_remitos1));
				} else {
					insert.setBigDecimal(7, null);
				}
				if (idconta_remitos2 != ""
						&& !idconta_remitos2.equalsIgnoreCase("")) {
					insert.setBigDecimal(8, new BigDecimal(idconta_remitos2));
				} else {
					insert.setBigDecimal(8, null);
				}
				if (idconta_remitos3 != ""
						&& !idconta_remitos3.equalsIgnoreCase("")) {
					insert.setBigDecimal(9, new BigDecimal(idconta_remitos3));
				} else {
					insert.setBigDecimal(9, null);
				}
				if (idconta_remitos4 != ""
						&& !idconta_remitos4.equalsIgnoreCase("")) {
					insert.setBigDecimal(10, new BigDecimal(idconta_remitos4));
				} else {
					insert.setBigDecimal(10, null);
				}
				insert.setString(11, usuarioalt);
				insert.setBigDecimal(12, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalpuestosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalpuestosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalpuestosCreateOrUpdate(BigDecimal idpuesto,
			String puesto, BigDecimal idplanta, String idconta_facturasa,
			String idconta_facturasb, String idconta_facturasc,
			String idconta_recibos, String idconta_remitos1,
			String idconta_remitos2, String idconta_remitos3,
			String idconta_remitos4, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpuesto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpuesto ";
		if (puesto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puesto ";
		if (idplanta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idplanta ";

		// 2. sin nada desde la pagina
		if (puesto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: puesto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalpuestos WHERE idpuesto = "
					+ idpuesto.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPUESTOS SET puesto=?, idplanta=?, idconta_facturasa=?, idconta_facturasb=?, idconta_facturasc=?, idconta_recibos=?, idconta_remitos1=?, idconta_remitos2=?, idconta_remitos3=?, idconta_remitos4=?, usuarioact=?, fechaact=? WHERE idpuesto=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, puesto);
					insert.setBigDecimal(2, idplanta);
					if (idconta_facturasa != null
							&& !idconta_facturasa.equalsIgnoreCase("null")) {
						insert.setBigDecimal(3, new BigDecimal(
								idconta_facturasa));
					} else {
						insert.setBigDecimal(3, null);
					}
					if (idconta_facturasb != null
							&& !idconta_facturasb.equalsIgnoreCase("null")) {
						insert.setBigDecimal(4, new BigDecimal(
								idconta_facturasb));
					} else {
						insert.setBigDecimal(4, null);
					}
					if (idconta_facturasc != null
							&& !idconta_facturasc.equalsIgnoreCase("null")) {
						insert.setBigDecimal(5, new BigDecimal(
								idconta_facturasc));
					} else {
						insert.setBigDecimal(5, null);
					}
					if (idconta_recibos != null
							&& !idconta_recibos.equalsIgnoreCase("null")) {
						insert
								.setBigDecimal(6, new BigDecimal(
										idconta_recibos));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idconta_remitos1 != null
							&& !idconta_remitos1.equalsIgnoreCase("null")) {
						insert.setBigDecimal(7,
								new BigDecimal(idconta_remitos1));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idconta_remitos2 != null
							&& !idconta_remitos2.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8,
								new BigDecimal(idconta_remitos2));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idconta_remitos3 != null
							&& !idconta_remitos3.equalsIgnoreCase("null")) {
						insert.setBigDecimal(9,
								new BigDecimal(idconta_remitos3));
					} else {
						insert.setBigDecimal(9, null);
					}
					if (idconta_remitos4 != null
							&& !idconta_remitos4.equalsIgnoreCase("null")) {
						insert.setBigDecimal(10, new BigDecimal(
								idconta_remitos4));
					} else {
						insert.setBigDecimal(10, null);
					}
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idpuesto);
					insert.setBigDecimal(14, idempresa);
				} else {
					String ins = "INSERT INTO GLOBALPUESTOS(puesto, idplanta, idconta_facturasa, idconta_facturasb, idconta_facturasc, idconta_recibos, idconta_remitos1, idconta_remitos2, idconta_remitos3, idconta_remitos4, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, puesto);
					insert.setBigDecimal(2, idplanta);
					if (idconta_facturasa != ""
							&& !idconta_facturasa.equalsIgnoreCase("")) {
						insert.setBigDecimal(3, new BigDecimal(
								idconta_facturasa));
					} else {
						insert.setBigDecimal(3, null);
					}
					if (idconta_facturasb != ""
							&& !idconta_facturasb.equalsIgnoreCase("")) {
						insert.setBigDecimal(4, new BigDecimal(
								idconta_facturasb));
					} else {
						insert.setBigDecimal(4, null);
					}
					if (idconta_facturasc != ""
							&& !idconta_facturasc.equalsIgnoreCase("")) {
						insert.setBigDecimal(5, new BigDecimal(
								idconta_facturasc));
					} else {
						insert.setBigDecimal(5, null);
					}
					if (idconta_recibos != ""
							&& !idconta_recibos.equalsIgnoreCase("")) {
						insert
								.setBigDecimal(6, new BigDecimal(
										idconta_recibos));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idconta_remitos1 != ""
							&& !idconta_remitos1.equalsIgnoreCase("")) {
						insert.setBigDecimal(7,
								new BigDecimal(idconta_remitos1));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idconta_remitos2 != ""
							&& !idconta_remitos2.equalsIgnoreCase("")) {
						insert.setBigDecimal(8,
								new BigDecimal(idconta_remitos2));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idconta_remitos3 != ""
							&& !idconta_remitos3.equalsIgnoreCase("")) {
						insert.setBigDecimal(9,
								new BigDecimal(idconta_remitos3));
					} else {
						insert.setBigDecimal(9, null);
					}
					if (idconta_remitos4 != ""
							&& !idconta_remitos4.equalsIgnoreCase("")) {
						insert.setBigDecimal(10, new BigDecimal(
								idconta_remitos4));
					} else {
						insert.setBigDecimal(10, null);
					}
					insert.setString(11, usuarioalt);
					insert.setBigDecimal(12, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalpuestosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalpuestosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalpuestosUpdate(BigDecimal idpuesto, String puesto,
			BigDecimal idplanta, String idconta_facturasa,
			String idconta_facturasb, String idconta_facturasc,
			String idconta_recibos, String idconta_remitos1,
			String idconta_remitos2, String idconta_remitos3,
			String idconta_remitos4, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpuesto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpuesto ";
		if (puesto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puesto ";
		if (idplanta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idplanta ";

		// 2. sin nada desde la pagina
		if (puesto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: puesto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalpuestos WHERE idpuesto = "
					+ idpuesto.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALPUESTOS SET puesto=?, idplanta=?, idconta_facturasa=?, idconta_facturasb=?, idconta_facturasc=?, idconta_recibos=?, idconta_remitos1=?, idconta_remitos2=?, idconta_remitos3=?, idconta_remitos4=?, usuarioact=?, fechaact=? WHERE idpuesto=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, puesto);
					insert.setBigDecimal(2, idplanta);
					if (idconta_facturasa != null
							&& !idconta_facturasa.equalsIgnoreCase("null")) {
						insert.setBigDecimal(3, new BigDecimal(
								idconta_facturasa));
					} else {
						insert.setBigDecimal(3, null);
					}
					if (idconta_facturasb != null
							&& !idconta_facturasb.equalsIgnoreCase("null")) {
						insert.setBigDecimal(4, new BigDecimal(
								idconta_facturasb));
					} else {
						insert.setBigDecimal(4, null);
					}
					if (idconta_facturasc != null
							&& !idconta_facturasc.equalsIgnoreCase("null")) {
						insert.setBigDecimal(5, new BigDecimal(
								idconta_facturasc));
					} else {
						insert.setBigDecimal(5, null);
					}
					if (idconta_recibos != null
							&& !idconta_recibos.equalsIgnoreCase("null")) {
						insert
								.setBigDecimal(6, new BigDecimal(
										idconta_recibos));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idconta_remitos1 != null
							&& !idconta_remitos1.equalsIgnoreCase("null")) {
						insert.setBigDecimal(7,
								new BigDecimal(idconta_remitos1));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idconta_remitos2 != null
							&& !idconta_remitos2.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8,
								new BigDecimal(idconta_remitos2));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idconta_remitos3 != null
							&& !idconta_remitos3.equalsIgnoreCase("null")) {
						insert.setBigDecimal(9,
								new BigDecimal(idconta_remitos3));
					} else {
						insert.setBigDecimal(9, null);
					}
					if (idconta_remitos4 != null
							&& !idconta_remitos4.equalsIgnoreCase("null")) {
						insert.setBigDecimal(10, new BigDecimal(
								idconta_remitos4));
					} else {
						insert.setBigDecimal(10, null);
					}
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idpuesto);
					insert.setBigDecimal(14, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalpuestosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalpuestosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov plantas
	public List getPlantasAll(long limit, long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idplanta,planta,usuarioalt,usuarioact,fechaalt,fechaact FROM globalplantas ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getPlantasAll() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getPlantasAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPlantasOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idplanta,planta,usuarioalt,usuarioact,fechaalt,fechaact FROM globalplantas where UPPER(planta) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPlantasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPlantasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// lov plantas
	public List getContadoresAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcontador,contador,usuarioalt,usuarioact,fechaalt,fechaact FROM globalcontadores where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getContadoresAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getContadoresAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getContadoresOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcontador,contador,usuarioalt,usuarioact,fechaalt,fechaact FROM globalcontadores where idempresa = "
				+ idempresa.toString()
				+ " and (idcontador::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(contador) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getContadoresOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getContadoresOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// TODO: UNIFICAR 20061020 EJV
	// ATENCION !!!!:
	// --------------------------------------------------------------------
	// Metodos:...........................................................................
	// getExisteArticuloDeposito - getCantidadArticuloDeposito -
	// getValorSecuencia
	// -----------------------------------------------------------------------------------
	// duplicado en ProveedoresBean, solucion provisoria, para poder
	// generar transaccion con una sola coneccion.
	public static BigDecimal getValorSequencia(String sequencia, Connection conn)
			throws EJBException {
		PreparedStatement statement;
		String qSeq = "select currval(?::regclass)";
		ResultSet rsSeq;
		BigDecimal id = null;
		try {
			statement = conn.prepareStatement(qSeq);
			statement.setString(1, sequencia);
			rsSeq = statement.executeQuery();
			if (rsSeq.next()) {
				id = rsSeq.getBigDecimal(1);
			}

		} catch (Exception e) {
			log.error("getValorSequencia(String sequencia): " + e);
		}

		return id;
	}

	// Verifica la cantidad de un determinado articulo en un deposito en
	// particular.
	// TODO: UNIFICAR 20061020 EJV
	// ATENCION !!!!: -----------------------------------------------
	// Metodos getExisteArticuloDeposito - getCantidadArticuloDeposito
	// --------------------------------------------------------------
	// duplicado en ProveedoresBean, solucion provisoria, para poder
	// generar transaccion con una sola coneccion.
	public static BigDecimal getCantidadArticuloDeposito(String articulo,
			BigDecimal deposito, BigDecimal idempresa, Connection conn)
			throws EJBException {
		PreparedStatement statement;
		String qCant = "SELECT canti_sb FROM stockstockbis WHERE articu_sb=? AND deposi_sb=? AND idempresa=?";
		ResultSet rsCant;
		BigDecimal cantidad = new BigDecimal("0");
		try {
			statement = conn.prepareStatement(qCant);
			statement.setString(1, articulo);
			statement.setBigDecimal(2, deposito);
			statement.setBigDecimal(3, idempresa);
			rsCant = statement.executeQuery();
			if (rsCant.next()) {
				cantidad = rsCant.getBigDecimal(1);
			}

		} catch (Exception e) {
			log
					.error("getCantidadArticuloDeposito(String articulo, BigDecimal deposito): "
							+ e);
		}

		return cantidad;
	}

	// Verifica la cantidad en reserva de un determinado articulo en un deposito
	// en particular.
	// --------------------------------------------------------------

	public static BigDecimal getCantidadReservaArticuloDeposito(
			String articulo, BigDecimal deposito, BigDecimal idempresa,
			Connection conn) throws EJBException {
		PreparedStatement statement;
		String qCant = "SELECT pedid_sb FROM stockstockbis WHERE articu_sb=? AND deposi_sb=? AND idempresa=?";
		ResultSet rsCant;
		BigDecimal cantidad = new BigDecimal("0");
		try {
			statement = conn.prepareStatement(qCant);
			statement.setString(1, articulo);
			statement.setBigDecimal(2, deposito);
			statement.setBigDecimal(3, idempresa);
			rsCant = statement.executeQuery();
			if (rsCant.next()) {
				cantidad = rsCant.getBigDecimal(1);
			}

		} catch (Exception e) {
			log
					.error("getCantidadReservaArticuloDeposito(String articulo, BigDecimal deposito): "
							+ e);
		}

		return cantidad;
	}

	// Verifica la cantidad de un determinado articulo en un deposito en
	// particular.
	// TODO: UNIFICAR 20061020 EJV
	// ATENCION !!!!:
	// --------------------------------------------------------------------
	// Metodos:...........................................................................
	// getExisteArticuloDeposito - getCantidadArticuloDeposito -
	// getValorSecuencia
	// -----------------------------------------------------------------------------------
	// duplicado en ProveedoresBean, solucion provisoria, para poder
	// generar transaccion con una sola coneccion.

	public static boolean getExisteArticuloDeposito(String articulo,
			BigDecimal deposito, BigDecimal idempresa, Connection conn)
			throws EJBException {
		PreparedStatement statement;
		String qExiste = "SELECT count(1) FROM stockstockbis WHERE articu_sb=? AND deposi_sb=? AND idempresa=?";
		ResultSet rsExiste;
		boolean existe = false;
		try {
			statement = conn.prepareStatement(qExiste);
			statement.setString(1, articulo);
			statement.setBigDecimal(2, deposito);
			statement.setBigDecimal(3, idempresa);
			rsExiste = statement.executeQuery();
			if (rsExiste.next()) {
				if (rsExiste.getBigDecimal(1).compareTo(new BigDecimal("0")) > 0)
					existe = true;
			}

		} catch (Exception e) {
			log
					.error("getExisteArticuloDeposito(String articulo, BigDecimal deposito): "
							+ e);
		}

		return existe;
	}

	public static BigDecimal getNextValorSequencia(String sequencia,
			Connection conn) throws EJBException {
		PreparedStatement statement;
		String qSeq = "select nextval(?::regclass)";
		ResultSet rsSeq;
		BigDecimal id = null;
		try {
			statement = conn.prepareStatement(qSeq);
			statement.setString(1, sequencia);
			rsSeq = statement.executeQuery();
			if (rsSeq.next()) {
				id = rsSeq.getBigDecimal(1);
			}

		} catch (Exception e) {
			log.error("getNextValorSequencia(String sequencia): " + e);
		}

		return id;
	}

	public static boolean hasStockNegativo(BigDecimal idempresa,
			Connection dbconn) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select valor from setupvariables where variable='stockEnNegativo' AND idempresa = "
				+ idempresa.toString();
		boolean salida = false;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			String valor = "";
			while (rsSalida.next()) {
				valor = rsSalida.getString("valor");
			}
			if (valor.equalsIgnoreCase("S"))
				salida = true;
			log.debug("Stock en negativo: " + valor);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : hasStockNegativo(BigDecimal idempresa, Connection dbconn) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: hasStockNegativo(BigDecimal idempresa, Connection dbconn)  "
							+ ex);
		}
		return salida;
	}

	public static boolean hasMovTesoIdentificador(String identificador,
			BigDecimal idempresa, Connection dbconn) throws EJBException {
		ResultSet rsSalida = null;
		boolean hasMovimientos = true;
		String cQuery = ""
				+ "SELECT count(1) FROM cajamovteso WHERE cartera_mt = '"
				+ identificador.toUpperCase() + "' AND idempresa="
				+ idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				if (rsSalida.getInt(1) == 0)
					hasMovimientos = false;
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : hasMovTesoIdentificador( ...  ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: hasMovTesoIdentificador( ... )  "
							+ ex);
		}

		return hasMovimientos;

	}

	public static boolean isExisteCtaImputable(BigDecimal idcuenta,
			int ejercicioactivo, BigDecimal idempresa, Connection dbconn)
			throws EJBException {
		ResultSet rsSalida = null;
		boolean isExisteImputable = false;
		String cQuery = ""
				+ "SELECT count(idcuenta) FROM contableinfiplan WHERE ejercicio = "
				+ ejercicioactivo + " AND idcuenta=" + idcuenta
				+ " AND UPPER(inputable)='S' AND idempresa="
				+ idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				if (rsSalida.getInt(1) > 0)
					isExisteImputable = true;
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : isExisteCtaImputable( BigDecimal idcuenta, ejercicioactivo  ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isExisteCtaImputable( BigDecimal idcuenta, ejercicioactivo )  "
							+ ex);
		}
		return isExisteImputable;
	}

	public static boolean isCombrobanteConStock(BigDecimal nrointerno,
			BigDecimal idempresa, Connection dbconn) throws EJBException {
		ResultSet rsSalida = null;
		boolean isCompConStock = false;
		String cQuery = "SELECT count(comprob_ms) as existe  FROM stockmovstock WHERE comprob_ms="
				+ nrointerno.toString()
				+ " AND UPPER(sistema_ms)='P' AND idempresa="
				+ idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next())
				isCompConStock = rsSalida.getDouble("existe") < 1 ? false
						: true;

			log.info("isCompConStock        :" + isCompConStock);

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : isCombrobanteConStock( ...........  ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isCombrobanteConStock( ......... )  "
							+ ex);
		}
		return isCompConStock;
	}

	public static BigDecimal getSaldoMovProveed(BigDecimal nrointerno,
			BigDecimal idempresa, Connection conn) throws EJBException {
		PreparedStatement statement;
		String qCant = "SELECT saldo FROM proveedomovprov WHERE nrointerno=? AND  idempresa=?";
		ResultSet rs;
		BigDecimal saldo = new BigDecimal(0);
		try {
			statement = conn.prepareStatement(qCant);
			statement.setBigDecimal(1, nrointerno);
			statement.setBigDecimal(2, idempresa);
			rs = statement.executeQuery();
			if (rs != null) {
				if (rs.next()) {
					saldo = rs.getBigDecimal(1);
				} else {
					log.warn("getSaldoMovProveed(): RS no hay proximo");
				}
			} else {
				log.warn("getSaldoMovProveed(): RS vacio");
			}

		} catch (Exception e) {
			log
					.error("getSaldoMovProveed(String articulo, BigDecimal deposito): "
							+ e);
		}

		return saldo;
	}

	// lov puestos
	public List getPuestosLovAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpuesto,puesto,usuarioalt,usuarioact,fechaalt,fechaact FROM globalpuestos "
				+ " where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getPuestosLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPuestosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPuestosLovOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpuesto,puesto,usuarioalt,usuarioact,fechaalt,fechaact FROM globalpuestos "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idpuesto::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(puesto) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPuestosLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPuestosLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// convertir un importe a letras para la emision de documentos comerciales
	// (Ej. cheques, recibos, etc).

	public String convertirNumerosALetras(int num) {
		NumeroToText numero = new NumeroToText(num);
		return numero.convertirLetras(num);
	}

	// formula Cabecera
	public List getFormulas_cabeAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idformulacabe,formula,usuarioalt,usuarioact,fechaalt,fechaact FROM FORMULAS_CABE ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getFormulas_cabe() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_cabe()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getFormulas_cabeOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idformulacabe,formula,usuarioalt,usuarioact,fechaalt,fechaact FROM FORMULAS_CABE WHERE UPPER(FORMULA) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getFormulas_cabe(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_cabe(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getFormulas_cabePK(BigDecimal idformulacabe)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idformulacabe,formula,usuarioalt,usuarioact,fechaalt,fechaact FROM FORMULAS_CABE WHERE idformulacabe="
				+ idformulacabe.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getFormulas_cabePK( BigDecimal idformulacabe ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_cabePK( BigDecimal idformulacabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String formulas_cabeDelete(BigDecimal idformulacabe)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM FORMULAS_CABE WHERE idformulacabe="
				+ idformulacabe.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM FORMULAS_CABE WHERE idformulacabe="
						+ idformulacabe.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : formulas_cabeDelete( BigDecimal idformulacabe ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: formulas_cabeDelete( BigDecimal idformulacabe )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String formulas_cabeCreate(String formula, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (formula.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formula ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO FORMULAS_CABE(formula, usuarioalt ) VALUES (?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, formula);
				insert.setString(2, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String formulas_cabeCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String formulas_cabeCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String formulas_cabeCreateOrUpdate(BigDecimal idformulacabe,
			String formula, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idformulacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformulacabe ";
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";

		// 2. sin nada desde la pagina
		if (formula.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formula ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM formulas_cabe WHERE idformulacabe = "
					+ idformulacabe.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE FORMULAS_CABE SET formula=?, usuarioact=?, fechaact=? WHERE idformulacabe=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, formula);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idformulacabe);
				} else {
					String ins = "INSERT INTO FORMULAS_CABE(formula, usuarioalt ) VALUES (?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, formula);
					insert.setString(2, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String formulas_cabeCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String formulas_cabeCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String formulas_cabeUpdate(BigDecimal idformulacabe, String formula,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idformulacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformulacabe ";
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";

		// 2. sin nada desde la pagina
		if (formula.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formula ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM formulas_cabe WHERE idformulacabe = "
					+ idformulacabe.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE FORMULAS_CABE SET formula=?, usuarioact=?, fechaact=? WHERE idformulacabe=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, formula);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idformulacabe);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String formulas_cabeUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String formulas_cabeUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// traigo todos el detalle de la cabecera de la formula
	public List getFormulas_detaAll(String idformulacabe, long limit,
			long offset) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT FORMULAS_DETA.idformula,FORMULAS_DETA.precedencia,FORMULAS_DETA.formuladesc,FORMULAS_DETA.formula_logica,FORMULAS_DETA.formula_calculo,FORMULAS_DETA.usuarioalt,FORMULAS_DETA.usuarioact,FORMULAS_DETA.fechaalt,FORMULAS_DETA.fechaact FROM FORMULAS_DETA,FORMULAS_CABE where FORMULAS_CABE.idformulacabe = FORMULAS_DETA.idformulacabe"
				+ " and FORMULAS_DETA.idformulacabe = '"
				+ idformulacabe.toString()
				+ "'"
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getFormulas_detaAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_detaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// traigo el total de todos el detalle de la cabecera de la formula
	public long getTotalFormulas_detaAll(String idformulacabe)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM FORMULAS_DETA WHERE idformulacabe ='"
				+ idformulacabe.toString() + "'";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalFormulas_detaAll()- Error al recuperar total: "
								+ idformulacabe);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalFormulas_detaAll()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalFormulas_detaAll()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// traigo por ocurrencia el detalle de la cabecera de la formula
	public List getFormulas_detaOcu(String idformulacabe, long limit,
			long offset, String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT FORMULAS_DETA.idformula,FORMULAS_DETA.precedencia,FORMULAS_DETA.formuladesc,FORMULAS_DETA.formula_logica,FORMULAS_DETA.formula_calculo,FORMULAS_DETA.usuarioalt,FORMULAS_DETA.usuarioact,FORMULAS_DETA.fechaalt,FORMULAS_DETA.fechaact FROM FORMULAS_DETA,FORMULAS_CABE where FORMULAS_CABE.idformulacabe = FORMULAS_DETA.idformulacabe"
				+ " and FORMULAS_DETA.idformulacabe = '"
				+ idformulacabe.toString()
				+ "'"
				+ " and (FORMULAS_DETA.idformula::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(FORMULAS_DETA.precedencia::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getFormulas_detaOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_detaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// traigo por ocurrencia el total detalle de la cabecera de la formula
	public long getTotalFormulas_detaOcu(String idformulacabe, String[] campos,
			String ocurrencia) throws EJBException {
		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM vformuladetalle WHERE idformulacabe = '"
				+ idformulacabe.toString() + "'";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalFormulas_detaOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalFormulas_detaOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalFormulas_detaOcu()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// por primary key (primer campo por defecto)

	public List getFormulas_detaPK(BigDecimal idformula) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT FORMULAS_DETA.idformula,FORMULAS_DETA.idformulacabe,FORMULAS_CABE.formula,FORMULAS_DETA.precedencia,FORMULAS_DETA.formuladesc,FORMULAS_DETA.formula_logica,FORMULAS_DETA.formula_calculo,FORMULAS_DETA.usuarioalt,FORMULAS_DETA.usuarioact,FORMULAS_DETA.fechaalt,FORMULAS_DETA.fechaact FROM FORMULAS_DETA,FORMULAS_CABE where FORMULAS_CABE.idformulacabe = FORMULAS_DETA.idformulacabe and FORMULAS_DETA.idformula="
				+ idformula.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getFormulas_detaPK( BigDecimal idformula ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getFormulas_detaPK( BigDecimal idformula )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String formulas_detaDelete(BigDecimal idformula) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM FORMULAS_DETA WHERE idformula="
				+ idformula.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM FORMULAS_DETA WHERE idformula="
						+ idformula.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : formulas_detaDelete( BigDecimal idformula ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: formulas_detaDelete( BigDecimal idformula )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String formulas_detaCreate(BigDecimal idformulacabe,
			BigDecimal precedencia, String formuladesc, String formula_logica,
			String formula_calculo, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idformulacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformulacabe ";
		if (formuladesc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formuladesc ";
		if (formula_logica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula_logica ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (formuladesc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formuladesc ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO FORMULAS_DETA(idformulacabe, precedencia, formuladesc, formula_logica, formula_calculo, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idformulacabe);
				insert.setBigDecimal(2, precedencia);
				insert.setString(3, formuladesc);
				insert.setString(4, formula_logica);
				insert.setString(5, formula_calculo);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String formulas_detaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String formulas_detaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String formulas_detaCreateOrUpdate(BigDecimal idformula,
			BigDecimal idformulacabe, BigDecimal precedencia,
			String formuladesc, String formula_logica, String formula_calculo,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idformula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformula ";
		if (idformulacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformulacabe ";
		if (formuladesc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formuladesc ";
		if (formula_logica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula_logica ";

		// 2. sin nada desde la pagina
		if (formuladesc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formuladesc ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM formulas_deta WHERE idformula = "
					+ idformula.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE FORMULAS_DETA SET idformulacabe=?, precedencia=?, formuladesc=?, formula_logica=?, formula_calculo=?, usuarioact=?, fechaact=? WHERE idformula=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idformulacabe);
					insert.setBigDecimal(2, precedencia);
					insert.setString(3, formuladesc);
					insert.setString(4, formula_logica);
					insert.setString(5, formula_calculo);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idformula);
				} else {
					String ins = "INSERT INTO FORMULAS_DETA(idformulacabe, precedencia, formuladesc, formula_logica, formula_calculo, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idformulacabe);
					insert.setBigDecimal(2, precedencia);
					insert.setString(3, formuladesc);
					insert.setString(4, formula_logica);
					insert.setString(5, formula_calculo);
					insert.setString(6, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String formulas_detaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String formulas_detaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String formulas_detaUpdate(BigDecimal idformula,
			BigDecimal idformulacabe, BigDecimal precedencia,
			String formuladesc, String formula_logica, String formula_calculo,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idformula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformula ";
		if (idformulacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idformulacabe ";
		if (formuladesc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formuladesc ";
		if (formula_logica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula_logica ";

		// 2. sin nada desde la pagina
		if (formuladesc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formuladesc ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM formulas_deta WHERE idformula = "
					+ idformula.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE FORMULAS_DETA SET idformulacabe=?, precedencia=?, formuladesc=?, formula_logica=?, formula_calculo=?, usuarioact=?, fechaact=? WHERE idformula=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idformulacabe);
					insert.setBigDecimal(2, precedencia);
					insert.setString(3, formuladesc);
					insert.setString(4, formula_logica);
					insert.setString(5, formula_calculo);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idformula);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String formulas_detaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String formulas_detaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// empresa
	public List getGlobalempresasAll(long limit, long offset)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idempresa,empresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALEMPRESAS ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalempresas() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalempresas()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalempresasAll() throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idempresa,empresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALEMPRESAS ORDER BY 2  ;";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalempresas() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalempresas()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalempresasOcu(long limit, long offset, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idempresa,empresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALEMPRESAS "
				+ " where (idempresa::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(empresa) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalempresasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalempresasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalempresasPK(BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idempresa,empresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALEMPRESAS WHERE idempresa="
				+ idempresa.toString();
		;
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalempresasPK( BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalempresasPK( BigDecimal idempresa )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalempresasDelete(BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALEMPRESAS WHERE idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALEMPRESAS WHERE idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalempresasDelete( BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalempresasDelete( BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalempresasCreate(String empresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (empresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: empresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (empresa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: empresa ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALEMPRESAS(empresa, usuarioalt ) VALUES (?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, empresa);
				insert.setString(2, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalempresasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalempresasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalempresasCreateOrUpdate(BigDecimal idempresa,
			String empresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (empresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: empresa ";

		// 2. sin nada desde la pagina
		if (empresa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: empresa ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalempresas WHERE idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALEMPRESAS SET empresa=?, usuarioact=?, fechaact=? WHERE idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, empresa);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idempresa);
				} else {
					String ins = "INSERT INTO GLOBALEMPRESAS(empresa, usuarioalt ) VALUES (?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, empresa);
					insert.setString(2, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalempresasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalempresasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalempresasUpdate(BigDecimal idempresa, String empresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (empresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: empresa ";

		// 2. sin nada desde la pagina
		if (empresa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: empresa ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalempresas WHERE idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALEMPRESAS SET empresa=?, usuarioact=?, fechaact=? WHERE idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, empresa);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalempresasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalempresasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// total All GLOBALCONTADORES
	public long getTotalglobalcontadoresAll(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  GLOBALCONTADORES where idempresa = "
				+ idempresa.toString();
		;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalcontadoresAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalglobalcontadoresAll()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalglobalcontadoresAll()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total Ocu GLOBALCONTADORES
	public long getTotalglobalcontadoresOcu(BigDecimal idempresa,
			String[] campos, String ocurrencia) throws EJBException {
		/**
		 * Entidad: GLOBALCONTADORES
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM GLOBALCONTADORES WHERE idempresa = "
				+ idempresa + "";
		String like = "";
		int len = campos.length;
		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalcontadoresOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalglobalcontadoresOcu()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalglobalcontadoresOcu()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total All GLOBALPUESTOS
	public long getTotalglobalpuestosAll(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  GLOBALPUESTOS where idempresa = "
				+ idempresa.toString();
		;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalpuestosAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalglobalpuestosAll()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalglobalpuestosAll()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// total Ocu GLOBALPUESTOS
	public long getTotalglobalpuestosOcu(BigDecimal idempresa, String[] campos,
			String ocurrencia) throws EJBException {
		/**
		 * Entidad: GLOBALPUESTOS
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM GLOBALPUESTOS WHERE idempresa = "
				+ idempresa + "";
		String like = "";
		int len = campos.length;
		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalpuestosOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalglobalpuestosOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalglobalpuestosOcu()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// total All SETUPVARIABLES
	public long getTotalsetupvariablesAll(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  SETUPVARIABLES where idempresa = "
				+ idempresa.toString();
		;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalsetupvariablesAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalsetupvariablesAll()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalsetupvariablesAll()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total Ocu SETUPVARIABLES
	public long getTotalsetupvariablesOcu(BigDecimal idempresa,
			String[] campos, String ocurrencia) throws EJBException {
		/**
		 * Entidad: SETUPVARIABLES
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM SETUPVARIABLES WHERE idempresa = "
				+ idempresa + "";
		String like = "";
		int len = campos.length;
		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalsetupvariablesOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalsetupvariablesOcu()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalsetupvariablesOcu()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total All GLOBALUSUARIOS
	public long getTotalglobalusuariosAll(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  GLOBALUSUARIOS where idempresa = "
				+ idempresa.toString();
		;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalusuariosAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalglobalusuariosAll()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalglobalusuariosAll()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total Ocu GLOBALUSUARIOS
	public long getTotalglobalusuariosOcu(BigDecimal idempresa,
			String[] campos, String ocurrencia) throws EJBException {
		/**
		 * Entidad: GLOBALUSUARIOS
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM GLOBALUSUARIOS WHERE idempresa = "
				+ idempresa + "";
		String like = "";
		int len = campos.length;
		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalglobalusuariosOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalglobalusuariosOcu()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalglobalusuariosOcu()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	public String getImagencustomintro() throws EJBException {
		return imagencustomintro;
	}

	public String getImagenescustompath() throws EJBException {
		return imagenescustompath;
	}

	public String getImagencustommenu() throws EJBException {
		return imagencustommenu;
	}

	public String getImagenescustomapppath() throws EJBException {
		return imagenescustomapppath;
	}

	public String getImagenescustomapprelativepath() throws EJBException {
		return imagenescustomapprelativepath;
	}

	public String getJaspercustompath() throws EJBException {
		return jaspercustompath;
	}

	public String getJaspercustomapppath() throws EJBException {
		return jaspercustomapppath;
	}

	/**
	 * Metodo: copyFile .....................................................
	 * Objetivo: Copiar archivos.............................................
	 * Fecha: 20070921 ......................................................
	 * Autor: EJV ...........................................................
	 */

	public static boolean copyFile(String fileFrom, String fileDest,
			boolean sobreEscribir) throws EJBException {
		boolean result = false;
		File inputFile = null;
		File outputFile = null;
		try {

			inputFile = new File(fileFrom);
			outputFile = new File(fileDest);

			if ((sobreEscribir) || (!sobreEscribir && !outputFile.exists())) {

				InputStream in = new FileInputStream(inputFile);
				OutputStream out = new FileOutputStream(outputFile);

				// Transfer bytes from in to out
				byte[] buf = new byte[1024];
				int len;
				while ((len = in.read(buf)) > 0) {
					out.write(buf, 0, len);
				}
				in.close();
				out.close();

			}

		} catch (Exception e) {
			log
					.error("copyFile(String fileFrom, String fileDest,	boolean sobreEscribir):"
							+ e);
		}
		return result;
	}

	/**
	 * Metodo: copyDir ....................................................
	 * Objetivo: Copiar archivos / directorios contenidos en un ...........
	 * directorio especifico de forma recursiva............................
	 * Fecha:20070924 .....................................................
	 * Autor: EJV..........................................................
	 */

	public static boolean copyDir(String dirIn, String dirOut)
			throws EJBException {
		File directorioIn = new File(dirIn);
		boolean resultado = true;
		try {

			File[] arbolIn = directorioIn.listFiles();
			for (int j = 0; j < arbolIn.length; j++) {

				if (arbolIn[j].isDirectory()) {

					File newdir = new File(dirOut + arbolIn[j].getName());
					newdir.mkdir();
					copyDir(dirIn + arbolIn[j].getName() + File.separator,
							dirOut + arbolIn[j].getName() + File.separator);

				} else {

					copyFile(dirIn + arbolIn[j].getName(), dirOut
							+ arbolIn[j].getName(), false);

				}
			}

		} catch (Exception e) {
			log
					.error("copyDir(...) - [Verificar existencia de diretorios(in/out)]: "
							+ e);
		}

		return resultado;
	}

	// tickets proyectos categorias
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_proyectos_categoriasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idproyectocat,proyectocat,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_PROYECTOS_CATEGORIAS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_proyectos_categoriasAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectos_categoriasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_proyectos_categoriasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idproyectocat,proyectocat,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM TICKETS_PROYECTOS_CATEGORIAS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idproyectocat::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(proyectocat) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_proyectos_categoriasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectos_categoriasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_proyectos_categoriasPK(BigDecimal idproyectocat,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idproyectocat,proyectocat,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_PROYECTOS_CATEGORIAS WHERE idproyectocat="
				+ idproyectocat.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_proyectos_categoriasPK( Integer idproyectocat ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectos_categoriasPK( Integer idproyectocat )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_proyectos_categoriasDelete(BigDecimal idproyectocat,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_PROYECTOS_CATEGORIAS "
				+ " WHERE idproyectocat = " + idproyectocat.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_PROYECTOS_CATEGORIAS "
						+ " WHERE idproyectocat = " + idproyectocat.toString()
						+ "and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_proyectos_categoriasDelete( Integer idproyectocat ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_proyectos_categoriasDelete( Integer idproyectocat )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_proyectos_categoriasCreate(String proyectocat,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (proyectocat == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: proyectocat ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (proyectocat.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Proyecto categoria ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_PROYECTOS_CATEGORIAS(proyectocat, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, proyectocat);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_proyectos_categoriasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_proyectos_categoriasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_proyectos_categoriasCreateOrUpdate(
			BigDecimal idproyectocat, String proyectocat, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idproyectocat == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproyectocat ";
		if (proyectocat == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: proyectocat ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (proyectocat.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: proyectocat ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_proyectos_categorias WHERE idproyectocat = "
					+ idproyectocat.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PROYECTOS_CATEGORIAS SET proyectocat=?, idempresa=?, usuarioact=?, fechaact=? WHERE idproyectocat=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, proyectocat);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idproyectocat);
				} else {
					String ins = "INSERT INTO TICKETS_PROYECTOS_CATEGORIAS(proyectocat, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, proyectocat);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_proyectos_categoriasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_proyectos_categoriasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_proyectos_categoriasUpdate(BigDecimal idproyectocat,
			String proyectocat, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idproyectocat == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproyectocat ";
		if (proyectocat == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: proyectocat ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (proyectocat.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Proyecto categoria ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_proyectos_categorias WHERE idproyectocat = "
					+ idproyectocat.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PROYECTOS_CATEGORIAS SET proyectocat=?, idempresa=?, usuarioact=?, fechaact=? WHERE idproyectocat=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, proyectocat);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idproyectocat);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String tickets_proyectos_categoriasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_proyectos_categoriasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tickets estados
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_estadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_ESTADOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getTickets_estadosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_estadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_estadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_ESTADOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idestado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_estadosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_estadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_estadosPK(BigDecimal idestado, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_ESTADOS WHERE idestado="
				+ idestado.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_estadosPK( BigDecimal idestado ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_estadosPK( BigDecimal idestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_estadosDelete(BigDecimal idestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_ESTADOS " + " WHERE idestado = "
				+ idestado.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_ESTADOS " + " WHERE idestado="
						+ idestado.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_estadosDelete( BigDecimal idestado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_estadosDelete( BigDecimal idestado )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_estadosCreate(String estado, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_ESTADOS(estado, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, estado);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String tickets_estadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_estadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_estadosCreateOrUpdate(BigDecimal idestado,
			String estado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_estados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_ESTADOS SET estado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
				} else {
					String ins = "INSERT INTO TICKETS_ESTADOS(estado, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_estadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_estadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_estadosUpdate(BigDecimal idestado, String estado,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_estados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_ESTADOS SET estado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String tickets_estadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_estadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tickets Proyectos
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_proyectosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT TICKETS_PROYECTOS.idproyecto,TICKETS_PROYECTOS.nombre,TICKETS_PROYECTOS.description,es1.estado,TICKETS_PROYECTOS.activo,es2.estado,TICKETS_PROYECTOS.idempresa,TICKETS_PROYECTOS.usuarioalt,TICKETS_PROYECTOS.usuarioact,TICKETS_PROYECTOS.fechaalt,TICKETS_PROYECTOS.fechaact FROM TICKETS_PROYECTOS,tickets_estados es1,tickets_estados es2 where TICKETS_PROYECTOS.idestado = es1.idestado and  TICKETS_PROYECTOS.idestadovista = es2.idestado "
				+ " and TICKETS_PROYECTOS.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getTickets_proyectosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_proyectosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT TICKETS_PROYECTOS.idproyecto,TICKETS_PROYECTOS.nombre,TICKETS_PROYECTOS.description,es1.estado,TICKETS_PROYECTOS.activo,es2.estado,TICKETS_PROYECTOS.idempresa,TICKETS_PROYECTOS.usuarioalt,TICKETS_PROYECTOS.usuarioact,TICKETS_PROYECTOS.fechaalt,TICKETS_PROYECTOS.fechaact FROM TICKETS_PROYECTOS,tickets_estados es1,tickets_estados es2 where TICKETS_PROYECTOS.idestado = es1.idestado and  TICKETS_PROYECTOS.idestadovista = es2.idestado "
				+ " and TICKETS_PROYECTOS.idempresa= "
				+ idempresa.toString()
				+ " and (idproyecto::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(nombre) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_proyectosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_proyectosPK(BigDecimal idproyecto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT TICKETS_PROYECTOS.idproyecto,TICKETS_PROYECTOS.nombre,TICKETS_PROYECTOS.description,TICKETS_PROYECTOS.idestado,es1.estado,TICKETS_PROYECTOS.activo,TICKETS_PROYECTOS.idestadovista,es2.estado,TICKETS_PROYECTOS.idempresa,TICKETS_PROYECTOS.usuarioalt,TICKETS_PROYECTOS.usuarioact,TICKETS_PROYECTOS.fechaalt,TICKETS_PROYECTOS.fechaact FROM TICKETS_PROYECTOS,tickets_estados es1,tickets_estados es2 where TICKETS_PROYECTOS.idestado = es1.idestado and  TICKETS_PROYECTOS.idestadovista = es2.idestado"
				+ " and TICKETS_PROYECTOS.idproyecto="
				+ idproyecto.toString()
				+ " AND TICKETS_PROYECTOS.idempresa = "
				+ idempresa.toString()
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_proyectosPK( BigDecimal idproyecto ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_proyectosPK( BigDecimal idproyecto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_proyectosDelete(BigDecimal idproyecto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_PROYECTOS "
				+ " WHERE idproyecto=" + idproyecto.toString()
				+ " and idempresa =" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_PROYECTOS "
						+ " WHERE idproyecto=" + idproyecto.toString()
						+ " and idempresa =" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_proyectosDelete( BigDecimal idproyecto ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_proyectosDelete( BigDecimal idproyecto )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_proyectosCreate(String nombre, String description,
			BigDecimal idestado, String activo, BigDecimal idestadovista,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (description == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: description ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (activo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activo ";
		if (idestadovista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadovista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (description.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: description ";
		if (activo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_PROYECTOS(nombre, description, idestado, activo, idestadovista, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, nombre);
				insert.setString(2, description);
				insert.setBigDecimal(3, idestado);
				insert.setString(4, activo);
				insert.setBigDecimal(5, idestadovista);
				insert.setBigDecimal(6, idempresa);
				insert.setString(7, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String tickets_proyectosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_proyectosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_proyectosCreateOrUpdate(BigDecimal idproyecto,
			String nombre, String description, BigDecimal idestado,
			String activo, BigDecimal idestadovista, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idproyecto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproyecto ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (description == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: description ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (activo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activo ";
		if (idestadovista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadovista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (description.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: description ";
		if (activo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_proyectos WHERE idproyecto = "
					+ idproyecto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PROYECTOS SET nombre=?, description=?, idestado=?, activo=?, idestadovista=?, idempresa=?, usuarioact=?, fechaact=? WHERE idproyecto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, nombre);
					insert.setString(2, description);
					insert.setBigDecimal(3, idestado);
					insert.setString(4, activo);
					insert.setBigDecimal(5, idestadovista);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idproyecto);
				} else {
					String ins = "INSERT INTO TICKETS_PROYECTOS(nombre, description, idestado, activo, idestadovista, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, nombre);
					insert.setString(2, description);
					insert.setBigDecimal(3, idestado);
					insert.setString(4, activo);
					insert.setBigDecimal(5, idestadovista);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_proyectosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_proyectosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_proyectosUpdate(BigDecimal idproyecto, String nombre,
			String description, BigDecimal idestado, String activo,
			BigDecimal idestadovista, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idproyecto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproyecto ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (description == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: description ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (activo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activo ";
		if (idestadovista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadovista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (description.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: description ";
		if (activo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_proyectos WHERE idproyecto = "
					+ idproyecto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PROYECTOS SET nombre=?, description=?, idestado=?, activo=?, idestadovista=?, idempresa=?, usuarioact=?, fechaact=? WHERE idproyecto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, nombre);
					insert.setString(2, description);
					insert.setBigDecimal(3, idestado);
					insert.setString(4, activo);
					insert.setBigDecimal(5, idestadovista);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idproyecto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String tickets_proyectosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_proyectosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public long getTotalEntidadporempresa(String entidad, BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " WHERE idempresa=" + idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadporempresa()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalEntidadporempresa()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadporempresa()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	public long getTotalEntidadOcuporempresa(String entidad, String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadOcuporempresa()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcuporempresa()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadOcuporempresa()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	public List getEstadoLovAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM tickets_estados where idempresa ="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getEstadoLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getEstadoLovAll()  "
					+ ex);
		}
		return vecSalida;
	}

	public List getEstadoLovOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM tickets_estados "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idestado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getEstadoLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadoLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// tickets categorias
	public List getTickets_categoriasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idcategoria,categoria,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_CATEGORIAS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getTickets_categoriasAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_categoriasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_categoriasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcategoria,categoria,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_CATEGORIAS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcategoria::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(categoria) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_categoriasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_categoriasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_categoriasPK(BigDecimal idcategoria,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcategoria,categoria,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_CATEGORIAS WHERE idcategoria="
				+ idcategoria.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_categoriasPK( BigDecimal idcategoria ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_categoriasPK( BigDecimal idcategoria )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_categoriasDelete(BigDecimal idcategoria,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_CATEGORIAS "
				+ " WHERE idcategoria=" + idcategoria.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_CATEGORIAS "
						+ " WHERE idcategoria=" + idcategoria.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_categoriasDelete( BigDecimal idcategoria ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_categoriasDelete( BigDecimal idcategoria )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_categoriasCreate(String categoria,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (categoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (categoria.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoria ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_CATEGORIAS(categoria, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, categoria);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String tickets_categoriasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_categoriasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_categoriasCreateOrUpdate(BigDecimal idcategoria,
			String categoria, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoria ";
		if (categoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (categoria.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoria ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_categorias WHERE idcategoria = "
					+ idcategoria.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_CATEGORIAS SET categoria=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcategoria=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, categoria);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idcategoria);
				} else {
					String ins = "INSERT INTO TICKETS_CATEGORIAS(categoria, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, categoria);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_categoriasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_categoriasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_categoriasUpdate(BigDecimal idcategoria,
			String categoria, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoria ";
		if (categoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (categoria.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoria ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_categorias WHERE idcategoria = "
					+ idcategoria.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_CATEGORIAS SET categoria=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcategoria=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, categoria);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idcategoria);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String tickets_categoriasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_categoriasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tickets reproductividad
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_reproductividadAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idreproductividad,reproductividad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_REPRODUCTIVIDAD WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_reproductividadAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_reproductividadAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_reproductividadOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idreproductividad,reproductividad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_REPRODUCTIVIDAD "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idreproductividad::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(reproductividad) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_reproductividadOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_reproductividadOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_reproductividadPK(BigDecimal idreproductividad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idreproductividad,reproductividad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_REPRODUCTIVIDAD WHERE idreproductividad="
				+ idreproductividad.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_reproductividadPK( BigDecimal idreproductividad ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_reproductividadPK( BigDecimal idreproductividad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_reproductividadDelete(BigDecimal idreproductividad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_REPRODUCTIVIDAD "
				+ " WHERE idreproductividad = " + idreproductividad.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_REPRODUCTIVIDAD "
						+ " WHERE idreproductividad="
						+ idreproductividad.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_reproductividadDelete( BigDecimal idreproductividad ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_reproductividadDelete( BigDecimal idreproductividad )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_reproductividadCreate(String reproductividad,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (reproductividad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: reproductividad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (reproductividad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: reproductividad ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_REPRODUCTIVIDAD(reproductividad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, reproductividad);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_reproductividadCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_reproductividadCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_reproductividadCreateOrUpdate(
			BigDecimal idreproductividad, String reproductividad,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idreproductividad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreproductividad ";
		if (reproductividad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: reproductividad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (reproductividad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: reproductividad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_reproductividad WHERE idreproductividad = "
					+ idreproductividad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_REPRODUCTIVIDAD SET reproductividad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idreproductividad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, reproductividad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idreproductividad);
				} else {
					String ins = "INSERT INTO TICKETS_REPRODUCTIVIDAD(reproductividad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, reproductividad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_reproductividadCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_reproductividadCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_reproductividadUpdate(BigDecimal idreproductividad,
			String reproductividad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idreproductividad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreproductividad ";
		if (reproductividad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: reproductividad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (reproductividad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: reproductividad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_reproductividad WHERE idreproductividad = "
					+ idreproductividad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_REPRODUCTIVIDAD SET reproductividad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idreproductividad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, reproductividad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idreproductividad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String tickets_reproductividadUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_reproductividadUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tickets severidad
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_severidadAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idseveridad,severidad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_SEVERIDAD WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getTickets_severidadAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_severidadAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_severidadOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idseveridad,severidad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_SEVERIDAD "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idseveridad::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(severidad) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_severidadOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_severidadOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_severidadPK(BigDecimal idseveridad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idseveridad,severidad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_SEVERIDAD WHERE idseveridad="
				+ idseveridad.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_severidadPK( BigDecimal idseveridad ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_severidadPK( BigDecimal idseveridad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_severidadDelete(BigDecimal idseveridad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_SEVERIDAD "
				+ " WHERE idseveridad = " + idseveridad.toString()
				+ " and idempresa =" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_SEVERIDAD "
						+ " WHERE idseveridad=" + idseveridad.toString()
						+ " and idempresa =" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_severidadDelete( BigDecimal idseveridad ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_severidadDelete( BigDecimal idseveridad )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_severidadCreate(String severidad,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (severidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: severidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (severidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: severidad ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_SEVERIDAD(severidad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, severidad);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String tickets_severidadCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_severidadCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_severidadCreateOrUpdate(BigDecimal idseveridad,
			String severidad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idseveridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idseveridad ";
		if (severidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: severidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (severidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: severidad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_severidad WHERE idseveridad = "
					+ idseveridad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_SEVERIDAD SET severidad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idseveridad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, severidad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idseveridad);
				} else {
					String ins = "INSERT INTO TICKETS_SEVERIDAD(severidad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, severidad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_severidadCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_severidadCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_severidadUpdate(BigDecimal idseveridad,
			String severidad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idseveridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idseveridad ";
		if (severidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: severidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (severidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: severidad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_severidad WHERE idseveridad = "
					+ idseveridad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_SEVERIDAD SET severidad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idseveridad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, severidad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idseveridad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String tickets_severidadUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_severidadUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tickets prioridad
	// para todo (ordena por el segundo campo por defecto)
	public List getTickets_prioridadAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idprioridad,prioridad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_PRIORIDAD WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getTickets_prioridadAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_prioridadAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTickets_prioridadOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idprioridad,prioridad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_PRIORIDAD "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idprioridad::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(prioridad) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_prioridadOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_prioridadOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTickets_prioridadPK(BigDecimal idprioridad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idprioridad,prioridad,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETS_PRIORIDAD WHERE idprioridad="
				+ idprioridad.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getTickets_prioridadPK( BigDecimal idprioridad ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTickets_prioridadPK( BigDecimal idprioridad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String tickets_prioridadDelete(BigDecimal idprioridad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS_PRIORIDAD "
				+ " WHERE idprioridad=" + idprioridad.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETS_PRIORIDAD "
						+ " WHERE idprioridad=" + idprioridad.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : tickets_prioridadDelete( BigDecimal idprioridad ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: tickets_prioridadDelete( BigDecimal idprioridad )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String tickets_prioridadCreate(String prioridad,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (prioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: prioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (prioridad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: prioridad ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETS_PRIORIDAD(prioridad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, prioridad);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String tickets_prioridadCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_prioridadCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String tickets_prioridadCreateOrUpdate(BigDecimal idprioridad,
			String prioridad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprioridad ";
		if (prioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: prioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (prioridad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: prioridad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_prioridad WHERE idprioridad = "
					+ idprioridad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PRIORIDAD SET prioridad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idprioridad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, prioridad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idprioridad);
				} else {
					String ins = "INSERT INTO TICKETS_PRIORIDAD(prioridad, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, prioridad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String tickets_prioridadCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String tickets_prioridadCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String tickets_prioridadUpdate(BigDecimal idprioridad,
			String prioridad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprioridad ";
		if (prioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: prioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (prioridad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: prioridad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets_prioridad WHERE idprioridad = "
					+ idprioridad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS_PRIORIDAD SET prioridad=?, idempresa=?, usuarioact=?, fechaact=? WHERE idprioridad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, prioridad);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idprioridad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String tickets_prioridadUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String tickets_prioridadUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: globalImagenes Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Mon Mar 10 10:51:28 ART 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalImagenesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT idimagen,descripcion,path,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM GLOBALIMAGENES WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalImagenesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalImagenesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalImagenesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT idimagen,descripcion,path,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALIMAGENES WHERE (UPPER(DESCRIPCION) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalImagenesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalImagenesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalImagenesPK(BigDecimal idimagen, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT idimagen,descripcion,path,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALIMAGENES WHERE idimagen=" + idimagen.toString()
				+ " AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalImagenesPK( BigDecimal idimagen ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalImagenesPK( BigDecimal idimagen )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalImagenesDelete(BigDecimal idimagen, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALIMAGENES WHERE idimagen="
				+ idimagen.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALIMAGENES WHERE idimagen="
						+ idimagen.toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalImagenesDelete( BigDecimal idimagen ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalImagenesDelete( BigDecimal idimagen )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalImagenesCreate(String descripcion, String path,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (path == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: path ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (path.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: path ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALIMAGENES(descripcion, path, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, descripcion);
				insert.setString(2, path);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalImagenesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalImagenesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalImagenesCreateOrUpdate(BigDecimal idimagen,
			String descripcion, String path, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idimagen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idimagen ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (path == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: path ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (path.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: path ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalImagenes WHERE idimagen = "
					+ idimagen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALIMAGENES SET descripcion=?, path=?, idempresa=?, usuarioact=?, fechaact=? WHERE idimagen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setString(2, path);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idimagen);
				} else {
					String ins = "INSERT INTO GLOBALIMAGENES(descripcion, path, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, descripcion);
					insert.setString(2, path);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalImagenesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalImagenesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalImagenesUpdate(BigDecimal idimagen, String descripcion,
			String path, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idimagen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idimagen ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (path == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: path ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (path.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: path ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalImagenes WHERE idimagen = "
					+ idimagen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALIMAGENES SET descripcion=?, path=?, idempresa=?, usuarioact=?, fechaact=? WHERE idimagen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setString(2, path);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idimagen);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalImagenesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalImagenesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tipo documento
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobaltiposdocumentosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALTIPOSDOCUMENTOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobaltiposdocumentosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobaltiposdocumentosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobaltiposdocumentosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALTIPOSDOCUMENTOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtipodocumento::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipodocumento) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobaltiposdocumentosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobaltiposdocumentosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobaltiposdocumentosPK(BigDecimal idtipodocumento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM GLOBALTIPOSDOCUMENTOS WHERE idtipodocumento="
				+ idtipodocumento.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobaltiposdocumentosPK( BigDecimal idtipodocumento ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobaltiposdocumentosPK( BigDecimal idtipodocumento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globaltiposdocumentosDelete(BigDecimal idtipodocumento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALTIPOSDOCUMENTOS "
				+ " WHERE idtipodocumento=" + idtipodocumento.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALTIPOSDOCUMENTOS "
						+ " WHERE idtipodocumento="
						+ idtipodocumento.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globaltiposdocumentosDelete( BigDecimal idtipodocumento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globaltiposdocumentosDelete( BigDecimal idtipodocumento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globaltiposdocumentosCreate(String tipodocumento,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo Tipo Documento";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALTIPOSDOCUMENTOS(tipodocumento, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipodocumento);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globaltiposdocumentosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globaltiposdocumentosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globaltiposdocumentosCreateOrUpdate(
			BigDecimal idtipodocumento, String tipodocumento,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodocumento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globaltiposdocumentos WHERE idtipodocumento = "
					+ idtipodocumento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALTIPOSDOCUMENTOS SET tipodocumento=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodocumento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodocumento);
				} else {
					String ins = "INSERT INTO GLOBALTIPOSDOCUMENTOS(tipodocumento, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globaltiposdocumentosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globaltiposdocumentosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globaltiposdocumentosUpdate(BigDecimal idtipodocumento,
			String tipodocumento, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Tipo documento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globaltiposdocumentos WHERE idtipodocumento = "
					+ idtipodocumento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALTIPOSDOCUMENTOS SET tipodocumento=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodocumento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodocumento);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globaltiposdocumentosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globaltiposdocumentosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getGlobalentidadesasociablesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT identidadesasociables,entidadasociable,descripcion,campopk,querypk,querygrilla,idempresa,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALENTIDADESASOCIABLES WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociablesAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociablesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalentidadesasociablesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT identidadesasociables,entidadasociable,descripcion,campopk,querypk,querygrilla,"
				+ "       idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM GLOBALENTIDADESASOCIABLES " + " WHERE idempresa= "
				+ idempresa.toString()
				+ " and (identidadesasociables::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(entidadasociable) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociablesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociablesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalentidadesasociablesPK(
			BigDecimal identidadesasociables, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT identidadesasociables,entidadasociable,descripcion,campopk,querypk,querygrilla,"
				+ "       idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALENTIDADESASOCIABLES WHERE identidadesasociables="
				+ identidadesasociables.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociablesPK( BigDecimal identidadesasociables ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociablesPK( BigDecimal identidadesasociables )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalentidadesasociablesDelete(
			BigDecimal identidadesasociables, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALENTIDADESASOCIABLES "
				+ " WHERE identidadesasociables = "
				+ identidadesasociables.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALENTIDADESASOCIABLES "
						+ " WHERE identidadesasociables= "
						+ identidadesasociables.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalentidadesasociablesDelete( BigDecimal identidadesasociables ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalentidadesasociablesDelete( BigDecimal identidadesasociables )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalentidadesasociablesCreate(String entidadasociable,
			String descripcion, String campopk, String querypk,
			String querygrilla, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (entidadasociable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entidadasociable ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (campopk == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campopk ";
		if (querypk == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querypk ";
		if (querygrilla == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querygrilla ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (entidadasociable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entidadasociable ";
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (campopk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campopk ";
		if (querypk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querypk ";
		if (querygrilla.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querygrilla ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALENTIDADESASOCIABLES(entidadasociable, descripcion, campopk, querypk, querygrilla, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, entidadasociable);
				insert.setString(2, descripcion);
				insert.setString(3, campopk);
				insert.setString(4, querypk);
				insert.setString(5, querygrilla);
				insert.setBigDecimal(6, idempresa);
				insert.setString(7, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalentidadesasociablesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalentidadesasociablesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalentidadesasociablesCreateOrUpdate(
			BigDecimal identidadesasociables, String entidadasociable,
			String descripcion, String campopk, String querypk,
			String querygrilla, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidadesasociables == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadesasociables ";
		if (entidadasociable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entidadasociable ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (campopk == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campopk ";
		if (querypk == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querypk ";
		if (querygrilla == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querygrilla ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (entidadasociable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entidadasociable ";
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (campopk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campopk ";
		if (querypk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querypk ";
		if (querygrilla.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querygrilla ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalentidadesasociables WHERE identidadesasociables = "
					+ identidadesasociables.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALENTIDADESASOCIABLES SET entidadasociable=?, descripcion=?, campopk=?, querypk=?,querygrilla=?, idempresa=?, usuarioact=?, fechaact=? WHERE identidadesasociables=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, entidadasociable);
					insert.setString(2, descripcion);
					insert.setString(3, campopk);
					insert.setString(4, querypk);
					insert.setString(5, querygrilla);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, identidadesasociables);
				} else {
					String ins = "INSERT INTO GLOBALENTIDADESASOCIABLES(entidadasociable, descripcion, campopk, querypk, querygrilla, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, entidadasociable);
					insert.setString(2, descripcion);
					insert.setString(3, campopk);
					insert.setString(4, querypk);
					insert.setString(5, querygrilla);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalentidadesasociablesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalentidadesasociablesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalentidadesasociablesUpdate(
			BigDecimal identidadesasociables, String entidadasociable,
			String descripcion, String campopk, String querypk,
			String querygrilla, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidadesasociables == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadesasociables ";
		if (entidadasociable == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entidadasociable ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (campopk == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campopk ";
		if (querygrilla == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querypk ";
		if (querygrilla == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: querygrilla ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (entidadasociable.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entidadasociable ";
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (campopk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campopk ";
		if (querypk.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querypk ";
		if (querygrilla.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: querygrilla ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalentidadesasociables WHERE identidadesasociables = "
					+ identidadesasociables.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALENTIDADESASOCIABLES SET entidadasociable=?, descripcion=?, campopk=?, querypk=?, querygrilla=?, idempresa=?, usuarioact=?, fechaact=? WHERE identidadesasociables=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, entidadasociable);
					insert.setString(2, descripcion);
					insert.setString(3, campopk);
					insert.setString(4, querypk);
					insert.setString(5, querygrilla);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, identidadesasociables);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalentidadesasociablesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalentidadesasociablesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// global entidad asociaciones
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalentidadesasociacionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GLOBALENTIDADESASOCIACIONES.identidadorigen,globalentidadesasociables.entidadasociable,GLOBALENTIDADESASOCIACIONES.identidaddestino, a2.entidadasociable, GLOBALENTIDADESASOCIACIONES.observaciones, GLOBALENTIDADESASOCIACIONES.idempresa, GLOBALENTIDADESASOCIACIONES.usuarioalt, GLOBALENTIDADESASOCIACIONES.usuarioact, GLOBALENTIDADESASOCIACIONES.fechaalt, GLOBALENTIDADESASOCIACIONES.fechaact  FROM  GLOBALENTIDADESASOCIACIONES, globalentidadesasociables , globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidadorigen "
				+ " and globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and a2.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidaddestino "
				+ " and a2.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and   GLOBALENTIDADESASOCIACIONES.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalentidadesasociacionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GLOBALENTIDADESASOCIACIONES.identidadorigen,globalentidadesasociables.entidadasociable,GLOBALENTIDADESASOCIACIONES.identidaddestino, a2.entidadasociable, GLOBALENTIDADESASOCIACIONES.observaciones, GLOBALENTIDADESASOCIACIONES.idempresa, GLOBALENTIDADESASOCIACIONES.usuarioalt, GLOBALENTIDADESASOCIACIONES.usuarioact, GLOBALENTIDADESASOCIACIONES.fechaalt, GLOBALENTIDADESASOCIACIONES.fechaact  FROM  GLOBALENTIDADESASOCIACIONES, globalentidadesasociables , globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidadorigen "
				+ " and globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and a2.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidaddestino "
				+ " and a2.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and GLOBALENTIDADESASOCIACIONES.idempresa = "
				+ idempresa.toString()
				+ " and (globalentidadesasociables.entidadasociable LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(a2.entidadasociable) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(GLOBALENTIDADESASOCIACIONES.observaciones) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalentidadesasociacionesPK(BigDecimal identidadorigen,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GLOBALENTIDADESASOCIACIONES.identidadorigen,globalentidadesasociables.entidadasociable,GLOBALENTIDADESASOCIACIONES.identidaddestino,a2.entidadasociable,GLOBALENTIDADESASOCIACIONES.observaciones,GLOBALENTIDADESASOCIACIONES.idempresa,GLOBALENTIDADESASOCIACIONES.usuarioalt,GLOBALENTIDADESASOCIACIONES.usuarioact,GLOBALENTIDADESASOCIACIONES.fechaalt,GLOBALENTIDADESASOCIACIONES.fechaact FROM GLOBALENTIDADESASOCIACIONES,globalentidadesasociables ,globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidadorigen "
				+ " and globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and a2.identidadesasociables = GLOBALENTIDADESASOCIACIONES.identidaddestino "
				+ " and a2.idempresa = GLOBALENTIDADESASOCIACIONES.idempresa "
				+ " and identidadorigen = "
				+ identidadorigen.toString()
				+ " AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesPK( BigDecimal identidadorigen ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesPK( BigDecimal identidadorigen )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalentidadesasociacionesDelete(BigDecimal identidadorigen,
			BigDecimal identidaddestino, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALENTIDADESASOCIACIONES "
				+ " WHERE identidadorigen = " + identidadorigen.toString()
				+ " and identidaddestino = " + identidaddestino.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALENTIDADESASOCIACIONES "
						+ " WHERE identidadorigen = "
						+ identidadorigen.toString()
						+ " and identidaddestino = "
						+ identidaddestino.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalentidadesasociacionesDelete( BigDecimal identidadorigen ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalentidadesasociacionesDelete( BigDecimal identidadorigen )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalentidadesasociacionesCreate(BigDecimal identidadorigen,
			BigDecimal identidaddestino, String observaciones,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidaddestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidaddestino ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALENTIDADESASOCIACIONES(identidadorigen, identidaddestino, observaciones, idempresa, usuarioalt ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, identidadorigen);
				insert.setBigDecimal(2, identidaddestino);
				insert.setString(3, observaciones);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalentidadesasociacionesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalentidadesasociacionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * // actualizacion de un registro por PK NOTA: no se tiene en cuenta el
	 * primer // registro por PK y los datos de auditoria
	 * 
	 * public String globalentidadesasociacionesCreateOrUpdate( BigDecimal
	 * identidadorigen, BigDecimal identidaddestino, String observaciones,
	 * BigDecimal idempresa, String usuarioact) throws EJBException { Calendar
	 * hoy = new GregorianCalendar(); Timestamp fechaact = new
	 * Timestamp(hoy.getTime().getTime()); String salida = "NOOK"; //
	 * validaciones de datos: // 1. nulidad de campos if (identidadorigen ==
	 * null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * identidadorigen "; if (identidaddestino == null) salida = "Error: No se
	 * puede dejar sin datos (nulo) el campo: identidaddestino "; if (idempresa
	 * == null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * idempresa "; // 2. sin nada desde la pagina // fin validaciones boolean
	 * bError = true; if (salida.equalsIgnoreCase("NOOK")) bError = false; try {
	 * ResultSet rsSalida = null; String cQuery = "SELECT COUNT(*) FROM
	 * globalentidadesasociaciones WHERE identidadorigen = " +
	 * identidadorigen.toString(); Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); int
	 * total = 0; if (rsSalida != null && rsSalida.next()) total =
	 * rsSalida.getInt(1); PreparedStatement insert = null; String sql = ""; if
	 * (!bError) { if (total > 0) { // si existe hago update sql = "UPDATE
	 * GLOBALENTIDADESASOCIACIONES SET identidaddestino=?, observaciones=?,
	 * idempresa=?, usuarioact=?, fechaact=? WHERE identidadorigen=?;"; insert =
	 * dbconn.prepareStatement(sql); insert.setBigDecimal(1, identidaddestino);
	 * insert.setString(2, observaciones); insert.setBigDecimal(3, idempresa);
	 * insert.setString(4, usuarioact); insert.setTimestamp(5, fechaact);
	 * insert.setBigDecimal(6, identidadorigen); } else { String ins = "INSERT
	 * INTO GLOBALENTIDADESASOCIACIONES(identidaddestino, observaciones,
	 * idempresa, usuarioalt ) VALUES (?, ?, ?, ?)"; insert =
	 * dbconn.prepareStatement(ins); // seteo de campos: String usuarioalt =
	 * usuarioact; // esta variable va a // proposito insert.setBigDecimal(1,
	 * identidaddestino); insert.setString(2, observaciones);
	 * insert.setBigDecimal(3, idempresa); insert.setString(4, usuarioalt); }
	 * insert.executeUpdate(); salida = "Alta Correcta."; } } catch
	 * (SQLException sqlException) { salida = "Imposible dar de alta el
	 * registro."; log .error("Error SQL public String
	 * globalentidadesasociacionesCreateOrUpdate(.....)" + sqlException); }
	 * catch (Exception ex) { salida = "Imposible dar de alta el registro."; log
	 * .error("Error excepcion public String
	 * globalentidadesasociacionesCreateOrUpdate(.....)" + ex); } return salida;
	 * }
	 * 
	 * public String globalentidadesasociacionesUpdate(BigDecimal
	 * identidadorigen, BigDecimal identidaddestino, String observaciones,
	 * BigDecimal idempresa, String usuarioact) throws EJBException { Calendar
	 * hoy = new GregorianCalendar(); Timestamp fechaact = new
	 * Timestamp(hoy.getTime().getTime()); String salida = "NOOK"; //
	 * validaciones de datos: // 1. nulidad de campos if (identidadorigen ==
	 * null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * identidadorigen "; if (identidaddestino == null) salida = "Error: No se
	 * puede dejar sin datos (nulo) el campo: identidaddestino "; if (idempresa
	 * == null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * idempresa "; // 2. sin nada desde la pagina // fin validaciones boolean
	 * bError = true; if (salida.equalsIgnoreCase("NOOK")) bError = false; try {
	 * ResultSet rsSalida = null; String cQuery = "SELECT COUNT(*) FROM
	 * globalentidadesasociaciones " + " WHERE identidadorigen = " +
	 * identidadorigen.toString() + " and identidaddestino = " +
	 * identidaddestino.toString(); Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); int
	 * total = 0; if (rsSalida != null && rsSalida.next()) total =
	 * rsSalida.getInt(1); PreparedStatement insert = null; String sql = ""; if
	 * (!bError) { if (total > 0) { // si existe hago update sql = "UPDATE
	 * GLOBALENTIDADESASOCIACIONES SET identidadorigen=?,identidaddestino=?,
	 * observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE
	 * identidadorigen=? and identidaddestino=? ;"; insert =
	 * dbconn.prepareStatement(sql); insert.setBigDecimal(1, identidadorigen);
	 * insert.setBigDecimal(2, identidaddestino); insert.setString(3,
	 * observaciones); insert.setBigDecimal(4, idempresa); insert.setString(5,
	 * usuarioact); insert.setTimestamp(6, fechaact); insert.setBigDecimal(7,
	 * identidadorigen); insert.setBigDecimal(8, identidaddestino); }
	 * 
	 * int i = insert.executeUpdate(); if (i > 0) salida = "Actualizacion
	 * Correcta"; else salida = "Imposible actualizar el registro."; } } catch
	 * (SQLException sqlException) { salida = "Imposible actualizar el
	 * registro."; log .error("Error SQL public String
	 * globalentidadesasociacionesUpdate(.....)" + sqlException); } catch
	 * (Exception ex) { salida = "Imposible actualizar el registro."; log
	 * .error("Error excepcion public String
	 * globalentidadesasociacionesUpdate(.....)" + ex); } return salida; }
	 */
	public List getEntidAsociablesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  identidadesasociables,entidadasociable,usuarioalt,usuarioact,fechaalt,fechaact FROM globalentidadesasociables where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getEntidAsociablesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEntidAsociablesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getEntidAsociablesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  identidadesasociables,entidadasociable,usuarioalt,usuarioact,fechaalt,fechaact FROM globalentidadesasociables where idempresa = "
				+ idempresa.toString()
				+ " and (identidadesasociables::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(entidadasociable) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getEntidAsociablesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEntidAsociablesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// global entidad asociaciones mov
	public List getGlobalentidadesasociacionesmovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " "
				+ "SELECT GLOBALENTIDADESASOCIACIONESMOV.identidadesasociacionesmov,globalentidadesasociables.entidadasociable, a2.entidadasociable AS entidadasociable2,GLOBALENTIDADESASOCIACIONESMOV.pkorigen,GLOBALENTIDADESASOCIACIONESMOV.pkdestino,GLOBALENTIDADESASOCIACIONESMOV.fecha,GLOBALENTIDADESASOCIACIONESMOV.observacion, GLOBALENTIDADESASOCIACIONESMOV.idempresa, GLOBALENTIDADESASOCIACIONESMOV.usuarioalt, GLOBALENTIDADESASOCIACIONESMOV.usuarioact, GLOBALENTIDADESASOCIACIONESMOV.fechaalt, GLOBALENTIDADESASOCIACIONESMOV.fechaact FROM GLOBALENTIDADESASOCIACIONESMOV,globalentidadesasociables, globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidadorigen "
				+ " AND globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " AND a2.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidaddestino "
				+ " AND a2.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " and GLOBALENTIDADESASOCIACIONESMOV.idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesmovAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesmovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalentidadesasociacionesmovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " SELECT GLOBALENTIDADESASOCIACIONESMOV.identidadesasociacionesmov,globalentidadesasociables.entidadasociable, a2.entidadasociable,GLOBALENTIDADESASOCIACIONESMOV.pkorigen,GLOBALENTIDADESASOCIACIONESMOV.pkdestino,GLOBALENTIDADESASOCIACIONESMOV.fecha,GLOBALENTIDADESASOCIACIONESMOV.observacion, GLOBALENTIDADESASOCIACIONESMOV.idempresa, GLOBALENTIDADESASOCIACIONESMOV.usuarioalt, GLOBALENTIDADESASOCIACIONESMOV.usuarioact, GLOBALENTIDADESASOCIACIONESMOV.fechaalt, GLOBALENTIDADESASOCIACIONESMOV.fechaact FROM GLOBALENTIDADESASOCIACIONESMOV,globalentidadesasociables, globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidadorigen "
				+ " AND globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " AND a2.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidaddestino "
				+ " AND a2.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " and GLOBALENTIDADESASOCIACIONESMOV.idempresa = "
				+ idempresa.toString()
				+ " and (globalentidadesasociables.entidadasociable LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(a2.entidadasociable) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesmovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesmovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public boolean isExisteAsociacion(BigDecimal pkorigen,
			BigDecimal pkdestino, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		boolean existe = false;
		String cQuery = ""
				+ "SELECT COUNT(1) FROM globalentidadesasociacionesmov"
				+ " WHERE pkorigen = " + pkorigen.toString()
				+ "   AND pkdestino = " + pkdestino.toString()
				+ "   AND idempresa = " + idempresa.toString() + ";";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null && rsSalida.next()) {

				existe = rsSalida.getString(1).equals("0") ? false : true;

			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesmovPK( BigDecimal identidadesasociacionesmov ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesmovPK( BigDecimal identidadesasociacionesmov )  "
							+ ex);
		}
		return existe;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalentidadesasociacionesmovPK(
			BigDecimal identidadesasociacionesmov, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT GLOBALENTIDADESASOCIACIONESMOV.identidadesasociacionesmov,GLOBALENTIDADESASOCIACIONESMOV.identidadorigen, globalentidadesasociables.entidadasociable, GLOBALENTIDADESASOCIACIONESMOV.identidaddestino, a2.entidadasociable,GLOBALENTIDADESASOCIACIONESMOV.pkorigen,GLOBALENTIDADESASOCIACIONESMOV.pkdestino,GLOBALENTIDADESASOCIACIONESMOV.fecha,GLOBALENTIDADESASOCIACIONESMOV.observacion, GLOBALENTIDADESASOCIACIONESMOV.idempresa, GLOBALENTIDADESASOCIACIONESMOV.usuarioalt, GLOBALENTIDADESASOCIACIONESMOV.usuarioact, GLOBALENTIDADESASOCIACIONESMOV.fechaalt, GLOBALENTIDADESASOCIACIONESMOV.fechaact FROM GLOBALENTIDADESASOCIACIONESMOV,globalentidadesasociables, globalentidadesasociables a2 "
				+ " WHERE globalentidadesasociables.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidadorigen "
				+ " AND globalentidadesasociables.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " AND a2.identidadesasociables = GLOBALENTIDADESASOCIACIONESMOV.identidaddestino "
				+ " AND a2.idempresa = GLOBALENTIDADESASOCIACIONESMOV.idempresa "
				+ " and GLOBALENTIDADESASOCIACIONESMOV.identidadesasociacionesmov = "
				+ identidadesasociacionesmov.toString()
				+ " AND GLOBALENTIDADESASOCIACIONESMOV.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalentidadesasociacionesmovPK( BigDecimal identidadesasociacionesmov ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalentidadesasociacionesmovPK( BigDecimal identidadesasociacionesmov )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalentidadesasociacionesmovDelete(
			BigDecimal identidadesasociacionesmov, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALENTIDADESASOCIACIONESMOV "
				+ " WHERE identidadesasociacionesmov = "
				+ identidadesasociacionesmov.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALENTIDADESASOCIACIONESMOV "
						+ " WHERE identidadesasociacionesmov = "
						+ identidadesasociacionesmov.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalentidadesasociacionesmovDelete( BigDecimal identidadesasociacionesmov ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalentidadesasociacionesmovDelete( BigDecimal identidadesasociacionesmov )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalentidadesasociacionesmovCreate(
			BigDecimal identidadorigen, BigDecimal identidaddestino,
			BigDecimal pkorigen, BigDecimal pkdestino, java.sql.Date fecha,
			String observacion, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidadorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadorigen ";
		if (identidaddestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidaddestino ";
		if (pkorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkorigen ";
		if (pkdestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkdestino ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALENTIDADESASOCIACIONESMOV(identidadorigen, identidaddestino, pkorigen, pkdestino, fecha, observacion, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, identidadorigen);
				insert.setBigDecimal(2, identidaddestino);
				insert.setBigDecimal(3, pkorigen);
				insert.setBigDecimal(4, pkdestino);
				insert.setDate(5, fecha);
				insert.setString(6, observacion);
				insert.setBigDecimal(7, idempresa);
				insert.setString(8, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalentidadesasociacionesmovCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalentidadesasociacionesmovCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalentidadesasociacionesmovCreateOrUpdate(
			BigDecimal identidadesasociacionesmov, BigDecimal identidadorigen,
			BigDecimal identidaddestino, BigDecimal pkorigen,
			BigDecimal pkdestino, java.sql.Date fecha, String observacion,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidadesasociacionesmov == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadesasociacionesmov ";
		if (identidadorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadorigen ";
		if (identidaddestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidaddestino ";
		if (pkorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkorigen ";
		if (pkdestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkdestino ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalentidadesasociacionesmov WHERE identidadesasociacionesmov = "
					+ identidadesasociacionesmov.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALENTIDADESASOCIACIONESMOV SET identidadorigen=?, identidaddestino=?, pkorigen=?, pkdestino=?, fecha=?, observacion=?, idempresa=?, usuarioact=?, fechaact=? WHERE identidadesasociacionesmov=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, identidadorigen);
					insert.setBigDecimal(2, identidaddestino);
					insert.setBigDecimal(3, pkorigen);
					insert.setBigDecimal(4, pkdestino);
					insert.setDate(5, fecha);
					insert.setString(6, observacion);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, identidadesasociacionesmov);
				} else {
					String ins = "INSERT INTO GLOBALENTIDADESASOCIACIONESMOV(identidadorigen, identidaddestino, pkorigen, pkdestino, fecha, observacion, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, identidadorigen);
					insert.setBigDecimal(2, identidaddestino);
					insert.setBigDecimal(3, pkorigen);
					insert.setBigDecimal(4, pkdestino);
					insert.setDate(5, fecha);
					insert.setString(6, observacion);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalentidadesasociacionesmovCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalentidadesasociacionesmovCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalentidadesasociacionesmovUpdate(
			BigDecimal identidadesasociacionesmov, BigDecimal identidadorigen,
			BigDecimal identidaddestino, BigDecimal pkorigen,
			BigDecimal pkdestino, java.sql.Date fecha, String observacion,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (identidadesasociacionesmov == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadesasociacionesmov ";
		if (identidadorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidadorigen ";
		if (identidaddestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: identidaddestino ";
		if (pkorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkorigen ";
		if (pkdestino == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pkdestino ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalentidadesasociacionesmov WHERE identidadesasociacionesmov = "
					+ identidadesasociacionesmov.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALENTIDADESASOCIACIONESMOV SET identidadorigen=?, identidaddestino=?, pkorigen=?, pkdestino=?, fecha=?, observacion=?, idempresa=?, usuarioact=?, fechaact=? WHERE identidadesasociacionesmov=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, identidadorigen);
					insert.setBigDecimal(2, identidaddestino);
					insert.setBigDecimal(3, pkorigen);
					insert.setBigDecimal(4, pkdestino);
					insert.setDate(5, fecha);
					insert.setString(6, observacion);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, identidadesasociacionesmov);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalentidadesasociacionesmovUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalentidadesasociacionesmovUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// ///////////////////////////////////////////////////////////////////

	public List getDocumentosGenericosLovAll(long limit, long offset,
			String queryEntidad, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " SELECT * FROM " + queryEntidad
				+ " WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getDocumentosGenericosLovAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getDocumentosGenericosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// ///////////////////////////////////////////////////////////////////

	public List getDocumentosGenericosLovOcu(long limit, long offset,
			String queryEntidad, String filtro, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " SELECT * FROM " + queryEntidad
				+ " WHERE idempresa = " + idempresa.toString() + filtro
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getDocumentosGenericosLovOcu() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getDocumentosGenericosLovOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	// ///////////////////////////////////////////////////////////////////

	public List getDocumentosGenericosAll(long limit, long offset,
			String queryEntidad, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " SELECT * FROM " + queryEntidad
				+ " WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getDocumentosGenericosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getDocumentosGenericosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getDocumentosGenericosOcu(long limit, long offset,
			String queryEntidad, String filtro, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " SELECT * FROM " + queryEntidad
				+ " WHERE idempresa = " + idempresa.toString() + filtro
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getDocumentosGenericosOcu() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getDocumentosGenericosOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	public String[][] getQueryEntidadMetadata(String queryEntidad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " SELECT * FROM " + queryEntidad
				+ " WHERE idempresa = " + idempresa.toString()
				+ " LIMIT 1 OFFSET  0;";
		String[][] sSalida = new String[][] { {} };
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			if (rsSalida != null) {
				int totCampos = md.getColumnCount();

				sSalida = new String[totCampos][2];
				int i = 1;
				while (i <= totCampos) {
					sSalida[i - 1][0] = md.getColumnName(i);
					sSalida[i - 1][1] = md.getColumnTypeName(i);
					i++;
				}

			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getQueryEntidadMetadata() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getQueryEntidadMetadata()  "
							+ ex);
		}

		return sSalida;
	}

	public List getAsociacionesXOrigen(BigDecimal pkorigen, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT am.pkdestino, am.fecha, ea.entidadasociable, ea.descripcion,"
				+ "       replace(ea.querypk, '#oid#'::VARCHAR, am.pkdestino::VARCHAR)"
				+ "  FROM globalentidadesasociacionesmov am "
				+ "       INNER JOIN globalentidadesasociables ea ON am.identidaddestino = ea.identidadesasociables "
				+ "              AND am.idempresa = ea.idempresa "
				+ " WHERE am.pkorigen = " + pkorigen + "  AND am.idempresa = "
				+ idempresa.toString() + " ORDER BY 3  ;";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getAsociacionesXOrigen() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getAsociacionesXOrigen()  "
							+ ex);
		}
		return vecSalida;
	}

	// ///////////////////////////////////////////////////////////////////
	// Calcular dias habiles de clearing. A partir de una fecha dada, suma los
	// dias de clearing que sean habiles (salteando sabados, domingos,
	// feriados). Si la fecha es un dia no habil, por mas que el clearing sea 0
	// dias, la misma se correra al primer dia habil que se encuentre.

	public static java.sql.Date setFechaClearing(java.sql.Date fecha, int dias,
			Hashtable htFeriados) throws EJBException {
		java.sql.Date fechaClearing = fecha;
		Calendar cal = new GregorianCalendar();

		try {

			int nohabiles = 0;
			cal.setTime(fechaClearing);
			int j = 1;

			while (j <= dias) {
				cal.add(Calendar.DATE, 1);
				if (cal.get(Calendar.DAY_OF_WEEK) == 1
						|| cal.get(Calendar.DAY_OF_WEEK) == 7
						|| htFeriados.containsKey(new java.sql.Date(cal
								.getTimeInMillis()).toString())) {
					nohabiles++;
				}
				j++;
			}

			cal.add(Calendar.DATE, nohabiles);

			while (cal.get(Calendar.DAY_OF_WEEK) == 1
					|| cal.get(Calendar.DAY_OF_WEEK) == 7
					|| htFeriados.containsKey(new java.sql.Date(cal
							.getTimeInMillis()).toString())) {
				cal.add(Calendar.DATE, 1);
			}

			fechaClearing = new java.sql.Date(cal.getTimeInMillis());

		} catch (Exception e) {
			log.error("setFechaClearing():" + e);
		}

		return fechaClearing;
	}

	// global usuarios depositos
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalusuariosdepositosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select globalusuariosdepositos.idusuariosdepositos,globalusuarios.usuario,stockdepositos.descrip_dt,globalusuariosdepositos.observaciones,globalusuariosdepositos.idempresa,globalusuariosdepositos.usuarioalt,globalusuariosdepositos.usuarioact,globalusuariosdepositos.fechaalt,globalusuariosdepositos.fechaact  from globalusuariosdepositos,globalusuarios,stockdepositos where globalusuarios.idusuario = globalusuariosdepositos.idusuario and globalusuarios.idempresa = globalusuariosdepositos.idempresa and stockdepositos.codigo_dt = globalusuariosdepositos.codigo_dt and stockdepositos.idempresa = globalusuariosdepositos.idempresa and globalusuariosdepositos.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 1  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosdepositosAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosdepositosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalusuariosdepositosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select globalusuariosdepositos.idusuariosdepositos,globalusuarios.usuario,stockdepositos.descrip_dt,globalusuariosdepositos.observaciones,globalusuariosdepositos.idempresa,globalusuariosdepositos.usuarioalt,globalusuariosdepositos.usuarioact,globalusuariosdepositos.fechaalt,globalusuariosdepositos.fechaact  from globalusuariosdepositos,globalusuarios,stockdepositos where globalusuarios.idusuario = globalusuariosdepositos.idusuario and globalusuarios.idempresa = globalusuariosdepositos.idempresa and stockdepositos.codigo_dt = globalusuariosdepositos.codigo_dt and stockdepositos.idempresa = globalusuariosdepositos.idempresa"
				+ " and ((globalusuariosdepositos.idusuariosdepositos::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(globalusuarios.usuario) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(stockdepositos.descrip_dt) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(globalusuariosdepositos.observaciones) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND globalusuariosdepositos.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 1  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosdepositosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosdepositosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalusuariosdepositosPK(BigDecimal idusuariosdepositos,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select globalusuariosdepositos.idusuariosdepositos,globalusuariosdepositos.idusuario,globalusuarios.usuario,globalusuariosdepositos.codigo_dt,stockdepositos.descrip_dt,globalusuariosdepositos.observaciones,globalusuariosdepositos.idempresa,globalusuariosdepositos.usuarioalt,globalusuariosdepositos.usuarioact,globalusuariosdepositos.fechaalt,globalusuariosdepositos.fechaact  from globalusuariosdepositos,globalusuarios,stockdepositos where globalusuarios.idusuario = globalusuariosdepositos.idusuario and globalusuarios.idempresa = globalusuariosdepositos.idempresa and stockdepositos.codigo_dt = globalusuariosdepositos.codigo_dt and stockdepositos.idempresa = globalusuariosdepositos.idempresa  and globalusuariosdepositos.idusuariosdepositos="
				+ idusuariosdepositos.toString()
				+ " AND globalusuariosdepositos.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalusuariosdepositosPK( BigDecimal idusuariosdepositos ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalusuariosdepositosPK( BigDecimal idusuariosdepositos )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalusuariosdepositosDelete(BigDecimal idusuariosdepositos,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALUSUARIOSDEPOSITOS "
				+ " WHERE idusuariosdepositos = "
				+ idusuariosdepositos.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALUSUARIOSDEPOSITOS "
						+ " WHERE idusuariosdepositos = "
						+ idusuariosdepositos.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalusuariosdepositosDelete( BigDecimal idusuariosdepositos ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalusuariosdepositosDelete( BigDecimal idusuariosdepositos )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalusuariosdepositosCreate(BigDecimal idusuario,
			BigDecimal codigo_dt, String observaciones, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALUSUARIOSDEPOSITOS(idusuario, codigo_dt, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idusuario);
				insert.setBigDecimal(2, codigo_dt);
				insert.setString(3, observaciones);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosdepositosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosdepositosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalusuariosdepositosCreateOrUpdate(
			BigDecimal idusuariosdepositos, BigDecimal idusuario,
			BigDecimal codigo_dt, String observaciones, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuariosdepositos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuariosdepositos ";
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosdepositos WHERE idusuariosdepositos = "
					+ idusuariosdepositos.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSDEPOSITOS SET idusuario=?, codigo_dt=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idusuariosdepositos=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, codigo_dt);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idusuariosdepositos);
				} else {
					String ins = "INSERT INTO GLOBALUSUARIOSDEPOSITOS(idusuario, codigo_dt, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, codigo_dt);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalusuariosdepositosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalusuariosdepositosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalusuariosdepositosUpdate(BigDecimal idusuariosdepositos,
			BigDecimal idusuario, BigDecimal codigo_dt, String observaciones,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idusuariosdepositos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuariosdepositos ";
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idusuario ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuariosdepositos WHERE idusuariosdepositos = "
					+ idusuariosdepositos.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALUSUARIOSDEPOSITOS SET idusuario=?, codigo_dt=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idusuariosdepositos=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idusuario);
					insert.setBigDecimal(2, codigo_dt);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idusuariosdepositos);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalusuariosdepositosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalusuariosdepositosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// pedidos canones
	// para todo (ordena por el segundo campo por defecto)
	public List getPedidoscanonesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idcanon,canon,por_desc,formula,precedencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSCANONES WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getPedidoscanonesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidoscanonesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidoscanonesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcanon,canon,por_desc,formula,precedencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSCANONES "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcanon::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(canon) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPedidoscanonesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidoscanonesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidoscanonesPK(BigDecimal idcanon, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idcanon,canon,por_desc,formula,precedencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSCANONES WHERE idcanon="
				+ idcanon.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPedidoscanonesPK( BigDecimal idcanon ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidoscanonesPK( BigDecimal idcanon )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidoscanonesDelete(BigDecimal idcanon, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSCANONES " + " WHERE idcanon="
				+ idcanon.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSCANONES " + " WHERE idcanon="
						+ idcanon.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidoscanonesDelete( BigDecimal idcanon ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidoscanonesDelete( BigDecimal idcanon )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidoscanonesCreate(String canon, Double por_desc,
			String formula, BigDecimal precedencia, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (canon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canon ";
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";
		if (precedencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precedencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (canon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canon ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSCANONES(canon, por_desc, formula, precedencia, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, canon);
				insert.setDouble(2, por_desc.doubleValue());
				insert.setString(3, formula);
				insert.setBigDecimal(4, precedencia);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String pedidoscanonesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidoscanonesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidoscanonesCreateOrUpdate(BigDecimal idcanon,
			String canon, Double por_desc, String formula,
			BigDecimal precedencia, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcanon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanon ";
		if (canon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canon ";
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";
		if (precedencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precedencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (canon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canon ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidoscanones WHERE idcanon = "
					+ idcanon.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSCANONES SET canon=?, por_desc=?, formula=?, precedencia=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcanon=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, canon);
					insert.setDouble(2, por_desc.doubleValue());
					insert.setString(3, formula);
					insert.setBigDecimal(4, precedencia);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idcanon);
				} else {
					String ins = "INSERT INTO PEDIDOSCANONES(canon, por_desc, formula, precedencia, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, canon);
					insert.setDouble(2, por_desc.doubleValue());
					insert.setString(3, formula);
					insert.setBigDecimal(4, precedencia);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidoscanonesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidoscanonesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidoscanonesUpdate(BigDecimal idcanon, String canon,
			Double por_desc, String formula, BigDecimal precedencia,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcanon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanon ";
		if (canon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canon ";
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (formula == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formula ";
		if (precedencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precedencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (canon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canon ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidoscanones WHERE idcanon = "
					+ idcanon.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSCANONES SET canon=?, por_desc=?, formula=?, precedencia=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcanon=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, canon);
					insert.setDouble(2, por_desc.doubleValue());
					insert.setString(3, formula);
					insert.setBigDecimal(4, precedencia);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idcanon);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String pedidoscanonesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidoscanonesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// esto hay que pasarlo a
	// clientes**********************************************************************
	// clientes expreso zonas
	public List getClientesexpresoszonasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT ez.codigo, ex.expreso, z.zona,"
				+ "       ez.idempresa, ez.usuarioalt, ez.usuarioact, ez.fechaalt, ez.fechaact"
				+ "  FROM clientesexpresoszonas ez "
				+ "       INNER JOIN clientesexpresos ex ON ex.idexpreso = ez.idexpreso AND ex.idempresa = ez.idempresa "
				+ "       INNER JOIN clienteszonas z  ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ " WHERE ez.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesexpresoszonasAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresoszonasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesexpresoszonasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT ez.codigo, ex.expreso, z.zona,"
				+ "       ez.idempresa, ez.usuarioalt, ez.usuarioact, ez.fechaalt, ez.fechaact"
				+ "  FROM clientesexpresoszonas ez "
				+ "       INNER JOIN clientesexpresos ex ON ex.idexpreso = ez.idexpreso AND ex.idempresa = ez.idempresa "
				+ "       INNER JOIN clienteszonas z  ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ " WHERE ez.idempresa = " + idempresa.toString()
				+ "   AND (UPPER(z.zona) LIKE '%" + ocurrencia.toUpperCase()
				+ "%' OR " + " UPPER(ex.expreso) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesexpresoszonasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresoszonasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesexpresoszonasPK(BigDecimal codigo,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT CLIENTESEXPRESOSZONAS.codigo,clientesexpresos.idexpreso,clientesexpresos.expreso,clienteszonas.idzona,clienteszonas.zona,CLIENTESEXPRESOSZONAS.idempresa,CLIENTESEXPRESOSZONAS.usuarioalt,CLIENTESEXPRESOSZONAS.usuarioact,CLIENTESEXPRESOSZONAS.fechaalt,CLIENTESEXPRESOSZONAS.fechaact FROM CLIENTESEXPRESOSZONAS,clientesexpresos,clienteszonas where clientesexpresos.idexpreso = CLIENTESEXPRESOSZONAS.idexpreso and clientesexpresos.idempresa = CLIENTESEXPRESOSZONAS.idempresa and clienteszonas.idzona = CLIENTESEXPRESOSZONAS.idzona and clienteszonas.idempresa = CLIENTESEXPRESOSZONAS.idempresa"
				+ " and  CLIENTESEXPRESOSZONAS.codigo="
				+ codigo.toString()
				+ " AND CLIENTESEXPRESOSZONAS.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesexpresoszonasPK( BigDecimal codigo ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresoszonasPK( BigDecimal codigo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesexpresoszonasDelete(BigDecimal codigo,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESEXPRESOSZONAS "
				+ " WHERE codigo = " + codigo.toString() + " and idempresa= "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESEXPRESOSZONAS "
						+ " WHERE codigo=" + codigo.toString()
						+ " and idempresa= " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesexpresoszonasDelete( BigDecimal codigo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesexpresoszonasDelete( BigDecimal codigo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesexpresoszonasCreate(BigDecimal idexpreso,
			BigDecimal idzona, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESEXPRESOSZONAS(idexpreso, idzona, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idexpreso);
				insert.setBigDecimal(2, idzona);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesexpresoszonasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesexpresoszonasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesexpresoszonasCreateOrUpdate(BigDecimal codigo,
			BigDecimal idexpreso, BigDecimal idzona, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo ";
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesexpresoszonas WHERE codigo = "
					+ codigo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESEXPRESOSZONAS SET idexpreso=?, idzona=?, idempresa=?, usuarioact=?, fechaact=? WHERE codigo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idzona);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, codigo);
				} else {
					String ins = "INSERT INTO CLIENTESEXPRESOSZONAS(idexpreso, idzona, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idzona);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesexpresoszonasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesexpresoszonasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesexpresoszonasUpdate(BigDecimal codigo,
			BigDecimal idexpreso, BigDecimal idzona, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo ";
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesexpresoszonas WHERE codigo = "
					+ codigo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESEXPRESOSZONAS SET idexpreso=?, idzona=?, idempresa=?, usuarioact=?, fechaact=? WHERE codigo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idzona);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, codigo);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesexpresoszonasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesexpresoszonasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes descuentos
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesdescuentosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT iddescuento,por_desc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESDESCUENTOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 1  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesdescuentosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesdescuentosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesdescuentosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  iddescuento,por_desc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESDESCUENTOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (iddescuento::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " (por_desc::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 1  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesdescuentosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesdescuentosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesdescuentosPK(BigDecimal iddescuento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  iddescuento,por_desc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESDESCUENTOS WHERE iddescuento="
				+ iddescuento.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesdescuentosPK( BigDecimal iddescuento ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesdescuentosPK( BigDecimal iddescuento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesdescuentosDelete(BigDecimal iddescuento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESDESCUENTOS "
				+ " WHERE iddescuento=" + iddescuento.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESDESCUENTOS "
						+ " WHERE iddescuento=" + iddescuento.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesdescuentosDelete( BigDecimal iddescuento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesdescuentosDelete( BigDecimal iddescuento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesdescuentosCreate(Double por_desc,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESDESCUENTOS(por_desc, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setDouble(1, por_desc.doubleValue());
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesdescuentosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesdescuentosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesdescuentosCreateOrUpdate(BigDecimal iddescuento,
			Double por_desc, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddescuento ";
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesdescuentos WHERE iddescuento = "
					+ iddescuento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESDESCUENTOS SET por_desc=?, idempresa=?, usuarioact=?, fechaact=? WHERE iddescuento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setDouble(1, por_desc.doubleValue());
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, iddescuento);
				} else {
					String ins = "INSERT INTO CLIENTESDESCUENTOS(por_desc, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setDouble(1, por_desc.doubleValue());
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesdescuentosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesdescuentosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesdescuentosUpdate(BigDecimal iddescuento,
			Double por_desc, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddescuento ";
		if (por_desc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: por_desc ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesdescuentos WHERE iddescuento = "
					+ iddescuento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESDESCUENTOS SET por_desc=?, idempresa=?, usuarioact=?, fechaact=? WHERE iddescuento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setDouble(1, por_desc.doubleValue());
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, iddescuento);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesdescuentosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesdescuentosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes anexo localidades
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesanexolocalidadesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT CLIENTESANEXOLOCALIDADES.idanexolocalidad,clientesexpresos.expreso,globalprovincias.provincia,globallocalidades.localidad,CLIENTESANEXOLOCALIDADES.cpostal,CLIENTESANEXOLOCALIDADES.tax1bulto,CLIENTESANEXOLOCALIDADES.taxexcedente,CLIENTESANEXOLOCALIDADES.tax1bulto2,CLIENTESANEXOLOCALIDADES.taxexcedente2,CLIENTESANEXOLOCALIDADES.valor_seguro,CLIENTESANEXOLOCALIDADES.usuarioalt,CLIENTESANEXOLOCALIDADES.usuarioact,CLIENTESANEXOLOCALIDADES.fechaalt,CLIENTESANEXOLOCALIDADES.fechaact,CLIENTESANEXOLOCALIDADES.idempresa FROM CLIENTESANEXOLOCALIDADES,clientesexpresos,globalprovincias,globallocalidades where clientesexpresos.idexpreso = CLIENTESANEXOLOCALIDADES.idexpreso and clientesexpresos.idempresa = CLIENTESANEXOLOCALIDADES.idempresa and globalprovincias.idprovincia = CLIENTESANEXOLOCALIDADES.idprovincia and globallocalidades.idlocalidad =CLIENTESANEXOLOCALIDADES.idlocalidad"
				+ " and CLIENTESANEXOLOCALIDADES.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesanexolocalidadesAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesanexolocalidadesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesanexolocalidadesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT CLIENTESANEXOLOCALIDADES.idanexolocalidad,clientesexpresos.expreso,globalprovincias.provincia,globallocalidades.localidad,CLIENTESANEXOLOCALIDADES.cpostal,CLIENTESANEXOLOCALIDADES.tax1bulto,CLIENTESANEXOLOCALIDADES.taxexcedente,CLIENTESANEXOLOCALIDADES.tax1bulto2,CLIENTESANEXOLOCALIDADES.taxexcedente2,CLIENTESANEXOLOCALIDADES.valor_seguro,CLIENTESANEXOLOCALIDADES.usuarioalt,CLIENTESANEXOLOCALIDADES.usuarioact,CLIENTESANEXOLOCALIDADES.fechaalt,CLIENTESANEXOLOCALIDADES.fechaact,CLIENTESANEXOLOCALIDADES.idempresa FROM CLIENTESANEXOLOCALIDADES,clientesexpresos,globalprovincias,globallocalidades where clientesexpresos.idexpreso = CLIENTESANEXOLOCALIDADES.idexpreso and clientesexpresos.idempresa = CLIENTESANEXOLOCALIDADES.idempresa and globalprovincias.idprovincia = CLIENTESANEXOLOCALIDADES.idprovincia and globallocalidades.idlocalidad =CLIENTESANEXOLOCALIDADES.idlocalidad "
				+ " and CLIENTESANEXOLOCALIDADES.idempresa= "
				+ idempresa.toString()
				+ " and (CLIENTESANEXOLOCALIDADES.idanexolocalidad::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(clientesexpresos.expreso) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 1  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesanexolocalidadesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesanexolocalidadesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesanexolocalidadesPK(BigDecimal idanexolocalidad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT CLIENTESANEXOLOCALIDADES.idanexolocalidad,clientesexpresos.idexpreso,clientesexpresos.expreso,globalprovincias.idprovincia,globalprovincias.provincia,globallocalidades.idlocalidad,globallocalidades.localidad,CLIENTESANEXOLOCALIDADES.cpostal,CLIENTESANEXOLOCALIDADES.tax1bulto,CLIENTESANEXOLOCALIDADES.taxexcedente,CLIENTESANEXOLOCALIDADES.tax1bulto2,CLIENTESANEXOLOCALIDADES.taxexcedente2,CLIENTESANEXOLOCALIDADES.valor_seguro,CLIENTESANEXOLOCALIDADES.usuarioalt,CLIENTESANEXOLOCALIDADES.usuarioact,CLIENTESANEXOLOCALIDADES.fechaalt,CLIENTESANEXOLOCALIDADES.fechaact,CLIENTESANEXOLOCALIDADES.idempresa FROM CLIENTESANEXOLOCALIDADES,clientesexpresos,globalprovincias,globallocalidades where clientesexpresos.idexpreso = CLIENTESANEXOLOCALIDADES.idexpreso and clientesexpresos.idempresa = CLIENTESANEXOLOCALIDADES.idempresa and globalprovincias.idprovincia = CLIENTESANEXOLOCALIDADES.idprovincia and globallocalidades.idlocalidad =CLIENTESANEXOLOCALIDADES.idlocalidad"
				+ " and CLIENTESANEXOLOCALIDADES.idanexolocalidad="
				+ idanexolocalidad.toString()
				+ " AND CLIENTESANEXOLOCALIDADES.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesanexolocalidadesPK( BigDecimal idanexolocalidad ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesanexolocalidadesPK( BigDecimal idanexolocalidad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesanexolocalidadesDelete(BigDecimal idanexolocalidad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESANEXOLOCALIDADES "
				+ " WHERE idanexolocalidad=" + idanexolocalidad.toString()
				+ " and idempresa =" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESANEXOLOCALIDADES "
						+ " WHERE idanexolocalidad="
						+ idanexolocalidad.toString() + " and idempresa ="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesanexolocalidadesDelete( BigDecimal idanexolocalidad ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesanexolocalidadesDelete( BigDecimal idanexolocalidad )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesanexolocalidadesCreate(BigDecimal idexpreso,
			BigDecimal idprovincia, BigDecimal idlocalidad, BigDecimal cpostal,
			Double tax1bulto, Double taxexcedente, Double tax1bulto2,
			Double taxexcedente2, Double valor_seguro, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (cpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cpostal ";
		if (tax1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tax1bulto ";
		if (taxexcedente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: taxexcedente ";
		if (tax1bulto2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tax1bulto2 ";
		if (taxexcedente2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: taxexcedente2 ";
		if (valor_seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";

		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESANEXOLOCALIDADES(idexpreso, idprovincia, idlocalidad, cpostal, tax1bulto, taxexcedente, tax1bulto2, taxexcedente2, valor_seguro, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idexpreso);
				insert.setBigDecimal(2, idprovincia);
				insert.setBigDecimal(3, idlocalidad);
				insert.setBigDecimal(4, cpostal);
				insert.setDouble(5, tax1bulto.doubleValue());
				insert.setDouble(6, taxexcedente.doubleValue());
				insert.setDouble(7, tax1bulto2.doubleValue());
				insert.setDouble(8, taxexcedente2.doubleValue());
				insert.setDouble(9, valor_seguro.doubleValue());
				insert.setString(10, usuarioalt);
				insert.setBigDecimal(11, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesanexolocalidadesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesanexolocalidadesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria
	/*
	 * public String clientesanexolocalidadesCreateOrUpdate(BigDecimal
	 * idanexolocalidad, BigDecimal idexpreso, BigDecimal idprovincia,
	 * BigDecimal idlocalidad, BigDecimal cpostal, Double tax1bulto, Double
	 * taxexcedente, Double tax1bulto2, Double taxexcedente2, Double
	 * valor_seguro, String usuarioact, Timestamp fechaact) throws EJBException
	 * { Calendar hoy = new GregorianCalendar(); //Timestamp fechaact = new
	 * Timestamp(hoy.getTime().getTime()); String salida = "NOOK"; //
	 * validaciones de datos: // 1. nulidad de campos if(idanexolocalidad ==
	 * null ) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * idanexolocalidad "; if(idexpreso == null ) salida = "Error: No se puede
	 * dejar sin datos (nulo) el campo: idexpreso "; if(idprovincia == null )
	 * salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
	 * if(idlocalidad == null ) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: idlocalidad "; if(cpostal == null ) salida = "Error: No
	 * se puede dejar sin datos (nulo) el campo: cpostal "; if(tax1bulto == null
	 * ) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: tax1bulto ";
	 * if(taxexcedente == null ) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: taxexcedente "; if(tax1bulto2 == null ) salida = "Error:
	 * No se puede dejar sin datos (nulo) el campo: tax1bulto2 ";
	 * if(taxexcedente2 == null ) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: taxexcedente2 "; if(valor_seguro == null ) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro "; //
	 * 2. sin nada desde la pagina // fin validaciones boolean bError=true;
	 * if(salida.equalsIgnoreCase("NOOK")) bError = false; try { ResultSet
	 * rsSalida = null; String cQuery = "SELECT COUNT(*) FROM
	 * clientesanexolocalidades WHERE idanexolocalidad = " +
	 * idanexolocalidad.toString(); Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); int
	 * total = 0; if (rsSalida != null && rsSalida.next()) total =
	 * rsSalida.getInt(1); PreparedStatement insert = null; String sql = "";
	 * if(!bError){ if (total > 0) { // si existe hago update sql="UPDATE
	 * CLIENTESANEXOLOCALIDADES SET idexpreso=?, idprovincia=?, idlocalidad=?,
	 * cpostal=?, tax1bulto=?, taxexcedente=?, tax1bulto2=?, taxexcedente2=?,
	 * valor_seguro=?, usuarioact=?, fechaact=?idempresa=? WHERE
	 * idanexolocalidad=?;"; insert = dbconn.prepareStatement(sql);
	 * insert.setBigDecimal(1,idexpreso); insert.setBigDecimal(2,idprovincia);
	 * insert.setBigDecimal(3,idlocalidad); insert.setBigDecimal(4,cpostal);
	 * insert.setDouble(5,tax1bulto.doubleValue());
	 * insert.setDouble(6,taxexcedente.doubleValue());
	 * insert.setDouble(7,tax1bulto2.doubleValue());
	 * insert.setDouble(8,taxexcedente2.doubleValue());
	 * insert.setDouble(9,valor_seguro.doubleValue());
	 * insert.setString(10,usuarioact); insert.setTimestamp(11,fechaact);
	 * //insert.setBigDecimal(12,idempresa);
	 * insert.setBigDecimal(13,idanexolocalidad); } else { String ins = "INSERT
	 * INTO CLIENTESANEXOLOCALIDADES(idexpreso, idprovincia, idlocalidad,
	 * cpostal, tax1bulto, taxexcedente, tax1bulto2, taxexcedente2,
	 * valor_seguro, usuarioalt, fechaalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?,
	 * ?, ?)"; insert = dbconn.prepareStatement(ins); //seteo de campos: String
	 * usuarioalt=usuarioact; // esta variable va a proposito
	 * insert.setBigDecimal(1,idexpreso); insert.setBigDecimal(2,idprovincia);
	 * insert.setBigDecimal(3,idlocalidad); insert.setBigDecimal(4,cpostal);
	 * insert.setDouble(5,tax1bulto.doubleValue());
	 * insert.setDouble(6,taxexcedente.doubleValue());
	 * insert.setDouble(7,tax1bulto2.doubleValue());
	 * insert.setDouble(8,taxexcedente2.doubleValue());
	 * insert.setDouble(9,valor_seguro.doubleValue());
	 * insert.setString(10,usuarioalt); //insert.setTimestamp(11,fechaalt); }
	 * insert.executeUpdate(); salida = "Alta Correcta."; } } catch
	 * (SQLException sqlException) { salida = "Imposible dar de alta el
	 * registro."; log.error("Error SQL public String
	 * clientesanexolocalidadesCreateOrUpdate(.....)" + sqlException); } catch
	 * (Exception ex) { salida = "Imposible dar de alta el registro.";
	 * log.error("Error excepcion public String
	 * clientesanexolocalidadesCreateOrUpdate(.....)" + ex); } return salida; }
	 */
	public String clientesanexolocalidadesUpdate(BigDecimal idanexolocalidad,
			BigDecimal idexpreso, BigDecimal idprovincia,
			BigDecimal idlocalidad, BigDecimal cpostal, Double tax1bulto,
			Double taxexcedente, Double tax1bulto2, Double taxexcedente2,
			Double valor_seguro, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idanexolocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idanexolocalidad ";
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (cpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cpostal ";
		if (tax1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tax1bulto ";
		if (taxexcedente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: taxexcedente ";
		if (tax1bulto2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tax1bulto2 ";
		if (taxexcedente2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: taxexcedente2 ";
		if (valor_seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesanexolocalidades WHERE idanexolocalidad = "
					+ idanexolocalidad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESANEXOLOCALIDADES SET idexpreso=?, idprovincia=?, idlocalidad=?, cpostal=?, tax1bulto=?, taxexcedente=?, tax1bulto2=?, taxexcedente2=?, valor_seguro=?, usuarioact=?, fechaact=?,idempresa=? WHERE idanexolocalidad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idprovincia);
					insert.setBigDecimal(3, idlocalidad);
					insert.setBigDecimal(4, cpostal);
					insert.setDouble(5, tax1bulto.doubleValue());
					insert.setDouble(6, taxexcedente.doubleValue());
					insert.setDouble(7, tax1bulto2.doubleValue());
					insert.setDouble(8, taxexcedente2.doubleValue());
					insert.setDouble(9, valor_seguro.doubleValue());
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idempresa);
					insert.setBigDecimal(13, idanexolocalidad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesanexolocalidadesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesanexolocalidadesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes precarga
	public List getClientesPrecargaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,cl.idtipoclie,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,cl.idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,cep.estadoprecarga, "
				+ " ccb.idclub, ccb.club, ccb.logo "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"

				+ " left JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and ctc.idempresa = ccb.idempresa "

				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " left JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa"
				+ " left JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesPrecargaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,cl.idtipoclie,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,cl.idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,cep.estadoprecarga, "
				+ " ccb.idclub, ccb.club, ccb.logo "
				+ " FROM clientesPrecargaclientes cl "
				// --> TODO: EJV - 20110720 - Bug quedan diferentes las razones
				// cuando se modifica cliente !!!
				+ " left JOIN clientesclientes clie ON cl.idcliente = clie.idcliente AND cl.idempresa = clie.idempresa  "
				// <--
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"

				+ " left JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and ctc.idempresa = ccb.idempresa "

				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " left JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa"
				+ " left JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ "  WHERE ("
				// --> TODO: EJV - 20110720 - Bug quedan diferentes las razones
				+ "UPPER(clie.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' "
				+ // <--
				"OR UPPER(cl.razon) LIKE '%" + ocurrencia.toUpperCase().trim()
				+ "%' OR cl.idprecarga::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR cl.nrodocumento::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND cl.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesPrecargaPK(BigDecimal idprecarga,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva, "
				+ "             cl.idcondicion,co.condicion, cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto, "
				+ "             cl.idmoneda,mo.moneda,cl.idlista,li.descri_lis,cl.idtipoclie,tcl.tipoclie,cl.observacion, "
				+ "             cl.lcredito,cl.idtipocomp,tc.descri_tc,cl.autorizado,cl.idcredcate,cc.credcate,cl.fechadeingreso,cl.fechadenacimiento,"
				+ "             cl.sexo,cl.referencia,ccc.razon,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,"
				+ "             cep.estadoprecarga,cl.idpreferencia,cp.preferencia,cl.idorigen,op.origen,cl.idsuborigen,sp.suborigen, cl.idpromocion, prm.promocion,"
				+ "             cl.sucursalfactura, COALESCE(cl.idcliente, -1) idcliente, "
				+ "             cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact "
				+ "  FROM clientesPrecargaclientes  cl "
				+ "       LEFT JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and  cl.idempresa = td.idempresa "
				+ "       LEFT JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
				+ "       LEFT JOIN clientescondicio co ON cl.idcondicion = co.idcondicion AND cl.idempresa = co.idempresa "
				+ "       LEFT JOIN globalmonedas mo ON cl.idmoneda = mo.idmoneda  "
				+ "       LEFT JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa "
				+ "       LEFT JOIN clientestipoclie tcl ON cl.idtipoclie = tcl.idtipoclie AND cl.idempresa = tcl.idempresa "
				+ "       LEFT JOIN clienteslistas li ON cl.idlista = li.idlista AND cl.idempresa = li.idempresa "
				+ "       LEFT JOIN clientestipocomp tc ON  cl.idtipocomp = tc.idtipocomp AND cl.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientesclientes ccc ON  cl.referencia = ccc.idcliente AND cl.idempresa = ccc.idempresa "
				+ "       LEFT JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa "
				+ "       LEFT JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ "       LEFT JOIN clientespreferencias cp ON cl.idpreferencia = cp.idpreferencia and cl.idempresa = cp.idempresa"
				+ "       LEFT JOIN origenprospecto op ON cl.idorigen = op.idorigen and cl.idempresa = op.idempresa"
				+ "       LEFT JOIN suborigenprospecto sp ON cl.idsuborigen = sp.idsuborigen and cl.idempresa = sp.idempresa "
				+ "       LEFT JOIN clientespromociones prm ON cl.idpromocion = prm.idpromocion and cl.idempresa = prm.idempresa "
				+ " WHERE cl.idprecarga=" + idprecarga.toString()
				+ "   AND cl.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesPrecargaPK( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaPK( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// 20110331 - EJV - Mantis 683 -->
	public List getClientesPrecargaXIdCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva, "
				+ "       cl.idcondicion,co.condicion, cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto, "
				+ "       cl.idmoneda,mo.moneda,cl.idlista,li.descri_lis,cl.idtipoclie,tcl.tipoclie,cl.observacion, "
				+ "       cl.lcredito,cl.idtipocomp,tc.descri_tc,cl.autorizado,cl.idcredcate,cc.credcate,cl.fechadeingreso,cl.fechadenacimiento,"
				+ "       cl.sexo,cl.referencia,ccc.razon,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,"
				+ "       cep.estadoprecarga,cl.idpreferencia,cp.preferencia,cl.idorigen,op.origen,cl.idsuborigen,sp.suborigen, "
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact "
				+ "  FROM clientesPrecargaclientes  cl "
				+ "       LEFT JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and  cl.idempresa = td.idempresa "
				+ "       LEFT JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
				+ "       LEFT JOIN clientescondicio co ON cl.idcondicion = co.idcondicion AND cl.idempresa = co.idempresa "
				+ "       LEFT JOIN globalmonedas mo ON cl.idmoneda = mo.idmoneda  "
				+ "       LEFT JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa "
				+ "       LEFT JOIN clientestipoclie tcl ON cl.idtipoclie = tcl.idtipoclie AND cl.idempresa = tcl.idempresa "
				+ "       LEFT JOIN clienteslistas li ON cl.idlista = li.idlista AND cl.idempresa = li.idempresa "
				+ "       LEFT JOIN clientestipocomp tc ON  cl.idtipocomp = tc.idtipocomp AND cl.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientesclientes ccc ON  cl.referencia = ccc.idcliente AND cl.idempresa = ccc.idempresa "
				+ "       LEFT JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa "
				+ "       LEFT JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ "       LEFT JOIN clientespreferencias cp ON cl.idpreferencia = cp.idpreferencia and cl.idempresa = cp.idempresa"
				+ "       LEFT JOIN origenprospecto op ON cl.idorigen = op.idorigen and cl.idempresa = op.idempresa"
				+ "       LEFT JOIN suborigenprospecto sp ON cl.idsuborigen = sp.idsuborigen and cl.idempresa = sp.idempresa"
				+ " WHERE cl.idcliente=" + idcliente.toString()
				+ "   AND cl.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesPrecargaPK( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaPK( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	public String getClientesPrecargaDelete(BigDecimal idprecarga,
			BigDecimal idempresa) throws EJBException, SQLException {
		ResultSet rsSalida = null;

		String cQuery = "SELECT * FROM clientesPrecargaclientes WHERE idprecarga="
				+ idprecarga.toString()
				+ " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		dbconn.setAutoCommit(false);

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {

				salida = clienteTarjetasCreditoXClienteDelete(idprecarga,
						idempresa);

				if (salida.equalsIgnoreCase("OK")) {

					salida = clientesEmailXClienteDelete(idprecarga, idempresa);

					if (salida.equalsIgnoreCase("OK")) {

						salida = clientesDomiciliosXClienteDelete(idprecarga,
								idempresa);

						if (salida.equalsIgnoreCase("OK")) {

							cQuery = "DELETE FROM clientesPrecargaclientes WHERE idprecarga="
									+ idprecarga.toString()
									+ " AND idempresa = "
									+ idempresa.toString();
							statement.execute(cQuery);
							int i = statement.getUpdateCount();

							if (i <= 0) {

								salida = "Cliente inexistente - eliminado desde otra sesion.";

							}

						}

					}

				}

			} else {
				salida = "Error: Cliente inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar cliente.";
			log
					.error("Error SQL en el metodo : getClientesPrecargaDelete( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar cliente.";
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaDelete( BigDecimal idcliente )  "
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();

		} else {
			dbconn.commit();
			salida = "Baja de cliente correcta.";
		}
		dbconn.setAutoCommit(true);
		return salida;
	}

	public String clientesPrecargaCreate(BigDecimal idprecarga, String razon,
			BigDecimal idtipodocumento, BigDecimal nrodocumento, String brutos,
			BigDecimal idtipoiva, BigDecimal idcondicion, Double descuento1,
			Double descuento2, Double descuento3, BigDecimal idctaneto,
			BigDecimal idmoneda, BigDecimal idlista, BigDecimal idtipoclie,
			String observacion, Double lcredito, BigDecimal idtipocomp,
			String autorizado, BigDecimal idcredcate, Hashtable htDomicilios,
			Hashtable htTarjetas, Timestamp fechadeingreso,
			Timestamp fechadenacimiento, String sexo, BigDecimal referencia,
			BigDecimal idcliente, BigDecimal idempresa, String usuarioalt,
			String nuevoreactivacion, BigDecimal porcentaje,
			BigDecimal idvendedorasignado, BigDecimal idestadoprecarga,
			BigDecimal condomicilio, BigDecimal idpreferencia,
			BigDecimal idorigen, BigDecimal idsuborigen,
			BigDecimal idpromocion, BigDecimal sucursalfactura)
			throws EJBException, SQLException {
		String salida = "OK";
		Enumeration en;
		dbconn.setAutoCommit(false);

		// validaciones de datos:
		// 1. nulidad de campos
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		if (sucursalfactura == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sucursalfactura ";

		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO clientesPrecargaclientes"
						+ "  (idprecarga, razon, idtipodocumento, nrodocumento, brutos, idtipoiva,  "
						+ "   idcondicion, descuento1, descuento2, descuento3, idctaneto, idmoneda, idlista, "
						+ "   idtipoclie, observacion, lcredito, idtipocomp, autorizado, idcredcate,fechadeingreso,fechadenacimiento,sexo,referencia,idcliente, "
						+ "   idempresa, usuarioalt,nuevoreactivacion,porcentaje,idvendedorasignado,idestadoprecarga,idpreferencia,idorigen,idsuborigen, idpromocion, sucursalfactura )"
						+ " VALUES (?,?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idprecarga);
				insert.setString(2, razon);
				insert.setBigDecimal(3, idtipodocumento);
				insert.setBigDecimal(4, nrodocumento);
				insert.setString(5, brutos);
				insert.setBigDecimal(6, idtipoiva);
				// insert.setBigDecimal(7, idvendedor);
				insert.setBigDecimal(7, idcondicion);
				insert.setDouble(8, descuento1.doubleValue());
				insert.setDouble(9, descuento2.doubleValue());
				insert.setDouble(10, descuento3.doubleValue());
				insert.setBigDecimal(11, idctaneto);
				insert.setBigDecimal(12, idmoneda);
				insert.setBigDecimal(13, idlista);
				insert.setBigDecimal(14, idtipoclie);
				insert.setString(15, observacion);
				insert.setDouble(16, lcredito.doubleValue());
				insert.setBigDecimal(17, idtipocomp);
				insert.setString(18, autorizado);
				insert.setBigDecimal(19, idcredcate);
				insert.setTimestamp(20, fechadeingreso);
				insert.setTimestamp(21, fechadenacimiento);
				insert.setString(22, sexo);
				insert.setBigDecimal(23, referencia);
				insert.setBigDecimal(24, idcliente);
				insert.setBigDecimal(25, idempresa);
				insert.setString(26, usuarioalt);
				insert.setString(27, nuevoreactivacion);
				insert.setBigDecimal(28, porcentaje);
				insert.setBigDecimal(29, idvendedorasignado);
				insert.setBigDecimal(30, idestadoprecarga);
				insert.setBigDecimal(31, idpreferencia);
				insert.setBigDecimal(32, idorigen);
				insert.setBigDecimal(33, idsuborigen);
				insert.setBigDecimal(34, idpromocion);
				insert.setBigDecimal(35, sucursalfactura);
				int n = insert.executeUpdate();

				if (n == 1) {

					en = htDomicilios.keys();

					while (en.hasMoreElements()) {

						Object[] domicilios = (Object[]) htDomicilios.get(en
								.nextElement());

						BigDecimal iddomicilio = new BigDecimal(domicilios[0]
								.toString());
						BigDecimal idtipodomicilio = new BigDecimal(
								domicilios[1].toString());
						// String tipodomicilio = domicilios[2].toString();
						String esdefault = domicilios[3].toString();
						String calle = domicilios[4].toString();
						String nro = domicilios[5].toString();
						String piso = domicilios[6].toString();
						String depto = domicilios[7].toString();
						BigDecimal idlocalidad = new BigDecimal(domicilios[8]
								.toString());
						// String localidad = domicilios[9].toString();
						String cpa = domicilios[10].toString();
						String postal = domicilios[11].toString();
						String contacto = domicilios[12].toString();
						String cargocontacto = domicilios[13].toString();
						String telefonos = domicilios[14].toString();
						String celular = domicilios[15].toString();
						String fax = domicilios[16].toString();
						String web = domicilios[17].toString();
						BigDecimal idzona = new BigDecimal(domicilios[18]
								.toString());
						// String zona = domicilios[19].toString();
						BigDecimal idexpreso = new BigDecimal(domicilios[20]
								.toString());
						// String expreso = domicilios[21].toString();
						BigDecimal idcobrador = new BigDecimal(domicilios[22]
								.toString());
						// String cobrador = domicilios[23].toString();
						BigDecimal idvendedor = new BigDecimal(domicilios[24]
								.toString());
						// String vendedor = domicilios[25].toString();
						String[] email = (String[]) domicilios[26];
						String statusItem = domicilios[27].toString();
						BigDecimal idanexolocalidad = new BigDecimal(
								domicilios[28].toString());
						String obsentrega = domicilios[29].toString();

						if (statusItem.equalsIgnoreCase("B"))
							continue;

						if (condomicilio.compareTo(new BigDecimal(0)) == 1) {
							salida = clientesDomiciliosCreate(idcliente,
									idtipodomicilio, esdefault, calle, nro,
									piso, depto, idlocalidad, cpa, postal,
									contacto, cargocontacto, telefonos,
									celular, fax, web, idanexolocalidad,
									idcobrador, idvendedor, idempresa,
									usuarioalt, idprecarga, obsentrega);
							if (salida.equalsIgnoreCase("OK")) {
								iddomicilio = GeneralBean.getValorSequencia(
										"seq_clientesdomiclilios", dbconn);
								for (int j = 0; email != null
										&& j < email.length; j++) {
									salida = clientesEmailCreate(iddomicilio,
											idcliente, idprecarga, email[j],
											idempresa, usuarioalt);
									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						}
					}

					if (salida.equalsIgnoreCase("OK")) {

						// 20090717 - EJV
						if (getTotalEntidadFiltro("clientesdomicilios",
								" WHERE idprecarga = " + idprecarga
										+ " AND esdefault = 'S' ", idempresa) < 1) {

							salida = "Es necesario marcar un domicilio de entrega como default.";

						}

						if (salida.equalsIgnoreCase("OK")) {

							if (htTarjetas != null && !htTarjetas.isEmpty()) {

								en = htTarjetas.keys();

								while (en.hasMoreElements()) {

									SimpleDateFormat sdf = new SimpleDateFormat(
											"dd/MM/yyyy");

									String[] tarjetasCliente = (String[]) htTarjetas
											.get(en.nextElement());
									// BigDecimal idtarjeta = new BigDecimal(
									// tarjetasCliente[0]);
									BigDecimal idtarjetacredito = new BigDecimal(
											tarjetasCliente[1]);
									// String tarjetacredito =
									// tarjetasCliente[2];
									BigDecimal idtipotarjeta = new BigDecimal(
											tarjetasCliente[3]);
									// String tipotarjeta = tarjetasCliente[4];
									String nrotarjeta = tarjetasCliente[5];
									String nrocontrol = tarjetasCliente[6];
									Timestamp fecha_emision = tarjetasCliente[7] != null
											&& !tarjetasCliente[7].equals("") ? new Timestamp(
											sdf.parse(
													tarjetasCliente[7]
															.replaceAll("-",
																	"/"))
													.getTime())
											: null;
									Timestamp fecha_vencimiento = new Timestamp(
											sdf.parse(
													tarjetasCliente[8]
															.replaceAll("-",
																	"/"))
													.getTime());
									String titular = tarjetasCliente[9];
									BigDecimal orden = new BigDecimal(
											tarjetasCliente[10]);
									String activa = tarjetasCliente[11];
									String statusItem = tarjetasCliente[12];

									if (statusItem.equalsIgnoreCase("B"))
										continue;

									salida = clienteTarjetasCreditoCreate(
											idtarjetacredito, idcliente,
											idtipotarjeta, nrotarjeta,
											nrocontrol, fecha_emision,
											fecha_vencimiento, titular, orden,
											activa, idempresa, usuarioalt,
											idprecarga);

									// verifico el numero y tipo de tarjeta'
									// if (salida.equalsIgnoreCase("OK")) {
									// salida =
									// getValidacionTarjetaDeCredito(idempresa,
									// nrotarjeta, idtipotarjeta);
									// }

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						}

					}

				}

			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesPrecargaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesPrecargaCreate(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
		}

		dbconn.setAutoCommit(true);

		return salida;
	} // actualizacion de un registro por PK NOTA: no se tiene en cuenta el //

	// primer
	// registro por PK y los datos de auditoria

	public String clientesPrecargaCreateOrUpdate(BigDecimal idcliente,
			String razon, BigDecimal idtipodocumento, BigDecimal nrodocumento,
			String brutos, BigDecimal idtipoiva, BigDecimal idcondicion,
			Double descuento1, Double descuento2, Double descuento3,
			BigDecimal idctaneto, BigDecimal idmoneda, BigDecimal idlista,
			BigDecimal idtipoclie, String observacion, Double lcredito,
			BigDecimal idtipocomp, String autorizado, BigDecimal idcredcate,
			Timestamp fechadeingreso, Timestamp fechadenacimiento, String sexo,
			BigDecimal referencia, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPrecargaclientes WHERE idcliente = "
					+ idcliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE clientesPrecargaclientes SET razon=?, idtipodocumento=?, nrodocumento=?, brutos=?, idtipoiva=?, idcondicion=?, descuento1=?, descuento2=?, descuento3=?, idctaneto=?, idmoneda=?, idlista=?, idtipoclie=?, observacion=?, lcredito=?, idtipocomp=?, autorizado=?, idcredcate=?,fechadeingreso=?,fechadenacimiento=?,sexo=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcliente=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setTimestamp(19, fechadeingreso);
					insert.setTimestamp(20, fechadenacimiento);
					insert.setString(21, sexo);
					insert.setBigDecimal(22, idempresa);
					insert.setString(23, usuarioact);
					insert.setTimestamp(24, fechaact);
					insert.setBigDecimal(25, idcliente);
				} else {
					String ins = "INSERT INTO clientesPrecargaclientes(razon, idtipodocumento, nrodocumento, brutos, idtipoiva, idvendedor, idcondicion, descuento1, descuento2, descuento3, idctaneto, idmoneda, idlista, idtipoclie, observacion, lcredito, idtipocomp, autorizado, idcredcate,fechadeingreso,fechadenacimiento,sexo, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,?,?,?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setTimestamp(19, fechadeingreso);
					insert.setTimestamp(20, fechadenacimiento);
					insert.setString(21, sexo);
					insert.setBigDecimal(22, idempresa);
					insert.setString(23, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesPrecargaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesPrecargaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesPrecargaUpdate(BigDecimal idprecarga, String razon,
			BigDecimal idtipodocumento, BigDecimal nrodocumento, String brutos,
			BigDecimal idtipoiva, BigDecimal idcondicion, Double descuento1,
			Double descuento2, Double descuento3, BigDecimal idctaneto,
			BigDecimal idmoneda, BigDecimal idlista, BigDecimal idtipoclie,
			String observacion, Double lcredito, BigDecimal idtipocomp,
			String autorizado, BigDecimal idcredcate, Hashtable htDomicilios,
			Hashtable htTarjetas, Timestamp fechadeingreso,
			Timestamp fechadenacimiento, String sexo, BigDecimal referencia,
			BigDecimal idempresa, String usuarioact, String nuevoreactivacion,
			BigDecimal porcentaje, BigDecimal idvendedorasignado,
			BigDecimal idestadoprecarga, BigDecimal condomicilio,
			BigDecimal idpreferencia, BigDecimal idorigen,
			BigDecimal idsuborigen, BigDecimal idpromocion,
			BigDecimal sucursalfactura) throws EJBException, SQLException {
		BigDecimal idcliente = null;
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		Enumeration en;
		dbconn.setAutoCommit(false);

		// validaciones de datos:
		// 1. nulidad de campos
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		if (sucursalfactura == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sucursalfactura ";

		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPrecargaclientes WHERE idprecarga = "
					+ idprecarga.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE clientesPrecargaclientes "
							+ "      SET razon=?, idtipodocumento=?, nrodocumento=?, brutos=?, idtipoiva=?, idcondicion=?, descuento1=?, descuento2=?, descuento3=?, "
							+ "             idctaneto=?, idmoneda=?, idlista=?, idtipoclie=?, observacion=?, lcredito=?, idtipocomp=?, autorizado=?, idcredcate=?,fechadeingreso=?,"
							+ "             fechadenacimiento=?,sexo=?,referencia=?, idempresa=?, usuarioact=?, fechaact=?, nuevoreactivacion =?, porcentaje =?,idvendedorasignado =?, "
							+ "            idestadoprecarga=?,idpreferencia=?, idorigen=?, idsuborigen=?, idpromocion=?, sucursalfactura=? WHERE idprecarga=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setTimestamp(19, fechadeingreso);
					insert.setTimestamp(20, fechadenacimiento);
					insert.setString(21, sexo);
					insert.setBigDecimal(22, referencia);
					insert.setBigDecimal(23, idempresa);
					insert.setString(24, usuarioact);
					insert.setTimestamp(25, fechaact);
					insert.setString(26, nuevoreactivacion);
					insert.setBigDecimal(27, porcentaje);
					insert.setBigDecimal(28, idvendedorasignado);
					insert.setBigDecimal(29, idestadoprecarga);
					insert.setBigDecimal(30, idpreferencia);
					insert.setBigDecimal(31, idorigen);
					insert.setBigDecimal(32, idsuborigen);
					insert.setBigDecimal(33, idpromocion);
					insert.setBigDecimal(34, sucursalfactura);
					insert.setBigDecimal(35, idprecarga);
				}

				int i = insert.executeUpdate();
				if (i == 1) {

					en = htDomicilios.keys();

					while (en.hasMoreElements()) {

						Object[] domicilios = (Object[]) htDomicilios.get(en
								.nextElement());
						BigDecimal iddomicilio = new BigDecimal(domicilios[0]
								.toString());
						BigDecimal idtipodomicilio = new BigDecimal(
								domicilios[1].toString());
						// String tipodomicilio = domicilios[2].toString();
						String esdefault = domicilios[3].toString();
						String calle = domicilios[4].toString();
						String nro = domicilios[5].toString();
						String piso = domicilios[6].toString();
						String depto = domicilios[7].toString();
						BigDecimal idlocalidad = new BigDecimal(domicilios[8]
								.toString());
						// String localidad = domicilios[9].toString();
						String cpa = domicilios[10].toString();
						String postal = domicilios[11].toString();
						String contacto = domicilios[12].toString();
						String cargocontacto = domicilios[13].toString();
						String telefonos = domicilios[14].toString();
						String celular = domicilios[15].toString();
						String fax = domicilios[16].toString();
						String web = domicilios[17].toString();
						BigDecimal idzona = new BigDecimal(domicilios[18]
								.toString());
						// String zona = domicilios[19].toString();
						BigDecimal idexpreso = new BigDecimal(domicilios[20]
								.toString());
						// String expreso = domicilios[21].toString();
						BigDecimal idcobrador = new BigDecimal(domicilios[22]
								.toString());
						// String cobrador = domicilios[23].toString();
						BigDecimal idvendedor = new BigDecimal(domicilios[24]
								.toString());
						// String cobrador = domicilios[25].toString();
						String[] email = (String[]) domicilios[26];
						String statusItem = domicilios[27].toString();
						BigDecimal idanexolocalidad = new BigDecimal(
								domicilios[28] != null ? domicilios[28]
										.toString() : "-1");
						String obsentrega = domicilios[29].toString();

						if (statusItem.equalsIgnoreCase("A")) {
							salida = clientesDomiciliosCreate(idcliente,
									idtipodomicilio, esdefault, calle, nro,
									piso, depto, idlocalidad, cpa, postal,
									contacto, cargocontacto, telefonos,
									celular, fax, web, idanexolocalidad,
									idcobrador, idvendedor, idempresa,
									usuarioact, idprecarga, obsentrega);

							if (salida.equalsIgnoreCase("OK")) {

								iddomicilio = GeneralBean.getValorSequencia(
										"seq_clientesdomiclilios", dbconn);

								for (int j = 0; email != null
										&& j < email.length; j++) {

									salida = clientesEmailCreate(iddomicilio,
											idcliente, idprecarga, email[j],
											idempresa, usuarioact);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						} else if (statusItem.equalsIgnoreCase("U")) {
							salida = clientesDomiciliosUpdate(iddomicilio,
									idcliente, idtipodomicilio, esdefault,
									calle, nro, piso, depto, idlocalidad, cpa,
									postal, contacto, cargocontacto, telefonos,
									celular, fax, web, idanexolocalidad,
									idcobrador, idvendedor, idempresa,
									usuarioact, idprecarga, obsentrega);

							if (salida.equalsIgnoreCase("OK")) {

								salida = clientesEmailXDomicilioDelete(
										iddomicilio, idempresa);

								for (int j = 0; salida.equalsIgnoreCase("OK")
										&& email != null && j < email.length; j++) {

									salida = clientesEmailCreate(iddomicilio,
											idcliente, idprecarga, email[j],
											idempresa, usuarioact);

								}

							}

						} else if (statusItem.equalsIgnoreCase("B")) {

							if (iddomicilio.longValue() > 0) {

								salida = clientesEmailXDomicilioDelete(
										idprecarga, idempresa);

								if (salida.equalsIgnoreCase("OK"))
									salida = clientesDomiciliosDelete(
											iddomicilio, idempresa);

							}
						}

					}

					if (salida.equalsIgnoreCase("OK")) {

						if (getTotalEntidadFiltro("clientesdomicilios",
								" WHERE idprecarga = " + idprecarga
										+ " AND esdefault = 'S' ", idempresa) < 1) {

							salida = "Es necesario marcar un domicilio de entrega como default.";

						}

						if (salida.equalsIgnoreCase("OK")) {

							if (htTarjetas != null && !htTarjetas.isEmpty()) {

								en = htTarjetas.keys();

								while (en.hasMoreElements()) {

									SimpleDateFormat sdf = new SimpleDateFormat(
											"dd/MM/yyyy");

									String[] tarjetasCliente = (String[]) htTarjetas
											.get(en.nextElement());
									BigDecimal idtarjeta = new BigDecimal(
											tarjetasCliente[0]);
									BigDecimal idtarjetacredito = new BigDecimal(
											tarjetasCliente[1]);
									// String tarjetacredito =
									// tarjetasCliente[2];
									BigDecimal idtipotarjeta = new BigDecimal(
											tarjetasCliente[3]);
									// String tipotarjeta = tarjetasCliente[4];
									String nrotarjeta = tarjetasCliente[5];
									String nrocontrol = tarjetasCliente[6];
									Timestamp fecha_emision = tarjetasCliente[7] != null
											&& !tarjetasCliente[7].equals("") ? new Timestamp(
											sdf.parse(
													tarjetasCliente[7]
															.replaceAll("-",
																	"/"))
													.getTime())
											: null;
									Timestamp fecha_vencimiento = new Timestamp(
											sdf.parse(
													tarjetasCliente[8]
															.replaceAll("-",
																	"/"))
													.getTime());
									String titular = tarjetasCliente[9];
									BigDecimal orden = new BigDecimal(
											tarjetasCliente[10]);
									String activa = tarjetasCliente[11];
									String statusItem = tarjetasCliente[12];

									// log.info("Tarjetas : " + idtarjeta);
									// log.info("statusItem: " + statusItem);

									if (statusItem.equalsIgnoreCase("A"))
										salida = clienteTarjetasCreditoCreate(
												idtarjetacredito, idcliente,
												idtipotarjeta, nrotarjeta,
												nrocontrol, fecha_emision,
												fecha_vencimiento, titular,
												orden, activa, idempresa,
												usuarioact, idprecarga);
									else if (statusItem.equalsIgnoreCase("U"))
										salida = clienteTarjetasCreditoUpdate(
												idtarjeta, idtarjetacredito,
												idcliente, idtipotarjeta,
												nrotarjeta, nrocontrol,
												fecha_emision,
												fecha_vencimiento, titular,
												orden, activa, idempresa,
												usuarioact, idprecarga);
									else if (statusItem.equalsIgnoreCase("B"))
										if (idtarjeta.longValue() > 0)
											salida = clienteTarjetasCreditoDelete(
													idtarjeta, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						}

					}

				} else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesPrecargaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesPrecargaUpdate(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	public String clientesEmailCreate(BigDecimal iddomicilio,
			BigDecimal idcliente, BigDecimal idprecarga, String email,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESEMAIL(iddomicilio, idcliente,idprecarga, email, idempresa, usuarioalt ) VALUES (?,?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, iddomicilio);
				insert.setBigDecimal(2, idcliente);
				insert.setBigDecimal(3, idprecarga);
				insert.setString(4, email);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar e-mail cliente.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesEmailCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesEmailCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteTarjetasCreditoCreate(BigDecimal idtarjetacredito,
			BigDecimal idcliente, BigDecimal idtipotarjeta, String nrotarjeta,
			String nrocontrol, Timestamp fecha_emision,
			Timestamp fecha_vencimiento, String titular, BigDecimal orden,
			String activa, BigDecimal idempresa, String usuarioalt,
			BigDecimal idprecarga) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (nrotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrotarjeta ";
		if (nrocontrol == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol ";
		// if (fecha_emision == null)salida = "Error: No se puede dejar sin
		// datos (nulo) el campo: fecha_emision ";
		if (fecha_vencimiento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento ";
		if (titular == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: titular ";
		if (orden == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: orden ";
		if (activa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activa ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (nrotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrotarjeta ";
		if (nrocontrol.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrocontrol ";
		if (titular.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: titular ";
		if (activa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activa ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTETARJETASCREDITO(idtarjetacredito, idcliente, idtipotarjeta, nrotarjeta, nrocontrol, fecha_emision, fecha_vencimiento, titular, orden, activa, idempresa, usuarioalt,idprecarga ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idtarjetacredito);
				insert.setBigDecimal(2, idcliente);
				insert.setBigDecimal(3, idtipotarjeta);
				insert.setString(4, nrotarjeta);
				insert.setString(5, nrocontrol);
				insert.setTimestamp(6, fecha_emision);
				insert.setTimestamp(7, fecha_vencimiento);
				insert.setString(8, titular);
				insert.setBigDecimal(9, orden);
				insert.setString(10, activa);
				insert.setBigDecimal(11, idempresa);
				insert.setString(12, usuarioalt);
				insert.setBigDecimal(13, idprecarga);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar tarjeta de credito.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible generar tarjeta.";
			log
					.error("Error SQL public String clienteTarjetasCreditoCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible generar tarjeta.";
			log
					.error("Error excepcion public String clienteTarjetasCreditoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosCreate(BigDecimal idcliente,
			BigDecimal idtipodomicilio, String esdefault, String calle,
			String nro, String piso, String depto, BigDecimal idlocalidad,
			String cpa, String postal, String contacto, String cargocontacto,
			String telefonos, String celular, String fax, String web,
			BigDecimal idanexolocalidad, BigDecimal idcobrador,
			BigDecimal idvendedor, BigDecimal idempresa, String usuarioalt,
			BigDecimal idprecarga, String obsentrega) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprecarga == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecarga ";
		if (esdefault == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: esdefault ";
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (esdefault.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: esdefault ";
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {

			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() == 1) {
				salida = clientesDomiciliosSetDefault(new BigDecimal(-1),
						idprecarga, idempresa, usuarioalt);
			}
			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() != 1) {
				salida = "No es posible marcar como default un domicilio que no es de entrega.";
			} else if (idtipodomicilio.intValue() == 2
					|| idtipodomicilio.intValue() == 3) {
				clientesDomiciliosSetTipoAlternativo(new BigDecimal(-1),
						idprecarga, idtipodomicilio, idempresa, usuarioalt);
			}

			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESDOMICILIOS(idcliente, idtipodomicilio, esdefault, calle, nro, piso, depto, idlocalidad, cpa, postal, contacto, cargocontacto, telefonos, celular, fax, web, idanexolocalidad, idcobrador, idvendedor, idempresa, usuarioalt,idprecarga, obsentrega ) "
						+ " VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idtipodomicilio);
				insert.setString(3, esdefault);
				insert.setString(4, calle);
				insert.setString(5, nro);
				insert.setString(6, piso);
				insert.setString(7, depto);
				insert.setBigDecimal(8, idlocalidad);
				insert.setString(9, cpa);
				insert.setString(10, postal);
				insert.setString(11, contacto);
				insert.setString(12, cargocontacto);
				insert.setString(13, telefonos);
				insert.setString(14, celular);
				insert.setString(15, fax);
				insert.setString(16, web);
				insert.setBigDecimal(17, GeneralBean.setNull(idanexolocalidad,
						1));
				// insert.setBigDecimal(18, GeneralBean.setNull(idexpreso, 1));
				insert.setBigDecimal(18, GeneralBean.setNull(idcobrador, 0));
				insert.setBigDecimal(19, GeneralBean.setNull(idvendedor, 1));
				insert.setBigDecimal(20, idempresa);
				insert.setString(21, usuarioalt);
				insert.setBigDecimal(22, idprecarga);
				insert.setString(23, obsentrega);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el domicilio.";
			log.error("Error SQL public String clientesDomiciliosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesEmailXDomicilioDelete(BigDecimal iddomicilio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "DELETE FROM CLIENTESEMAIL WHERE iddomicilio="
				+ iddomicilio.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el e-mails domicilio - cliente("
					+ iddomicilio + ").";
			log
					.error("Error SQL en el metodo : clientesEmailXDomicilioDelete( ..) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el e-mails cliente(" + iddomicilio
					+ ").";
			log
					.error("Salida por exception: en el metodo: clientesEmailXDomicilioDelete( .. )  "
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosUpdate(BigDecimal iddomicilio,
			BigDecimal idcliente, BigDecimal idtipodomicilio, String esdefault,
			String calle, String nro, String piso, String depto,
			BigDecimal idlocalidad, String cpa, String postal, String contacto,
			String cargocontacto, String telefonos, String celular, String fax,
			String web, BigDecimal idanexolocalidad, BigDecimal idcobrador,
			BigDecimal idvendedor, BigDecimal idempresa, String usuarioact,
			BigDecimal idprecarga, String obsentrega) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (esdefault == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: esdefault ";
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (esdefault.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: esdefault ";
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesDomicilios WHERE iddomicilio = "
					+ iddomicilio.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";

			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() == 1) {
				salida = clientesDomiciliosSetDefault(new BigDecimal(-1),
						idprecarga, idempresa, usuarioact);
			}
			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() != 1) {
				salida = "No es posible marcar como default un domicilio que no es de entrega.";
			} else if (idtipodomicilio.intValue() == 2
					|| idtipodomicilio.intValue() == 3) {
				clientesDomiciliosSetTipoAlternativo(iddomicilio, idprecarga,
						idtipodomicilio, idempresa, usuarioact);
			}

			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "    UPDATE CLIENTESDOMICILIOS "
							+ "   SET idtipodomicilio=?, esdefault=?, calle=?, nro=?, piso=?, depto=?, idlocalidad=?, cpa=?, postal=?, contacto=?, cargocontacto=?, telefonos=?, celular=?, fax=?, web=?, idanexolocalidad=?, idcobrador=?, idvendedor=?, obsentrega=?, idempresa=?, usuarioact=?, fechaact=?,idprecarga=? "
							+ " WHERE iddomicilio=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					// insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(1, idtipodomicilio);
					insert.setString(2, esdefault);
					insert.setString(3, calle);
					insert.setString(4, nro);
					insert.setString(5, piso);
					insert.setString(6, depto);
					insert.setBigDecimal(7, idlocalidad);
					insert.setString(8, cpa);
					insert.setString(9, postal);
					insert.setString(10, contacto);
					insert.setString(11, cargocontacto);
					insert.setString(12, telefonos);
					insert.setString(13, celular);
					insert.setString(14, fax);
					insert.setString(15, web);
					insert.setBigDecimal(16, GeneralBean.setNull(
							idanexolocalidad, 1));
					// insert.setBigDecimal(18, GeneralBean.setNull(idexpreso,
					// 1));
					insert
							.setBigDecimal(17, GeneralBean.setNull(idcobrador,
									0));
					insert
							.setBigDecimal(18, GeneralBean.setNull(idvendedor,
									1));
					insert.setString(19, obsentrega);
					insert.setBigDecimal(20, idempresa);
					insert.setString(21, usuarioact);
					insert.setTimestamp(22, fechaact);
					insert.setBigDecimal(23, idprecarga);
					insert.setBigDecimal(24, iddomicilio);
					insert.setBigDecimal(25, idempresa);
				}

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar domicilio.";
			log.error("Error SQL public String clientesDomiciliosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// 20090717 - EJV - REPLICADOS DE ClientesBean

	public String clientesDomiciliosSetDefault(BigDecimal iddomicilio,
			BigDecimal idprecarga, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idprecarga == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecarga ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "    UPDATE CLIENTESDOMICILIOS "
						+ "   SET esdefault=?, usuarioact=?, fechaact=?"
						+ " WHERE iddomicilio <> ? AND idprecarga =? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setString(1, "N");
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, iddomicilio);
				insert.setBigDecimal(5, idprecarga);
				insert.setBigDecimal(6, idempresa);

				int i = insert.executeUpdate();

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar domicilio default.";
			log
					.error("Error SQL public String clientesDomiciliosSetDefault(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar domicilio default.";
			log
					.error("Error excepcion public String clientesDomiciliosSetDefault(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosSetTipoAlternativo(BigDecimal iddomicilio,
			BigDecimal idprecarga, BigDecimal idtipodomicilio,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idprecarga == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecarga ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "    UPDATE CLIENTESDOMICILIOS "
						+ "   SET idtipodomicilio=?, usuarioact=?, fechaact=?"
						+ " WHERE iddomicilio <> ? AND idprecarga =? AND idtipodomicilio=? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setBigDecimal(1, new BigDecimal(4));
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, iddomicilio);
				insert.setBigDecimal(5, idprecarga);
				insert.setBigDecimal(6, idtipodomicilio);
				insert.setBigDecimal(7, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar tipos domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar tipos domicilio.";
			log
					.error("Error SQL public String clientesDomiciliosSetTipo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar tipos domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosSetTipo(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosDelete(BigDecimal iddomicilio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESDOMICILIOS WHERE iddomicilio="
				+ iddomicilio.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESDOMICILIOS WHERE iddomicilio="
						+ iddomicilio.toString() + " AND idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);

			} else {
				salida = "Error: Registro domicilio inesxistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Error SQL en el metodo : clientesDomiciliosDelete( BigDecimal iddomicilio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Salida por exception: en el metodo: clientesDomiciliosDelete( BigDecimal iddomicilio )  "
							+ ex);
		}
		return salida;
	}

	public String clienteTarjetasCreditoUpdate(BigDecimal idtarjeta,
			BigDecimal idtarjetacredito, BigDecimal idcliente,
			BigDecimal idtipotarjeta, String nrotarjeta, String nrocontrol,
			Timestamp fecha_emision, Timestamp fecha_vencimiento,
			String titular, BigDecimal orden, String activa,
			BigDecimal idempresa, String usuarioact, BigDecimal idprecarga)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjeta ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idprecarga == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecarga ";
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (nrotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrotarjeta ";
		if (nrocontrol == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol ";
		// if (fecha_emision == null)
		// salida = "Error: No se puede dejar sin datos (nulo) el campo:
		// fecha_emision ";
		if (fecha_vencimiento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento ";
		if (titular == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: titular ";
		if (orden == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: orden ";
		if (activa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activa ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nrotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrotarjeta ";
		if (nrocontrol.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrocontrol ";
		if (titular.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: titular ";
		if (activa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activa ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteTarjetasCredito WHERE idtarjeta = "
					+ idtarjeta.toString()
					+ " AND idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "    UPDATE CLIENTETARJETASCREDITO "
							+ "   SET idtarjetacredito=?, idcliente=?, idtipotarjeta=?, nrotarjeta=?, nrocontrol=?, fecha_emision=?, fecha_vencimiento=?, titular=?, orden=?, activa=?, idempresa=?, usuarioact=?, fechaact=?,idprecarga=? "
							+ " WHERE idtarjeta=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idtipotarjeta);
					insert.setString(4, nrotarjeta);
					insert.setString(5, nrocontrol);
					insert.setTimestamp(6, fecha_emision);
					insert.setTimestamp(7, fecha_vencimiento);
					insert.setString(8, titular);
					insert.setBigDecimal(9, orden);
					insert.setString(10, activa);
					insert.setBigDecimal(11, idempresa);
					insert.setString(12, usuarioact);
					insert.setTimestamp(13, fechaact);
					insert.setBigDecimal(14, idprecarga);
					insert.setBigDecimal(15, idtarjeta);
					insert.setBigDecimal(16, idempresa);
				}

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar tarjeta de credito ("
							+ idtarjeta + ").";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar tarjeta de credito (" + idtarjeta
					+ ").";
			log
					.error("Error SQL public String clienteTarjetasCreditoUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar tarjeta de credito (" + idtarjeta
					+ ").";
			log
					.error("Error excepcion public String clienteTarjetasCreditoUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteTarjetasCreditoDelete(BigDecimal idtarjeta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTETARJETASCREDITO WHERE idtarjeta="
				+ idtarjeta.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTETARJETASCREDITO WHERE idtarjeta="
						+ idtarjeta.toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				int i = statement.getUpdateCount();
				if (i > 1) {
					salida = "Instruccion delete (tarjetas de credito) devuelve mas de una fila.";
				} else if (i < 1) {
					salida = "Instruccion delete (tarjetas de credito) devuelve cero filas.";
				}

			} else {
				salida = "Error: Tarjeta credito inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar tarjeta credito.";
			log
					.error("Error SQL en el metodo : clienteTarjetasCreditoDelete( BigDecimal idtarjeta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteTarjetasCreditoDelete( BigDecimal idtarjeta )  "
							+ ex);
		}
		return salida;
	}

	public String clienteTarjetasCreditoXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();

			String cQuery = "DELETE FROM CLIENTETARJETASCREDITO WHERE idcliente="
					+ idcliente.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar tarjeta credito asociadas al cliente.";
			log
					.error("Error SQL en el metodo : clienteTarjetasCreditoDeleteAll( ... ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteTarjetasCreditoDeleteAll( ... )  "
							+ ex);
		}
		return salida;
	}

	public String clientesEmailXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "DELETE FROM CLIENTESEMAIL WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el e-mails domicilio - cliente("
					+ idcliente + ").";
			log
					.error("Error SQL en el metodo : clientesEmailXClienteDelete( ..) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el e-mails cliente(" + idcliente
					+ ").";
			log
					.error("Salida por exception: en el metodo: clientesEmailXClienteDelete( .. )  "
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "";
		String salida = "OK";
		try {

			Statement statement = dbconn.createStatement();

			cQuery = "DELETE FROM CLIENTESDOMICILIOS WHERE idcliente="
					+ idcliente.toString() + " AND idempresa = "
					+ idempresa.toString();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Error SQL en el metodo : clientesDomiciliosXClienteDelete( BigDecimal iddomicilio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Salida por exception: en el metodo: clientesDomiciliosXClienteDelete( BigDecimal iddomicilio )  "
							+ ex);
		}
		return salida;
	}

	public List getClientesEmailXCliente(BigDecimal idprecarga,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT idemail,iddomicilio,idcliente,email,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESEMAIL WHERE idprecarga="
				+ idprecarga.toString() + " AND idempresa = "
				+ idempresa.toString() + " ORDER BY iddomicilio;";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesEmailXCliente( BigDecimal idemail ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEmailXCliente( BigDecimal idemail )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClienteTarjetasCliente(long limit, long offset,
			BigDecimal idprecarga, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision::DATE,t.fecha_vencimiento::DATE,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesprecargaclientes cli ON  t.idprecarga = cli.idprecarga AND t.idempresa = cli.idempresa "
				+ " WHERE t.idprecarga = " + idprecarga.toString()
				+ " AND t.idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClienteTarjetasCliente() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesDomiciliosCliente(long limit, long offset,
			BigDecimal idprecarga, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		/*
		 * String cQuery = "" + "SELECT d.iddomicilio,d.idcliente,
		 * t.idtipodomicilio, t.tipodomicilio,
		 * d.esdefault,d.calle,d.nro,d.piso,d
		 * .depto,d.idlocalidad,l.localidad," + "
		 * d.cpa,d.postal,d.contacto,d.cargocontacto
		 * ,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona," + "
		 * e.idexpreso,e.expreso,d.idcobrador,c.cobrador,p.idprovincia,
		 * p.provincia, cl.idtipoiva, td.tipodocumento, cl.nrodocumento,
		 * cl.brutos," + "
		 * d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact
		 * ,cv.idvendedor,cv.vendedor " + " FROM clientesdomicilios d " + "
		 * INNER JOIN clientesprecargaclientes cl ON d.idprecarga =
		 * cl.idprecarga AND cl.idempresa = d.idempresa " + " INNER JOIN
		 * globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento
		 * and cl.idempresa = td.idempresa " + " INNER JOIN
		 * clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio
		 * AND d.idempresa = t.idempresa " + " INNER JOIN globallocalidades l ON
		 * d.idlocalidad = l.idlocalidad " + " INNER JOIN globalprovincias p ON
		 * l.idprovincia = p.idprovincia " + " LEFT JOIN clienteszonas z ON
		 * d.idzona = z.idzona AND d.idempresa = z.idempresa " + " LEFT JOIN
		 * clientesexpresoszonas ez ON z.idzona = ez.idzona AND z.idempresa =
		 * ez.idempresa " + " LEFT JOIN clientesexpresos e ON ez.idexpreso =
		 * e.idexpreso AND ez.idempresa = e.idempresa " + " LEFT JOIN
		 * clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa =
		 * c.idempresa " + " LEFT JOIN clientesvendedor cv ON d.idvendedor =
		 * cv.idvendedor AND d.idempresa = cv.idempresa " + " WHERE d.idprecarga
		 * = " + idprecarga.toString() + " AND d.idempresa = " +
		 * idempresa.toString() + " ORDER BY 2 LIMIT " + limit + " OFFSET
		 * " + offset + ";";
		 */

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,"
				+ "       d.idlocalidad,l.localidad, d.cpa,d.postal,d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,z.idzona,z.zona,"
				+ "       e.idexpreso,e.expreso,d.idcobrador,c.cobrador,p.idprovincia, p.provincia, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact,d.idvendedor, v.vendedor,"
				+ "       date_part('day',  now() - COALESCE(d.fechaact, d.fechaalt) ) as diasauditados, "
				+ "       p.idprovincia, p.provincia, xl.idanexolocalidad, d.obsentrega "
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN clientesprecargaclientes cl ON d.idprecarga = cl.idprecarga AND cl.idempresa = d.idempresa "
				+ "        INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
				+ "   LEFT JOIN clientesanexolocalidades xl ON d.idanexolocalidad = xl.idanexolocalidad AND d.idempresa = xl.idempresa"
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "

				+ "   LEFT JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "   LEFT JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "   LEFT JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "

				+ "        LEFT JOIN clientesvendedor v ON d.idvendedor = v.idvendedor "
				+ "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ " WHERE d.idprecarga = " + idprecarga.toString()
				+ "   AND d.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesDomiciliosCliente() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	// *****************************************************************************************************
	public String usuarioUpdate(BigDecimal idusuario, String usuario,
			String clave, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalusuarios WHERE idusuario = "
					+ idusuario.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE globalusuarios SET usuario=?, clave=?, usuarioact=?, fechaact=?  WHERE idusuario=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, usuario);
					insert.setString(2, encrypt(clave));
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idusuario);
					insert.setBigDecimal(6, idempresa);
				}
				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
				log.error("el query:" + sql);
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";

			log.error("Error SQL public String usuarioUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String usuarioUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public boolean isClaveAnterior(BigDecimal idusuario, String c,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String claveSQL = encrypt(c);
		boolean isExisteClave = false;
		String cQuery = "SELECT COUNT(*) FROM globalusuarios WHERE idusuario = "
				+ idusuario.toString()
				+ " and idempresa = "
				+ idempresa.toString()
				+ " and (LOWER(clave) = '"
				+ c.toLowerCase()
				+ "' or LOWER(clave)= '"
				+ claveSQL.toLowerCase() + "')";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				if (rsSalida.getInt(1) > 0)
					isExisteClave = true;
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : isClaveAnterior( ...  ) "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isClaveAnterior( ... )  "
							+ ex);
		}

		return isExisteClave;

	}

	public BigDecimal getMaximoClientePrecarga(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		BigDecimal idprecarga = BigDecimal.valueOf(0);
		ResultSet rsSalida = null;
		String cQuery = "SELECT COALESCE(MAX(idprecarga), 0) + 1 as idprecarga "
				+ " FROM clientesprecargaclientes WHERE idempresa = "
				+ idempresa.toString() + " and idprecarga <= 699999 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next()) {
				idprecarga = rsSalida.getBigDecimal("idprecarga");
			} else {
				log.warn("getMaximoCliente()- Error al recuperar idcliente: ");
			}
		} catch (SQLException sqlException) {
			log.error("getMaximoClientePrecarga()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getMaximoClientePrecarga()- Salida por exception: "
							+ ex);
		}
		return idprecarga;
	}

	// -- security
	public String encrypt(String plaintext) throws EJBException {
		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance("SHA"); // step 2
		} catch (NoSuchAlgorithmException ex) {
			log
					.error("encrypt(String plaintext) - Salida por exception: "
							+ ex);
		}
		try {
			md.update(plaintext.getBytes("UTF-8")); // step 3
		} catch (UnsupportedEncodingException ex) {
			log
					.error("encrypt(String plaintext) - Salida por exception: "
							+ ex);
		}

		byte raw[] = md.digest(); // step 4
		String hash = (new BASE64Encoder()).encode(raw); // step 5
		return hash; // step 6
	}

	// -- metodos para la evaluacion de formulas en pedidos a traves de canones
	// CEP 20/08/2008
	// no hacen falta como metodo publico
	// para ver su utilizacion en setMediciones4Inspeccion de
	// BUEEvalVerificacionBean

	private BigDecimal geCurCanon(BigDecimal idcliente) {
		BigDecimal salida = new BigDecimal("-1");
		try {
			ResultSet rsToken = null;

			String cQuery = "select idcanon, formula from pedidoscanones order by precedencia ";
			Statement statement = dbconn.createStatement();
			rsToken = statement.executeQuery(cQuery);
			while (rsToken != null && rsToken.next()) {
				String formula = rsToken.getString("formula");
				String resultadoFormula = evaluarCondicion(setFormula(formula,
						idcliente.toString()));
				if (resultadoFormula.equalsIgnoreCase("TRUE")) {
					salida = rsToken.getBigDecimal("idcanon");
					break;
				}
			}
		} catch (Exception ex) {
			log.error("geCurCanon() " + ex);
		}
		return salida;
	}

	private String evaluarCondicion(String condicion) {
		String salida = "nada";
		try {

			Interpreter i = new Interpreter();
			i.eval(condicion);
			salida = i.get("bar").toString();
		} catch (EvalError ex) {
			log
					.error("salida por excepcion  evaluarCondicion(String condicion: "
							+ condicion + "):" + ex);
		}
		return salida;
	}

	private String setFormula(String formulaCruda, String valorParametro) {
		/*
		 * Objetivo: recibir una formula en crudo y hacer los replaces
		 * necesarios Puntualmente para el caso de vtv se van a reemplazar los
		 * numeros de vehiculos Retorna : la formula en texto con todos sus
		 * metodos cambiados por los valores resultantes Despues de ejecutar
		 * este metodo hay que evaluar la formula con beanshell
		 */
		String outString = "";
		ResultSet rsToken = null;
		String cQuery = "Select metodo from tokenizer";
		BigDecimal vParametro = new BigDecimal(valorParametro);

		try {
			Statement statement = dbconn.createStatement();
			rsToken = statement.executeQuery(cQuery);
			String salida = formulaCruda;

			while (rsToken.next()) {
				String metodo = rsToken.getString(1).trim();
				int indice = formulaCruda.indexOf(metodo);
				if (indice >= 0) {

					// Valida que realmente el string encontrado sea el buscado
					// Ejemplo:
					// String buscado: MetodoAEjecutar
					// String leido: MetodoAEjecutarLeido /
					// OtroMetodoAEjecutarLeido
					// Resultado esperado: FALSE
					// Resultado Obtenido: TRUE
					int indiceFinMetodo = indice + metodo.length();
					if (indiceFinMetodo >= formulaCruda.length())
						formulaCruda += " ";
					if (!isCharValido(formulaCruda.charAt(indice
							+ metodo.length()))
							|| (indice > 0 && !isCharValido(formulaCruda
									.charAt(indice - 1)))) {

						log
								.warn("--------------------------------------------------------------------------------");
						log
								.warn("setFormula: Metodo "
										+ metodo
										+ " ilegal, condicion mal formada o nombre de metodo coincide con string en formula. ");
						log.warn("FORMULA: " + formulaCruda);

					} else {

						formulaCruda = formulaCruda.trim();

						String resultado = "";
						Pattern p = Pattern.compile(metodo);
						Matcher m = p.matcher(salida);
						try {
							Method met = this.getClass().getMethod(metodo,
									new Class[] { BigDecimal.class });
							resultado = (String) met.invoke(this,
									new Object[] { vParametro });

							outString = m.replaceAll(resultado);
							salida = outString;
						} catch (NoSuchMethodException e) {
							log.error("Error en el metodo. " + e);
						} catch (ClassCastException e) {
							log.error("Errror de casteo. " + e);
						}

					}
				}
			}
		} catch (Exception ex) {
			log
					.error("setFormula(String formulaCruda, String parametro, String valorParametro) "
							+ ex);
		}

		return outString;
	}

	private boolean isCharValido(char inChar) {
		boolean existeChar = false;
		try {

			char[] caracter = new char[] { ' ', '&', '|', '=', '<', '>', '(',
					')', '!', '?', ':' };
			for (int i = 0; i < caracter.length; i++)
				if (caracter[i] == inChar) {
					existeChar = true;
					break;
				}
		} catch (Exception e) {
			log.error("isCharValido(char inChar): " + e);
		}
		return existeChar;
	}

	public List getClientesPrecargaLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,coalesce(cl.idtipoclie,-1) as idtipoclie ,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,coalesce(cl.idtipocomp,-1) as idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"
				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ " and cl.idcliente is null "
				+ " and cl.nuevoreactivacion = 'N' "
				+ " and cl.idestadoprecarga = 1 " + "  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesPrecargaLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesPrecargaLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,coalesce(cl.idtipoclie,-1) as idtipoclie ,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,coalesce(cl.idtipocomp,-1) as idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa"
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"
				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ "  WHERE cl.idcliente is null "
				+ " and cl.nuevoreactivacion = 'N' "
				+ " and cl.idestadoprecarga = 1 "
				+ " and (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR cl.idprecarga::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR cl.nrodocumento::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND cl.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesPrecargaOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEntidadProspectoLov(String entidad) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " where idcliente is null " + " and nuevoreactivacion = 'N'"
				+ " and idestadoprecarga = 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadProspectoLov()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadProspectoLov()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadProspectoLov()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	public long getTotalEntidadProspectoLovOcu(String entidad, String[] campos,
			String ocurrencia) throws EJBException {

		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " WHERE idcliente is null " + " and nuevoreactivacion = 'N'"
				+ " and idestadoprecarga = 1 ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadProspectoLovOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadProspectoLovOcu()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadProspectoLovOcu()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// lov estado precarga
	public List getEstadoPrecargaLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestadoprecarga,estadoprecarga,usuarioalt,usuarioact,fechaalt,fechaact FROM clientesestadoprecarga "
				+ " where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getEstadoPrecargaLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadoPrecargaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getEstadoPrecargaLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestadoprecarga,estadoprecarga,usuarioalt,usuarioact,fechaalt,fechaact FROM clientesestadoprecarga "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idestadoprecarga::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estadoprecarga) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getEstadoPrecargaLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadoPrecargaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEstadoPrecargaAll(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  clientesestadoprecarga where idempresa = "
				+ idempresa.toString();
		;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEstadoPrecargaAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalglobalpuestosAll()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEstadoPrecargaAll()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// total
	public long getTotalEstadoPrecargaOcu(BigDecimal idempresa,
			String[] campos, String ocurrencia) throws EJBException {
		/**
		 * Entidad: GLOBALPUESTOS
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM clientesestadoprecarga WHERE idempresa = "
				+ idempresa + "";
		String like = "";
		int len = campos.length;
		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEstadoPrecargaOcu()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getTotalEstadoPrecargaOcu()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log.error("getTotalEstadoPrecargaOcu()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// consulta de precarga filtrando por fechaalt
	public List getClientesConsultaPrecargaAll(long limit, long offset,
			String fdesde, String fhasta, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,td.tipodocumento,cl.nrodocumento,cl.brutos,ti.tipoiva,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,gm.moneda,cli.descri_lis,ctc.tipoclie,"
				+ " cl.lcredito,cco.descri_tc,cl.autorizado,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,"
				+ " cl.nuevoreactivacion,cl.porcentaje,cv.vendedor,cep.estadoprecarga "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"
				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " left JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa"
				+ " left JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ " where cl.fechaalt between '" + fdesde.toString()
				+ "' and '" + fhasta.toString() + "' and cl.idempresa ="
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesConsultaPrecargaAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultaPrecargaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getMaximoCliente(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		BigDecimal idcliente = BigDecimal.valueOf(0);
		ResultSet rsSalida = null;
		String cQuery = "SELECT COALESCE(MAX(idcliente), 0) + 1 as idcliente "
				+ " FROM clientesclientes WHERE idcliente < 699999 and idempresa = "
				+ idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next()) {
				idcliente = rsSalida.getBigDecimal("idcliente");
			} else {
				log.warn("getMaximoCliente()- Error al recuperar idcliente: ");
			}
		} catch (SQLException sqlException) {
			log.error("getMaximoCliente()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getMaximoCliente()- Salida por exception: " + ex);
		}
		return idcliente;
	}

	public String UpdateClientesPrecarga(BigDecimal idprecarga,
			int ejercicioactivo, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		String salida = "OK";
		BigDecimal idtipoclie = new BigDecimal(-1);
		Connection conn = null;
		BigDecimal idcliente = new BigDecimal(-1);
		ResultSet rsSalida = null;

		try {

			log.info("INICIA ACTIVACION ...");

			conn = GeneralBean.getTransaccionConn(this.clase, this.url,
					this.usuario, this.clave);

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			idcliente = getMaximoCliente(idempresa);
			Statement statement = conn.createStatement();
			String control = "SELECT count(*) FROM clientesprecargaclientes WHERE idcliente IS NULL AND idestadoprecarga = 1 AND idempresa ="
					+ idempresa + " AND idprecarga = " + idprecarga;

			log.info("ACTIVACION ... P01: " + idcliente);
			rsSalida = statement.executeQuery(control);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			if (total == 0) {
				salida = "No es posible transformar precarga en cliente: verificar estado, si ya no se asigno nro. cliente o bien el registro fue eliminado. ";
			} else {
				PreparedStatement insert = null;
				String sql = "";
				sql = "UPDATE clientesprecargaclientes SET idcliente=? WHERE idprecarga=? and idempresa =?;";
				insert = conn.prepareStatement(sql);
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idprecarga);
				insert.setBigDecimal(3, idempresa);
				int i = insert.executeUpdate();

				if (i != 1) {
					salida = "No fue posible asignar idcliente a precarga.";
				}

			}

			if (salida.equalsIgnoreCase("OK")) {

				// 20110711 - EJV - Mantis 727 -->
				String cQuery = "SELECT idtipoclie FROM clientesprecargaclientes WHERE idprecarga = "
						+ idprecarga + " AND idempresa = " + idempresa;
				Iterator it = getLista(cQuery).iterator();

				if (it.hasNext()) {

					String[] datos = (String[]) it.next();

					// 20110907 - EJV - Mantis 777 -->
					if (datos[0] != null && Integer.parseInt(datos[0]) > 0) {
						// <--

						idtipoclie = new BigDecimal(datos[0]);
						int verificarEsKosher = verificarKosher(idtipoclie,
								idempresa);

						if (verificarEsKosher > -1) {

							salida = insertClientestclientes(idcliente,
									idprecarga, verificarEsKosher, idempresa,
									conn);

							if (salida.equalsIgnoreCase("OK")) {
								salida = updateClientestarjetas(idcliente,
										idprecarga, idempresa, conn);

								if (salida.equalsIgnoreCase("OK")) {
									salida = updateClientesmail(idcliente,
											idprecarga, idempresa, conn);

									if (salida.equalsIgnoreCase("OK")) {
										salida = updateClientesdomicilios(
												idcliente, idprecarga,
												idempresa, conn);

										if (salida.equalsIgnoreCase("OK")) {
											salida = ClientesInsertoEstadoInicial(
													idcliente, new BigDecimal(
															"1"),
													new BigDecimal("1"),
													"Alta del Socio",
													// 20111005 - EJV - Mantis
													// 740 -->
													// "Alta del Socio",
													usuarioalt,
													// <--
													idempresa, conn);
											if (salida.equalsIgnoreCase("OK")) {
												salida = ClientesInsertoCategoriaInicial(
														idcliente, idempresa,
														conn);

												// inserto la periodicidad del
												// cliente
												if (salida
														.equalsIgnoreCase("OK")) {
													salida = ClientesInsertoPeriodicidaddelSocio(
															idcliente,
															verificarEsKosher,
															idempresa, conn);

													// GENERAR MOVCLI PARA CI
													// -->
													// TODO: Usuario alta ...
													if (salida
															.equalsIgnoreCase("OK")) {

														log
																.info("ACTIVACION ... P02: "
																		+ idcliente);

														salida = clientesMovimientoClienteCreateCI(
																idcliente,
																ejercicioactivo,
																"A",
																usuarioalt,
																idempresa, conn);

													}
													// <--

												} else
													log
															.warn("No se pudo crear periodicidad en conversion de precarga ---> cliente.");

											} else
												log
														.warn("No se pudo crear categoria inicial en conversion de precarga ---> cliente.");

										} else
											log
													.warn("No se pudo asociar domicilios en conversion de precarga ---> cliente.");

									} else
										log
												.warn("No se pudo asociar emails en conversion de precarga ---> cliente.");

								} else
									log
											.warn("No se pudo asociar tarjetas en conversion de precarga ---> cliente. ");

							} else
								log
										.warn("No se pudo crear cliente en conversion de precarga ---> cliente.");

						} else {
							salida = "No fue posible validar club para tipo de cliente asignado.";
							log
									.warn("No se pudo validar club tipo cliente en conversion de precarga ---> cliente.");
						}

					} else {
						salida = "Precarga no tiene asigando un tipo de cliente valido.";
						log
								.warn("Tipo cliente nulo-invalido en conversion de precarga ---> cliente.");
					}

				} else {
					salida = "No se pudo recuperar tipo de cliente asignado.";
					log
							.warn("No se pudo recuperar tipo cliente en conversion de precarga ---> cliente.");
				}

			}

			// if (!error.equalsIgnoreCase("OK")) {
			// error = insertClientestclientes(idcliente, idprecarga,
			// idempresa);
			// }
			// if (!error.equalsIgnoreCase("OK")) {
			// error = updateClientestarjetas(idcliente, idprecarga, idempresa);
			// }
			// if (!error.equalsIgnoreCase("OK")) {
			// error = updateClientesmail(idcliente, idprecarga, idempresa);
			// }
			// if (!error.equalsIgnoreCase("OK")) {
			// error = updateClientesdomicilios(idcliente, idprecarga,
			// idempresa);
			// }
			// if (!error.equalsIgnoreCase("OK")) {
			// error = ClientesInsertoEstadoInicial(idcliente, new BigDecimal(
			// "1"), new BigDecimal("1"), "Alta del Socio",
			// "Alta del Socio", idempresa);
			// }
			//
			// if (!error.equalsIgnoreCase("OK")) {
			// error = ClientesInsertoCategoriaInicial(idcliente, idempresa);
			// }
			//
			// // inserto la periodicidad del cliente
			// if (!error.equalsIgnoreCase("OK")) {
			// error = ClientesInsertoPeriodicidaddelSocio(idcliente,
			// idempresa);
			// }
			//
			// if (error.equalsIgnoreCase("OK")) {
			// dbconn.rollback();
			// } else {
			// dbconn.commit();
			// salida = "Se Genero el Cliente Correctamente N� " + idcliente;
			// }

		} catch (Exception ex) {
			// error = "OK";
			salida = "(EX) Se disparo una excepcion al generar cliente.";
			log
					.error("Error excepcion public String UpdateClientesPrecarga(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			conn.rollback();
		} else {
			conn.commit();
			salida = "Se Genero el Cliente Correctamente Nro.: " + idcliente;
		}

		conn.close();

		return salida;

	}

	public int verificarKosher(BigDecimal idtipoclie, BigDecimal idempresa)
			throws EJBException {

		int verif = -1;
		Iterator it;

		String cQuery = ""
				+ "SELECT  COALESCE(cb.club, 'INDETERMINADO')  "
				+ "   FROM clientestipoclie tc "
				+ "             INNER JOIN clientesclub cb ON tc.idclub = cb.idclub AND tc.idempresa =  cb.idempresa "
				+ " WHERE tc.idtipoclie=" + idtipoclie.toString()
				+ "     AND tc.idempresa=" + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			it = getLista(cQuery).iterator();

			if (it.hasNext()) {

				String[] datos = (String[]) it.next();

				if (datos[0].trim().equalsIgnoreCase("KOSHER"))
					verif = 1;
				else
					verif = 0;

			}

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: verificarKosher( BigDecimal idtipoclie )  "
							+ ex);
		}

		return verif;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String insertClientestclientes(BigDecimal idcliente,
			BigDecimal idprecarga, int verificarEsKosher, BigDecimal idempresa,
			Connection conn) throws EJBException {
		String salida = "OK";
		Iterator it;
		// int verificarEsKosher = -1;
		// String error = "";
		// fin validaciones
		// boolean bError = true;
		try {

			// 20110711 - EJV - Mantis 727 -->
			// String cQuery =
			// "SELECT idtipoclie FROM clientesprecargaclientes WHERE idprecarga = "
			// + idprecarga + " AND idempresa = " + idempresa;
			// it = getLista(cQuery).iterator();
			//
			// if (it.hasNext()) {

			// String[] datos = (String[]) it.next();
			// BigDecimal idtipoclie = new BigDecimal(datos[0]);

			// verificarEsKosher = verificarKosher(idtipoclie, idempresa);

			if (verificarEsKosher > -1) {

				String ins = " "
						+ "INSERT INTO clientesclientes "
						+ "(  idcliente,razon,idtipodocumento,nrodocumento,brutos,idtipoiva,idcondicion,descuento1,descuento2,"
						+ "        descuento3,idctaneto,idmoneda,idlista,idtipoclie,observacion,lcredito,idtipocomp,autorizado,"
						+ "        idcredcate, idclientekosher, sucursalfactura, idempresa,usuarioalt "
						+ ")"

						+ "(SELECT ?,razon,idtipodocumento,nrodocumento,brutos,idtipoiva,idcondicion,descuento1,descuento2,"
						+ "        descuento3,idctaneto,idmoneda,idlista,idtipoclie,observacion,lcredito,idtipocomp,autorizado, idcredcate,"
						+ "        CASE WHEN "
						+ verificarEsKosher
						+ " = 1 THEN nextval('seq_idclientekosher'::regclass) ELSE null END, sucursalfactura, "
						+ "        idempresa,usuarioalt "
						+ "   FROM clientesprecargaclientes WHERE idprecarga = ? and idempresa = ?)";

				PreparedStatement insert = conn.prepareStatement(ins);
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idprecarga);
				insert.setBigDecimal(3, idempresa);

				int i = insert.executeUpdate();

				if (i != 1)
					salida = "1 -Inconsistencia al generar registro de cliente desde precarga [ "
							+ i + " ].";
			} else
				salida = "No fue posible verificar tipo de club.";

			// } else
			// salida =
			// "No fue posible recuperar tipo de cliente, para verificar club.";
			// seteo de campos:
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar registro de cliente.";
			// error = "OK";
			log.error("Error SQL public String insertClientestclientes(.....)"
					+ sqlException);
		} catch (Exception ex) {
			// error = "OK";
			salida = "(EX)Imposible generar registro de cliente.";
			log
					.error("Error excepcion public String insertClientestclientes(.....)"
							+ ex);
		}
		return salida;
	}

	public String updateClientestarjetas(BigDecimal idcliente,
			BigDecimal idprecarga, BigDecimal idempresa, Connection conn)
			throws EJBException, SQLException {
		// Calendar hoy = new GregorianCalendar();
		// Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// String error = "";
		// Enumeration en;
		// dbconn.setAutoCommit(false);
		// boolean bError = true;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT count(*) FROM clientetarjetascredito WHERE idcliente IS NULL  AND idempresa ="
					+ idempresa + " AND idprecarga = " + idprecarga;
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = -1;
			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getInt(1);

				if (total > 0) {

					PreparedStatement insert = null;
					String sql = "";
					sql = "UPDATE clientetarjetascredito SET idcliente=? WHERE idprecarga=? and idempresa =?;";
					insert = conn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idprecarga);
					insert.setBigDecimal(3, idempresa);
					int i = insert.executeUpdate();

					if (i < 1)
						salida = "Inconsistencia al asignar idcliente a las tarjetas de precarga.";

				}

			} else {
				salida = "No fue posible verificar existencia de tarjetas de credito.";
			}

		} catch (Exception ex) {
			// error = "OK";
			salida = "(EX)No fue posible asociar idcliente con tarjetas de precarga.";
			log
					.error("Error excepcion public String updateClientestarjetas(.....)"
							+ ex);
		}

		return salida;

	}

	public String updateClientesmail(BigDecimal idcliente,
			BigDecimal idprecarga, BigDecimal idempresa, Connection conn)
			throws EJBException, SQLException {
		Calendar hoy = new GregorianCalendar();
		// Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// String error = "";
		// Enumeration en;
		// dbconn.setAutoCommit(false);
		// boolean bError = true;
		try {
			ResultSet rsSalida = null;
			Statement statement = conn.createStatement();
			String cQuery = "SELECT count(*) FROM clientesemail WHERE idcliente IS NULL  AND idempresa ="
					+ idempresa + " AND idprecarga = " + idprecarga;
			rsSalida = statement.executeQuery(cQuery);

			int total = -1;
			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getInt(1);

				if (total > 0) {

					PreparedStatement insert = null;
					String sql = "";
					sql = "UPDATE clientesemail SET idcliente=? WHERE idprecarga=? and idempresa =?;";
					insert = conn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idprecarga);
					insert.setBigDecimal(3, idempresa);
					int i = insert.executeUpdate();
					if (i < 1)
						salida = "Inconsistencia al asignar idcliente a las cuentas de correo de precarga.";

				}

			} else {
				salida = "No fue posible verificar existencia de cuentas de correo.";
			}

		} catch (Exception ex) {
			// error = "OK";
			salida = "(EX)No fue posible asociar idcliente con cuentas de correo de precarga.";
			log.error("Error excepcion public String updateClientesmail(.....)"
					+ ex);
		}
		return salida;

	}

	public String updateClientesdomicilios(BigDecimal idcliente,
			BigDecimal idprecarga, BigDecimal idempresa, Connection conn)
			throws EJBException, SQLException {

		String salida = "OK";

		// Calendar hoy = new GregorianCalendar();
		// Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		// String error = "";
		// Enumeration en;
		// dbconn.setAutoCommit(false);
		// boolean bError = true;
		try {

			ResultSet rsSalida = null;
			Statement statement = conn.createStatement();
			String cQuery = "SELECT count(*) FROM clientesdomicilios WHERE idcliente IS NULL  AND idempresa ="
					+ idempresa + " AND idprecarga = " + idprecarga;
			rsSalida = statement.executeQuery(cQuery);

			int total = -1;
			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getInt(1);

				if (total > 0) {

					PreparedStatement insert = null;
					String sql = "";
					sql = "UPDATE clientesdomicilios SET idcliente=? WHERE idprecarga=? and idempresa =?;";
					insert = conn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idprecarga);
					insert.setBigDecimal(3, idempresa);
					int i = insert.executeUpdate();

					if (i < 1)
						salida = "Inconsistencia al asignar idcliente a los domicilios de precarga.";

				}

			} else {
				salida = "No fue posible verificar existencia de domicilios.";
			}

		} catch (Exception ex) {
			salida = "(EX)No fue posible asociar idcliente con domicilios de precarga.";
			log
					.error("Error excepcion public String updateClientesdomicilios(.....)"
							+ ex);
		}

		return salida;

	}

	public String ClientesInsertoEstadoInicial(BigDecimal idcliente,
			BigDecimal idestado, BigDecimal idmotivo, String observaciones,
			String usuarioalt, BigDecimal idempresa, Connection conn)
			throws EJBException {
		String salida = "OK";
		Calendar hoy = new GregorianCalendar();
		Timestamp fechadesde = new Timestamp(hoy.getTime().getTime());
		boolean bError = true;

		try {
			if (salida.equalsIgnoreCase("OK")) {

				String ins = "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idestado);
				insert.setBigDecimal(3, idmotivo);
				insert.setTimestamp(4, fechadesde);
				insert.setString(5, observaciones);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();

				if (n != 1)
					salida = "Inconsistencia al crear estado inicial para cliente.";

				log
						.info("actualizando estado inicial del cliente a: " + n
								+ "");
				// String graboTablaMaterial = setClientesEstadosHoyCliente(
				// idcliente, idempresa);

				if (salida.equalsIgnoreCase("OK"))
					salida = setClientesEstadosHoyCliente(idcliente, idempresa,
							conn);

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible crear estado inicial para cliente.";
			log
					.error("Error SQL public String clientesestadosclientesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible crear estado inicial para cliente.";
			log
					.error("Error excepcion public String clientesestadosclientesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes preferencias
	public List getClientespreferenciasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idpreferencia,preferencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM CLIENTESPREFERENCIAS "
				+ " WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientespreferenciasAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientespreferenciasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientespreferenciasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpreferencia,preferencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM CLIENTESPREFERENCIAS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idpreferencia::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(preferencia) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientespreferenciasOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientespreferenciasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientespreferenciasPK(BigDecimal idpreferencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpreferencia,preferencia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM CLIENTESPREFERENCIAS "
				+ " WHERE idpreferencia="
				+ idpreferencia.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientespreferenciasPK( BigDecimal idpreferencia ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientespreferenciasPK( BigDecimal idpreferencia )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientespreferenciasDelete(BigDecimal idpreferencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESPREFERENCIAS "
				+ " WHERE idpreferencia = " + idpreferencia.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESPREFERENCIAS "
						+ " WHERE idpreferencia = " + idpreferencia.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientespreferenciasDelete( BigDecimal idpreferencia ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientespreferenciasDelete( BigDecimal idpreferencia )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientespreferenciasCreate(String preferencia,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (preferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: preferencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (preferencia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: preferencia ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESPREFERENCIAS(preferencia, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, preferencia);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientespreferenciasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientespreferenciasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientespreferenciasCreateOrUpdate(BigDecimal idpreferencia,
			String preferencia, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpreferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreferencia ";
		if (preferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: preferencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (preferencia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: preferencia ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientespreferencias WHERE idpreferencia = "
					+ idpreferencia.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPREFERENCIAS SET preferencia=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpreferencia=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, preferencia);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idpreferencia);
				} else {
					String ins = "INSERT INTO CLIENTESPREFERENCIAS(preferencia, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, preferencia);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientespreferenciasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientespreferenciasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientespreferenciasUpdate(BigDecimal idpreferencia,
			String preferencia, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpreferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreferencia ";
		if (preferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: preferencia ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (preferencia.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: preferencia ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientespreferencias WHERE idpreferencia = "
					+ idpreferencia.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPREFERENCIAS SET preferencia=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpreferencia=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, preferencia);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idpreferencia);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientespreferenciasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientespreferenciasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// origen del prospecto
	public List getOrigenprospectoAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idorigen,origen,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM ORIGENPROSPECTO "
				+ " WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getOrigenprospectoAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getOrigenprospectoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getOrigenprospectoOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idorigen,origen,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM ORIGENPROSPECTO "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idorigen::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(origen) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getOrigenprospectoOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getOrigenprospectoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getOrigenprospectoPK(BigDecimal idorigen, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idorigen,origen,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM ORIGENPROSPECTO "
				+ " WHERE idorigen= "
				+ idorigen.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getOrigenprospectoPK( BigDecimal idorigen ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getOrigenprospectoPK( BigDecimal idorigen )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String origenprospectoDelete(BigDecimal idorigen,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM ORIGENPROSPECTO " + " WHERE idorigen = "
				+ idorigen.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM ORIGENPROSPECTO " + " WHERE idorigen = "
						+ idorigen.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : origenprospectoDelete( BigDecimal idorigen ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: origenprospectoDelete( BigDecimal idorigen )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String origenprospectoCreate(String origen, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (origen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: origen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (origen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: origen ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO ORIGENPROSPECTO(origen, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, origen);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String origenprospectoCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String origenprospectoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String origenprospectoCreateOrUpdate(BigDecimal idorigen,
			String origen, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idorigen ";
		if (origen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: origen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (origen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: origen ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM origenprospecto WHERE idorigen = "
					+ idorigen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE ORIGENPROSPECTO SET origen=?, idempresa=?, usuarioact=?, fechaact=? WHERE idorigen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, origen);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idorigen);
				} else {
					String ins = "INSERT INTO ORIGENPROSPECTO(origen, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, origen);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String origenprospectoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String origenprospectoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String origenprospectoUpdate(BigDecimal idorigen, String origen,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idorigen ";
		if (origen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: origen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (origen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: origen ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM origenprospecto WHERE idorigen = "
					+ idorigen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE ORIGENPROSPECTO SET origen=?, idempresa=?, usuarioact=?, fechaact=? WHERE idorigen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, origen);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idorigen);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String origenprospectoUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String origenprospectoUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getSuborigenprospectoAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT a.idsuborigen,a.suborigen,a.idorigen,b.origen,a.idempresa,a.usuarioalt,a.usuarioact,a.fechaalt,a.fechaact "
				+ " FROM SUBORIGENPROSPECTO a,"
				+ " ORIGENPROSPECTO b "
				+ " where b.idorigen = a.idorigen "
				+ " and a.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 3, 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getSuborigenprospectoAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSuborigenprospectoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSuborigenprospectoOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT a.idsuborigen,a.suborigen,a.idorigen,b.origen,a.idempresa,a.usuarioalt,a.usuarioact,a.fechaalt,a.fechaact "
				+ " FROM SUBORIGENPROSPECTO a,"
				+ " ORIGENPROSPECTO b "
				+ " where b.idorigen = a.idorigen "
				+ " and a.idempresa= "
				+ idempresa.toString()
				+ " and (a.idsuborigen::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(a.suborigen) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 3, 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getSuborigenprospectoOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSuborigenprospectoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSuborigenprospectoPK(BigDecimal idsuborigen,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT a.idsuborigen,a.suborigen,a.idorigen,b.origen,a.idempresa,a.usuarioalt,a.usuarioact,a.fechaalt,a.fechaact "
				+ " FROM SUBORIGENPROSPECTO a,"
				+ " ORIGENPROSPECTO b "
				+ " where b.idorigen = a.idorigen "
				+ " and a.idsuborigen = "
				+ idsuborigen.toString()
				+ " AND a.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getSuborigenprospectoPK( BigDecimal idsuborigen ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSuborigenprospectoPK( BigDecimal idsuborigen )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String suborigenprospectoDelete(BigDecimal idsuborigen,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SUBORIGENPROSPECTO "
				+ " WHERE idsuborigen=" + idsuborigen.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SUBORIGENPROSPECTO "
						+ " WHERE idsuborigen = " + idsuborigen.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : suborigenprospectoDelete( BigDecimal idsuborigen ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: suborigenprospectoDelete( BigDecimal idsuborigen )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String suborigenprospectoCreate(String suborigen,
			BigDecimal idorigen, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (suborigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: suborigen ";
		if (idorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idorigen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (suborigen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: suborigen ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO SUBORIGENPROSPECTO(suborigen, idorigen, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, suborigen);
				insert.setBigDecimal(2, idorigen);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String suborigenprospectoCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String suborigenprospectoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String suborigenprospectoCreateOrUpdate(BigDecimal idsuborigen,
			String suborigen, BigDecimal idorigen, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idsuborigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsuborigen ";
		if (suborigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: suborigen ";
		if (idorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idorigen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (suborigen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: suborigen ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM suborigenprospecto WHERE idsuborigen = "
					+ idsuborigen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SUBORIGENPROSPECTO SET suborigen=?, idorigen=?, idempresa=?, usuarioact=?, fechaact=? WHERE idsuborigen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, suborigen);
					insert.setBigDecimal(2, idorigen);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idsuborigen);
				} else {
					String ins = "INSERT INTO SUBORIGENPROSPECTO(suborigen, idorigen, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, suborigen);
					insert.setBigDecimal(2, idorigen);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String suborigenprospectoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String suborigenprospectoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String suborigenprospectoUpdate(BigDecimal idsuborigen,
			String suborigen, BigDecimal idorigen, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idsuborigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsuborigen ";
		if (suborigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: suborigen ";
		if (idorigen == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idorigen ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (suborigen.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: suborigen ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM suborigenprospecto WHERE idsuborigen = "
					+ idsuborigen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SUBORIGENPROSPECTO SET suborigen=?, idorigen=?, idempresa=?, usuarioact=?, fechaact=? WHERE idsuborigen=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, suborigen);
					insert.setBigDecimal(2, idorigen);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idsuborigen);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String suborigenprospectoUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String suborigenprospectoUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getOrigenLovAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idorigen,origen,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM origenprospecto"
				+ " where idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getOrigenLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getOrigenLovAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getOrigenLovOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idorigen,origen,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM origenprospecto "
				+ " where "
				+ " idempresa = "
				+ idempresa.toString()
				+ " and (idorigen::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(origen) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getOrigenLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getOrigenLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPreferenciaLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpreferencia,preferencia,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM clientespreferencias"
				+ " where idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getPreferenciaLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPreferenciaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPreferenciaLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idpreferencia,preferencia,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM clientespreferencias "
				+ " where "
				+ " idempresa = "
				+ idempresa.toString()
				+ " and (idpreferencia::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(preferencia) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getPreferenciaLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPreferenciaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// lov suborigen
	public List getSuborigenLovAll(long limit, long offset,
			BigDecimal idorigen, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idsuborigen,suborigen,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM suborigenprospecto"
				+ " where idempresa = "
				+ idempresa.toString()
				+ " and idorigen = "
				+ idorigen.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getSuborigenLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSuborigenLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSuborigenLovOcu(long limit, long offset, String ocurrencia,
			BigDecimal idorigen, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idsuborigen,suborigen,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM suborigenprospecto "
				+ " where "
				+ " idempresa = "
				+ idempresa.toString()
				+ " and idorigen = "
				+ idorigen.toString()
				+ " and (idsuborigen::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(suborigen) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getSuborigenLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSuborigenLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEntidadporempresayOrigen(String entidad,
			BigDecimal idorigen, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " WHERE idempresa=" + idempresa.toString()
				+ " and idorigen =" + idorigen.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadporempresayOrigen()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadporempresayOrigen()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadporempresayOrigen()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getTotalEntidadOcuporempresauOrigen(String entidad,
			String[] campos, String ocurrencia, BigDecimal idorigen,
			BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND idempresa = " + idempresa.toString()
					+ "and idorigen = " + idorigen.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadOcuporempresauOrigen()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcuporempresauOrigen()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadOcuporempresauOrigen()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public List getClientesPrecargaActivarAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,cl.idtipoclie,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,cl.idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,cep.estadoprecarga, "
				+ "             ccb.club, ccb.logo "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"
				+ "          left JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and ctc.idempresa = ccb.idempresa"
				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " left JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa"
				+ " left JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ " and cl.idcliente is null " + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaActivarAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesPrecargaActivarOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT cl.idprecarga,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva,cl.idcondicion,con.condicion,"
				+ " cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,gm.moneda,cl.idlista,cli.descri_lis,cl.idtipoclie,ctc.tipoclie,cl.observacion,"
				+ " cl.lcredito,cl.idtipocomp,cco.descri_tc,cl.autorizado,cl.idcredcate,ccc.credcate,cl.fechadeingreso,cl.fechadenacimiento,cl.sexo,cl.referencia,cl.idcliente,"
				+ " cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,cl.nuevoreactivacion,cl.porcentaje,cl.idvendedorasignado,cv.vendedor,cl.idestadoprecarga,cep.estadoprecarga, "
				+ "             ccb.club, ccb.logo  "
				+ " FROM clientesPrecargaclientes cl "
				+ " left JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ " left JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and cl.idempresa = ti.idempresa"
				+ " left JOIN clientescondicio con ON cl.idcondicion = con.idcondicion and cl.idempresa = con.idempresa"
				+ " left JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda "
				+ " left JOIN clienteslistas cli ON cl.idlista = cli.idlista and cl.idempresa = cli.idempresa"
				+ " left JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and cl.idempresa = ctc.idempresa"

				+ "          left JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and ctc.idempresa = ccb.idempresa"

				+ " left JOIN clientestipocomp cco ON cl.idtipocomp= cco.idtipocomp and cl.idempresa = cco.idempresa"
				+ " left JOIN clientescredcate ccc ON cl.idcredcate= ccc.idcredcate and cl.idempresa = ccc.idempresa"
				+ " left JOIN clientesvendedor cv ON cl.idvendedorasignado = cv.idvendedor and cl.idempresa = cv.idempresa"
				+ " left JOIN clientesestadoprecarga cep ON cl.idestadoprecarga = cep.idestadoprecarga and cl.idempresa = cep.idempresa"
				+ "  WHERE (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR cl.idprecarga::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR cl.nrodocumento::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND cl.idempresa = "
				+ idempresa.toString() + " and cl.idcliente is null "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesPrecargaActivarOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPrecargaActivarOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalActivarEntidad(String entidad) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " where idcliente is null";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalActivarEntidad()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalActivarEntidad()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalActivarEntidad()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalActivarOcu(String entidad, String[] campos,
			String ocurrencia) throws EJBException {

		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " WHERE idcliente is null and ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += like;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalActivarOcu()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalActivarOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalActivarOcu()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getControlNumeroDocumentoPrecargaCreate(BigDecimal idempresa,
			BigDecimal tipodoc, String numerodoc) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		String salida = "OK";
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM clientesprecargaclientes "
				+ " where idempresa = "
				+ idempresa.toString()
				+ " and idtipodocumento = "
				+ tipodoc.toString()
				+ " and nrodocumento = " + numerodoc.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
				if (total > 0) {
					salida = "Error: el numero de documento exite en la tabla clientesprecargaclientes";
				}
			} else {
				log
						.warn("getControlNumeroDocumentoPrecargaCreate()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getControlNumeroDocumentoPrecargaCreate()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getControlNumeroDocumentoPrecargaCreate()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getControlNumeroDocumentoClientesCreate(BigDecimal idempresa,
			BigDecimal tipodoc, String numerodoc) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		String salida = "OK";
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM clientesclientes "
				+ " where idempresa = " + idempresa.toString()
				+ " and idtipodocumento = " + tipodoc.toString()
				+ " and nrodocumento = " + numerodoc.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
				if (total > 0) {
					salida = "Error: el numero de documento exite en la tabla clientesprecargaclientes";
				}
			} else {
				log
						.warn("getControlNumeroDocumentoClientesCreate()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getControlNumeroDocumentoClientesCreate()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getControlNumeroDocumentoClientesCreate()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public List getClientesConsultadePrecarga(String fdesde, String fhasta,
			BigDecimal idtipoclie, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " pre.idvendedorasignado,"
				+ " ven.vendedor,"
				+ " count(idvendedorasignado) as total"
				+ " from "
				+ " clientesprecargaclientes pre "
				+ " join clientesvendedor ven on( pre.idvendedorasignado = ven.idvendedor and pre.idempresa = ven.idempresa) "
				+ " where "
				+ " pre.fechadeingreso::date  between '"
				+ fdesde.toString()
				+ "'"
				+ " and '"
				+ fhasta.toString()
				+ "' and pre.idempresa ="
				+ idempresa.toString()
				+ (idtipoclie != null && idtipoclie.intValue() > 0 ? " AND pre.idtipoclie =  "
						+ idtipoclie
						: " ") + " group by " + " pre.idvendedorasignado,"
				+ " ven.vendedor " + " ORDER BY 3 desc ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultadePrecarga()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesConsultadePrecargaXFechaingreso(String fdesde,
			String fhasta, BigDecimal idtipoclie, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " cpc.idprecarga,"
				+ " cpc.nuevoreactivacion,"
				+ " cpc.razon,"
				+ " cpc.fechadenacimiento,"
				+ " gtd.tipodocumento,"
				+ " cpc.nrodocumento,"
				+ " cpc.fechadeingreso,"
				// + " ctm.tarjetacredito,"
				// + " ctc.nrotarjeta,"
				+ " cv.vendedor,"
				+ " cpc.idcliente,"
				+ " op.origen,"
				+ " sop.suborigen,"
				// + " gl.localidad,"
				// + " gp.provincia,"
				+ " cti.tipoiva,"
				+ " cep.estadoprecarga,"
				// + " ce.email,"
				+ " cpc.fechaalt, "
				// 20110711 - EJV - Mantis 727 -->
				+ "       ccb.idclub, ccb.club, ccb.logo, "
				// <--
				// 20110912 - EJV - Mantis 789 -->
				+ "      pro.idpromocion, pro.promocion, cpc.sucursalfactura,  "
				// <--
				// 20111007 - EJV - Mantis 795 -->
				+ "       prf.idpreferencia, prf.preferencia, lis.idlista, lis.descri_lis, ifp.idcuenta, "
				+ "       ifp.cuenta, COALESCE(ifp.activo, 'N') activo, con.idcondicion, con.condicion,   "
				+ "       fu_periodicidad(cpc.idcliente, cpc.idempresa) periodicidad"
				// <--

				+ " from "
				+ " clientesprecargaclientes cpc"
				+ " LEFT JOIN globaltiposdocumentos gtd ON cpc.idtipodocumento = gtd.idtipodocumento and cpc.idempresa = gtd.idempresa "
				// + " LEFT JOIN clientetarjetascredito ctc ON cpc.idprecarga =
				// ctc.idprecarga and cpc.idempresa = ctc.idempresa "
				// + " LEFT JOIN clientetarjetascreditomarcas ctm ON
				// ctc.idtarjetacredito = ctm.idtarjetacredito and ctc.idempresa
				// = ctm.idempresa "
				+ " LEFT JOIN clientesvendedor cv ON cpc.idvendedorasignado = cv.idvendedor and cpc.idempresa = cv.idempresa  "
				+ " LEFT JOIN origenprospecto op ON cpc.idorigen = op.idorigen and cpc.idempresa = op.idempresa "
				+ " LEFT JOIN suborigenprospecto sop ON cpc.idsuborigen = sop.idsuborigen and cpc.idempresa = sop.idempresa "
				// + " LEFT JOIN clientesdomicilios cd ON cpc.idprecarga =
				// cd.idprecarga and cpc.idempresa = cd.idempresa "
				// + " LEFT JOIN globallocalidades gl ON cd.idlocalidad =
				// gl.idlocalidad "
				// + " LEFT JOIN globalprovincias gp ON gl.idprovincia =
				// gp.idprovincia "
				+ " LEFT JOIN clientestablaiva cti ON cpc.idtipoiva = cti.idtipoiva and cpc.idempresa = cti.idempresa "
				+ " LEFT JOIN clientesestadoprecarga cep ON cpc.idestadoprecarga = cep.idestadoprecarga and cpc.idempresa = cep.idempresa "
				// + " LEFT JOIN clientesemail ce ON cpc.idprecarga =
				// ce.idprecarga and cpc.idempresa = ce.idempresa "

				// 20110711 - EJV - Mantis 727 -->
				+ "       LEFT JOIN clientestipoclie ctc ON cpc.idtipoclie = ctc.idtipoclie and  cpc.idempresa = ctc.idempresa "
				+ "       LEFT JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and  ctc.idempresa = ccb.idempresa "
				// <--
				// 20110912 - EJV - Mantis 789 -->
				+ "       LEFT JOIN clientespromociones pro ON cpc.idpromocion = pro.idpromocion and  cpc.idempresa = pro.idempresa "
				// <--
				// 20111007 - EJV - Mantis 795 -->
				+ "       LEFT JOIN clientespreferencias prf ON cpc.idpreferencia = prf.idpreferencia and  cpc.idempresa = prf.idempresa "
				+ "       LEFT JOIN clienteslistas lis ON cpc.idlista = lis.idlista and  cpc.idempresa = lis.idempresa    "
				+ "       LEFT JOIN clientescondicio con ON cpc.idcondicion = con.idcondicion AND cpc.idempresa = con.idempresa    "
				+ "       LEFT JOIN ( "
				+ "                         SELECT cu.idcuenta, cu.cuenta, ej.activo, cu.idempresa "
				+ "                           FROM  contableinfiplan cu  "
				+ "                                     INNER JOIN contableejercicios ej ON cu.ejercicio = ej.ejercicio "
				+ "                                               AND cu.idempresa = ej.idempresa AND ej.activo= 'S' "
				+ "                       ) ifp  ON cpc.idctaneto = ifp.idcuenta AND ctc.idempresa = ifp.idempresa    "
				// <--
				+ " where "
				+ " cpc.fechadeingreso::date  between '"
				+ fdesde.toString()
				+ "'"
				+ " and '"
				+ fhasta.toString()
				+ "' and cpc.idempresa ="
				+ idempresa.toString()
				+ (idtipoclie != null && idtipoclie.intValue() > 0 ? " AND cpc.idtipoclie =  "
						+ idtipoclie
						: " ") + " ORDER BY 1 ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultadePrecargaXFechaingreso()  "
							+ ex);
		}
		return vecSalida;
	}

	public String ClientesInsertoCategoriaInicial(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) throws EJBException {
		String salida = "OK";
		// String error = "";
		Calendar hoy = new GregorianCalendar();
		// Timestamp fechadesde = new Timestamp(hoy.getTime().getTime());

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO bacotmcategorizaciones(idcliente, idcategoria,idempresa,usuarioalt ) VALUES (?,?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, new BigDecimal(4));
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, "Categoria Inicial");
				int n = insert.executeUpdate();

				if (n != 1)
					salida = "1 - No fue posible generar registro de categorizacion de cliente.";

			}

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar categorizacion de cliente.";
			log
					.error("Error SQL public String clientesestadosclientesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar categorizacion de cliente.";
			log
					.error("Error excepcion public String clientesestadosclientesCreate(.....)"
							+ ex);
		}

		return salida;
	}

	public String getValidacionTarjetaDeCredito(BigDecimal idempresa,
			String nrotarjeta, BigDecimal idmarcatarjeta) throws EJBException {

		String salida = "";
		long longitudTarjetaMarca = 0;
		long longitudTarjeta = 0;
		ResultSet rsSalida = null;

		// String cQuery = "select trim(length(replace(formato,' ',''))) as
		// total from clientetarjetascreditomarcas "
		// + " where idempresa = "
		// + idempresa.toString()
		// + " and idtarjetacredito = " + idmarcatarjeta.toString();

		String cQuery = ""
				+ "SELECT LENGTH(TRIM(REPLACE(formato,' ',''))) AS total "
				+ "  FROM clientetarjetascreditomarcas "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "   AND idtarjetacredito = " + idmarcatarjeta.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				longitudTarjetaMarca = rsSalida.getLong("total");
			}
			longitudTarjeta = nrotarjeta.length();
			if (longitudTarjeta != longitudTarjetaMarca)
				salida = "La longitud de la tarjeta es incorrecta";

		} catch (SQLException sqlException) {
			log.error("getValidacionTarjetaDeCredito()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getValidacionTarjetaDeCredito()- Salida por exception: "
					+ ex);
		}
		return salida;
	}

	public String getValidacionTarjetaDeCreditoExistenciaaAlta(
			BigDecimal idempresa, String nrotarjeta, BigDecimal idmarcatarjeta)
			throws EJBException {

		String salida = "";
		long total = 0;
		ResultSet rsSalida = null;

		String cQuery = ""
				+ "SELECT COUNT(1) AS total FROM clientetarjetascredito "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "   AND idtarjetacredito = " + idmarcatarjeta.toString()
				+ "   AND nrotarjeta = '" + nrotarjeta.toString() + "'";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			}
			if (total != 0)
				salida = "La tarjeta ya existe!";
		} catch (SQLException sqlException) {
			log
					.error("getValidacionTarjetaDeCreditoExistenciaaAlta()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getValidacionTarjetaDeCreditoExistenciaaAlta()- Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String getValidacionTarjetaDeCreditoExistenciaaModificacion(
			BigDecimal idempresa, String nrotarjeta, BigDecimal idmarcatarjeta,
			BigDecimal idtarjeta) throws EJBException {

		String salida = "";
		long total = 0;
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT COUNT(1) AS total FROM clientetarjetascredito "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "   AND idtarjetacredito = " + idmarcatarjeta.toString()
				+ "   AND nrotarjeta = '" + nrotarjeta.toString() + "'"
				+ "   AND idtarjeta <> " + idtarjeta.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			}
			if (total != 0)
				salida = "La tarjeta ya existe!";
		} catch (SQLException sqlException) {
			log
					.error("getValidacionTarjetaDeCreditoExistenciaaModificacion()- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getValidacionTarjetaDeCreditoExistenciaaModificacion()- Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String validarTarjetaDeCredito(String nrotarjeta) {
		String salida = "NOOK";
		String letra = "";
		String tar = "";
		int i = 0;
		try {
			while (i < nrotarjeta.length()) {
				letra = nrotarjeta.substring(i, ++i);
				if (i % 2 == 0)
					tar += letra;
				else {
					int num = Integer.parseInt(letra);
					num = num * 2;
					if (num < 9) {
						tar += num;
					} else {
						num = num - 9;
						tar += num;
					}
				}
			}
			// -- fin de descomposicion del numero
			// -- ahora viene la suma algebraica.
			i = 0;
			int total = 0;
			while (i < tar.length()) {
				letra = tar.substring(i, ++i);
				int num = Integer.parseInt(letra);
				total += num;
			}
			// fin de suma algebraica.
			if (total < 150 && total % 10 == 0)
				salida = "";

		} catch (Exception ex) {
			System.out.println("Error validarTarjetaDeCredito " + ex);

		}

		return salida;
	}

	public String getClienteTarjeta(BigDecimal idempresa, String nrotarjeta,
			BigDecimal idmarcatarjeta) throws EJBException {
		String salida = "";
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT (cl.idcliente || '-' || cl.razon || ' - (CLIENTE)')::VARCHAR  AS cliente "
				+ "  FROM clientetarjetascredito tc  "
				+ "       INNER JOIN clientesclientes cl ON tc.idcliente = cl.idcliente AND tc.idempresa = cl.idempresa "
				+ " WHERE tc.idempresa = "
				+ idempresa.toString()
				+ "   AND tc.idtarjetacredito = "
				+ idmarcatarjeta.toString()
				+ "   AND tc.nrotarjeta = '"
				+ nrotarjeta.toString()
				+ "'"
				+ "UNION "
				+ "SELECT (pc.idprecarga || '-' || pc.razon || ' - (PROSPECTO)')::VARCHAR  AS cliente "
				+ "  FROM clientetarjetascredito tc  "
				+ "       INNER JOIN clientesprecargaclientes pc ON tc.idprecarga = pc.idprecarga AND tc.idempresa = pc.idempresa "
				+ " WHERE tc.idempresa = " + idempresa.toString()
				+ "   AND tc.idtarjetacredito = " + idmarcatarjeta.toString()
				+ "   AND tc.nrotarjeta = '" + nrotarjeta.toString() + "'";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next()) {
				salida = rsSalida.getString("cliente");
			} else
				salida = "CLIENTE DESCONOCIDO, error al recuperarlo.";

		} catch (SQLException sqlException) {
			log.error("getClienteTarjeta()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getClienteTarjeta()- Salida por exception: " + ex);
		}
		return salida;
	}

	public List Clientesesstadosbajasuspensionlarga(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO',cv.vendedor) as vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where "
				+ " vceh.idempresa = "
				+ idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones is null "
				+ " ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : Clientesesstadosbajasuspensionlarga() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: Clientesesstadosbajasuspensionlarga()  "
							+ ex);
		}
		return vecSalida;
	}

	public String EstadoActualUpdate(String[] idcliente, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechabaja = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			Statement statement = dbconn.createStatement();
			int total = 0;
			PreparedStatement insert = null;
			String sql = "";
			// sql =
			// "UPDATE clientesreactivaciones set fechabaja=? WHERE idcliente=? and idempresa =? and fechabaja is null and idreactivacion <> (select max(idreactivacion) from clientesreactivaciones )";
			sql = "UPDATE clientesreactivaciones set fechabaja=? WHERE idcliente=? and idempresa =? and fechabaja is null and idreactivacion <> (select max(idreactivacion) from clientesreactivaciones )";
			insert = dbconn.prepareStatement(sql);
			for (int j = 0; j < idcliente.length; j++) {
				insert.setTimestamp(1, fechabaja);
				insert.setBigDecimal(2, new BigDecimal(idcliente[j]));
				insert.setBigDecimal(3, idempresa);
				int i = insert.executeUpdate();
			}
			// if (i > 0)
			salida = "OK";
			// else
			// salida = "";
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String EstadoActualUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String EstadoActualUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	public String EstadoActualInsert(String[] idcliente, BigDecimal idestado,
			BigDecimal idmotivo, String observaciones, int ejercicio,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {
		String salida = "OK";
		Calendar hoy = new GregorianCalendar();
		Timestamp fechadesde = new Timestamp(hoy.getTime().getTime());
		boolean bError = true;
		int rows = 0;
		// 20110912 - EJV - Mantis 789 -->
		Connection conn = getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		if (conn == null) {
			salida = "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";
			log.error(salida);
			return salida;
		}
		// <--
		try {

			conn.setAutoCommit(false);

			String ins = "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
			PreparedStatement insert = conn.prepareStatement(ins);
			Statement upd = conn.createStatement();

			// seteo de campos:
			for (int j = 0; j < idcliente.length; j++) {

				// 20110912 - EJV - Mantis 789 -->
				String queryPromo = "";
				queryPromo = ""
						+ "UPDATE clientesprecargaclientes  "
						+ "     SET idpromocion = veh.idpromocion "
						+ "  FROM ( "
						+ "	SELECT COALESCE(cr.idpromocion, -1) idpromocion, eh.idcliente, eh.idempresa "
						+ "	  FROM clientesestadoshoy eh  "
						+ "	            INNER JOIN clientesreactivaciones cr on eh.idcliente = cr.idcliente AND eh.idempresa= cr.idempresa "
						+ "   WHERE eh.idestado in (2,5)  "
						+ "	    AND cr.idestadoreactivaciones = 1 "
						+ "  ) veh "
						+ " WHERE clientesprecargaclientes.idcliente = veh.idcliente "
						+ "     AND clientesprecargaclientes.idempresa = veh.idempresa "
						+ "     AND clientesprecargaclientes.idcliente =    "
						+ idcliente[j]
						+ "     AND clientesprecargaclientes.idempresa =   "
						+ idempresa;

				upd.executeUpdate(queryPromo);
				// <--

				insert.setBigDecimal(1, new BigDecimal(idcliente[j]));
				insert.setBigDecimal(2, new BigDecimal(1));
				insert.setBigDecimal(3, new BigDecimal(50));
				insert.setTimestamp(4, fechadesde);
				insert.setString(5, observaciones);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				String qDML = "DELETE FROM CLIENTESESTADOSHOY WHERE idcliente=? AND idempresa=?";
				PreparedStatement pstatement = conn.prepareStatement(qDML);
				pstatement = conn.prepareStatement(qDML);
				// seteo de campos:
				pstatement.setBigDecimal(1, new BigDecimal(idcliente[j]));
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();

				qDML = ""
						+ "INSERT INTO clientesestadoshoy "
						+ "       (idestadocliente,idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioalt, fechaalt, fechaact ) "
						+ "SELECT idestadocliente, idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioact, fechaalt, fechaact "
						+ "  FROM vclientesestadoshoy_snapshot WHERE idcliente = ? AND idempresa = ?;";
				pstatement = conn.prepareStatement(qDML);
				pstatement.setBigDecimal(1, new BigDecimal(idcliente[j]));
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();
				// String grabo = setClientesEstadosHoyCliente(new
				// BigDecimal(idcliente),idempresa);

				// 20110912 - EJV - Mantis 789 -->
				//

				salida = clientesMovimientoClienteCreateCI(new BigDecimal(
						idcliente[j]), ejercicio, "R", usuarioalt, idempresa,
						conn);

				// <--

			}

		} catch (SQLException sqlException) {
			salida = "(SQL)No fue posible modificar estados del cliente.";
			log.error("Error SQL public String EstadoActualInsert(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible modificar estados del cliente.";
			log.error("Error excepcion public String EstadoActualInsert(.....)"
					+ ex);
		}

		if (salida.equalsIgnoreCase("OK")) {
			conn.commit();
		} else {
			conn.rollback();
		}

		conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	public long getTotalEntidadporempresaEstado(BigDecimal idempresa)
			throws EJBException {
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones is null ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadporempresaEstado()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadporempresaEstado()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadporempresaEstado()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getTotalEntidadOcuporempresaEstado(String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones is null " + " and ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND vceh.idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadOcuporempresaEstado()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcuporempresaEstado()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadOcuporempresaEstado()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public List ClientesesstadosbajasuspensionlargaOcu(long limit, long offset,
			BigDecimal idempresa, String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO',cv.vendedor) as vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where " + " vceh.idempresa = "
				+ idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones is null "
				+ " and (vceh.idcliente::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(vceh.razon) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.motivo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(cv.vendedor) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " group by vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,cv.vendedor "
				+ "ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : Clientesesstadosbajasuspensionlarga() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: Clientesesstadosbajasuspensionlarga()  "
							+ ex);
		}
		return vecSalida;
	}

	public String EstadoActualinserto(BigDecimal idcliente,
			BigDecimal porcreact, String usuarioalt, BigDecimal idempresa,
			Timestamp fechareactivacion, BigDecimal idvendedor,
			BigDecimal idestadoreactivaciones, BigDecimal idpromocion)
			throws EJBException {
		String salida = "NOOK";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;

		try {
			if (!bError) {
				String ins = "INSERT INTO clientesreactivaciones(idcliente,porcreact,usuarioalt,idempresa,fechareactivacion,idvendedor,idestadoreactivaciones, idpromocion) VALUES (?,?,?,?,?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, porcreact);
				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);
				insert.setTimestamp(5, fechareactivacion);
				insert.setBigDecimal(6, idvendedor);
				insert.setBigDecimal(7, new BigDecimal(1));
				insert.setBigDecimal(8, idpromocion);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "OK";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String globalcontadoresCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalcontadoresCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String DescripcionClientexNumero(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String total = "";
		String cQuery = "SELECT razon as razon FROM clientesclientes "
				+ " WHERE idcliente = " + idcliente.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = rsSalida.getString("razon");
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : globalcontadoresDelete( BigDecimal idcontador ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: globalcontadoresDelete( BigDecimal idcontador )  "
							+ ex);
		}
		return salida;
	}

	public List getClientesConsultaReactEntreFechas(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " re.idcliente,"
				+ " cl.razon,"
				+ " re.porcreact,"
				+ " ve.vendedor,"
				+ " re.fechabaja,"
				+ " re.fechareactivacion,"
				// <--
				// 20110912 - EJV - Mantis 789 -->
				+ "      pmc.idpromocion, pmc.promocion, pr.sucursalfactura,  "
				// <--
				// 20111007 - EJV - Mantis 796 -->
				+ "       prf.idpreferencia, prf.preferencia, lis.idlista, lis.descri_lis, ifp.idcuenta, "
				+ "       ifp.cuenta, COALESCE(ifp.activo, 'N') activo, con.idcondicion, con.condicion,   "
				+ "       cti.idtipoiva, cti.tipoiva, "
				+ "       fu_periodicidad(cl.idcliente, cl.idempresa) periodicidad"
				// <--
				+ " from "
				+ " clientesreactivaciones re"
				+ " join clientesclientes cl on (re.idcliente = cl.idcliente and cl.idempresa = re.idempresa ) "
				+ " join clientesprecargaclientes pr on (cl.idcliente = pr.idcliente  and cl.idempresa = pr.idempresa) "
				+ " left join clientesvendedor ve on ( re.idvendedor = ve.idvendedor and  re.idempresa = ve.idempresa) "
				// EJV - MANTIS - 531 -->
				// + " where re.fechabaja is null "
				// + " where re.fechabaja is null "
				// + " and re.fechaalt :: date between '" + fdesde.toString()
				// <--
				// 20110912 - EJV - Mantis 789 -->
				+ "       LEFT JOIN clientespromociones pmc ON pr.idpromocion = pmc.idpromocion and  pr.idempresa = pmc.idempresa "
				// <--
				// 20111007 - EJV - Mantis 796 -->
				+ "       LEFT JOIN clientestablaiva cti ON cl.idtipoiva = cti.idtipoiva and cl.idempresa = cti.idempresa "
				+ "       LEFT JOIN clientespreferencias prf ON pr.idpreferencia = prf.idpreferencia and  pr.idempresa = prf.idempresa "
				+ "       LEFT JOIN clienteslistas lis ON cl.idlista = lis.idlista and  cl.idempresa = lis.idempresa    "
				+ "       LEFT JOIN clientescondicio con ON cl.idcondicion = con.idcondicion AND cl.idempresa = con.idempresa    "
				+ "       LEFT JOIN ( "
				+ "                         SELECT cu.idcuenta, cu.cuenta, ej.activo, cu.idempresa "
				+ "                           FROM  contableinfiplan cu  "
				+ "                                     INNER JOIN contableejercicios ej ON cu.ejercicio = ej.ejercicio "
				+ "                                               AND cu.idempresa = ej.idempresa AND ej.activo= 'S' "
				+ "                       ) ifp  ON cl.idctaneto = ifp.idcuenta AND cl.idempresa = ifp.idempresa    "
				// <--

				+ " where  re.fechareactivacion:: date between '"
				+ fdesde.toString() + "'::date and '" + fhasta.toString()
				+ "'::date and re.idempresa =" + idempresa.toString()
				+ " ORDER BY re.fechareactivacion ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesConsultaReactEntreFechas() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultaReactEntreFechas()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesConsultaReactEntreFechasxVendedor(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " coalesce (ve.vendedor,'no tiene vendedor asignado'),"
				+ " count(*) as total, "
				// EJV - MANTIS 531 -->
				+ " CASE WHEN re.fechabaja IS NULL THEN 'NO' ELSE 'SI' END AS reactivacion"
				// <--
				+ " from "
				+ " clientesreactivaciones re"
				+ " join clientesclientes cl on (re.idcliente = cl.idcliente and cl.idempresa = re.idempresa ) "
				+ " join clientesprecargaclientes pr on (cl.idcliente = pr.idcliente  and cl.idempresa = pr.idempresa) "
				+ " left join clientesvendedor ve on ( pr.idvendedorasignado = ve.idvendedor and  pr.idempresa = ve.idempresa) "
				// EJV - MANTIS 531 -->
				// + " where re.fechaalt :: date between '" + fdesde.toString()
				// + "' and '" + fhasta.toString()
				// + "'  and re.fechabaja is null"
				// <--
				+ " where re.fechareactivacion:: date between '"
				+ fdesde.toString() + "' and '" + fhasta.toString()
				+ "' and re.idempresa =" + idempresa.toString()
				+ " group by ve.vendedor, "
				// EJV - MANTIS 531 -->
				+ " CASE WHEN re.fechabaja IS NULL THEN 'NO' ELSE 'SI' END "
				// <--
				+ " ORDER BY 1, 3, 2 ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesConsultaReactEntreFechasxVendedor() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultaReactEntreFechasxVendedor()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesConsultaPrecargaVendedor(String fdesde,
			String fhasta, BigDecimal idvendedor, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " coalesce(cep.estadoprecarga,'no tiene vendedor asignado') ,"
				+ " count(*) as total"
				+ " from "
				+ " clientesprecargaclientes pr "
				+ " left join clientesvendedor ve on ( pr.idvendedorasignado = ve.idvendedor and  pr.idempresa = ve.idempresa) "
				+ " left JOIN clientesestadoprecarga cep ON pr.idestadoprecarga = cep.idestadoprecarga and pr.idempresa = cep.idempresa"
				+ " where " + " pr.fechaalt :: date between '"
				+ fdesde.toString() + "' and '" + fhasta.toString() + "' "
				+ " and pr.idempresa =" + idempresa.toString()
				+ " and idvendedorasignado = " + idvendedor.toString()
				+ " group by cep.estadoprecarga " + " ORDER BY 2 ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesConsultaReactEntreFechasxVendedor() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultaReactEntreFechasxVendedor()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalLocalidadesXProvAll(long limit, long offset,
			BigDecimal idprovincia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, l.cpostal, "
				+ "       l.usuarioalt, l.usuarioact, l.fechaalt, l.fechaact"
				+ "  FROM GLOBALLOCALIDADES l"
				+ "        INNER JOIN  globalprovincias p ON p.idprovincia = l.idprovincia AND l.idprovincia = "
				+ idprovincia + " ORDER BY 2  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalLocalidadesXProvAll() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesXProvAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalLocalidadesXProvOcu(long limit, long offset,
			String ocurrencia, BigDecimal idprovincia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, l.cpostal, "
				+ "       l.usuarioalt, l.usuarioact, l.fechaalt, l.fechaact"
				+ "  FROM GLOBALLOCALIDADES l"
				+ "       INNER JOIN  globalprovincias p ON p.idprovincia = l.idprovincia AND l.idprovincia = "
				+ idprovincia + " WHERE UPPER(l.localidad) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalLocalidadesXProvOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesXProvOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// ------------------------------------------------------------------------
	// LOCALIDADES POR PROVINCIA - TEST EJV 20090129 - AJAX

	public List getGlobalLocalidadesProvAll(BigDecimal idprovincia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + "SELECT idlocalidad, localidad"
				+ "  FROM  GLOBALLOCALIDADES" + " WHERE idprovincia = "
				+ idprovincia + " ORDER BY 2  ;";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalLocalidades() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidades()  "
							+ ex);
		}
		return vecSalida;
	}

	public static Enumeration getSetSorted(Set set) {
		Enumeration enSorted = null;
		try {
			if (set != null && !set.isEmpty()) {
				Vector vecSort = new Vector(set);
				Collections.sort(vecSort);
				enSorted = vecSort.elements();
			}
		} catch (Exception e) {
			log.error("sortSet(set):" + e);
		}
		return enSorted;
	}

	// update la tabla clientesprecargaclientes desde la reactivacion
	public String globalUpdateVendedor(String[] idcliente,
			BigDecimal idvendedor, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = " SELECT COUNT(*) FROM clientesprecargaclientes "
					+ " WHERE idcliente = " + idcliente.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) {
					sql = "UPDATE clientesprecargaclientes SET idvendedorasignado=? WHERE idcliente=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					for (int j = 0; j < idcliente.length; j++) {
						insert.setBigDecimal(1, idvendedor);
						insert.setBigDecimal(2, new BigDecimal(idcliente[j]));
						insert.setBigDecimal(3, idempresa);
						int i = insert.executeUpdate();
					}
					// if (i > 0)
					salida = "OK";
					// else
					// salida = "";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalUpdateVendedor(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalUpdateVendedor(.....)"
							+ ex);
		}
		return salida;
	}

	public List globalUpdatePK(BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select cv.idvendedor,cv.vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and cp.idcliente = " + idcliente.toString()
				+ " and vceh.idestado in (2,5) " + " ORDER BY 1";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalcontadoresPK( BigDecimal idcontador )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getEstadosReactivacionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestadoreactivaciones,estadoreactivaciones,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM clientesestadosreactivaciones "
				+ " where idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getEstadosReactivacionesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadosReactivacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getEstadosReactivacionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idestadoreactivaciones,estadoreactivaciones,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM clientesestadosreactivaciones "
				+ " where (idestadoreactivaciones::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estadoreactivaciones) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getEstadosReactivacionesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadosReactivacionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// segunda estapa reactivacion
	public List ClientesReactivacionAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "select vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO') as vendedor, cr.idpromocion "
				+ "  from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " left JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa  "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones = 1 " + " ORDER BY 1  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : Clientesesstadosbajasuspensionlarga() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: Clientesesstadosbajasuspensionlarga()  "
							+ ex);
		}
		return vecSalida;
	}

	public List ClientesReactivacionOcu(long limit, long offset,
			BigDecimal idempresa, String ocurrencia) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO',cv.vendedor) as vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " left JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa  "
				+ " where " + " vceh.idempresa = "
				+ idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and (vceh.idcliente::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(vceh.razon) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.motivo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(cv.vendedor) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " group by vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,cv.vendedor "
				+ "ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : Clientesesstadosbajasuspensionlarga() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: Clientesesstadosbajasuspensionlarga()  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEntidadReactivacionAll(BigDecimal idempresa)
			throws EJBException {
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones = 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadReactivacionAll()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadReactivacionAll()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadReactivacionAll()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getTotalEntidadReactivacionOcu(String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " left JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa "
				+ " left join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and vceh.idestado in (2,5) "
				+ " and cr.idestadoreactivaciones = 1 " + " and ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND vceh.idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadOcuporempresaEstado()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcuporempresaEstado()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadOcuporempresaEstado()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	/**
	 * 
	 * Metodos para la entidad: globalBlobImagenes Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Jun 16 10:05:43 GYT 2009
	 * 
	 */

	public String callGlobalBlobImagenesCreate(String tupla, File files[],
			String nombre[], String descripcion[], String principal[],
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {
		String salida = "OK";

		dbconn.setAutoCommit(false);

		try {

			for (int j = 0; files != null && j < files.length; j++) {
				if (files[j] == null)
					continue;

				String file = files[j].getAbsolutePath();
				salida = globalBlobImagenesCreate(tupla, file, files[j]
						.getName(), descripcion[j], principal[j], files[j]
						.getPath(), new BigDecimal(files[j].length()),
						idempresa, usuario);
				if (files[j] != null)
					files[j].delete();
				if (!salida.equalsIgnoreCase("OK"))
					break;

			}

		} catch (Exception e) {
			log.error("callGlobalBlobImagenesCreate():" + e);
		}

		if (salida.equalsIgnoreCase("OK"))
			dbconn.commit();
		else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return salida;
	}

	public String globalBlobImagenesCreate(String tupla, String file,
			String nombre, String descripcion, String principal,
			String tmppath, BigDecimal size, BigDecimal idempresa,
			String usuarioalt) throws EJBException {

		String salida = "OK";
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		PreparedStatement insert = null;
		// validaciones de datos:
		// 1. nulidad de campos
		if (file == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: trama ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (principal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: principal ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (principal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: principal ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {

			if (salida.equalsIgnoreCase("OK")) {

				if (principal.equalsIgnoreCase("S")) {
					String sql = "";
					sql = "   UPDATE GLOBALBLOBIMAGENES "
							+ "      SET principal=? , usuarioact=?, fechaact=? "
							+ "WHERE tupla=?::OID  AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, "N");
					insert.setString(2, usuarioalt);
					insert.setTimestamp(3, fechaact);
					insert.setString(4, tupla.toString());
					insert.setBigDecimal(5, idempresa);
					insert.executeUpdate();

				}

				String ins = ""
						+ "INSERT INTO globalblobimagenes(tupla, trama, nombre, descripcion, principal, tmppath, size, idempresa, usuarioalt ) "
						+ " VALUES (?::OID, LO_IMPORT(?), ?, ?, ?, ?, ?, ?, ?)";
				insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tupla);
				insert.setString(2, file);
				insert.setString(3, nombre);
				insert.setString(4, descripcion);
				insert.setString(5, principal);
				insert.setString(6, tmppath);
				insert.setBigDecimal(7, size);
				insert.setBigDecimal(8, idempresa);
				insert.setString(9, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No se pudo generar registro de BLOB en globalblobimagenes.";
			}
		} catch (SQLException sqlException) {
			salida = "SQLE: Imposible dar de alta el registro BLOB en globalblobimagenes.";
			log
					.error("Error SQL public String globalBlobImagenesCreate(.....): "
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: Imposible dar de alta el registro BLOB en globalblobimagenes.";
			log
					.error("Error excepcion public String globalBlobImagenesCreate(.....):"
							+ ex);
		}
		return salida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalBlobImagenesAll(long limit, long offset,
			BigDecimal tupla, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		// String path = "'D:'|| E'\\\\desarrollo'|| E'\\\\jboss4'||
		// E'\\\\server'|| E'\\\\default'|| E'\\\\deploy'||
		// E'\\\\syswarpERP.ear'|| E'\\\\syswarpERPWeb.war'|| E'\\\\imagenes' ||
		// E'\\\\general'|| E'\\\\'";
		String cQuery = ""
				+ "SELECT tupla,trama,nombre,descripcion,principal,tmppath,"
				+ "       LO_EXPORT(trama, "
				+ blobSqlPath
				+ "  || nombre),idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM globalblobimagenes WHERE idempresa = "
				+ idempresa.toString() + " AND tupla = " + tupla
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGlobalBlobImagenesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalBlobImagenesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalBlobImagenesOcu(long limit, long offset,
			BigDecimal tupla, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;

		// String path = "'D:'|| E'\\\\desarrollo'|| E'\\\\jboss4'||
		// E'\\\\server'|| E'\\\\default'|| E'\\\\deploy'||
		// E'\\\\syswarpERP.ear'|| E'\\\\syswarpERPWeb.war'|| E'\\\\imagenes' ||
		// E'\\\\general'|| E'\\\\'";

		String cQuery = ""
				+ "SELECT tupla,trama,nombre,descripcion,principal,tmppath,"
				+ "       LO_EXPORT(trama , "
				+ blobSqlPath
				+ "  || nombre),idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM globalblobimagenes WHERE (UPPER(descripcion) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND tupla = " + tupla
				+ " AND idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalBlobImagenesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalBlobImagenesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalBlobImagenesPK(BigDecimal tupla, BigDecimal trama,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT tupla,trama,nombre,descripcion,principal,tmppath,"
				+ "       idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM globalblobimagenes WHERE tupla=" + tupla.toString()
				+ " AND trama = " + trama.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalBlobImagenesPK( BigDecimal tupla ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalBlobImagenesPK( BigDecimal tupla )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalBlobImagenesDelete(BigDecimal tupla, BigDecimal trama,
			BigDecimal idempresa) throws EJBException, SQLException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM globalblobimagenes WHERE tupla="
				+ tupla.toString() + " AND trama = " + trama.toString()
				+ " AND idempresa=" + idempresa.toString();
		String salida = "OK";

		dbconn.setAutoCommit(false);
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {

				cQuery = "SELECT LO_UNLINK(trama) FROM globalblobimagenes WHERE tupla="
						+ tupla.toString()
						+ " AND trama = "
						+ trama.toString()
						+ " AND idempresa=" + idempresa.toString();

				rsSalida = statement.executeQuery(cQuery);

				if (rsSalida.next() && rsSalida.getString(1).equals("1")) {

					cQuery = "DELETE FROM globalblobimagenes WHERE tupla="
							+ tupla.toString().toString() + " AND trama = "
							+ trama.toString() + " AND idempresa="
							+ idempresa.toString();
					statement.execute(cQuery);

				} else {
					salida = "Imposible eliminar link a blob.";
				}

			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalBlobImagenesDelete( BigDecimal tupla, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalBlobImagenesDelete( BigDecimal tupla, BigDecimal idempresa )  "
							+ ex);
		}

		if (salida.equalsIgnoreCase("OK")) {
			salida = "Baja Correcta";
			dbconn.commit();
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(false);

		return salida;
	}

	public String globalBlobImagenesUpdate(BigDecimal tupla, BigDecimal trama,
			String nombre, String descripcion, String principal,
			String tmppath, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tupla == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tupla ";
		if (trama == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: trama ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (principal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: principal ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (principal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: principal ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalBlobImagenes WHERE tupla = "
					+ tupla.toString()
					+ " AND trama = "
					+ trama.toString()
					+ " AND idempresa=" + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			int i = 0;
			if (!bError) {
				if (total > 0) { // si existe hago update

					if (principal.equalsIgnoreCase("S")) {

						sql = "   UPDATE GLOBALBLOBIMAGENES "
								+ "      SET principal=? , usuarioact=?, fechaact=? "
								+ "WHERE tupla=?::OID AND trama<>?::OID AND idempresa=?;";
						insert = dbconn.prepareStatement(sql);

						insert.setString(1, "N");
						insert.setString(2, usuarioact);
						insert.setTimestamp(3, fechaact);
						insert.setString(4, tupla.toString());
						insert.setString(5, trama.toString());
						insert.setBigDecimal(6, idempresa);
						i = insert.executeUpdate();

					}

					sql = "   UPDATE GLOBALBLOBIMAGENES "
							+ "  SET nombre=?, descripcion=?, principal=?, tmppath=?, usuarioact=?, fechaact=? "
							+ "WHERE tupla=?::OID AND trama=?::OID AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, nombre);
					insert.setString(2, descripcion);
					insert.setString(3, principal);
					insert.setString(4, tmppath);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setString(7, tupla.toString());
					insert.setString(8, trama.toString());
					insert.setBigDecimal(9, idempresa);
				}

				i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalBlobImagenesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalBlobImagenesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String ClientesInsertoPeriodicidaddelSocio(BigDecimal idcliente,
			int verificarEsKosher, BigDecimal idempresa, Connection conn)
			throws EJBException {
		String salida = "OK";
		int i = 1;
		int step = 1;
		// String error = "";
		// Calendar hoy = new GregorianCalendar();
		// Timestamp fechadesde = new Timestamp(hoy.getTime().getTime());

		switch (verificarEsKosher) {

		case 0:
			break;
		case 1:
			i = 2;
			step = 2;
			break;
		default:
			break;
		}

		try {
			if (salida.equalsIgnoreCase("OK")) {
				for (; i <= 12; i = i + step) {
					String ins = "INSERT INTO clientesperiodicidadentrega(idcliente, idmes,idempresa,usuarioalt ) VALUES (?, ?, ?, ?)";
					PreparedStatement insert = conn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idcliente);
					insert.setInt(2, i);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, "Periodicidad Inicial");
					int n = insert.executeUpdate();
					if (n != 1) {
						salida = "No fue posible generar periodicidad inicial para mes: "
								+ i;
						break;
					}
				}
			}
			// error = "OK";
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar periodicidad inicial.";
			log
					.error("Error SQL public String clientesestadosclientesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar periodicidad inicial.";
			log
					.error("Error excepcion public String clientesestadosclientesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// SAS--ingreso de fichas
	public List getConsultaIngresoFichas(String fdesde, String fhasta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " SELECT cp.idprecarga, cp.fechadeingreso, cp.idcliente, cp.fechaalt,"
				+ "        ce.estado, cp.razon, tc.idtipoclie, tc.tipoclie "
				+ "   FROM clientesprecargaclientes cp"
				+ "        INNER JOIN clientestipoclie tc ON cp.idtipoclie = tc.idtipoclie AND cp.idempresa = tc.idempresa "
				+ "        LEFT JOIN vclientesestadoshoy ce ON cp.idcliente = ce.idcliente AND cp.idempresa = ce.idempresa "
				+ "  WHERE " + " cp.fechaalt::DATE BETWEEN '"
				+ fdesde.toString() + "' AND '" + fhasta.toString() + "' "
				+ "    AND cp.idempresa =" + idempresa.toString()
				+ " ORDER BY 3 ";
		List vecSalida = new ArrayList();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getConsultaIngresoFichas() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getConsultaIngresoFichas()  "
							+ ex);
		}
		return vecSalida;
	}

	// TIPOS EVENTOS
	public List getWkftipoeventosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idtipoevento,tipoevento,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFTIPOEVENTOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkftipoeventosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipoeventosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkftipoeventosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipoevento,tipoevento,usuarioalt,usuarioact,fechaalt,fechaact,idempresa "
				+ " FROM WKFTIPOEVENTOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtipoevento::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipoevento) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftipoeventosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipoeventosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkftipoeventosPK(BigDecimal idtipoevento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipoevento,tipoevento,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFTIPOEVENTOS WHERE idtipoevento="
				+ idtipoevento.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftipoeventosPK( BigDecimal idtipoevento ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipoeventosPK( BigDecimal idtipoevento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkftipoeventosDelete(BigDecimal idtipoevento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFTIPOEVENTOS "
				+ " WHERE idtipoevento = " + idtipoevento.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFTIPOEVENTOS "
						+ " WHERE idtipoevento = " + idtipoevento.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkftipoeventosDelete( BigDecimal idtipoevento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkftipoeventosDelete( BigDecimal idtipoevento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkftipoeventosCreate(String tipoevento, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoevento ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipoevento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoevento ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFTIPOEVENTOS(tipoevento, usuarioalt,idempresa ) VALUES (?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipoevento);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkftipoeventosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkftipoeventosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkftipoeventosUpdate(BigDecimal idtipoevento,
			String tipoevento, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoevento ";
		if (tipoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoevento ";

		// 2. sin nada desde la pagina
		if (tipoevento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoevento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkftipoeventos WHERE idtipoevento = "
					+ idtipoevento.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFTIPOEVENTOS SET tipoevento=?, usuarioact=? WHERE idtipoevento=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoevento);
					insert.setString(2, usuarioact);
					insert.setBigDecimal(3, idtipoevento);
					insert.setBigDecimal(4, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkftipoeventosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkftipoeventosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// TIPO TRANSACCION
	public List getWkftipotransaccionAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idtipotransaccion,tipotransaccion,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFTIPOTRANSACCION WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkftipotransaccionAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipotransaccionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkftipotransaccionOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipotransaccion,tipotransaccion,usuarioalt,usuarioact,fechaalt,fechaact,idempresa "
				+ " FROM WKFTIPOTRANSACCION "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtipotransaccion::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipotransaccion) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftipotransaccionOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipotransaccionOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkftipotransaccionPK(BigDecimal idtipotransaccion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idtipotransaccion,tipotransaccion,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFTIPOTRANSACCION WHERE idtipotransaccion="
				+ idtipotransaccion.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftipotransaccionPK( BigDecimal idtipotransaccion ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftipotransaccionPK( BigDecimal idtipotransaccion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkftipotransaccionDelete(BigDecimal idtipotransaccion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFTIPOTRANSACCION "
				+ " WHERE idtipotransaccion = " + idtipotransaccion.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFTIPOTRANSACCION "
						+ " WHERE idtipotransaccion = "
						+ idtipotransaccion.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkftipotransaccionDelete( BigDecimal idtipotransaccion ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkftipotransaccionDelete( BigDecimal idtipotransaccion )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkftipotransaccionCreate(String tipotransaccion,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipotransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipotransaccion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipotransaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipotransaccion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFTIPOTRANSACCION(tipotransaccion, usuarioalt, idempresa ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipotransaccion);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkftipotransaccionCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkftipotransaccionCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkftipotransaccionUpdate(BigDecimal idtipotransaccion,
			String tipotransaccion, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipotransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotransaccion ";
		if (tipotransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipotransaccion ";

		// 2. sin nada desde la pagina
		if (tipotransaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipotransaccion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkftipotransaccion WHERE idtipotransaccion = "
					+ idtipotransaccion.toString()
					+ " and idempresa = "
					+ idempresa;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFTIPOTRANSACCION SET tipotransaccion=?, usuarioact=?, fechaact=? WHERE idtipotransaccion=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipotransaccion);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idtipotransaccion);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkftipotransaccionUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkftipotransaccionUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// EVENTOS

	public List getWkfeventosAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select "
				+ " ev.idevento, "
				+ " ev.evento, "
				+ " te.tipoevento,"
				+ " ev2.evento, "
				+ " ev.descripcion,"
				+ " ev.usuarioalt,"
				+ " ev.usuarioact,"
				+ " ev.fechaalt,"
				+ " ev.fechaact,"
				+ " ev.idempresa "
				+ " from "
				+ " wkfeventos ev "
				+ " left join wkftipoeventos te on ev.idtipoevento = te.idtipoevento and ev.idempresa = te.idempresa "
				+ " left join wkfeventos ev2 on ev.idproximoevento = ev2.idevento and ev.idempresa = ev2.idempresa "
				+ " WHERE ev.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkfeventosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkfeventosOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select "
				+ " ev.idevento, "
				+ " ev.evento, "
				+ " te.tipoevento,"
				+ " ev2.evento, "
				+ " ev.descripcion,"
				+ " ev.usuarioalt,"
				+ " ev.usuarioact,"
				+ " ev.fechaalt,"
				+ " ev.fechaact,"
				+ " ev.idempresa "
				+ " from "
				+ " wkfeventos ev "
				+ " left join wkftipoeventos te on ev.idtipoevento = te.idtipoevento and ev.idempresa = te.idempresa "
				+ " left join wkfeventos ev2 on ev.idproximoevento = ev2.idevento and ev.idempresa = ev2.idempresa "
				+ " where ev.idempresa= " + idempresa.toString()
				+ " and (ev.idevento::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(ev.evento) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkfeventosPK(BigDecimal idevento, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select"
				+ " ev.idevento,"
				+ " ev.evento,"
				+ " te.idtipoevento,"
				+ " te.tipoevento,"
				+ " ev.idproximoevento,"
				+ " ev2.evento,"
				+ " ev.descripcion,"
				+ " ev.usuarioalt,"
				+ " ev.usuarioact,"
				+ " ev.fechaalt,"
				+ " ev.fechaact,"
				+ " ev.idempresa"
				+ " from "
				+ " wkfeventos ev "
				+ " left join wkftipoeventos te on ev.idtipoevento = te.idtipoevento and ev.idempresa = te.idempresa "
				+ " left join wkfeventos ev2 on ev.idproximoevento = ev2.idevento and ev.idempresa = ev2.idempresa "
				+ " WHERE ev.idevento=" + idevento.toString()
				+ " AND ev.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosPK( BigDecimal idevento ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosPK( BigDecimal idevento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkfeventosDelete(BigDecimal idevento, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFEVENTOS " + " WHERE idevento = "
				+ idevento.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFEVENTOS WHERE idevento = "
						+ idevento.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkfeventosDelete( BigDecimal idevento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkfeventosDelete( BigDecimal idevento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkfeventosCreate(String evento, BigDecimal idtipoevento,
			BigDecimal idproximoevento, String descripcion, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (evento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: evento ";
		if (idtipoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoevento ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (evento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: evento ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFEVENTOS(evento, idtipoevento, idproximoevento, descripcion, usuarioalt,idempresa ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, evento);
				insert.setBigDecimal(2, idtipoevento);

				// insert.setBigDecimal(3,idproximoevento);

				if (idproximoevento.longValue() > 0) {
					insert.setBigDecimal(3, idproximoevento);
				} else {
					insert.setBigDecimal(3, null);
				}

				insert.setString(4, descripcion);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkfeventosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String wkfeventosCreate(.....)"
					+ ex);
		}
		return salida;
	}

	public String wkfeventosUpdate(BigDecimal idevento, String evento,
			BigDecimal idtipoevento, BigDecimal idproximoevento,
			String descripcion, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idevento ";
		if (evento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: evento ";
		if (idtipoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoevento ";

		// 2. sin nada desde la pagina
		if (evento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: evento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkfeventos WHERE idevento = "
					+ idevento.toString() + " and idempresa ="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFEVENTOS SET evento=?, idtipoevento=?, idproximoevento=?, descripcion=?, usuarioact=?, fechaact=? WHERE idevento=? and idempresa=?";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, evento);
					insert.setBigDecimal(2, idtipoevento);

					if (idproximoevento.longValue() > 0) {
						insert.setBigDecimal(3, idproximoevento);
					} else {
						insert.setBigDecimal(3, null);
					}

					// insert.setBigDecimal(3,idproximoevento);
					insert.setString(4, descripcion);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idevento);
					insert.setBigDecimal(8, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkfeventosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String wkfeventosUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	// TRANSACCIONES
	public List getWkftransaccionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " wt.idtransaccion,"
				+ " wt.transaccion,"
				+ " tt.tipotransaccion,"
				+ " wt2.transaccion,"
				+ " wt.descripcion,"
				+ " wt.usuarioalt,"
				+ " wt.usuarioact,"
				+ " wt.fechaalt,"
				+ " wt.fechaact,"
				+ " wt.idempresa"
				+ " FROM "
				+ " WKFTRANSACCIONES wt"
				+ " left join  wkftipotransaccion tt on wt.idtipotransaccion = tt.idtipotransaccion and wt.idempresa = tt.idempresa "
				+ " left join  WKFTRANSACCIONES wt2 on wt.idproximatransaccion = wt2.idtransaccion and wt.idempresa = wt2.idempresa "
				+ " WHERE wt.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkftransaccionesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftransaccionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkftransaccionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " wt.idtransaccion,"
				+ " wt.transaccion,"
				+ " tt.tipotransaccion,"
				+ " wt2.transaccion,"
				+ " wt.descripcion,"
				+ " wt.usuarioalt,"
				+ " wt.usuarioact,"
				+ " wt.fechaalt,"
				+ " wt.fechaact,"
				+ " wt.idempresa"
				+ " FROM "
				+ " WKFTRANSACCIONES wt"
				+ " left join  wkftipotransaccion tt on wt.idtipotransaccion = tt.idtipotransaccion and wt.idempresa = tt.idempresa "
				+ " left join  WKFTRANSACCIONES wt2 on wt.idproximatransaccion = wt2.idtransaccion and wt.idempresa = wt2.idempresa "
				+ " where wt.idempresa= " + idempresa.toString()
				+ " and (wt.idtransaccion::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(wt.transaccion) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftransaccionesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftransaccionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkftransaccionesPK(BigDecimal idtransaccion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select"
				+ " wt.idtransaccion,"
				+ " wt.transaccion,"
				+ " tt.idtipotransaccion,"
				+ " tt.tipotransaccion,"
				+ " wt2.idproximatransaccion,"
				+ " wt2.transaccion,"
				+ " wt.descripcion,"
				+ " wt.usuarioalt,"
				+ " wt.usuarioact,"
				+ " wt.fechaalt,"
				+ " wt.fechaact,"
				+ " wt.idempresa"
				+ " FROM "
				+ " WKFTRANSACCIONES wt "
				+ " left join  wkftipotransaccion tt on wt.idtipotransaccion = tt.idtipotransaccion and wt.idempresa = tt.idempresa "
				+ " left join  WKFTRANSACCIONES wt2 on wt.idproximatransaccion = wt2.idtransaccion and wt.idempresa = wt2.idempresa "
				+ " WHERE wt.idtransaccion=" + idtransaccion.toString()
				+ " AND wt.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkftransaccionesPK( BigDecimal idtransaccion ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkftransaccionesPK( BigDecimal idtransaccion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkftransaccionesDelete(BigDecimal idtransaccion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFTRANSACCIONES "
				+ " WHERE idtransaccion = " + idtransaccion.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFTRANSACCIONES "
						+ " WHERE idtransaccion = " + idtransaccion.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkftransaccionesDelete( BigDecimal idtransaccion ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkftransaccionesDelete( BigDecimal idtransaccion )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkftransaccionesCreate(String transaccion,
			BigDecimal idtipotransaccion, BigDecimal idproximatransaccion,
			String descripcion, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (transaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: transaccion ";
		if (idtipotransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotransaccion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (transaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: transaccion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFTRANSACCIONES(transaccion, idtipotransaccion, idproximatransaccion, descripcion, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, transaccion);
				insert.setBigDecimal(2, idtipotransaccion);
				// insert.setBigDecimal(3,idproximatransaccion);

				if (idproximatransaccion.longValue() > 0) {
					insert.setBigDecimal(3, idproximatransaccion);
				} else {
					insert.setBigDecimal(3, null);
				}
				insert.setString(4, descripcion);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkftransaccionesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkftransaccionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkftransaccionesUpdate(BigDecimal idtransaccion,
			String transaccion, BigDecimal idtipotransaccion,
			BigDecimal idproximatransaccion, String descripcion,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtransaccion ";
		if (transaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: transaccion ";
		if (idtipotransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotransaccion ";

		// 2. sin nada desde la pagina
		if (transaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: transaccion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkftransacciones WHERE idtransaccion = "
					+ idtransaccion.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFTRANSACCIONES SET transaccion=?, idtipotransaccion=?, idproximatransaccion=?, descripcion=?, usuarioact=?, fechaact=? WHERE idtransaccion=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, transaccion);
					insert.setBigDecimal(2, idtipotransaccion);

					// insert.setBigDecimal(3,idproximatransaccion);

					if (idproximatransaccion.longValue() > 0) {
						insert.setBigDecimal(3, idproximatransaccion);
					} else {
						insert.setBigDecimal(3, null);
					}
					insert.setString(4, descripcion);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idtransaccion);
					insert.setBigDecimal(8, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkftransaccionesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkftransaccionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// PROCESO NEGOCIO
	public List getWkfprocesonegocioAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT"
				+ " pn.idprocesonegocio,"
				+ " pn.procesonegocio,"
				+ " pn2.procesonegocio,"
				+ " pn.usuarioalt,"
				+ " pn.usuarioact,"
				+ " pn.fechaalt,"
				+ " pn.fechaact,"
				+ " pn.idempresa "
				+ " FROM WKFPROCESONEGOCIO  pn"
				+ " left join WKFPROCESONEGOCIO  pn2 on pn2.idprocesonegocio = pn.idprocesonegocionext and pn2.idempresa = pn.idempresa     "
				+ " WHERE pn.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkfprocesonegocioAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesonegocioAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkfprocesonegocioOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT"
				+ " pn.idprocesonegocio,"
				+ " pn.procesonegocio,"
				+ " pn2.procesonegocio,"
				+ " pn.usuarioalt,"
				+ " pn.usuarioact,"
				+ " pn.fechaalt,"
				+ " pn.fechaact,"
				+ " pn.idempresa "
				+ " FROM WKFPROCESONEGOCIO  pn"
				+ " left join WKFPROCESONEGOCIO  pn2 on pn2.idprocesonegocio = pn.idprocesonegocionext and pn2.idempresa = pn.idempresa     "
				+ " where pn.idempresa= " + idempresa.toString()
				+ " and (pn.idprocesonegocio::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(pn.procesonegocio) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfprocesonegocioOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesonegocioOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkfprocesonegocioPK(BigDecimal idprocesonegocio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT"
				+ " pn.idprocesonegocio,"
				+ " pn.procesonegocio,"
				+ " pn2.idprocesonegocionext,"
				+ " pn2.procesonegocio,"
				+ " pn.usuarioalt,"
				+ " pn.usuarioact,"
				+ " pn.fechaalt,"
				+ " pn.fechaact,"
				+ " pn.idempresa "
				+ " FROM WKFPROCESONEGOCIO  pn"
				+ " left join WKFPROCESONEGOCIO  pn2 on pn2.idprocesonegocio = pn.idprocesonegocionext and pn2.idempresa = pn.idempresa     "
				+ " WHERE pn.idprocesonegocio=" + idprocesonegocio.toString()
				+ " AND pn.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfprocesonegocioPK( BigDecimal idprocesonegocio ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesonegocioPK( BigDecimal idprocesonegocio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkfprocesonegocioDelete(BigDecimal idprocesonegocio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFPROCESONEGOCIO "
				+ " WHERE idprocesonegocio = " + idprocesonegocio.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFPROCESONEGOCIO "
						+ " WHERE idprocesonegocio = "
						+ idprocesonegocio.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkfprocesonegocioDelete( BigDecimal idprocesonegocio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkfprocesonegocioDelete( BigDecimal idprocesonegocio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkfprocesonegocioCreate(String procesonegocio,
			BigDecimal idprocesonegocionext, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (procesonegocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesonegocio ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (procesonegocio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: procesonegocio ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFPROCESONEGOCIO(procesonegocio, idprocesonegocionext, usuarioalt, idempresa ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, procesonegocio);
				// insert.setBigDecimal(2,idprocesonegocionext);
				if (idprocesonegocionext.longValue() > 0) {
					insert.setBigDecimal(2, idprocesonegocionext);
				} else {
					insert.setBigDecimal(2, null);
				}

				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkfprocesonegocioCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkfprocesonegocioCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkfprocesonegocioUpdate(BigDecimal idprocesonegocio,
			String procesonegocio, BigDecimal idprocesonegocionext,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprocesonegocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprocesonegocio ";
		if (procesonegocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesonegocio ";

		// 2. sin nada desde la pagina
		if (procesonegocio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: procesonegocio ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkfprocesonegocio WHERE idprocesonegocio = "
					+ idprocesonegocio.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFPROCESONEGOCIO SET procesonegocio=?, idprocesonegocionext=?, usuarioact=?, fechaact=? WHERE idprocesonegocio=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, procesonegocio);
					// insert.setBigDecimal(2,idprocesonegocionext);
					if (idprocesonegocionext.longValue() > 0) {
						insert.setBigDecimal(2, idprocesonegocionext);
					} else {
						insert.setBigDecimal(2, null);
					}
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idprocesonegocio);
					insert.setBigDecimal(6, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkfprocesonegocioUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkfprocesonegocioUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// PROCESOS EVENTOS
	public List getWkfprocesoseventosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " pe.idprocesoevento, "
				+ " pn.procesonegocio, "
				+ " ev.evento, "
				+ " pe.descripcion, "
				+ " pn2.descripcion, "
				+ " pe.usuarioalt,"
				+ " pe.usuarioact,"
				+ " pe.fechaalt,"
				+ " pe.fechaact, "
				+ " pe.idempresa "
				+ " FROM WKFPROCESOSEVENTOS pe "
				+ " left join wkfprocesonegocio pn on pn.idprocesonegocio = pe.idproceso and pn.idempresa = pe.idempresa "
				+ " left join wkfeventos        ev on ev.idevento = pe.idevento and pn.idempresa = pe.idempresa "
				+ " left join wkfprocesoseventos  pn2 on pe.idprocesonegocionext = pn2.idprocesoevento and pe.idempresa = pn2.idempresa  "
				+ " WHERE pe.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkfprocesoseventosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesoseventosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkfprocesoseventosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " pe.idprocesoevento, "
				+ " pn.procesonegocio, "
				+ " ev.evento, "
				+ " pe.descripcion, "
				+ " pn2.descripcion, "
				+ " pe.usuarioalt,"
				+ " pe.usuarioact,"
				+ " pe.fechaalt,"
				+ " pe.fechaact, "
				+ " pe.idempresa "
				+ " FROM WKFPROCESOSEVENTOS pe "
				+ " left join wkfprocesonegocio pn on pn.idprocesonegocio = pe.idproceso and pn.idempresa = pe.idempresa "
				+ " left join wkfeventos        ev on ev.idevento = pe.idevento and pn.idempresa = pe.idempresa "
				+ " left join wkfprocesoseventos  pn2 on pe.idprocesonegocionext = pn2.idprocesoevento and pe.idempresa = pn2.idempresa  "
				+ " where pe.idempresa= " + idempresa.toString()
				+ " and (pe.idprocesoevento::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(pe.descripcion) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfprocesoseventosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesoseventosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkfprocesoseventosPK(BigDecimal idprocesoevento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT"
				+ " pe.idprocesoevento,"
				+ " pe.idproceso, "
				+ " pn.procesonegocio, "
				+ " pe.idevento, "
				+ " ev.evento, "
				+ " pe.descripcion,"
				+ " pe.idprocesonegocionext,"
				+ " pn2.descripcion, "
				+ " pe.usuarioalt, "
				+ " pe.usuarioact, "
				+ " pe.fechaalt, "
				+ " pe.fechaact, "
				+ " pe.idempresa  "
				+ " FROM WKFPROCESOSEVENTOS pe "
				+ " left join wkfprocesonegocio pn on pn.idprocesonegocio = pe.idproceso and pn.idempresa = pe.idempresa "
				+ " left join wkfeventos ev on ev.idevento = pe.idevento and pn.idempresa = pe.idempresa "
				+ " left join wkfprocesoseventos  pn2 on pe.idprocesonegocionext = pn2.idprocesoevento and pe.idempresa = pn2.idempresa  "
				+ " WHERE pe.idprocesoevento = " + idprocesoevento.toString()
				+ " AND pe.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfprocesoseventosPK( BigDecimal idprocesoevento ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfprocesoseventosPK( BigDecimal idprocesoevento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkfprocesoseventosDelete(BigDecimal idprocesoevento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFPROCESOSEVENTOS "
				+ " WHERE idprocesoevento = " + idprocesoevento.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFPROCESOSEVENTOS "
						+ " WHERE idprocesoevento="
						+ idprocesoevento.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkfprocesoseventosDelete( BigDecimal idprocesoevento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkfprocesoseventosDelete( BigDecimal idprocesoevento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkfprocesoseventosCreate(BigDecimal idproceso,
			BigDecimal idevento, String descripcion,
			BigDecimal idprocesonegocionext, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idproceso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproceso ";
		if (idevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idevento ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFPROCESOSEVENTOS(idproceso, idevento, descripcion, idprocesonegocionext, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idproceso);
				insert.setBigDecimal(2, idevento);
				insert.setString(3, descripcion);
				// insert.setBigDecimal(4,idprocesonegocionext);
				if (idprocesonegocionext.longValue() > 0) {
					insert.setBigDecimal(4, idprocesonegocionext);
				} else {
					insert.setBigDecimal(4, null);
				}

				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String wkfprocesoseventosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkfprocesoseventosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkfprocesoseventosUpdate(BigDecimal idprocesoevento,
			BigDecimal idproceso, BigDecimal idevento, String descripcion,
			BigDecimal idprocesonegocionext, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprocesoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprocesoevento ";
		if (idproceso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idproceso ";
		if (idevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idevento ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";

		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkfprocesoseventos WHERE idprocesoevento = "
					+ idprocesoevento.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFPROCESOSEVENTOS SET idproceso=?, idevento=?, descripcion=?, idprocesonegocionext=?, usuarioact=?, fechaact=? WHERE idprocesoevento=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idproceso);
					insert.setBigDecimal(2, idevento);
					insert.setString(3, descripcion);
					// insert.setBigDecimal(4,idprocesonegocionext);
					if (idprocesonegocionext.longValue() > 0) {
						insert.setBigDecimal(4, idprocesonegocionext);
					} else {
						insert.setBigDecimal(4, null);
					}
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idprocesoevento);
					insert.setBigDecimal(8, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String wkfprocesoseventosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkfprocesoseventosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// EVENTOS RESULTADOS

	public List getWkfeventosresultadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT ideventoresultado,eventoresultado,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFEVENTOSRESULTADOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkfeventosresultadosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosresultadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkfeventosresultadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  ideventoresultado,eventoresultado,usuarioalt,usuarioact,fechaalt,fechaact,idempresa "
				+ " FROM WKFEVENTOSRESULTADOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (ideventoresultado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(eventoresultado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosresultadosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosresultadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkfeventosresultadosPK(BigDecimal ideventoresultado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  ideventoresultado,eventoresultado,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM WKFEVENTOSRESULTADOS WHERE ideventoresultado="
				+ ideventoresultado.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosresultadosPK( BigDecimal ideventoresultado ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosresultadosPK( BigDecimal ideventoresultado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String wkfeventosresultadosDelete(BigDecimal ideventoresultado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFEVENTOSRESULTADOS "
				+ " WHERE ideventoresultado = " + ideventoresultado.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFEVENTOSRESULTADOS "
						+ " WHERE ideventoresultado="
						+ ideventoresultado.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : wkfeventosresultadosDelete( BigDecimal ideventoresultado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: wkfeventosresultadosDelete( BigDecimal ideventoresultado )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String wkfeventosresultadosCreate(String eventoresultado,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (eventoresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: eventoresultado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (eventoresultado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: eventoresultado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFEVENTOSRESULTADOS(eventoresultado, usuarioalt, idempresa ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, eventoresultado);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String wkfeventosresultadosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String wkfeventosresultadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String wkfeventosresultadosUpdate(BigDecimal ideventoresultado,
			String eventoresultado, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (ideventoresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ideventoresultado ";
		if (eventoresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: eventoresultado ";

		// 2. sin nada desde la pagina
		if (eventoresultado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: eventoresultado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM wkfeventosresultados WHERE ideventoresultado = "
					+ ideventoresultado.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFEVENTOSRESULTADOS SET eventoresultado=?, usuarioact=?, fechaact=? WHERE ideventoresultado=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, eventoresultado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, ideventoresultado);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String wkfeventosresultadosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String wkfeventosresultadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// EVENTOS ACTUALES
	public List getWkfeventosactualesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " ea.idventoactual, "
				+ " er.eventoresultado, "
				+ " pe.descripcion, "
				+ " wt.transaccion,"
				+ " ea.fecha, "
				+ " ea.transaccion, "
				+ " ea.usuarioalt,"
				+ " ea.usuarioact,"
				+ " ea.fechaalt, "
				+ " ea.fechaact, "
				+ " ea.idempresa "
				+ " FROM "
				+ " WKFEVENTOSACTUALES ea "
				+ " inner join wkfeventosresultados er on ea.ideventoresultado = er.ideventoresultado and ea.idempresa = er.idempresa "
				+ " inner join wkfprocesoseventos   pe on ea.idprocesoevento   =  pe.idprocesoevento  and ea.idempresa = pe.idempresa "
				+ " inner join wkftransacciones     wt on ea.idtransaccion     =  wt.idtransaccion    and wt.idempresa = pe.idempresa "
				+ " WHERE ea.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getWkfeventosactualesAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosactualesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getWkfeventosactualesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT "
				+ " ea.idventoactual, "
				+ " er.eventoresultado, "
				+ " pe.descripcion, "
				+ " wt.transaccion,"
				+ " ea.fecha, "
				+ " ea.transaccion, "
				+ " ea.usuarioalt,"
				+ " ea.usuarioact,"
				+ " ea.fechaalt, "
				+ " ea.fechaact, "
				+ " ea.idempresa "
				+ " FROM "
				+ " WKFEVENTOSACTUALES ea "
				+ " inner join wkfeventosresultados er on ea.ideventoresultado = er.ideventoresultado and ea.idempresa = er.idempresa "
				+ " inner join wkfprocesoseventos   pe on ea.idprocesoevento   =  pe.idprocesoevento  and ea.idempresa = pe.idempresa "
				+ " inner join wkftransacciones     wt on ea.idtransaccion     =  wt.idtransaccion    and wt.idempresa = pe.idempresa "
				+ " where ea.idempresa= " + idempresa.toString()
				+ " and (ea.idventoactual::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(ea.transaccion) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosactualesOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosactualesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getWkfeventosactualesPK(BigDecimal idventoactual,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT"
				+ " ea.idventoactual,"
				+ " er.ideventoresultado,"
				+ " er.eventoresultado,"
				+ " pe.idprocesoevento,"
				+ " pe.descripcion, "
				+ " wt.idtransaccion, "
				+ " wt.transaccion, "
				+ " ea.fecha,"
				+ " ea.transaccion, "
				+ " ea.usuarioalt, "
				+ " ea.usuarioact, "
				+ " ea.fechaalt, "
				+ " ea.fechaact, "
				+ " ea.idempresa "
				+ " FROM "
				+ " WKFEVENTOSACTUALES ea "
				+ " inner join wkfeventosresultados er on ea.ideventoresultado = er.ideventoresultado and ea.idempresa = er.idempresa "
				+ " inner join wkfprocesoseventos   pe on ea.idprocesoevento   =  pe.idprocesoevento  and ea.idempresa = pe.idempresa "
				+ " inner join wkftransacciones     wt on ea.idtransaccion     =  wt.idtransaccion    and wt.idempresa = pe.idempresa "
				+ " WHERE ea.idventoactual = " + idventoactual.toString()
				+ " AND ea.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getWkfeventosactualesPK( BigDecimal idventoactual ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getWkfeventosactualesPK( BigDecimal idventoactual )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String WkfeventosactualesDelete(BigDecimal idventoactual,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM WKFEVENTOSACTUALES "
				+ " WHERE idventoactual = " + idventoactual.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM WKFEVENTOSACTUALES "
						+ " WHERE idventoactual =  " + idventoactual.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : WkfeventosactualesDelete( BigDecimal idventoactual ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: WkfeventosactualesDelete( BigDecimal idventoactual )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String WkfeventosactualesCreate(BigDecimal ideventoresultado,
			BigDecimal idprocesoevento, BigDecimal idtransaccion,
			Timestamp fecha, String transaccion, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (ideventoresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ideventoresultado ";
		if (idprocesoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprocesoevento ";
		if (idtransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtransaccion ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (transaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: transaccion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (transaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: transaccion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO WKFEVENTOSACTUALES(ideventoresultado, idprocesoevento, idtransaccion, fecha, transaccion, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, ideventoresultado);
				insert.setBigDecimal(2, idprocesoevento);
				insert.setBigDecimal(3, idtransaccion);
				insert.setTimestamp(4, fecha);
				insert.setString(5, transaccion);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String WkfeventosactualesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String WkfeventosactualesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String WkfeventosactualesUpdate(BigDecimal idventoactual,
			BigDecimal ideventoresultado, BigDecimal idprocesoevento,
			BigDecimal idtransaccion, Timestamp fecha, String transaccion,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idventoactual == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idventoactual ";
		if (ideventoresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ideventoresultado ";
		if (idprocesoevento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprocesoevento ";
		if (idtransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtransaccion ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (transaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: transaccion ";

		// 2. sin nada desde la pagina
		if (transaccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: transaccion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM Wkfeventosactuales "
					+ " WHERE idventoactual = " + idventoactual.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE WKFEVENTOSACTUALES SET ideventoresultado=?, idprocesoevento=?, idtransaccion=?, fecha=?, transaccion=?, usuarioact=?, fechaact=? WHERE idventoactual=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, ideventoresultado);
					insert.setBigDecimal(2, idprocesoevento);
					insert.setBigDecimal(3, idtransaccion);
					insert.setTimestamp(4, fecha);
					insert.setString(5, transaccion);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idventoactual);
					insert.setBigDecimal(9, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String WkfeventosactualesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String WkfeventosactualesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	private String setClientesEstadosHoyCliente(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		// 2. sin nada desde la pagina

		// fin validaciones
		int rows = 0;

		try {
			if (salida.equalsIgnoreCase("OK")) {

				String qDML = "DELETE FROM CLIENTESESTADOSHOY WHERE idcliente=? AND idempresa=?";
				PreparedStatement pstatement = conn.prepareStatement(qDML);
				pstatement = conn.prepareStatement(qDML);
				// seteo de campos:
				pstatement.setBigDecimal(1, idcliente);
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();

				qDML = ""
						+ "INSERT INTO clientesestadoshoy "
						+ "       (idestadocliente,idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioalt, fechaalt, fechaact ) "
						+ "SELECT idestadocliente, idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioact, fechaalt, fechaact "
						+ "  FROM vclientesestadoshoy_snapshot WHERE idcliente = ? AND idempresa = ?;";
				pstatement = conn.prepareStatement(qDML);
				pstatement.setBigDecimal(1, idcliente);
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();
				if (rows != 1)
					salida = "No se pudo generar estado de clientes actual, es posible que fecha desde del proximo estado sea superior a la del dia o que no exista un estado definido.";

			}

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible dar de alta el estado en vista materializada.";
			log
					.error("Error SQL public String setClientesEstadosHoyCliente(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible dar de alta el estado en vista materializada.";
			log
					.error("Error excepcion public String setClientesEstadosHoyCliente(.....)"
							+ ex);
		}
		return salida;
	}

	// PROCESO DE CUMPLEAÑOS
	public List getConsultaProcesodeCumpleanios(String anio, String mes,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " cc.idcliente, "
				+ " cc.razon, "
				+ " cd.calle, "
				+ " gl.localidad, "
				+ " gp.provincia, "
				+ " veh.estado "
				+ " from "
				+ " clientesclientes cc "
				+ " left join clientesprecargaclientes cp on cc.idcliente = cp.idcliente and cc.idempresa = cp.idempresa "
				+ " left join clientesdomicilios cd on cc.idcliente = cd.idcliente and cc.idempresa = cd.idempresa and cd.esdefault = 'S'  "
				+ " left join globallocalidades gl on cd.idlocalidad = gl.idlocalidad "
				+ " left join globalprovincias gp on gl.idprovincia = gp.idprovincia "
				+ " left join vclientesestadoshoy veh on cc.idcliente = veh.idcliente "
				+ " where " + " to_char(fechadenacimiento,'YYYY') = " + "'"
				+ anio.toString() + "'"
				+ " and to_char(fechadenacimiento,'MM') = " + "'"
				+ mes.toString() + "'" + " and cc.idempresa = "
				+ idempresa.toString() + " order by 1 ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getConsultaProcesodeCumpleanios() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getConsultaProcesodeCumpleanios()  "
							+ ex);
		}
		return vecSalida;
	}

	// CARTA DE BIENVENIDA
	public List getCartaBienvenida(String fechaactivacion, String idtipoclie,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " e.expreso, "
				+ " cc.idcliente, "
				+ " cc.razon "
				+ " from "
				+ " clientesclientes cc "
				+ " left join clientestipoclie ct on cc.idtipoclie = ct.idtipoclie and cc.idempresa = ct.idempresa "
				+ " left join clientesdomicilios cd on cc.idcliente = cd.idcliente and cc.idempresa = cd.idempresa and esdefault = 'S' "
				+ " left JOIN clientesanexolocalidades xl ON cd.idanexolocalidad = xl.idanexolocalidad AND cd.idempresa = xl.idempresa "
				+ " left JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ " left JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ " left JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ " where cc.fechaalt::date = " + "'"
				+ fechaactivacion
				+ "'" // fecha de ingreso del cliente
				+ " and  ct.idtipoclie = " + idtipoclie.toString()
				+ " and cc.idempresa = " + idempresa.toString()
				+ " order by 2 ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getConsultaProcesodeCumpleanios() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getConsultaProcesodeCumpleanios()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGestionTmCampania(BigDecimal idtelemark,
			BigDecimal idcampacabe, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " "
				+ "SELECT tms.idcampacabe, bc.campacabe, tms.idcliente, cl.razon, "
				+ "       cl.idestado,cl.estado, cl.idmotivo, cl.motivo ,bcata.categoriasocio,"
				+ "       tms.idempresa   "
				+ " FROM  bacotmseleccionsocio tms "
				+ "       INNER JOIN vclientesestadoshoy cl ON tms.idcliente = cl.idcliente "
				+ "              AND tms.idempresa = cl.idempresa "
				+ "       INNER JOIN bacotmcampacabe bc ON tms.idcampacabe = bc.idcampacabe  "
				+ "              AND tms.idempresa = bc.idempresa  "
				+ "        LEFT JOIN bacotmcategorizaciones bcat ON tms.idcliente = bcat.idcliente  "
				+ "              AND tms.idempresa = bcat.idempresa AND bcat.fhasta IS NULL "
				+ "        LEFT JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio"
				+ "              AND bcat.idempresa = bcata.idempresa  "
				+ "  WHERE tms.idtelemark = "
				+ idtelemark.toString()
				+ "    AND tms.idcampacabe = "
				+ idcampacabe.toString()
				+ "    AND tms.idcliente NOT IN( "
				+ "                             SELECT idcliente "
				+ "                               FROM bacotmllamados "
				+ "                              WHERE idcampacabe =  "
				+ idcampacabe.toString()
				+ "                                AND idempresa = tms.idempresa "
				+ "                            ) AND tms.idempresa =  "
				+ idempresa
				+ " ORDER BY bcata.categoriasocio,cl.estado,tms.idcliente ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getGestionTmCampania() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGestionTmCampania()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGestionTmCampaniaResultado(BigDecimal idtelemark,
			BigDecimal idcampacabe, BigDecimal idresultado,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " "
				+ "SELECT LL.idCampaCabe, cab.campacabe, LL.idcliente, CL.razon, cp.fechadeingreso,"
				+ "       LL.socioTelefono, LL.fechaRellamada, cl.estado, cl.motivo, LL.observaciones, bcata.categoriasocio "
				+ "  FROM bacotmllamados LL "
				+ "       INNER JOIN vclientesestadoshoy cl ON LL.idcliente = cl.idcliente AND LL.idempresa = cl.idempresa "
				+ "       INNER JOIN clientesprecargaclientes cp ON LL.idcliente = cp.idcliente AND LL.idempresa = cp.idempresa "
				+ "       INNER JOIN bacotmcampacabe cab ON LL.idcampacabe = cab.idcampacabe AND LL.idempresa = cab.idempresa  "
				+ "        LEFT JOIN bacotmcategorizaciones bcat ON LL.idcliente = bcat.idcliente AND LL.idempresa = bcat.idempresa  AND bcat.fhasta IS NULL "
				+ "        LEFT JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio "
				+ "              AND bcat.idempresa = bcata.idempresa "
				+ " WHERE LL.idResultado = " + idresultado.toString()
				+ "   AND LL.idCampaCabe = " + idcampacabe.toString()
				+ "   AND UPPER(LL.usuarioalt) = '" + usuarioalt.toUpperCase()
				+ "'  AND LL.idLlamado = ("
				+ "                        SELECT MAX(idLlamado) "
				+ "                          FROM bacotmllamados "
				+ "                         WHERE idcliente = LL.idcliente "
				+ "                           AND idCampaCabe = "
				+ idcampacabe.toString() + " AND UPPER(usuarioalt) = " + "'"
				+ usuarioalt.toUpperCase() + "'"
				+ "                              ) AND LL.idempresa = "
				+ idempresa
				+ " ORDER BY bcata.categoriasocio, cl.estado, LL.idcliente ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGestionTmCampaniaResultado() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGestionTmCampaniaResultado()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGestionTmCampaniaResultado2(BigDecimal idtelemark,
			BigDecimal idcampacabe, BigDecimal idresultado,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " "
				+ "SELECT LL.idCampaCabe, cab.campacabe, LL.idcliente, CL.razon, cp.fechadeingreso,"
				+ "       LL.socioTelefono, LL.fechaRellamada, cl.estado, cl.motivo, LL.observaciones, bcata.categoriasocio "
				+ "  FROM bacotmllamados LL "
				+ "       INNER JOIN vclientesestadoshoy cl ON LL.idcliente = cl.idcliente AND LL.idempresa = cl.idempresa "
				+ "       INNER JOIN clientesprecargaclientes cp ON LL.idcliente = cp.idcliente AND LL.idempresa = cp.idempresa "
				+ "       INNER JOIN bacotmcampacabe cab ON LL.idcampacabe = cab.idcampacabe AND LL.idempresa = cab.idempresa  "
				+ "        LEFT JOIN bacotmcategorizaciones bcat ON LL.idcliente = bcat.idcliente AND LL.idempresa = bcat.idempresa AND bcat.fhasta IS NULL "
				+ "        LEFT JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio "
				+ "              AND bcat.idempresa = bcata.idempresa "
				+ " WHERE LL.idResultado = "
				+ idresultado.toString()
				+ "   AND LL.idCampaCabe = "
				+ idcampacabe.toString()
				+ " AND UPPER(LL.usuarioalt) = "
				+ "'"
				+ usuarioalt.toUpperCase()
				+ "'"
				// MANTIS 426
				// + " and LL.fechaRellamada <= now() "
				// 20091015 - EJV REDEFINIDO
				// +
				// "   AND LL.fechaRellamada  BETWEEN CURRENT_DATE::TIMESTAMP  AND CURRENT_TIMESTAMP "
				+ "   AND LL.fechaRellamada  <= CURRENT_TIMESTAMP "
				+ "   AND LL.idLlamado = ("
				+ "                SELECT MAX(idLlamado) "
				+ "                  FROM bacotmllamados "
				+ "                 WHERE idcliente =  LL.idcliente and idCampaCabe = "
				+ idcampacabe.toString() + "   AND UPPER(usuarioalt) = " + "'"
				+ usuarioalt.toUpperCase() + "') AND LL.idempresa = "
				+ idempresa + " ORDER BY LL.fechaRellamada DESC";

		// log.info("QUERY: " + cQuery);

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGestionTmCampaniaResultado2() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGestionTmCampaniaResultado2()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getZonaLovAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idzona,zona,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM clienteszonas "
				+ " where idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getZonaLovAll() "
					+ sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getZonaLovAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getZonaLovOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT  idzona,zona,usuarioalt,usuarioact,fechaalt,fechaact FROM clienteszonas "
				+ " where "
				+ " idempresa = "
				+ idempresa.toString()
				+ " and (idzona::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(zona) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getZonaLovOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getZonaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getBajasporVendedor(String anio, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select * from vbacoclientesaltasvsbajas "
				+ "  where anio = " + anio.toString() + " and idempresa = "
				+ idempresa.toString() + " order by  vendedor,anio, idmes ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getBajasporVendedor() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBajasporVendedor()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesConsultadeEstados(String fdesde, String fhasta,
			BigDecimal idestado, String criterio, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;

		String filtroFecha = (criterio.equalsIgnoreCase("M") ? "   AND veh.fechadesde  "
				: "   AND veh.fechaalt::DATE ")
				+ " BETWEEN '"
				+ fdesde.toString()
				+ "'  AND '"
				+ fhasta.toString() + "'";

		String cQuery = ""
				// 20110405 - EJV - Mantis 699 -->
				// +
				// " SELECT veh.idcliente, cc.razon, cv.vendedor, veh.fechadesde, cm.motivo, veh.observaciones "
				+ " SELECT tc.idtipoclie, tc.tipoclie, veh.idcliente, cc.razon, cv.vendedor, veh.fechadesde, cm.motivo, veh.observaciones, veh.usuarioalt, veh.fechaalt  "
				// <--
				+ "   FROM clientesestadosclientes veh "
				+ "           INNER JOIN clientesclientes cc ON veh.idcliente = cc.idcliente AND veh.idempresa = cc.idempresa  "
				// 20110405 - EJV - Mantis 699 -->
				// +
				// "            LEFT JOIN clientesprecargaclientes cp ON veh.idcliente = cp.idcliente AND veh.idempresa = cp.idempresa  "
				+ "           INNER JOIN clientesprecargaclientes cp ON veh.idcliente = cp.idcliente AND veh.idempresa = cp.idempresa  "
				+ "           INNER JOIN clientestipoclie tc ON cc.idtipoclie = tc.idtipoclie AND cc.idempresa = tc.idempresa  "
				// <--
				+ "            LEFT JOIN clientesvendedor cv ON cp.idvendedorasignado = cv.idvendedor AND cp.idempresa = cv.idempresa  "
				+ "            LEFT JOIN clientesmotivos cm ON veh.idmotivo = cm.idmotivo AND veh.idempresa = cm.idempresa  "
				+ "WHERE veh.idestado = "
				+ idestado.toString()
				// 20110405 - EJV - Mantis 699 -->
				// + "   AND veh.fechadesde BETWEEN '" + fdesde.toString()
				// + "'  AND '" + fhasta.toString() + "'"
				+ filtroFecha
				// <--
				+ "   AND veh.idempresa = " + idempresa.toString()
				+ "  AND veh.fbaja IS NULL " + "ORDER BY 3, 4 ";

		List vecSalida = new ArrayList();

		try {

			// Statement statement = dbconn.createStatement();
			// rsSalida = statement.executeQuery(cQuery);
			// ResultSetMetaData md = rsSalida.getMetaData();
			// while (rsSalida.next()) {
			// int totCampos = md.getColumnCount() - 1;
			// String[] sSalida = new String[totCampos + 1];
			// int i = 0;
			// while (i <= totCampos) {
			// sSalida[i] = rsSalida.getString(++i);
			// }
			// vecSalida.add(sSalida);
			// }

			vecSalida = getLista(cQuery);

			// } catch (SQLException sqlException) {
			// log
			// .error("Error SQL en el metodo : getClientesConsultadeEstados() "
			// + sqlException);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConsultadeEstados()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesDiferenciaenPedidos(String anio, String mes,
			BigDecimal codigo_fm, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " clientesclientes.idcliente, "
				+ " clientesclientes.razon, "
				+ " count(pedidos_deta.cantidad) as cantidad "
				+ " from "
				+ " pedidos_cabe "
				+ " inner join pedidos_deta on pedidos_cabe.idpedido_cabe = pedidos_deta.idpedido_cabe and pedidos_cabe.idempresa = pedidos_deta.idempresa "
				+ " inner join clientesclientes on pedidos_cabe.idcliente = clientesclientes.idcliente and pedidos_cabe.idempresa = clientesclientes.idempresa "
				+ " inner join stockstock  on pedidos_deta.codigo_st = stockstock.codigo_st and pedidos_deta.idempresa = stockstock.idempresa "
				+ " inner join stockgrupos on stockstock.grupo_st = stockgrupos.codigo_gr and stockstock.idempresa = stockgrupos.idempresa "
				+ " inner join stockfamilias on stockgrupos.codigo_fm = stockfamilias.codigo_fm and stockgrupos.idempresa = stockfamilias.idempresa "
				+ " where  " + " pedidos_cabe.idestado = 1 "
				+ " AND date_part('year',  pedidos_deta.fecha) =  "
				+ anio.toString()
				+ " AND date_part('month', pedidos_deta.fecha) =  "
				+ mes.toString() + " and pedidos_cabe.idempresa = " + idempresa
				+ " and stockfamilias.codigo_fm  = " + codigo_fm.toString()
				+ " and pedidos_deta.porcdesc_apli = 0 " + " group by  "
				+ " clientesclientes.idcliente,  "
				+ " clientesclientes.razon  ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesDiferenciaenPedidos() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDiferenciaenPedidos()  "
							+ ex);
		}
		return vecSalida;
	}

	// levanto por cliente todas las suspensiones de entregas regulares
	public List getClientesSuspEntregaRegularporCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select"
				+ " idcodigo, "
				+ " anio, "
				+ " globalmeses.mes, "
				+ " clientessuspentregasregularesMotivos.motsusp,"
				+ " clientessuspentregasregulares.fbaja, "
				+ " clientessuspentregasregulares.usuarioalt,"
				+ " clientessuspentregasregulares.usuarioact,"
				+ " clientessuspentregasregulares.fechaalt,"
				+ " clientessuspentregasregulares.fechaact"
				+ " from clientessuspentregasregulares "
				+ " inner join globalmeses on clientessuspentregasregulares.mes = globalmeses.idmes "
				+ " left  join clientessuspentregasregularesMotivos on clientessuspentregasregulares.idmotsusp = clientessuspentregasregularesMotivos.idmotsusp and clientessuspentregasregulares.idempresa = clientessuspentregasregularesMotivos.idempresa "
				+ " where " + " clientessuspentregasregulares.idcliente = "
				+ idcliente.toString()
				+ " and clientessuspentregasregulares.idempresa = "
				+ idempresa.toString() + " order by 2 desc, 3 desc ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSuspEntregaRegularporCliente() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSuspEntregaRegularporCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	public String clientesSuspEntregasRegularesFBajaUpd(BigDecimal idcodigo,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcodigo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcodigo ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = ""
					+ "SELECT COUNT(*) FROM clientesSuspEntregasRegulares WHERE idcodigo = "
					+ idcodigo.toString() + " AND idempresa = "
					+ idempresa.toString() + " AND fbaja IS NULL ";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE clientessuspentregasregulares"
							+ "    SET fbaja=?,  usuarioact=?, fechaact=?"
							+ "  WHERE idcodigo=? AND idempresa=? AND fbaja IS NULL;";
					insert = dbconn.prepareStatement(sql);

					insert.setTimestamp(1, fechaact);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idcodigo);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i == 1)
						salida = "Suspension anulada correctamente.";
					else
						salida = "Inconsistencia de datos al anular suspension: "
								+ idcodigo;

				} else
					salida = "Imposible anular suspension, posiblemente afectada desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesSuspEntregasRegularesFBajaUpd(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesSuspEntregasRegularesFBajaUpd(.....)"
							+ ex);
		}
		return salida;
	}

	// BACO TIPO OBSEQUIOS
	public List getBacotipoobsequiosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT ti.idtipoobsequio, ti.tipoobsequio, ti.idmotivodescuento, md.motivodescuento, "
				+ "       ti.idempresa,ti.usuarioalt"
				+ "  FROM bacotipoobsequios ti "
				+ "       INNER JOIN pedidosmotivosdescuento md ON ti.idmotivodescuento = md.idmotivodescuento ANd ti.idempresa = md.idempresa "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getBacotipoobsequiosAll() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotipoobsequiosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getBacotipoobsequiosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT ti.idtipoobsequio, ti.tipoobsequio, ti.idmotivodescuento, md.motivodescuento, "
				+ "       ti.idempresa,ti.usuarioalt"
				+ "  FROM bacotipoobsequios ti "
				+ "       INNER JOIN pedidosmotivosdescuento md ON ti.idmotivodescuento = md.idmotivodescuento ANd ti.idempresa = md.idempresa "
				+ " WHERE ti.idempresa = " + idempresa.toString()
				+ " AND (ti.idtipoobsequio::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(ti.tipoobsequio) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getBacotipoobsequiosOcu(String ocurrencia) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotipoobsequiosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacotipoobsequiosPK(BigDecimal idtipoobsequio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT idtipoobsequio,tipoobsequio, idmotivodescuento from bacotipoobsequios "
				+ " where idtipoobsequio = "
				+ idtipoobsequio.toString()
				+ " and idempresa  = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getBacotipoobsequiosPK( BigDecimal idtipoobsequio ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotipoobsequiosPK( BigDecimal idtipoobsequio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String BacotipoobsequiosDelete(BigDecimal idtipoobsequio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM bacotipoobsequios "
				+ " WHERE idtipoobsequio= " + idtipoobsequio.toString()
				+ " and idempresa =" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM bacotipoobsequios WHERE idtipoobsequio="
						+ idtipoobsequio.toString() + "and idempresa = "
						+ idempresa.toString();

				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : BacotipoobsequiosDelete( BigDecimal idtipoobsequio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: BacotipoobsequiosDelete( BigDecimal idtipoobsequio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String BacotipoobsequiosCreate(String tipoobsequio,
			BigDecimal idmotivodescuento, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoobsequio ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO bacotipoobsequios(tipoobsequio, idmotivodescuento,usuarioalt,idempresa ) VALUES (?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:

				insert.setString(1, tipoobsequio);
				insert.setBigDecimal(2, idmotivodescuento);
				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);

				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String BacotipoobsequiosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String BacotipoobsequiosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String BacotipoobsequiosUpdate(BigDecimal idtipoobsequio,
			String tipoobsequio, BigDecimal idmotivodescuento,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoobsequio ";
		if (tipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoobsequio ";
		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotipoobsequios WHERE idtipoobsequio = "
					+ idtipoobsequio.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE bacotipoobsequios SET tipoobsequio =?, idmotivodescuento=?, usuarioact=?, fechaact=? WHERE idtipoobsequio=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoobsequio);
					insert.setBigDecimal(2, idmotivodescuento);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipoobsequio);
					insert.setBigDecimal(6, idempresa);
				}
				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String BacotipoobsequiosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String BacotipoobsequiosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// BUSQUEDA POR CLIENTE
	public List getGestionTmBusquedaporCliente(String buscarsocio,
			BigDecimal idtelemark, BigDecimal idcampacabe, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " "

				/*
				 * 20100201 - EJV ----> MANTIS: 456 - 503 - 504
				 */

				// +
				// "SELECT LL.idCampaCabe, cab.campacabe, LL.idcliente, CL.razon, cp.fechadeingreso,"
				// +
				// "       LL.socioTelefono, LL.fechaRellamada, cl.estado, cl.motivo, LL.observaciones, bcata.categoriasocio, CL.idempresa "
				// + "  FROM bacotmllamados LL "
				// +
				// "       INNER JOIN vclientesestadoshoy cl ON LL.idcliente = cl.idcliente AND LL.idempresa = cl.idempresa "
				// +
				// "       INNER JOIN clientesprecargaclientes cp ON LL.idcliente = cp.idcliente AND LL.idempresa = cp.idempresa "
				// +
				// "       INNER JOIN bacotmcampacabe cab ON LL.idcampacabe = cab.idcampacabe AND LL.idempresa = cab.idempresa  "
				// +
				// "        LEFT JOIN bacotmcategorizaciones bcat ON LL.idcliente = bcat.idcliente AND LL.idempresa = bcat.idempresa AND bcat.fhasta IS NULL "
				// +
				// "        LEFT JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio "
				// + "              AND bcat.idempresa = bcata.idempresa "
				// + " WHERE " + "   UPPER(LL.usuarioalt) = '"
				// + usuarioalt.toUpperCase() + "'  AND LL.idLlamado = ("
				// + "                        SELECT MAX(idLlamado) "
				// + "                          FROM bacotmllamados "
				// + "                         WHERE idcliente = LL.idcliente "
				// + " AND UPPER(usuarioalt) = " + "'" +
				// usuarioalt.toUpperCase()
				// + "'" + "                              )"
				// + " and (LL.idcliente::VARCHAR LIKE '%" + buscarsocio
				// + "%' OR " + " UPPER(CL.razon) LIKE '%"
				// + buscarsocio.toUpperCase() + "%') "
				// + "   AND cab.idcampacabe = " + idcampacabe
				// +
				// " ORDER BY origen, bcata.categoriasocio, cl.estado, LL.idcliente ";
				/*
				 * 
				 * EJV <------
				 */

				// +
				+ " SELECT tms.idCampaCabe, cab.campacabe, tms.idcliente, cl.razon,  "
				+ "        cp.fechadeingreso, ll.socioTelefono, ll.fechaRellamada, "
				+ "        cl.estado, cl.motivo, ll.observaciones, bcata.categoriasocio, cl.idempresa "
				+ "  FROM  bacotmseleccionsocio tms  "
				+ "        INNER JOIN bacotmcampacabe cab ON tms.idcampacabe = cab.idcampacabe AND tms.idempresa = cab.idempresa "
				+ "        INNER JOIN vclientesestadoshoy cl ON tms.idcliente = cl.idcliente "
				+ "               AND tms.idempresa = cl.idempresa  "
				+ "        INNER JOIN clientesprecargaclientes cp ON tms.idcliente = cp.idcliente AND tms.idempresa = cp.idempresa "
				+ "        INNER JOIN bacotmcampacabe bc ON tms.idcampacabe = bc.idcampacabe "
				+ "               AND tms.idempresa = bc.idempresa  "
				+ "         LEFT JOIN bacotmllamados ll ON tms.idcliente = ll.idcliente AND tms.idcampacabe = ll.idcampacabe AND tms.idempresa = ll.idempresa "
				+ "               AND ll.idLlamado = ( "
				+ "			          SELECT MAX(idllamado)   "
				+ "			            FROM bacotmllamados   "
				+ "			           WHERE idcliente = ll.idcliente "
				+ "			             AND idempresa = ll.idempresa "
				+ "			             AND idcampacabe =   "
				+ idcampacabe
				+ "			        )   "
				+ "         LEFT JOIN bacotmcategorizaciones bcat ON tms.idcliente = bcat.idcliente "
				+ "               AND tms.idempresa = bcat.idempresa AND bcat.fhasta IS NULL  "
				+ "         LEFT JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio "
				+ "               AND bcat.idempresa = bcata.idempresa "
				+ "   WHERE tms.idtelemark =  " + idtelemark
				+ "     AND tms.idcampacabe =  " + idcampacabe
				+ "     AND tms.idempresa =  " + idempresa
				+ "     AND (cl.idcliente::VARCHAR LIKE '%"
				+ buscarsocio.toUpperCase() + "%' OR UPPER(cl.razon) LIKE '%"
				+ buscarsocio.toUpperCase() + "%') "
				+ "   ORDER BY bcata.categoriasocio, cl.estado, ll.idcliente ";

		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGestionTmBusquedaporCliente() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGestionTmBusquedaporCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	public static String getCallingMethodName() {

		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		PrintWriter printWriter = new PrintWriter(byteArrayOutputStream);
		(new Throwable()).printStackTrace(printWriter);
		printWriter.flush();
		String stackTrace = byteArrayOutputStream.toString();
		printWriter.close();

		StringTokenizer stringTokenizer = new StringTokenizer(stackTrace, "\n");

		// Line 1 -- java.lang.Throwable
		stringTokenizer.nextToken();

		// Line 2 -- "at thisClass.thisMethod(file.java:line)"
		stringTokenizer.nextToken();

		// Line 3 -- "at callingClass.callingMethod(file.java:line)"
		stringTokenizer.nextToken();

		// Line 4 -- "at originalClass.callingMethod(file.java:line)"
		String methodName = stringTokenizer.nextToken();
		stringTokenizer = new StringTokenizer(methodName.trim(), " (");
		stringTokenizer.nextToken();
		methodName = stringTokenizer.nextToken();

		// Return originalClass.callingMethod
		return methodName;
	}

	public static String getCallingMethodName(int stackLevel) {

		/*
		 * 0 - dumpThreads.................................................... 1
		 * - getStackTrace.................................................. 2 -
		 * thisMethod => getCurrentMethodNameFromThread................... 3 -
		 * callingMethod => method calling thisMethod..................... 4 -
		 * method calling callingMethod...................................
		 */

		// for (int s = 0; s < Thread.currentThread().getStackTrace().length;
		// s++)
		// log.info("-- < getStackTrace()[" + s + "]: "
		// + Thread.currentThread().getStackTrace()[s]);
		StackTraceElement stackTraceElement = Thread.currentThread()
				.getStackTrace()[3 + stackLevel];

		String className = stackTraceElement.getClassName();
		String methodName = stackTraceElement.getMethodName();

		log.info("getCallingMethodName():" + className + "." + methodName);

		return className + "." + methodName;

	}

	// pedido amelia para modificar solicitud de Reactivacion FGP 03/02/2010
	public List ClientesesstadosbajasuspensionlargaMod(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select cr.idreactivacion,vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO',cv.vendedor) as vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " inner join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " inner JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa "
				+ " where "
				+ " vceh.idempresa = "
				+ idempresa.toString()
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and fechabaja is null "
				+ " ORDER BY 1  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : ClientesesstadosbajasuspensionlargaMod() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: ClientesesstadosbajasuspensionlargaMod()  "
							+ ex);
		}
		return vecSalida;
	}

	public List ClientesesstadosbajasuspensionlargaOcuMod(long limit,
			long offset, BigDecimal idempresa, String ocurrencia)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select cr.idreactivacion,vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,COALESCE(cv.vendedor,'NO ASIGNADO',cv.vendedor) as vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " inner join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " inner JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa "
				+ " where " + " vceh.idempresa = "
				+ idempresa.toString()
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and fechabaja is null "
				+ " and (vceh.idcliente::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(vceh.razon) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(vceh.motivo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR "
				+ " UPPER(cv.vendedor) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " group by vceh.idcliente,vceh.razon,vceh.estado,vceh.motivo,cv.vendedor "
				+ "ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : ClientesesstadosbajasuspensionlargaOcuMod() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: ClientesesstadosbajasuspensionlargaOcuMod()  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEntidadporempresaEstadoMod(BigDecimal idempresa)
			throws EJBException {
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " inner join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " inner JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and fechabaja is null ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadporempresaEstadoMod()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadporempresaEstadoMod()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadporempresaEstadoMod()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getTotalEntidadOcuporempresaEstadoMod(String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "select count(*) as total  "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " inner join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " inner JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa "
				+ " where " + " vceh.idempresa = " + idempresa.toString()
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and fechabaja is null " + " and ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND vceh.idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadOcuporempresaEstadoMod()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcuporempresaEstado()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadOcuporempresaEstadoMod()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public List globalUpdatePKMod(BigDecimal idreactivacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "select cr.idreactivacion,cr.porcreact,cr.fechareactivacion,cv.idvendedor,cv.vendedor "
				+ " from vclientesestadoshoy  vceh "
				+ " left join clientesprecargaclientes cp on vceh.idcliente = cp.idcliente and vceh.idempresa = cp.idempresa "
				+ " inner join clientesreactivaciones cr on vceh.idcliente = cr.idcliente AND vceh.idempresa= cr.idempresa  "
				+ " inner JOIN clientesvendedor cv ON cr.idvendedor = cv.idvendedor AND cr.idempresa = cv.idempresa "
				+ " where "
				+ " vceh.idempresa = "
				+ idempresa.toString()
				+ " and cr.idreactivacion = "
				+ idreactivacion.toString()
				+ " and cr.idestadoreactivaciones = 1 "
				+ " and fechabaja is null " + " ORDER BY 1  ";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGlobalcontadoresPK( BigDecimal idcontador ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalcontadoresPK( BigDecimal idcontador )  "
							+ ex);
		}
		return vecSalida;
	}

	public String isManager(String usuario) throws EJBException {
		String salida = "N";
		String cQuery = "select count(*) as total from globalusuarios ";
		cQuery += "where upper(usuario) = '" + usuario.toUpperCase() + "' ";
		cQuery += "and idusuario in (select idusuario from globalusuariosgrupos ";
		cQuery += " where idgrupo in (select idgrupo from globalgrupos where upper(grupo) like '%MANAGER%' )  );";
		try {
			ResultSet rsSalida = null;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				int total = rsSalida.getInt("total");
				if (total > 0)
					salida = "S";
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : isManager(String usuario) "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isManager(String usuario)  "
							+ ex);
		}
		log.info("es manager? " + usuario + " :" + salida);
		return salida;
	}

	public static boolean generaArchivo(String source, String archivo,
			String path) throws FileNotFoundException, IOException {

		boolean generacion = false;
		try {

			archivo = path + archivo;
			OutputStream aFile = new FileOutputStream(archivo);
			aFile.flush();
			aFile.write(source.getBytes());
			aFile.flush();
			aFile.close();
			generacion = true;

		} catch (Exception e) {

			generacion = false;
			log.error("generaArchivo(...): " + e);

		}

		return generacion;

	}

	/** Comprime el contenido de un directorio y lo guarda en un unico archivo */
	public static void zipDirectory(String dir, String zipfile)
			throws IOException, IllegalArgumentException {
		// Verifica que el "directorio" sea un directorio y lee su contenido
		File d = new File(dir);
		if (!d.isDirectory())
			throw new IllegalArgumentException("Not a directory:  " + dir);
		String[] entries = d.list();
		byte[] buffer = new byte[4096]; // Crea buffer para copiar
		int bytesRead;

		ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile));

		for (int i = 0; i < entries.length; i++) {
			File f = new File(d, entries[i]);
			if (f.isDirectory())
				continue;// Ignora directorio
			FileInputStream in = new FileInputStream(f); // Stream a leer
			// file
			ZipEntry entry = new ZipEntry(f.getPath()); // Crea entrada zip
			out.putNextEntry(entry); // Almacena entrada
			while ((bytesRead = in.read(buffer)) != -1)
				out.write(buffer, 0, bytesRead);
			in.close();
		}
		out.close();
	}

	/** Comprime los archivos que se encuentran en un directorio determinado */
	public static boolean zipFile(File file, String zipfile)
			throws EJBException, IOException, IllegalArgumentException {

		boolean zipStatus = false;

		try {

			// Verifica que el "archivo" no sea un directorio y lee su contenido
			if (file.isDirectory())
				throw new IllegalArgumentException("Es un directorio:  "
						+ file.getName());

			byte[] buffer = new byte[4096]; // Crea buffer para copiar
			int bytesRead;

			ZipOutputStream out = new ZipOutputStream(new FileOutputStream(
					zipfile));

			FileInputStream in = new FileInputStream(file); // Stream a leer
			ZipEntry entry = new ZipEntry(file.getName()); // Crea entrada
			out.putNextEntry(entry); // Almacena entrada
			while ((bytesRead = in.read(buffer)) != -1) {
				out.write(buffer, 0, bytesRead);
			}
			in.close();
			out.close();
			zipStatus = true;
		} catch (Exception e) {
			// TODO: handle exception
			zipStatus = false;
			log.error("zipFile - Error al comprimir archivo: " + e);
		}

		return zipStatus;

	}

	/*
	 * Metodos para la entidad: bacotmliquidacionresumen Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Mar 02 15:34:16 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacotmliquidacionresumenAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT idliquidacion,anio,mes,usuario,comision_vc,total_vc,comision_vv,total_vv,comision_ve,total_ve,comision_vc_jf,total_vc_jf,comision_vv_jf,total_vv_jf,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMLIQUIDACIONRESUMEN WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmliquidacionresumenAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacotmliquidacionresumenOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idliquidacion,anio,mes,usuario,comision_vc,total_vc,comision_vv,total_vv,comision_ve,total_ve,comision_vc_jf,total_vc_jf,comision_vv_jf,total_vv_jf,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMLIQUIDACIONRESUMEN WHERE (UPPER(ANIO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmliquidacionresumenOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacotmliquidacionresumenPK(BigDecimal idliquidacion,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idliquidacion,anio,mes,usuario,comision_vc,total_vc,comision_vv,total_vv,comision_ve,total_ve,comision_vc_jf,total_vc_jf,comision_vv_jf,total_vv_jf,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMLIQUIDACIONRESUMEN WHERE idliquidacion="
				+ idliquidacion.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmliquidacionresumenPK( BigDecimal idliquidacion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacotmliquidacionresumenDelete(BigDecimal idliquidacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMLIQUIDACIONRESUMEN WHERE idliquidacion="
				+ idliquidacion.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMLIQUIDACIONRESUMEN WHERE idliquidacion="
						+ idliquidacion.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacotmliquidacionresumenDelete( BigDecimal idliquidacion, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacotmliquidacionresumenDelete( BigDecimal idliquidacion, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacotmliquidacionresumenCreate(BigDecimal anio,
			BigDecimal mes, String usuario, BigDecimal comision_vc,
			BigDecimal total_vc, BigDecimal comision_vv, BigDecimal total_vv,
			BigDecimal comision_ve, BigDecimal total_ve,
			BigDecimal comision_vc_jf, BigDecimal total_vc_jf,
			BigDecimal comision_vv_jf, BigDecimal total_vv_jf,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (comision_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc ";
		if (total_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc ";
		if (comision_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv ";
		if (total_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv ";
		if (comision_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_ve ";
		if (total_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_ve ";
		if (comision_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc_jf ";
		if (total_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc_jf ";
		if (comision_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv_jf ";
		if (total_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv_jf ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMLIQUIDACIONRESUMEN(anio, mes, usuario, comision_vc, total_vc, comision_vv, total_vv, comision_ve, total_ve, comision_vc_jf, total_vc_jf, comision_vv_jf, total_vv_jf, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, anio);
				insert.setBigDecimal(2, mes);
				insert.setString(3, usuario);
				insert.setBigDecimal(4, comision_vc);
				insert.setBigDecimal(5, total_vc);
				insert.setBigDecimal(6, comision_vv);
				insert.setBigDecimal(7, total_vv);
				insert.setBigDecimal(8, comision_ve);
				insert.setBigDecimal(9, total_ve);
				insert.setBigDecimal(10, comision_vc_jf);
				insert.setBigDecimal(11, total_vc_jf);
				insert.setBigDecimal(12, comision_vv_jf);
				insert.setBigDecimal(13, total_vv_jf);
				insert.setBigDecimal(14, idempresa);
				insert.setString(15, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacotmliquidacionresumenCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmliquidacionresumenCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacotmliquidacionresumenCreateOrUpdate(
			BigDecimal idliquidacion, BigDecimal anio, BigDecimal mes,
			String usuario, BigDecimal comision_vc, BigDecimal total_vc,
			BigDecimal comision_vv, BigDecimal total_vv,
			BigDecimal comision_ve, BigDecimal total_ve,
			BigDecimal comision_vc_jf, BigDecimal total_vc_jf,
			BigDecimal comision_vv_jf, BigDecimal total_vv_jf,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idliquidacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idliquidacion ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (comision_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc ";
		if (total_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc ";
		if (comision_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv ";
		if (total_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv ";
		if (comision_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_ve ";
		if (total_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_ve ";
		if (comision_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc_jf ";
		if (total_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc_jf ";
		if (comision_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv_jf ";
		if (total_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv_jf ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmliquidacionresumen WHERE idliquidacion = "
					+ idliquidacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMLIQUIDACIONRESUMEN SET anio=?, mes=?, usuario=?, comision_vc=?, total_vc=?, comision_vv=?, total_vv=?, comision_ve=?, total_ve=?, comision_vc_jf=?, total_vc_jf=?, comision_vv_jf=?, total_vv_jf=?, idempresa=?, usuarioact=?, fechaact=? WHERE idliquidacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, mes);
					insert.setString(3, usuario);
					insert.setBigDecimal(4, comision_vc);
					insert.setBigDecimal(5, total_vc);
					insert.setBigDecimal(6, comision_vv);
					insert.setBigDecimal(7, total_vv);
					insert.setBigDecimal(8, comision_ve);
					insert.setBigDecimal(9, total_ve);
					insert.setBigDecimal(10, comision_vc_jf);
					insert.setBigDecimal(11, total_vc_jf);
					insert.setBigDecimal(12, comision_vv_jf);
					insert.setBigDecimal(13, total_vv_jf);
					insert.setBigDecimal(14, idempresa);
					insert.setString(15, usuarioact);
					insert.setTimestamp(16, fechaact);
					insert.setBigDecimal(17, idliquidacion);
				} else {
					String ins = "INSERT INTO BACOTMLIQUIDACIONRESUMEN(anio, mes, usuario, comision_vc, total_vc, comision_vv, total_vv, comision_ve, total_ve, comision_vc_jf, total_vc_jf, comision_vv_jf, total_vv_jf, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, mes);
					insert.setString(3, usuario);
					insert.setBigDecimal(4, comision_vc);
					insert.setBigDecimal(5, total_vc);
					insert.setBigDecimal(6, comision_vv);
					insert.setBigDecimal(7, total_vv);
					insert.setBigDecimal(8, comision_ve);
					insert.setBigDecimal(9, total_ve);
					insert.setBigDecimal(10, comision_vc_jf);
					insert.setBigDecimal(11, total_vc_jf);
					insert.setBigDecimal(12, comision_vv_jf);
					insert.setBigDecimal(13, total_vv_jf);
					insert.setBigDecimal(14, idempresa);
					insert.setString(15, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacotmliquidacionresumenCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmliquidacionresumenCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacotmliquidacionresumenUpdate(BigDecimal idliquidacion,
			BigDecimal anio, BigDecimal mes, String usuario,
			BigDecimal comision_vc, BigDecimal total_vc,
			BigDecimal comision_vv, BigDecimal total_vv,
			BigDecimal comision_ve, BigDecimal total_ve,
			BigDecimal comision_vc_jf, BigDecimal total_vc_jf,
			BigDecimal comision_vv_jf, BigDecimal total_vv_jf,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idliquidacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idliquidacion ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (usuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (comision_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc ";
		if (total_vc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc ";
		if (comision_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv ";
		if (total_vv == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv ";
		if (comision_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_ve ";
		if (total_ve == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_ve ";
		if (comision_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vc_jf ";
		if (total_vc_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vc_jf ";
		if (comision_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision_vv_jf ";
		if (total_vv_jf == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total_vv_jf ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (usuario.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuario ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmliquidacionresumen WHERE idliquidacion = "
					+ idliquidacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMLIQUIDACIONRESUMEN SET anio=?, mes=?, usuario=?, comision_vc=?, total_vc=?, comision_vv=?, total_vv=?, comision_ve=?, total_ve=?, comision_vc_jf=?, total_vc_jf=?, comision_vv_jf=?, total_vv_jf=?, idempresa=?, usuarioact=?, fechaact=? WHERE idliquidacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, mes);
					insert.setString(3, usuario);
					insert.setBigDecimal(4, comision_vc);
					insert.setBigDecimal(5, total_vc);
					insert.setBigDecimal(6, comision_vv);
					insert.setBigDecimal(7, total_vv);
					insert.setBigDecimal(8, comision_ve);
					insert.setBigDecimal(9, total_ve);
					insert.setBigDecimal(10, comision_vc_jf);
					insert.setBigDecimal(11, total_vc_jf);
					insert.setBigDecimal(12, comision_vv_jf);
					insert.setBigDecimal(13, total_vv_jf);
					insert.setBigDecimal(14, idempresa);
					insert.setString(15, usuarioact);
					insert.setTimestamp(16, fechaact);
					insert.setBigDecimal(17, idliquidacion);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacotmliquidacionresumenUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacotmliquidacionresumenUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getVendedoresAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		String cQuery = "select idusuario,usuario from globalusuarios where idempresa ="
				+ idempresa.toString() + " order by usuario asc";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVendedoresAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getVentasPorVendedor(String vendedor, BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "select codigo_st,importe_fc,cantidad,total,comision,importe_com from bacotmliquidacion "
				+ " where usuario = '"
				+ vendedor
				+ "' and idcampacabe = "
				+ idcampania + " and idempresa= " + idempresa.toString();

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVentasPorVendedor()  "
							+ ex);
		}
		return vecSalida;

	}

	public List getBacotmliquidacionresumenParametros(String usuario,
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT idliquidacion,idcampacabe,usuario,comision_vc,total_vc,comision_vv,total_vv,comision_ve,total_ve FROM BACOTMLIQUIDACIONRESUMEN WHERE usuario = '"
				+ usuario
				+ "' and idcampacabe="
				+ idcampania
				+ " and idempresa = " + idempresa.toString();

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmliquidacionresumenParametros()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getCampanias() throws EJBException {
		String cQuery = "Select idcampacabe,campacabe from bacotmcampacabe  order by 1 desc  ";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getCampanias()  "
					+ ex);
		}
		return vecSalida;
	}

	// 20110505 -CAMI- Liquidacion a telemarketers
	public List getVendedoresTelemarketers() throws EJBException {
		ResultSet rs = null;
		BigDecimal idgrupo = new BigDecimal(-1);
		String cQuery = "Select idgrupo from globalgrupos where grupo = upper('telemarketing')";
		List vecSalida = new ArrayList();
		try {
			Statement statement = dbconn.createStatement();
			rs = statement.executeQuery(cQuery);
			while (rs != null && rs.next()) {
				idgrupo = rs.getBigDecimal("idgrupo");
				cQuery = "Select gu.idusuario, gu.usuario from globalusuariosgrupos gug "
						+ " inner join  globalusuarios gu on (gug.idusuario = gu.idusuario)  where idgrupo = "
						+ idgrupo + " order by gu.usuario asc";
			}
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVendedoresTelemarketers()  "
							+ ex);
		}
		return vecSalida;
	}

	// 20110614 -CAMI - Diseño de registros -->
	// public void setArchivoDiners() throws EJBException {
	// /**
	// * Select deta.fecha, cabe.idcliente, deta.precio, clitar.nrotarjeta
	// * from pedidos_cabe cabe inner join clientetarjetascredito clitar on
	// * (cabe.idcliente = clitar.idcliente) inner join pedidos_deta deta on
	// * (deta.idpedido_cabe = cabe.idpedido_cabe) where
	// * clitar.idtarjetacredito = 3 and fecha between '2011-01-01 00:00:00'
	// * and '2011-01-25 23:59:59'
	// * */
	// // Primer archivo a generar: los registros con los datos
	// BigDecimal contador = new BigDecimal(0);
	// String nombre = "pruebadiners";
	// try {
	// // CONSUMOS DE LA PRESENTACION
	// String contenido = "";
	// // path + extensión del archivo
	// String path = reportes + nombre + ".txt";
	// // 01-06
	// // fecha (Día del consumo,Mes del consumo,Año del consumo[ult. 2
	// // digitos]) DDMMAA sin barras
	// contenido += "130611";
	// // 07-10
	// // cod autorizacion
	// contenido += "0000";
	// // 11-12
	// contenido += "20";
	// // 13-24
	// for (int i = 0; i < 12; i++) {
	// // blanco
	// contenido += " ";
	// }
	// // 25-38
	// // Socio Diners (es el numero de tarjeta?)
	// contenido += "12345678901236";
	//
	// // 39-48
	// for (int i = 1; i <= 10; i++) {
	// // blanco
	// contenido += " ";
	// }
	// // 49-58
	// // Versión con formato LLLLNNNN donde LLLL= iniciales comercio y
	// // NNNNNN=ddmmaa (ultimos 2 digitos del año)
	// contenido += "BACO130611";
	// // 59-88
	// String nrocli = "01041836";
	// int lennrocli = nrocli.length();
	// int hastanrocli = 29 - lennrocli;
	// if (hastanrocli != 0) {
	// for (int i = 0; i <= hastanrocli; i++) {
	// // nro cliente comercio (se rellena con espacios a la
	// // izquierda
	// // hasta completar)
	// contenido += " ";
	// }
	// }
	// contenido += nrocli;
	// // 89-96
	// for (int i = 0; i <= 7; i++) {
	// // blanco
	// contenido += " ";
	// }
	// // 97-107
	// // Codigo establecimiento
	// contenido += "01184266003";
	// // 108-117
	// // Importe (SIN DECIMALES, COMAS PUNTOS [10,65 = 1065]
	// String importe = "123456";
	// int lenimporte = importe.length();
	// int hastaimporte = 9 - lenimporte;
	// if (hastaimporte != 0) {
	// for (int i = 0; i <= hastaimporte; i++) {
	// // importe
	// contenido += "0";
	// }
	// }
	// contenido += importe;
	// // 118-118
	// // debito /credito D = consumo, C = credito al socio
	// contenido += "C";
	// // 119-121
	// // Blanco
	// contenido += "   ";
	// // 122-125
	// // cuenta debito autom QUE ES?
	// // 0107 está sacado del ejemplo de diners
	// contenido += "0107";
	// // 126-126
	// contenido += " ";
	// // 127-128
	// contenido += "00";
	//
	// contenido += "\n";
	// contador = contador.add(new BigDecimal(1));
	// log.info("cantidad de caracteres: " + contenido.length());
	//
	// boolean resul = GeneraArchivo(path, contenido);
	// if (resul) {
	// String control = "CONTROL";
	// path = reportes + control + ".txt";
	// contenido = "";
	// // 01-04
	// // constante
	// contenido += "*CTL";
	// // 05-24(19)
	// // nombre del archivo
	// contenido += nombre;
	// int lennombre = nombre.length();
	// int hastanombre = 19 - lennombre;
	// if (hastanombre != 0) {
	// for (int i = 0; i <= hastanombre; i++) {
	// contenido += " ";
	// }
	// }
	// // 25-34
	// // version LLLLNNNNNN
	// contenido += "BACO130611";
	// // 35-41
	// // cant. de registros
	//
	// int lencontador = contador.toString().length();
	// int hastacontador = 6 - lencontador;
	// if (hastacontador != 0) {
	// for (int i = 0; i <= hastacontador; i++) {
	// contenido += "0";
	// }
	// }
	// contenido += contador;
	// // 42-56
	// // sumatoria de control (dos decimales)
	// // IMPORTES DE PRUEBA !
	// String sumatoria = "123456";
	// int lensumatoria = sumatoria.length();
	// int hastasumatoria = 14 - lensumatoria;
	// if (hastasumatoria != 0) {
	// for (int i = 0; i <= hastasumatoria; i++) {
	// // importe
	// contenido += "0";
	// }
	// }
	// contenido += sumatoria;
	// contenido += "\n";
	// log.info("Cantidad de caracteres:" + contenido.length());
	// GeneraArchivo(path, contenido);
	// }
	//
	// } catch (Exception ex) {
	// log
	// .info("Error: setArchivo(List lista, BigDecimal columnas, String nombre) "
	// + ex);
	// }
	// }

	// public boolean GeneraArchivo(String archivo, String source)
	// throws FileNotFoundException, IOException {
	// try {
	// final String DEFAULT_ENCODING = System.getProperty("file.encoding");
	// // log.debug("file.encoding: " + DEFAULT_ENCODING);
	// OutputStream aFile = new FileOutputStream(archivo);
	// aFile.write(source.getBytes());
	// aFile.close();
	// if (System.getProperty("file.separator").equals("\\"))
	// log.debug("ARCH. OK: "
	// + archivo.substring(archivo.lastIndexOf(92) + 1));
	// else if (System.getProperty("file.separator").equals("/"))
	// log.debug("ARCH. OK: "
	// + archivo.substring(archivo.lastIndexOf(47) + 1));
	// return true;
	// } catch (Exception e) {
	// return false;
	// }
	//
	// }

	/**
	 * Metodos para la entidad: cajaSucursalesContadores Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Jun 17 09:59:28 ART 2011
	 */

	public static BigDecimal getCajaSucursalesContadoresProximo(
			BigDecimal nrosucursal, String condicionletra, BigDecimal tipomov,
			BigDecimal idempresa, Connection conn) {
		BigDecimal proximo = BigDecimal.valueOf(-1);
		ResultSet rsSalida = null;
		String auxMsg = "" + strZero(nrosucursal.toString(), 4) + " - "
				+ condicionletra + " - " + tipomov;
		try {

			String cQuery = "SELECT proximo FROM cajasucursalescontadores WHERE nrosucursal="
					+ nrosucursal.toString()
					+ " AND condicionletra = '"
					+ condicionletra.toUpperCase()
					+ "' AND tipomov = "
					+ tipomov.toString()
					+ " AND idempresa = "
					+ idempresa.toString() + ";";

			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				proximo = rsSalida.getBigDecimal("proximo");

				cQuery = "UPDATE cajasucursalescontadores SET proximo = (proximo + 1) "
						+ "WHERE nrosucursal="
						+ nrosucursal.toString()
						+ " AND condicionletra = '"
						+ condicionletra.toUpperCase()
						+ "' AND tipomov = "
						+ tipomov.toString()
						+ " AND idempresa = "
						+ idempresa.toString() + ";";

				int i = statement.executeUpdate(cQuery);
				if (i == 0) {
					proximo = BigDecimal.valueOf(-1);
					log.warn("getCajaSucursalesContadoresProximo(" + auxMsg
							+ ") - Error al actualizar proximo nro contador. ");
				}

			} else {
				log.warn("getCajaSucursalesContadoresProximo(" + auxMsg
						+ ") - Error al recuperar proximo nro contador. ");
			}
		} catch (SQLException sqlException) {
			log.error("getCajaSucursalesContadoresProximo(" + auxMsg
					+ ")- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getCajaSucursalesContadoresProximo(" + auxMsg
					+ ")- Salida por exception: " + ex);
		}
		return proximo;
	}

	public static String setLockedTable(String entidad, String mode,
			Connection conn) throws EJBException {

		/*
		 * TODO: Manejar distintos tipos de acceso. ACCESS SHARE; ROW.SHARE;
		 * ROW.EXCLUSIVE; SHARE.UPDATE.EXCLUSIVE; SHARE; SHARE.ROW.EXCLUSIVE;
		 * EXCLUSIVE; ACCESS.EXCLUSIVE
		 */

		String salida = "OK";

		try {
			String cQuery = "";
			// TODO: Momentaneamente en acceso exclusivo, ver la posiblidad de
			// mejorar el metodo.
			cQuery = "LOCK TABLE " + entidad + " IN ACCESS EXCLUSIVE  MODE;";

			Statement statement = conn.createStatement();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "(SQLE)Error al generar lock en entidad: " + entidad;
			log.error("setLockedTable(String " + entidad + ")- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Error al generar lock en entidad: " + entidad;
			log.error("setLockedTable(String " + entidad
					+ ")- Salida por exception: " + ex);
		}
		return salida;
	}

	/**
	 * @author ejv
	 * @date 20110624
	 * 
	 *       Metodo de validacion de Clave de Identificacion Unica
	 *       [Tributaria(CUIT)-Laboral(CUIL)]
	 * 
	 * 
	 *       TIPO: Físicas (Hombres, Mujeres) o Jurídicas 27-mujer 20-hombre
	 *       23-puede ser ambos (se usa cuando hay otro número igual)
	 *       30-empresas
	 * 
	 *       Duplicado en Common.
	 * 
	 * */

	public boolean validarClaveIdentificacionUnica(String clave) {

		boolean cuitCuilValido = false;

		String identificador = (clave == null ? "" : clave).replaceAll("-", "")
				.trim();
		String tipo = "";
		String numero = "";
		String digitoIngresado = "";
		int digitoValido = -1;
		Hashtable htTiposValidos = new Hashtable();

		htTiposValidos.put("27", "MUJER");
		htTiposValidos.put("20", "HOMBRE");
		htTiposValidos.put("23", "AMBOS");
		// --
		htTiposValidos.put("24", "HOMBRE?");
		htTiposValidos.put("30", "EMPRESA");
		// --
		htTiposValidos.put("33", "EMPRESA?");
		htTiposValidos.put("34", "EMPRESA?");

		try {

			if (!esEntero(identificador)) {
				// Caracteres invalidos
				log
						.warn("validarClaveIdentificacionUnica: Caracteres invalidos en CUIT-CUIL - "
								+ clave);
			} else if (identificador.length() < 4) {
				// Longitud minima
				log
						.warn("validarClaveIdentificacionUnica: Longitud no alcanza la minima CUIT-CUIL - "
								+ clave);

			} else if (identificador.length() > 11) {
				// Longitud minima
				log
						.warn("validarClaveIdentificacionUnica: Longitud excede la maxima CUIT-CUIL - "
								+ clave);
			} else {

				tipo = identificador.substring(0, 2);
				numero = identificador.substring(2, identificador.length() - 1);
				digitoIngresado = identificador.substring(identificador
						.length() - 1);

				if (!htTiposValidos.containsKey(tipo)) {

					// Tipo invalido
					log
							.warn("validarClaveIdentificacionUnica: Tipo invalido CUIT-CUIL - "
									+ clave);

				} else {

					numero = tipo + strZero(numero, 8);
					int suma = 0;
					int modSumaOnce = 0;
					for (int i = 9, factor = 2; i >= 0; i--, factor++) {
						if (factor > 7)
							factor = 2;

						if (i == 9) {
							suma += Integer.parseInt(numero.substring(i))
									* factor;

						} else {
							suma += Integer
									.parseInt(numero.substring(i, i + 1))
									* factor;
						}

					}

					modSumaOnce = suma % 11;

					digitoValido = 11 - modSumaOnce;

					if (digitoValido == 11)
						digitoValido = 0;
					if (digitoValido == 10)
						digitoValido = 9;

					if (digitoValido == Integer.parseInt(digitoIngresado)) {
						cuitCuilValido = true;
						log
								.info("validarClaveIdentificacionUnica: DIGITO CORRECTO :  "
										+ digitoValido
										+ " / "
										+ digitoIngresado);

					} else
						log
								.info("validarClaveIdentificacionUnica: DIGITO INVALIDO :  "
										+ digitoValido
										+ " / "
										+ digitoIngresado);

				}

			}

		} catch (Exception e) {
			log.error("validarClaveIdentificacionUnica(): " + e);
		}

		return cuitCuilValido;

	}

	// 20110908 - EJV - Mantis 777 -->

	public String clientesMovimientoClienteCreateCI(BigDecimal idcliente,
			int ejercicioactivo, String activacion, String usuarioalt,
			BigDecimal idempresa, Connection conn) throws EJBException,
			SQLException {

		String salida = "OK";
		BigDecimal nrointernomovcliente = null;
		Enumeration en;
		String keyenum = "";

		BigDecimal nrointerno_ms = BigDecimal.valueOf(-1);
		// Enumeration en;
		String[] resultado = new String[2];
		// 20110617 - EJV - Factuaracion FE-CF-MA -->
		// Connection conn = null;
		// <--

		Timestamp fechamov = new Timestamp(Calendar.getInstance()
				.getTimeInMillis());
		BigDecimal sucursal = new BigDecimal(0);
		BigDecimal comprob = new BigDecimal(0);
		BigDecimal comprob_has = null;

		BigDecimal tipomov = new BigDecimal(1);
		String tipomovs = "FA";
		// 20110617 - EJV - Factuaracion FE-CF-MA -->
		String condicionletra = "";
		String letraContador = "";
		// <--
		BigDecimal saldo = new BigDecimal(0);
		BigDecimal importe = new BigDecimal(0);
		BigDecimal cambio = new BigDecimal(1);
		BigDecimal moneda = new BigDecimal(1);
		String unamode = "";
		String tipocomp = "";
		// Reemplazo por idcondicion -->
		// BigDecimal condicion = new BigDecimal(0);
		// <--
		BigDecimal nrointerno = new BigDecimal(0);
		BigDecimal com_venta = null;
		BigDecimal com_cobra = null;
		BigDecimal com_vende = null;
		String anulada = null;
		BigDecimal retoque = null;
		BigDecimal expreso = null;
		BigDecimal sucucli = null;
		BigDecimal remito = null;
		BigDecimal credito = null;
		BigDecimal idclub = new BigDecimal(-1);
		// int ejercicioactivo = 0;
		String observaciones = "";
		// 20110628 - EJV - Factuaracion FE-CF-MA -->
		BigDecimal por_per = new BigDecimal(0);
		// <--
		Hashtable htCuentasContCli = new Hashtable();

		// 20120502 - EJV -->
		BigDecimal idtipoclie = new BigDecimal(-1);
		BigDecimal idtipocliepre = new BigDecimal(-1);
		boolean tipoclieinconsistente = true;
		BigDecimal idpromocionasignada = new BigDecimal(-1);
		BigDecimal idpromocionasignadavigente = new BigDecimal(-1);

		String fechaPromocionVigente = "";

		// <--

		String cQuery = "";

		try {

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			fechaPromocionVigente = getFechaPromocion(idcliente, activacion,
					idempresa, conn);

			cQuery = ""
					+ "SELECT  cl.idcliente, cl.razon,  cl.idcondicion,  COALESCE(tj.idtarjeta, 0) idtarjeta,  "
					+ "             lp.precio - ((lp.precio * COALESCE(CASE WHEN '"
					+ activacion
					+ "' = 'A' THEN pm.porc_desc_ci ELSE pm.porc_desc_ci_react END, 0)/100)  )  "
					+ "             + ((   (lp.precio - ((lp.precio * COALESCE(CASE WHEN '"
					+ activacion
					+ "' = 'A' THEN pm.porc_desc_ci ELSE pm.porc_desc_ci_react END, 0)/100)  ))   * COALESCE(iv.porcent1, 0)/100)  ) total, "
					+ "             lp.precio - ((lp.precio * COALESCE(CASE WHEN '"
					+ activacion
					+ "' = 'A' THEN pm.porc_desc_ci ELSE pm.porc_desc_ci_react END, 0)/100)  ) AS totalgravado, "
					+ "             (   (lp.precio - ((lp.precio * COALESCE(CASE WHEN '"
					+ activacion
					+ "' = 'A' THEN pm.porc_desc_ci ELSE pm.porc_desc_ci_react END , 0)/100)  ))   * COALESCE(iv.porcent1, 0)/100)  AS iva, "
					+ "             lp.precio, 1 cantidad, "
					+ "             ctc.idtipocomp,  "
					+ "             COALESCE(cl.idctaneto, 0) AS idctaneto,  "
					+ "             COALESCE(ctc.ctaiva_tc, 0) AS ctaiva_tc,  "
					+ "             COALESCE(ctc.ctivani_tc, 0) AS ctivani_tc,  "
					+ "             COALESCE(ctc.ctgrava_tc, 0) AS ctgrava_tc,  "
					+ "             COALESCE(ctc.ctexent_tc, 0) AS ctexent_tc, "
					+ "             COALESCE(ctc.ctare1_tc, 0) AS ctare1_tc,  "
					+ "             COALESCE(ctc.ctare2_tc, 0) AS ctare2_tc, "
					+ "             td.idtipodocumento,  "
					+ "             td.tipodocumento,  "
					+ "             cl.nrodocumento, "
					+ "             iv.letra,  "
					+ "             cl.sucursalfactura, "
					+ "             ctc.tipomov_tc, "
					+ "             st.codigo_st, st.descrip_st, tp.idclub,  "
					+ "             cl.idtipoclie tipoencliente,"
					+ "             pre.idtipoclie tipoenprecarga,"
					+ "             cl.idtipoclie IS DISTINCT FROM pre.idtipoclie tipoinconsistente, "
					+ "             COALESCE(pre.idpromocion, -1) idpromocionasig,"
					+ "             COALESCE(pm.idpromocion, -1) idpromocion "
					+ "  FROM clientesclientes cl   "
					+ "           INNER JOIN clientestipocomp ctc ON cl.idtipocomp = ctc.idtipocomp AND cl.idempresa = ctc.idempresa  "
					+ "           INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento AND cl.idempresa = td.idempresa "
					+ "           INNER JOIN clienteslistasdeprecios lp ON cl.idlista = lp.idlista AND cl.idempresa = lp.idempresa "
					+ "           INNER JOIN stockstock st ON lp.codigo_st = st.codigo_st AND lp.idempresa = st.idempresa "
					+ "           INNER JOIN clientestipoclie tp ON cl.idtipoclie = tp.idtipoclie AND cl.idempresa = tp.idempresa "
					+ "           INNER JOIN clientestablaiva iv ON cl.idtipoiva = iv.idtipoiva AND cl.idempresa = iv.idempresa "
					+ "             LEFT JOIN clientesprecargaclientes pre ON cl.idcliente = pre.idcliente AND cl.idempresa = pre.idempresa "
					+ "             LEFT JOIN clientespromociones pm ON pre.idpromocion = pm.idpromocion AND pre.idempresa = pm.idempresa "
					+ "                     AND '"
					+ fechaPromocionVigente
					+ "'::date  BETWEEN pm.fechadesde AND pm.fechahasta "
					+ "             LEFT JOIN ( "
					+ "		                    SELECT DISTINCT ON (idcliente) idtarjeta, idcliente, idempresa "
					+ "		                      FROM clientetarjetascredito tjc  "
					+ "		                     ORDER BY idcliente, activa DESC, fecha_vencimiento DESC  "
					+ "                            ) tj ON cl.idcliente = tj.idcliente AND cl.idempresa = tj.idempresa "
					+ " WHERE cl.idempresa =  "
					+ idempresa
					+ "   AND cl.idcliente =  "
					+ idcliente
					+ "   AND lp.codigo_st LIKE '%C.I%' "
					+ "   AND st.inventa_st = 'N' ;";

			// conn = GeneralBean.getTransaccionConn(this.clase, this.url,
			// this.usuario, this.clave);
			// <--

			// conn.setAutoCommit(false);

			String queryTipo = " SELECT COALESCE(idtipoclie, -10) FROM clientesclientes WHERE idcliente = "
					+ idcliente + " AND idempresa = " + idempresa;
			List listTipo = getLista(queryTipo, conn);

			if (listTipo != null && !listTipo.isEmpty()) { // List TIPO

				idtipoclie = new BigDecimal(((String[]) listTipo.get(0))[0]);

				// 20120806 - EJV -
				// Mantis 835 -
				// Nota-1421:
				// TODO: Esta validacion no deberia estar aqui, toda la
				// logica de activacion - reactivacion - cambio de estado
				// deberia redefinierse, la misma tiene muchos parches y no
				// presenta una implementacion optima -->

				if (idtipoclie == null || idtipoclie.intValue() > 0) {

					if (idtipoclie.intValue() == 1
							|| idtipoclie.intValue() == 24) {
						// Tipo de cliente no lleva CI
						// <--

						GeneralBean.setLockedTable("cajasucursalescontadores",
								"ACCESS EXCLUSIVE", conn);

						Iterator it = getLista(cQuery, conn).iterator();

						if (it.hasNext()) {

							/*
							 * [ 0 - idcliente] * [ 1 - razon] * [ 2 -
							 * idcondicion] * [ 3 - idtarjeta] * [ 4 - total] *
							 * [ 5 - totalgravado] * [ 6 - iva] * [ 7 - precio]
							 * * [ 8 - cantidad] * [ 9 - idtipocomp] * [ 10 -
							 * idctaneto] * [ 11 - ctaiva_tc] * [ 12 -
							 * ctivani_tc] * [ 13 - ctgrava_tc] * [ 14 -
							 * ctexent_tc] * [ 15 - ctare1_tc] * [ 16 -
							 * ctare2_tc] * [ 17 - idtipodocumento] * [ 18 -
							 * tipodocumento] * [ 19 - nrodocumento] * [ 20 -
							 * letra] * [ 21 - sucursalfactura] * [ 22 -
							 * tipomov_tc] * [ 23 - codigo_st] * [ 24 -
							 * descrip_st] * [ 25 - idclub] *
							 */

							// log.info("La conulta recupero data ...");
							String data[] = (String[]) it.next();

							// for (int r = 0; r < data.length; r++) {
							//
							// log.info("data[" + r + "]: " + data[r]);
							//
							// }

							BigDecimal cuentatotal = new BigDecimal(data[10]);
							BigDecimal cuentaivaresponsablei = new BigDecimal(
									data[11]);
							BigDecimal cuentanoinscripto = new BigDecimal(
									data[12]);
							BigDecimal cuentagravado = new BigDecimal(data[13]);
							BigDecimal cuentaexento = new BigDecimal(data[14]);
							BigDecimal cuentaiibb = new BigDecimal(data[16]);
							String tipodocumento = data[17] == null ? ""
									: data[17].trim();
							String nrodocumento = data[19];

							BigDecimal totalCalculado = new BigDecimal(data[4]);
							BigDecimal total = new BigDecimal(0);
							BigDecimal iva = new BigDecimal(data[6]);
							BigDecimal totalgravado = new BigDecimal(data[5]);
							BigDecimal percepcioniibb = new BigDecimal(0);

							BigDecimal idcondicion = new BigDecimal(data[2]);
							BigDecimal idtarjeta = new BigDecimal(data[3]);
							String fechaValidezPromo = "";

							tipocomp = data[9];
							sucursal = new BigDecimal(data[21]);
							condicionletra = data[20];
							letraContador = condicionletra;

							observaciones = "En concepto de " + data[23]
									+ " - " + data[24] + "(" + activacion
									+ ").";
							idclub = new BigDecimal(data[25]);

							// 20120502 - EJV -->

							// 20120807 - EJV - Mantis 835 -->
							// Recuperar tipo de cliente desde consulta, ya que
							// ahora solo dos tipos de cliente GENERAN CUOTA DE
							// INSCRIPCION CI
							//
							// idtipoclie = new BigDecimal(data[26]);
							//
							// <--
							idtipocliepre = new BigDecimal(data[27]);
							tipoclieinconsistente = data[28]
									.equalsIgnoreCase("T");
							idpromocionasignada = new BigDecimal(data[29]);
							idpromocionasignadavigente = new BigDecimal(
									data[30]);

							// <--

							if (!tipoclieinconsistente) {// Tipo Cliente
								// Inconsistente

								String filtro = " WHERE '"
										+ fechaPromocionVigente
										+ "'::date BETWEEN fechadesde AND fechahasta AND idtipoclie = "
										+ idtipoclie;

								long totalPromocionVigente = getTotalEntidadFiltro(
										" clientespromociones ", filtro,
										idempresa);

								if (idpromocionasignada.intValue() > 0
										&& idpromocionasignada.intValue() == idpromocionasignadavigente
												.intValue()) {// Promocion
									// asignada -
									// vigente
									if (totalPromocionVigente > 0) {
										// Promo vigente
										// <--

										if (totalCalculado.doubleValue() == 0) {
											tipomov = new BigDecimal(5);
											tipomovs = "TNF";
											letraContador = "@";
										} else {

											tipomovs = tipomovs
													+ condicionletra;

											if (tipodocumento.toUpperCase()
													.equalsIgnoreCase("CUIT")
													|| tipodocumento
															.toUpperCase()
															.equalsIgnoreCase(
																	"CUIL")) {
												// Verificar si documento
												// cliente es
												// CUIT-CUIL

												if (!validarClaveIdentificacionUnica(nrodocumento)) {

													salida = tipodocumento
															+ " invalido.";

												} else {

													por_per = new BigDecimal(
															getPorPerIIBB(nrodocumento));

													if (por_per.floatValue() < 0) {
														salida = "E[10902]No fue posible capturar porcentaje de percepcion IIBB.";
													} else {

														BigDecimal factorIIBBBA = new BigDecimal(
																por_per
																		.floatValue() / 100)
																.setScale(
																		6,
																		BigDecimal.ROUND_HALF_UP);
														percepcioniibb = totalgravado
																.multiply(
																		factorIIBBBA)
																.setScale(
																		6,
																		BigDecimal.ROUND_HALF_UP);
														percepcioniibb = percepcioniibb
																.setScale(
																		4,
																		BigDecimal.ROUND_HALF_UP);

														totalCalculado = totalCalculado
																.add(percepcioniibb);

													}
												}
											}

										}

										importe = totalCalculado;
										saldo = importe;

										htCuentasContCli.put("T", new String[] {
												cuentatotal.toString(),
												totalCalculado.toString() });
										htCuentasContCli.put("G", new String[] {
												cuentagravado.toString(),
												totalgravado.toString() });
										htCuentasContCli.put("I", new String[] {
												cuentaivaresponsablei
														.toString(),
												iva.toString() });

										htCuentasContCli.put("E", new String[] {
												cuentaexento.toString(), "0" });
										htCuentasContCli.put("PIB",
												new String[] {
														cuentaiibb.toString(),
														percepcioniibb
																.toString() });

										// --

										if (salida.equalsIgnoreCase("OK")) {// 0.0

											comprob = GeneralBean
													.getCajaSucursalesContadoresProximo(
															sucursal,
															letraContador,
															tipomov, idempresa,
															conn);
											if (comprob.longValue() > -1) {// 0.1

												if (!isExisteComprobanteMovCli(
														sucursal, comprob,
														tipomovs, idempresa)) {// 0.2
													// <--

													nrointernomovcliente = GeneralBean
															.getContador(
																	new BigDecimal(
																			8),
																	idempresa,
																	conn);
													if (nrointernomovcliente
															.longValue() > -1) {// A

														// CLIENTE
														salida = ClientesBean
																.clientesMovCliCreate(
																		idcliente,
																		fechamov,
																		sucursal,
																		comprob,
																		comprob_has,
																		tipomov,
																		tipomovs,
																		saldo,
																		importe,
																		cambio,
																		moneda,
																		unamode,
																		tipocomp,
																		idcondicion,
																		nrointernomovcliente,
																		com_venta,
																		com_cobra,
																		com_vende,
																		anulada,
																		retoque,
																		expreso,
																		sucucli,
																		remito,
																		credito,
																		observaciones,
																		condicionletra,
																		// 20121005
																		// - EJV
																		// -
																		// Mantis
																		// 882
																		// -->
																		null,
																		// <--
																		usuarioalt,
																		idempresa,
																		conn);

														log
																.info("ANTES DE IC ");

														if (salida
																.equalsIgnoreCase("OK")) {// B

															if (idcondicion
																	.intValue() == 5) {

																if (idtarjeta
																		.longValue() > 0) {

																	Calendar cal = new GregorianCalendar();

																	cal
																			.setTimeInMillis(fechamov
																					.getTime());

																	java.sql.Date venci_cuo = new java.sql.Date(
																			fechamov
																					.getTime());
																	int periodo_cuo = periodo_cuo = Integer
																			.parseInt(cal
																					.get(Calendar.YEAR)
																					+ GeneralBean
																							.strZero(
																									""
																											+ (cal
																													.get(Calendar.MONTH) + 1),
																									2));

																	salida = ClientesBean
																			.clientesMovcuotaCreate(
																					new BigDecimal(
																							1),
																					nrointernomovcliente,
																					totalCalculado,
																					venci_cuo,
																					totalCalculado,
																					idcondicion,
																					idtarjeta,
																					periodo_cuo,
																					null,
																					null,
																					idclub,
																					idempresa,
																					usuarioalt,
																					conn);

																} else
																	salida = "MC-CI: Tarjeta de credito invalida, para condicion de pago tarjeta.";

															}

															log
																	.info("INICIA IC ");
															en = htCuentasContCli
																	.keys();

															while (en
																	.hasMoreElements()
																	&& salida
																			.equalsIgnoreCase("OK")) {// B.0

																log
																		.info("RECORRE DE IC ");
																keyenum = en
																		.nextElement()
																		.toString();
																String[] datos = (String[]) htCuentasContCli
																		.get(keyenum);

																if (Double
																		.parseDouble(datos[1]) > 0) {

																	log
																			.info("VALOR MAYOR A CERO DE IC ");

																	if (!GeneralBean
																			.isExisteCtaImputable(
																					new BigDecimal(
																							datos[0]),
																					ejercicioactivo,
																					idempresa,
																					conn)) {
																		salida = "La cuenta : "
																				+ datos[0]
																				+ " no existe o no es imputable. ["
																				+ keyenum
																				+ "]";

																	} else
																		log
																				.info("CUENTA CORRECTA:  "
																						+ datos[0]
																						+ " -  * -"
																						+ datos[1]);

																	if (!salida
																			.equalsIgnoreCase("OK"))
																		break;

																	BigDecimal porcentaje_percepcion = new BigDecimal(
																			0);
																	if (keyenum
																			.equalsIgnoreCase("PIB"))
																		porcentaje_percepcion = por_per;

																	salida = ClientesBean
																			.clientesContCliCreate(
																					new BigDecimal(
																							datos[0]),
																					new BigDecimal(
																							datos[1]),
																					keyenum,
																					nrointernomovcliente,
																					null,
																					null,
																					porcentaje_percepcion,
																					usuarioalt,
																					idempresa,
																					conn);

																} else
																	log
																			.info(" IC VALE CERO:  "
																					+ datos[0]
																					+ " -  * -"
																					+ datos[1]);

																if (!salida
																		.equalsIgnoreCase("OK"))
																	break;

															}// B.0

														}// B

													}// A
													else {
														salida = "MC-CI: Imposible recuperar Nro. Interno de Movimiento de Cliente.";
													}

												}// 0.2
												else {

													salida = "El comprobante "
															+ GeneralBean
																	.strZero(
																			sucursal
																					.toString(),
																			4)
															+ " - "
															+ GeneralBean
																	.strZero(
																			comprob
																					.toString(),
																			8)
															+ " ya fue emitido.";
												}

											}// 0.1
											else {
												salida = "MC-CI: No se recupero Nro. Comprobante para Sucursal "
														+ sucursal
														+ ", posiblemente no se haya definido contador.";
											}

										}// 0.0

									}

									else {
										// Promo vigente

										salida = "No fue posible contabilizar promocion vigente para tipo de cliente: "
												+ idtipoclie;

									}// Promo vigente

								} else // Promocion no asignada o no vigente
								{

									salida = "Tipo de cliente ("
											+ idtipoclie
											+ ") debe tener promoción asignada ("
											+ idpromocionasignada
											+ ")  y vigente ("
											+ idpromocionasignadavigente
											+ "), verifique la misma.";

								} // Promocion no asignada o no vigente

							} else {
								// Tipo Cliente Inconsistente

								salida = "MC-CI: Tipo de cliente inconsistente - CLI:  "
										+ idtipoclie
										+ " - PRE: "
										+ idtipocliepre;

							}// Tipo Cliente Inconsistente

						} else { // No se recuperaron datos cliente ...

							salida = "MC-CI: No fue posible recuperar datos para cliente: "
									+ idcliente;

						}// No se recuperaron datos cliente ...

					} else {
						// Tipo de cliente no lleva CI

						log
								.info("Activar - Reactivar cliente: "
										+ idcliente
										+ " - "
										+ activacion
										+ " - No es tipo de cliente Regular - Alianza : "
										+ idtipoclie);

					}// Tipo de cliente no lleva CI

				} else {

					salida = "Inconsistencia al recuperar tipo de cliente: "
							+ idtipoclie + ", para cliente: " + idcliente;

				}

			} else {// List TIPO

				salida = "No fue posible recuperar tipo de cliente para cliente: "
						+ idcliente;

			}

			resultado[0] = salida;
			resultado[1] = resultado[1] != null ? resultado[1] + "-"
					+ nrointerno_ms.toString() : nrointerno_ms.toString();

		} catch (Exception e) {
			salida = "Imposible generar movimiento de cliente.";
			log.error("clientesMovimientoClienteCreateCI:" + e);
		}

		// if (!salida.equalsIgnoreCase("OK")) {
		// conn.rollback();
		// } else {
		// conn.commit();
		// salida = nrointernomovcliente.toString();
		// }
		//
		// conn.setAutoCommit(true);
		// conn.close();

		return salida;
	}

	private String getFechaPromocion(BigDecimal idcliente, String tipo,
			BigDecimal idempresa, Connection conn) throws RemoteException {

		String query = "";
		List listFecha = new ArrayList();
		String fecha = "1975-10-08";

		try {

			query = ""
					+ "SELECT COALESCE( "
					+ "               CASE UPPER('"
					+ tipo
					+ "')  "
					+ "                    WHEN 'A' THEN pre.fechadeingreso::date  "
					+ "                    WHEN 'R' THEN r.fechareactivacion::date  "
					+ "                END,  "
					+ "              '1975-10-08'::date)  fechapromocion "
					+ "  FROM clientesprecargaclientes pre "
					+ "       LEFT JOIN clientesreactivaciones r ON pre.idcliente = r.idcliente AND pre.idempresa = r.idempresa  "
					+ "             AND r.idreactivacion = (SELECT MAX(idreactivacion) FROM clientesreactivaciones  WHERE idcliente = pre.idcliente AND idempresa = pre.idempresa)  "
					+ " WHERE pre.idcliente = " + idcliente
					+ "   AND pre.idempresa = " + idempresa;

			listFecha = getLista(query, conn);

			if (listFecha != null && listFecha.size() > 0) {

				fecha = ((String[]) listFecha.get(0))[0];

			} else {

				log
						.warn("getFechaPromocion - No se recupero fecha de promocion valida");

			}

		} catch (Exception e) {
			log.error("getFechaPromocion(): " + e);
		}

		return fecha;

	}

	// 20110909 - EJV - Mantis 777 REPLICADO EN GENERAL ORIGINAL CLIENTES
	public String getPorPerIIBB(String cuit) throws EJBException {

		String cQuery = "SELECT por_per FROM padroniibb WHERE cuit = '" + cuit
				+ "'";

		String por_per = "0";
		Iterator it;
		try {

			it = getLista(cQuery).iterator();
			if (it.hasNext()) {
				por_per = ((String[]) it.next())[0];
			}

		} catch (Exception ex) {
			por_per = "-1";
			log
					.error("Salida por exception: en el metodo: getPorPerIIBB( BigDecimal idtipoiva )  "
							+ ex);
		}
		return por_per;
	}

	// 20110909 - EJV - Mantis 777 REPLICADO EN GENERAL ORIGINAL CLIENTES
	public boolean isExisteComprobanteMovCli(BigDecimal sucursal,
			BigDecimal comprob, String tipomovs, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsExiste = null;
		boolean existe = false;
		String cQuery = " " + " SELECT 1 FROM clientesmovcli  WHERE sucursal="
				+ sucursal + " AND comprob=" + comprob + " AND tipomovs='"
				+ tipomovs + "' AND idempresa=" + idempresa.toString()
				+ " UNION SELECT 1 FROM clientesanexov WHERE sucur_an="
				+ sucursal + " AND compr_an=" + comprob + " AND tipmovs_an='"
				+ tipomovs + "' AND idempresa=" + idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsExiste = statement.executeQuery(cQuery);
			if (rsExiste.next()) {
				existe = true;
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : isExisteComprobanteMovCli( BigDecimal sucursal ...) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isExisteComprobanteMovCli( BigDecimal sucursal ...)  "
							+ ex);
		}
		return existe;
	}

	// <--

	public void GeneraArchivo(String archivo, String source)
			throws FileNotFoundException, IOException {
		final String DEFAULT_ENCODING = System.getProperty("file.encoding");
		// log.debug("file.encoding: " + DEFAULT_ENCODING);
		OutputStream aFile = new FileOutputStream(archivo);
		aFile.write(source.getBytes());
		aFile.close();
		if (System.getProperty("file.separator").equals("\\"))
			log.debug("ARCH. OK: "
					+ archivo.substring(archivo.lastIndexOf(92) + 1));
		else if (System.getProperty("file.separator").equals("/"))
			log.debug("ARCH. OK: "
					+ archivo.substring(archivo.lastIndexOf(47) + 1));

	}

	public void setArchivo(List lista, BigDecimal columnas, String nombre)
			throws EJBException {
		// Tengo que definir el numero de filas, eso me lo da el array.. me
		// muevo de izquierda a derecha,
		// cuando estoy en la ultima columa, osea n = ult colum meto un enter
		// así hasta que termino de recorrer el archivo. esto lo guardo todo en
		// un String
		// y se lo paso como param a Generar archivo
		try {
			Iterator iterlista = lista.iterator();
			String contenido = "";
			// path + extensión del archivo
			String path = reportecsv + nombre + ".csv";
			while (iterlista.hasNext()) {
				String[] datoslista = (String[]) iterlista.next();
				for (int i = 0; i <= columnas.intValue() - 1; i++) {

					contenido += datoslista[i];
					contenido += ";";
				}
				contenido += "\n";
			}
			GeneraArchivo(path, contenido);
		} catch (Exception ex) {
			log
					.info("Error: setArchivo(List lista, BigDecimal columnas, String 	nombre) "
							+ ex);
		}
	}

	public void setArchivo(List lista, BigDecimal columnas, String nombre,
			String[] tituCol) throws EJBException {
		// Tengo que definir el numero de filas, eso me lo da el array.. me
		// muevo de izquierda a derecha,
		// cuando estoy en la ultima columa, osea n = ult colum meto un enter
		// así hasta que termino de recorrer el archivo. esto lo guardo todo en
		// un String
		// y se lo paso como param a Generar archivo
		try {
			Iterator iterlista = lista.iterator();
			String contenido = "";
			// path + extensión del archivo
			String path = reportecsv + nombre + ".csv";
			for (int j = 0; j <= tituCol.length - 1; j++) {
				contenido += tituCol[j];
				contenido += ";";
			}
			contenido += "\n";
			while (iterlista.hasNext()) {
				String[] datoslista = (String[]) iterlista.next();
				for (int i = 0; i <= columnas.intValue() - 1; i++) {

					contenido += datoslista[i];
					contenido += ";";
				}
				contenido += "\n";
			}
			GeneraArchivo(path, contenido);
		} catch (Exception ex) {
			log
					.info("Error: setArchivo(List lista, BigDecimal columnas, String nombre , String[] tituCol) "
							+ ex);
		}
	}

	/*
	 * Metodos para la entidad: ticketsestados Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Sep 20 09:41:44 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getTicketsestadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT idticketestado,ticketestado,color_fondo,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETSESTADOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTicketsestadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTicketsestadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idticketestado,ticketestado,color_fondo,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETSESTADOS WHERE ((UPPER(TICKETESTADO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') or idticketestado::varchar like ('%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'))  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTicketsestadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTicketsestadosPK(BigDecimal idticketestado,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idticketestado,ticketestado,color_fondo,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM TICKETSESTADOS WHERE idticketestado="
				+ idticketestado.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTicketsestadosPK( BigDecimal idticketestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String ticketsestadosDelete(BigDecimal idticketestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETSESTADOS WHERE idticketestado="
				+ idticketestado.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM TICKETSESTADOS WHERE idticketestado="
						+ idticketestado.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : ticketsestadosDelete( BigDecimal idticketestado, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: ticketsestadosDelete( BigDecimal idticketestado, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String ticketsestadosCreate(String ticketestado, String color_fondo,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (ticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ticketestado ";
		if (color_fondo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: color_fondo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (ticketestado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ticketestado ";
		if (color_fondo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: color_fondo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO TICKETSESTADOS(ticketestado, color_fondo, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, ticketestado);
				insert.setString(2, color_fondo);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String ticketsestadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String ticketsestadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String ticketsestadosCreateOrUpdate(BigDecimal idticketestado,
			String ticketestado, String color_fondo, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticketestado ";
		if (ticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ticketestado ";
		if (color_fondo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: color_fondo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (ticketestado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ticketestado ";
		if (color_fondo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: color_fondo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM ticketsestados WHERE idticketestado = "
					+ idticketestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETSESTADOS SET ticketestado=?, color_fondo=?, idempresa=?, usuarioact=?, fechaact=? WHERE idticketestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, ticketestado);
					insert.setString(2, color_fondo);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idticketestado);
				} else {
					String ins = "INSERT INTO TICKETSESTADOS(ticketestado, color_fondo, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, ticketestado);
					insert.setString(2, color_fondo);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String ticketsestadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String ticketsestadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String ticketsestadosUpdate(BigDecimal idticketestado,
			String ticketestado, String color_fondo, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticketestado ";
		if (ticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ticketestado ";
		if (color_fondo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: color_fondo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (ticketestado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ticketestado ";
		if (color_fondo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: color_fondo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM ticketsestados WHERE idticketestado = "
					+ idticketestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETSESTADOS SET ticketestado=?, color_fondo=?, idempresa=?, usuarioact=?, fechaact=? WHERE idticketestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, ticketestado);
					insert.setString(2, color_fondo);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idticketestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String ticketsestadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String ticketsestadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * Metodos para la entidad: tickets Copyrigth(r) sysWarp S.R.L. Fecha de
	 * creacion: Thu Sep 20 11:56:06 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getTicketsAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {
		/*
		 * String filtroGrupo = ""; Iterator iter = grupo.iterator(); while
		 * (iter.hasNext()) { String[] datosGrupo = (String[]) iter.next();
		 * filtroGrupo += " ti.idgrupo = " + datosGrupo[0] + " and "; }
		 * filtroGrupo = filtroGrupo.substring(1, filtroGrupo.length()- 4);
		 * log.info(filtroGrupo);
		 */
		String cQuery = "SELECT ti.idticket,gp.grupo,gu.usuario,cli.razon,ti.resumen,ti.descripcion,"
				+ " te.ticketestado,ti.idempresa,te.color_fondo,ti.usuarioalt,ti.usuarioact,ti.fechaalt,ti.fechaact"
				+ " FROM TICKETS ti"
				+ " left join globalgrupos gp on (ti.idgrupo = gp.idgrupo)"
				+ " left join globalusuarios gu on (ti.idusuario = gu.idusuario and ti.idempresa = gu.idempresa)"
				+ " left join globalusuariosgrupos gup on (ti.idgrupo = gup.idgrupo and ti.idempresa = gu.idempresa)"
				+ " inner join clientesclientes cli on (ti.idcliente = cli.idcliente and ti.idempresa = cli.idempresa )"
				+ " inner join ticketsestados te on (ti.idticketestado = te.idticketestado  and ti.idempresa = te.idempresa)"
				+ " WHERE "
				+ " ti.idempresa = "
				+ idempresa.toString()
				/*
				 * + " and " + filtroGrupo + " and ti.idusuario = " +
				 * idusuario.toString()
				 */
				+ "  ORDER BY 1 DESC LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getTicketsAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTicketsOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		/*
		 * String filtroGrupo = ""; Iterator iter = grupo.iterator();
		 * 
		 * while (iter.hasNext()) { String[] datosGrupo = (String[])
		 * iter.next();
		 * 
		 * filtroGrupo += " ti.idgrupo = " + datosGrupo[0] + " and "; }
		 * filtroGrupo = filtroGrupo.substring(1, filtroGrupo.length() - 4);
		 * log.info(filtroGrupo);
		 */
		//
		String cQuery = "SELECT ti.idticket,gp.grupo,gu.usuario,cli.razon,ti.resumen,ti.descripcion,"
				+ " te.ticketestado,ti.idempresa,te.color_fondo,ti.usuarioalt,ti.usuarioact,ti.fechaalt,ti.fechaact"
				+ " FROM TICKETS ti"
				+ " left join globalgrupos gp on (ti.idgrupo = gp.idgrupo)"
				+ " left join globalusuarios gu on (ti.idusuario = gu.idusuario and ti.idempresa = gu.idempresa)"
				+ " left join globalusuariosgrupos gup on (ti.idgrupo = gup.idgrupo and ti.idempresa = gu.idempresa)"
				+ " inner join clientesclientes cli on (ti.idcliente = cli.idcliente and ti.idempresa = cli.idempresa )"
				+ " inner join ticketsestados te on (ti.idticketestado = te.idticketestado  and ti.idempresa = te.idempresa)"
				+ " WHERE (ti.idticket::varchar LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') or (upper (gp.grupo) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') or (upper (gu.usuario) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND ti.idempresa = "
				+ idempresa.toString()
				/*
				 * + " and " + filtroGrupo + " and ti.idusuario = " +
				 * idusuario.toString()
				 */
				+ " ORDER BY 1 DESC  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTicketsOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTicketsPK(BigDecimal idticket, BigDecimal idempresa)
			throws EJBException {
		String cQuery = "SELECT ti.idticket,ti.idgrupo,gp.grupo,ti.idusuario,gu.usuario,ti.idcliente,cli.razon,ti.resumen,ti.descripcion,"
				+ " ti.idticketestado,te.ticketestado,ti.idempresa,te.color_fondo,ti.usuarioalt,ti.usuarioact,ti.fechaalt,ti.fechaact"
				+ " FROM TICKETS ti"
				+ " left join globalgrupos gp on (ti.idgrupo = gp.idgrupo)"
				+ " left join globalusuarios gu on (ti.idusuario = gu.idusuario and ti.idempresa = gu.idempresa)"
				+ " left join globalusuariosgrupos gup on (ti.idgrupo = gup.idgrupo and ti.idempresa = gu.idempresa)"
				+ " inner join clientesclientes cli on (ti.idcliente = cli.idcliente and ti.idempresa = cli.idempresa )"
				+ " inner join ticketsestados te on (ti.idticketestado = te.idticketestado  and ti.idempresa = te.idempresa)"
				+ " WHERE ti.idticket = "
				+ idticket.toString()
				+ " AND ti.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTicketsPK( BigDecimal idticket )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String ticketsDelete(BigDecimal idticket, BigDecimal idempresa,
			boolean enviaCorreo) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM TICKETS WHERE idticket="
				+ idticket.toString() + " AND idempresa="
				+ idempresa.toString();

		String salida = "NOOK";
		String resumen = "";
		String descripcion = "";
		BigDecimal idgrupo = new BigDecimal(-1);
		BigDecimal idusuario = new BigDecimal(-1);
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				// si se le da de baja,el texto deberia ser el mismo ? o deberia
				// ser otro ?
				resumen = "Gestion de cobranza  - Baja de ticket ";
				descripcion = "Atencion: el ticket " + idticket.toString()
						+ " ha sido eliminado del workflow";
				idgrupo = !setNotNull(rsSalida.getString("idgrupo"))
						.equalsIgnoreCase("") ? rsSalida
						.getBigDecimal("idgrupo") : new BigDecimal(-1);
				idusuario = !setNotNull(rsSalida.getString("idusuario"))
						.equalsIgnoreCase("") ? rsSalida
						.getBigDecimal("idusuario") : new BigDecimal(-1);
				cQuery = "DELETE FROM TICKETS WHERE idticket="
						+ idticket.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
				if (enviaCorreo)
					salida = enviarCorreos(idgrupo, idusuario, salida, resumen,
							descripcion, dbconn);

			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : ticketsDelete( BigDecimal idticket, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: ticketsDelete( BigDecimal idticket, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String ticketsCreate(BigDecimal idgrupo, BigDecimal idusuario,
			BigDecimal idcliente, String resumen, String descripcion,
			BigDecimal idticketestado, BigDecimal idempresa, String usuarioalt,
			boolean enviaCorreo) throws EJBException {

		String salida = "OK";

		try {

			salida = ticketsCreate(idgrupo, idusuario, idcliente, resumen,
					descripcion, idticketestado, idempresa, usuarioalt,
					enviaCorreo, dbconn);

		} catch (Exception e) {
			log.error("ticketsCreate(): " + e);
		}

		return salida;
	}

	public static String ticketsCreate(BigDecimal idgrupo,
			BigDecimal idusuario, BigDecimal idcliente, String resumen,
			String descripcion, BigDecimal idticketestado,
			BigDecimal idempresa, String usuarioalt, boolean enviaCorreo,
			Connection conn) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticketestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {

				String ins = "INSERT INTO TICKETS(idgrupo, idusuario, idcliente, resumen, descripcion, idticketestado, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idgrupo);
				insert.setBigDecimal(2, idusuario);
				insert.setBigDecimal(3, idcliente);
				insert.setString(4, resumen);
				insert.setString(5, descripcion);
				insert.setBigDecimal(6, idticketestado);
				insert.setBigDecimal(7, idempresa);
				insert.setString(8, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1) {

					BigDecimal idticket = GeneralBean.getValorSequencia(
							"seq_tickets", conn);

					if (enviaCorreo) {

						resumen = " TICKET #  "
								+ strZero(idticket.toString(), 10) + " - "
								+ resumen;
						salida = enviarCorreos(idgrupo, idusuario, "ALTA",
								resumen, descripcion, conn);

					}
				} else
					salida = "No fue posible generar ticket ";

			}

		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible generar ticket ";
			log.error("Error SQL public String ticketsCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible generar ticket ";
			log
					.error("Error excepcion public String ticketsCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String ticketsCreateOrUpdate(BigDecimal idticket,
			BigDecimal idgrupo, BigDecimal idusuario, BigDecimal idcliente,
			String resumen, String descripcion, BigDecimal idticketestado,
			BigDecimal idempresa, String usuarioact, boolean enviaCorreo)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idticket == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticket ";
		if (idticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticketestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets WHERE idticket = "
					+ idticket.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS SET idgrupo=?, idusuario=?, idcliente=?, resumen=?, descripcion=?, idticketestado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idticket=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idusuario);
					insert.setBigDecimal(3, idcliente);
					insert.setString(4, resumen);
					insert.setString(5, descripcion);
					insert.setBigDecimal(6, idticketestado);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, idticket);
				} else {
					String ins = "INSERT INTO TICKETS(idgrupo, idusuario, idcliente, resumen, descripcion, idticketestado, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idusuario);
					insert.setBigDecimal(3, idcliente);
					insert.setString(4, resumen);
					insert.setString(5, descripcion);
					insert.setBigDecimal(6, idticketestado);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
				// Si total es mayo a cero,quiere decir que hay un registro ,
				// entonces la accion es update
				// aunque, deberia enviar cuando es alta,pero como esto se deja
				// comentado, nomas habria que eliminar la condicion
				if (total > 0)
					if (enviaCorreo)
						salida = enviarCorreos(idgrupo, idusuario,
								"modificacion", resumen, descripcion, dbconn);
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String ticketsCreateOrUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String ticketsCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String ticketsUpdate(BigDecimal idticket, BigDecimal idgrupo,
			BigDecimal idusuario, BigDecimal idcliente, String resumen,
			String descripcion, BigDecimal idticketestado,
			BigDecimal idempresa, String usuarioact, boolean enviaCorreo)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idticket == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticket ";
		if (idticketestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idticketestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM tickets WHERE idticket = "
					+ idticket.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE TICKETS SET idgrupo=?, idusuario=?, idcliente=?, resumen=?, descripcion=?, idticketestado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idticket=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idgrupo);
					insert.setBigDecimal(2, idusuario);
					insert.setBigDecimal(3, idcliente);
					insert.setString(4, resumen);
					insert.setString(5, descripcion);
					insert.setBigDecimal(6, idticketestado);
					insert.setBigDecimal(7, idempresa);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, idticket);
				}

				int i = insert.executeUpdate();
				if (i > 0) {
					salida = "Actualizacion Correcta";
					if (enviaCorreo)
						salida = enviarCorreos(idgrupo, idusuario, salida,
								resumen, descripcion, dbconn);
				} else {
					salida = "Imposible actualizar el registro.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String ticketsUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String ticketsUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public BigDecimal getUsuario(String nombre, BigDecimal idempresa)
			throws EJBException {
		BigDecimal idusuario = new BigDecimal(-1);
		String valor = "";
		String cQuery = "Select idusuario from globalusuarios where lower(nombre) = lower('"
				+ nombre + "') and idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		Iterator it;
		try {
			vecSalida = getLista(cQuery);
			it = getLista(cQuery).iterator();
			if (it.hasNext()) {
				valor = ((String[]) it.next())[0];
			}
			idusuario = new BigDecimal(valor);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getUsuario(String usuario)  "
							+ ex);
		}
		return idusuario;

	}

	public List getUsuarioGrupo(BigDecimal idusuario) throws EJBException {
		String cQuery = "Select idgrupo from globalusuariosgrupos where idusuario = "
				+ idusuario.toString();
		List vecSalida = new ArrayList();

		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getUsuarioGrupo(BigDecimal idusuario)   "
							+ ex);
		}
		return vecSalida;

	}

	public static List ObtenerMailGrupo(BigDecimal idgrupo, Connection conn)
			throws EJBException {
		String cQuery = "Select email from globalusuarios gu"
				+ " inner join globalusuariosgrupos gup on (gu.idusuario = gup.idusuario)"
				+ " where idgrupo = " + idgrupo.toString();
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery, conn);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: ObtenerMailGrupo(BigDecimal idgrupo)  "
							+ ex);
		}
		return vecSalida;
	}

	public static String ObtenerMailUsuario(BigDecimal idusuario,
			Connection conn) throws EJBException {
		String salida = "";
		String cQuery = "Select email from globalusuarios gu"
				+ " where idusuario =  " + idusuario.toString();
		List vecSalida = new ArrayList();
		Iterator it;
		try {
			vecSalida = getLista(cQuery, conn);
			it = vecSalida.iterator();
			if (it.hasNext()) {
				salida = ((String[]) it.next())[0];
			}
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo:ObtenerMailUsuario(BigDecimal idusuario)  "
							+ ex);
		}
		return salida;
	}

	// 20120925 - CAMI - Gestion de cobranzas
	/*
	 * Como comente en la funcion de sendMail, cree esta funcion (que
	 * originalmente estaba dentro del bean de tickets ) para poder enviar los
	 * correos de forma grupal o de forma unitaria a quien corresponda, segun
	 * usuario o segun grupo.
	 * 
	 * Cabe aclarar que enviarCorreos son distintas funciones por mas que se
	 * llamen igual(igual en ingles,pero se llaman igual)
	 */

	public static String enviarCorreos(BigDecimal idgrupo,
			BigDecimal idusuario, String accion, String resumen,
			String descripcion, Connection conn) throws EJBException {
		String salida = "OK";
		List emailGrupo = new ArrayList();
		boolean flag = true;
		String destino = "";
		// CAMILEADA
		// salida = accion;
		if (idgrupo == null) {
			idgrupo = new BigDecimal(-1);
		} else if (idusuario == null) {
			idusuario = new BigDecimal(-1);
		}
		if (idgrupo.longValue() > 0) {
			emailGrupo = ObtenerMailGrupo(idgrupo, conn);
			Iterator iterGrupo = emailGrupo.iterator();
			while (iterGrupo.hasNext()) {
				String[] datosGrupo = (String[]) iterGrupo.next();
				destino = datosGrupo[0];
				flag = sendMail(resumen, descripcion, destino, null);
				if (!flag) {
					salida = "Ha fallado el envío de correo interno.";
				}
				// log.info("se envio ? " + flag);
			}
		} else if (idusuario.longValue() > 0) {
			destino = ObtenerMailUsuario(idusuario, conn);
			flag = sendMail(resumen, descripcion, destino,
					"Gestion de cobranzas");
			if (!flag) {
				salida = "Ha fallado el envío de correo interno. ";
			}
		}
		return salida;
	}
}
