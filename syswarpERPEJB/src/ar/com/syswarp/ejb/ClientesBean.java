package ar.com.syswarp.ejb;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;

import org.apache.log4j.Logger;

import ar.com.syswarp.entity.AccionContacto;
import ar.com.syswarp.entity.ResultadoContacto;
import ar.com.syswarp.entitymanager.AccionContactoManager;
import ar.com.syswarp.entitymanager.ResultadoContactoManager;
import ar.com.syswarp.entitymanager.utils.QueryManager;
import ar.com.syswarp.utils.DateAndTimeUtils;

/**
 * XDoclet-based session bean. The class must be declared public according to
 * the EJB specification.
 * 
 * To generate the EJB related files to this EJB: - Add Standard EJB module to
 * XDoclet project properties - Customize XDoclet configuration for your
 * appserver - Run XDoclet
 * 
 * Below are the xdoclet-related tags needed for this EJB.
 * 
 * @ejb.bean name="Clientes" display-name="Name for Clientes"
 *           description="Description for Clientes" jndi-name="ejb/Clientes"
 *           type="Stateless" view-type="remote"
 */
@Stateless
public class ClientesBean implements Clientes {

	/** The session context */
	private SessionContext context;

	GeneralBean gb = new GeneralBean();

	/* conexion a la base de datos */

	private Connection dbconn;

	static Logger log = Logger.getLogger(ClientesBean.class);

	QueryManager queryManager = QueryManager.getInstance(log);

	/***********************
	****    Managers    ****
	***********************/
	AccionContactoManager accionContactoManager = new AccionContactoManager(log);
	ResultadoContactoManager resultadoContactoManager = new ResultadoContactoManager(log);

	private Connection conexion;

	private Properties props;

	private String url;

	private String clase;

	private String usuario;

	private String clave;

	private String mapKey;

	private String pathAndreani;

	public ClientesBean() {
		super();
		try {
			props = new Properties();
			props.load(ClientesBean.class
					.getResourceAsStream("system.properties"));

			url = props.getProperty("conn.url").trim();
			clase = props.getProperty("conn.clase").trim();
			usuario = props.getProperty("conn.usuario").trim();
			clave = props.getProperty("conn.clave").trim();
			mapKey = props.getProperty("map.key").trim();
			pathAndreani = props.getProperty("archivos.andreani.path").trim();

			Class.forName(clase);
			conexion = DriverManager.getConnection(url, usuario, clave);
			// conexion.createStatement().execute("SET application_name = 'DELTA: Clientes' ");
			this.dbconn = conexion;
		} catch (java.lang.ClassNotFoundException cnfException) {
			log.error("Error driver : " + cnfException);
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (IOException IOException) {
			log.error("Error SQL: " + IOException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
	}

	public ClientesBean(Connection dbconn) {
		this.dbconn = dbconn;
	}

	/**
	 * Set the associated session context. The container calls this method after
	 * the instance creation.
	 * 
	 * The enterprise bean instance should store the reference to the context
	 * object in an instance variable.
	 * 
	 * This method is called with no transaction context.
	 * 
	 * @throws EJBException
	 *             Thrown if method fails due to system-level error.
	 */
	public void setSessionContext(SessionContext newContext)
			throws EJBException {
		context = newContext;
	}

	public void ejbRemove() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbActivate() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbPassivate() throws EJBException, RemoteException {
		// TODO Auto-generated method stub

	}

	public void ejbCreate() throws CreateException {
		// TODO Add ejbCreate method implementation
	}

	// private static Connection getTransaccionConn(String _class, String _url,
	// String _user, String _clave) throws EJBException {
	//
	// // --> Intentar Generacion conexion aislada
	// Connection conn = null;
	// int r = 1;
	// while (r < 6) {
	// try {
	// Class.forName(_class);
	// conn = DriverManager.getConnection(_url, _user, _clave);
	// } catch (Exception e) {
	// log.warn("getTransaccionConn(): Intento de conexion nro. " + r
	// + " a base de datos  no concretado. ");
	// }
	//
	// if (conn != null) {
	// break;
	// }
	// r++;
	// }
	// // <--
	// return conn;
	// }

	private long getTotalEntidad(String entidad, BigDecimal idempresa,
			Connection conn) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ "       WHERE idempresa = " + idempresa.toString();
		try {
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidad()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidad()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidad()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidad(String entidad, BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ "       WHERE idempresa = " + idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidad()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidad()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidad()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadOcu(String entidad, String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadOcu()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadOcu()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadRelacion(String entidad, String[] campos,
			String[] ocurrencia) throws EJBException {

		/**
		 * Entidad: ???????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad de registros desde una tabla de
		 *             relacion para un id en particualar.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String filtro = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				filtro += campos[i] + " = " + ocurrencia[i] + " ";
				if (i + 1 < len)
					filtro += " AND ";
			}
			cQuery += filtro;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadRelacion()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadRelacion()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadRelacion()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadFiltro(String entidad, String filtro,
			BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " "
				+ filtro + " AND idempresa = " + idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadFiltro()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadFiltro()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadFiltro()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadFiltro(String entidad, String filtro)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " "
				+ filtro;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadFiltro()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadFiltro()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadFiltro()- Salida por exception: " + ex);
		}
		return total;
	}

	// private List getLista(String query) throws EJBException {
	private List getLista(String query) {
		List vecSalida = new ArrayList();
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(query);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
			if (rsSalida != null) {
				rsSalida.close();
				rsSalida = null;
				md = null;
			}
		} catch (SQLException sqlException) {
			log
					.error("(SQLE) getLista(String query) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName() + " : "
							+ sqlException);
			// throw new EJBException(
			// "getLista() - SQLException:  -- >: throw new EJBException ");
		} catch (Exception ex) {
			log.error("(EX) getLista(String query) - INVOCADO POR "
					+ GeneralBean.getCallingMethodName() + " : " + ex);

			// throw new EJBException(
			// "getLista() - Exception:  -- >: throw new EJBException ");
		}
		return vecSalida;
	}

	private List getLista(String query, Connection conn) {
		List vecSalida = new ArrayList();
		try {

			Statement statement = conn.createStatement();
			ResultSet rsSalida = statement.executeQuery(query);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
			if (rsSalida != null) {
				rsSalida.close();
				rsSalida = null;
				md = null;
			}
		} catch (SQLException sqlException) {

			log.info("QUERY: " + query);
			log
					.error("(SQLE) getLista(String query, Connection conn) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName()
							+ " : "
							+ sqlException);

		} catch (Exception ex) {
			log.info("QUERY: " + query);
			log
					.error("(EX) getLista(String query, Connection conn) - INVOCADO POR "
							+ GeneralBean.getCallingMethodName() + " : " + ex);

		}
		return vecSalida;
	}

	/**
	 * TODO: .............................................................
	 * getTotalEntidadGlobal - getTotalEntidadGlobalOcu.
	 * _______________________________________________________________________
	 * Queda pendiente de borrar estos dos metodos. Los mismos se crean para
	 * solventar momentaneamente consultas de acceso a entidades globales ya
	 * definidas en GeneralBean.
	 * _______________________________________________________________________
	 * 
	 */

	public long getTotalEntidadGlobal(String entidad) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1) AS total FROM " + entidad;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadGlobal()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadGlobal()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadGlobal()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadGlobalOcu(String entidad, String[] campos,
			String ocurrencia) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ")  ";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getTotalEntidadGlobalOcu()- Error al recuperar total: "
								+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadGlobalOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalEntidadGlobalOcu()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// CATEGORIAS DE CLIENTES
	// para todo (ordena por el segundo campo por defecto)
	public List getClientescredcateAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "" + " SELECT idcredcate,credcate,dias_cre,porcen_cre,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESCREDCATE WHERE idempresa="
				+ idempresa.toString() + " ORDER BY 2 DESC LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescredcate()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getClientescredcateOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "" + "SELECT idcredcate,credcate,dias_cre,porcen_cre,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESCREDCATE " + " WHERE idempresa= "
				+ idempresa.toString() + " and (idcredcate::VARCHAR LIKE '%"
				+ ocurrencia + "%' OR " + " UPPER(CREDCATE) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') "
				+ " ORDER BY 2 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescredcateOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientescredcatePK(BigDecimal idcredcate,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcredcate,credcate,dias_cre,porcen_cre,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESCREDCATE WHERE idcredcate="
				+ idcredcate.toString()
				+ "and idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescredcatePK( BigDecimal idcredcate )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientescredcateDelete(BigDecimal idcredcate,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESCREDCATE WHERE idcredcate="
				+ idcredcate.toString() + "and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESCREDCATE WHERE idcredcate="
						+ idcredcate.toString() + "and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientescredcateDelete( BigDecimal idcredcate ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientescredcateDelete( BigDecimal idcredcate )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientescredcateCreate(String credcate, BigDecimal dias_cre,
			Double porcen_cre, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (credcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: credcate ";
		if (dias_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: dias_cre ";
		if (porcen_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcen_cre ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (credcate.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: credcate ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESCREDCATE(credcate, dias_cre, porcen_cre, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, credcate);
				insert.setBigDecimal(2, dias_cre);
				insert.setDouble(3, porcen_cre.doubleValue());
				insert.setString(4, usuarioalt);
				insert.setBigDecimal(5, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientescredcateCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescredcateCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientescredcateCreateOrUpdate(BigDecimal idcredcate,
			String credcate, BigDecimal dias_cre, Double porcen_cre,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (credcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: credcate ";
		if (dias_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: dias_cre ";
		if (porcen_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcen_cre ";

		// 2. sin nada desde la pagina
		if (credcate.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: credcate ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescredcate WHERE idcredcate = "
					+ idcredcate.toString()
					+ "and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCREDCATE SET credcate=?, dias_cre=?, porcen_cre=?, usuarioact=?, fechaact=? WHERE idcredcate=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, credcate);
					insert.setBigDecimal(2, dias_cre);
					insert.setDouble(3, porcen_cre.doubleValue());
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcredcate);
					insert.setBigDecimal(7, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESCREDCATE(credcate, dias_cre, porcen_cre, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, credcate);
					insert.setBigDecimal(2, dias_cre);
					insert.setDouble(3, porcen_cre.doubleValue());
					insert.setString(4, usuarioalt);
					insert.setBigDecimal(5, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientescredcateCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescredcateCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientescredcateUpdate(BigDecimal idcredcate,
			String credcate, BigDecimal dias_cre, Double porcen_cre,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (credcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: credcate ";
		if (dias_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: dias_cre ";
		if (porcen_cre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcen_cre ";

		// 2. sin nada desde la pagina
		if (credcate.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: credcate ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescredcate WHERE idcredcate = "
					+ idcredcate.toString()
					+ "and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCREDCATE SET credcate=?, dias_cre=?, porcen_cre=?, usuarioact=?, fechaact=? WHERE idcredcate=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, credcate);
					insert.setBigDecimal(2, dias_cre);
					insert.setDouble(3, porcen_cre.doubleValue());
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcredcate);
					insert.setBigDecimal(7, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientescredcateUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientescredcateUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// TIPOS DE CLIENTES
	// para todo (ordena por el segundo campo por defecto)
	public List getClientestipoclieAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT tc.idtipoclie, tc.tipoclie, cb.idclub, cb.club, tc.usuarioalt, tc.usuarioact, tc.fechaalt, tc.fechaact "
				+ "   FROM clientestipoclie tc "
				+ "             INNER JOIN clientesclub cb ON tc.idclub = cb.idclub AND tc.idempresa =  cb.idempresa "
				+ "WHERE tc.idempresa=" + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipoclieAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientestipoclieOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT tc.idtipoclie, tc.tipoclie, cb.idclub, cb.club, tc.usuarioalt, tc.usuarioact, tc.fechaalt, tc.fechaact "
				+ "   FROM clientestipoclie tc "
				+ "             INNER JOIN clientesclub cb ON tc.idclub = cb.idclub AND tc.idempresa =  cb.idempresa "
				+ "WHERE tc.idempresa=" + idempresa.toString()
				+ "     AND (tc.idtipoclie::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(tc.tipoclie) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipoclieOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// 20110907 - EJV - Mantis 777 -->
	// para todos los correspondienes a un club (ordena por el segundo campo por
	// defecto)
	public List getClientestipoclieXClub(long limit, long offset,
			BigDecimal idclub, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT tc.idtipoclie, tc.tipoclie, cb.idclub, cb.club, tc.usuarioalt, tc.usuarioact, tc.fechaalt, tc.fechaact "
				+ "   FROM clientestipoclie tc "
				+ "             INNER JOIN clientesclub cb ON tc.idclub = cb.idclub AND tc.idempresa =  cb.idempresa "
				+ "WHERE tc.idempresa=" + idempresa.toString()
				+ " AND tc.idclub = " + idclub + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipoclieAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	// por primary key (primer campo por defecto)

	public List getClientestipocliePK(BigDecimal idtipoclie,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT tc.idtipoclie, tc.tipoclie, cb.idclub, cb.club, tc.usuarioalt, tc.usuarioact, tc.fechaalt, tc.fechaact "
				+ "   FROM clientestipoclie tc "
				+ "             INNER JOIN clientesclub cb ON tc.idclub = cb.idclub AND tc.idempresa =  cb.idempresa "
				+ " WHERE tc.idtipoclie=" + idtipoclie.toString()
				+ "     AND tc.idempresa=" + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipocliePK( BigDecimal idtipoclie )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientestipoclieDelete(BigDecimal idtipoclie,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTIPOCLIE WHERE idtipoclie="
				+ idtipoclie.toString() + "and idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTIPOCLIE WHERE idtipoclie="
						+ idtipoclie.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientestipoclieDelete( BigDecimal idtipoclie ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientestipoclieDelete( BigDecimal idtipoclie )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientestipoclieCreate(String tipoclie, BigDecimal idclub,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESTIPOCLIE(tipoclie, idclub, usuarioalt,idempresa ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipoclie);
				insert.setBigDecimal(2, idclub);
				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientestipoclieCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestipoclieCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientestipoclieCreateOrUpdate(BigDecimal idtipoclie,
			String tipoclie, BigDecimal idclub, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoclie ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestipoclie WHERE idtipoclie = "
					+ idtipoclie.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOCLIE SET tipoclie=?, idclub=?, usuarioact=?, fechaact=? WHERE idtipoclie=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoclie);
					insert.setBigDecimal(2, idclub);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipoclie);
					insert.setBigDecimal(6, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESTIPOCLIE(tipoclie, idclub,  usuarioalt, idempresa ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipoclie);
					insert.setString(2, usuarioalt);
					insert.setBigDecimal(3, idclub);
					insert.setBigDecimal(4, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestipoclieCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestipoclieCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientestipoclieUpdate(BigDecimal idtipoclie,
			String tipoclie, BigDecimal idclub, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoclie ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestipoclie WHERE idtipoclie = "
					+ idtipoclie.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOCLIE SET tipoclie=?, idclub=?, usuarioact=?, fechaact=? WHERE idtipoclie=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoclie);
					insert.setBigDecimal(2, idclub);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipoclie);
					insert.setBigDecimal(6, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientestipoclieUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientestipoclieUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// --> 20110711 - EJV - Mantis 727
	public List getClientesClubAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idclub, club, logo, usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientesclub WHERE idempresa=" + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClubAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	// CONDICIONES DE VENTA
	// para todo (ordena por el segundo campo por defecto)
	public List getClientescondicioAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT co.idcondicion, co.condicion, co.cant_dias, co.cuotas, co.lapso, co.fac_cred, co.ctanetoclie, COALESCE(ip.cuenta, 'CUENTA INACTIVA EN EJERCICIO') cuenta, "
				+ "             co.usuarioalt, co.usuarioact, co.fechaalt, co.fechaact "
				+ "  FROM clientescondicio co "
				+ "            LEFT JOIN vcontableinfiplanactivo  ip ON co.ctanetoclie = ip.idcuenta AND co.idempresa = ip.idempresa "
				+ "WHERE co.idempresa=" + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescondicio()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientescondicioOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT co.idcondicion, co.condicion, co.cant_dias, co.cuotas, co.lapso, co.fac_cred, co.ctanetoclie, COALESCE(ip.cuenta, 'CUENTA INACTIVA EN EJERCICIO') cuenta, "
				+ "             co.usuarioalt, co.usuarioact, co.fechaalt, co.fechaact "
				+ "  FROM clientescondicio co "
				+ "            LEFT JOIN vcontableinfiplanactivo  ip ON co.ctanetoclie = ip.idcuenta AND co.idempresa = ip.idempresa "
				+ "WHERE co.idempresa=" + idempresa.toString()
				+ "    AND (co.idcondicion::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(co.condicion) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescondicio(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientescondicioPK(BigDecimal idcondicion,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT co.idcondicion, co.condicion, co.cant_dias, co.cuotas, co.lapso, co.fac_cred, co.ctanetoclie, COALESCE(ip.cuenta, 'CUENTA INACTIVA EN EJERCICIO') cuenta, "
				+ "             co.usuarioalt, co.usuarioact, co.fechaalt, co.fechaact "
				+ "  FROM clientescondicio co "
				+ "            LEFT JOIN vcontableinfiplanactivo  ip ON co.ctanetoclie = ip.idcuenta AND co.idempresa = ip.idempresa "
				+ "WHERE co.idcondicion=" + idcondicion.toString()
				+ "    AND co.idempresa=" + idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescondicioPK( BigDecimal idcondicion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientescondicioDelete(BigDecimal idcondicion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESCONDICIO WHERE idcondicion="
				+ idcondicion.toString() + "and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESCONDICIO WHERE idcondicion="
						+ idcondicion.toString() + "and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientescondicioDelete( BigDecimal idcondicion ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientescondicioDelete( BigDecimal idcondicion )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientescondicioCreate(String condicion,
			BigDecimal cant_dias, BigDecimal cuotas, BigDecimal lapso,
			String fac_cred, BigDecimal ctanetoclie, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (condicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: condicion ";
		if (cant_dias == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cant_dias ";
		if (cuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuotas ";
		if (lapso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: lapso ";
		if (fac_cred == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fac_cred ";
		if (ctanetoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ctanetoclie ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (condicion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: condicion ";
		if (fac_cred.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fac_cred ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESCONDICIO(condicion, cant_dias, cuotas, lapso, fac_cred, ctanetoclie, usuarioalt,idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, condicion);
				insert.setBigDecimal(2, cant_dias);
				insert.setBigDecimal(3, cuotas);
				insert.setBigDecimal(4, lapso);
				insert.setString(5, fac_cred);
				insert.setBigDecimal(6, ctanetoclie);
				insert.setString(7, usuarioalt);
				insert.setBigDecimal(8, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientescondicioCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescondicioCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientescondicioCreateOrUpdate(BigDecimal idcondicion,
			String condicion, BigDecimal cant_dias, BigDecimal cuotas,
			BigDecimal lapso, String fac_cred, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (condicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: condicion ";
		if (cant_dias == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cant_dias ";
		if (cuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuotas ";
		if (lapso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: lapso ";
		if (fac_cred == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fac_cred ";

		// 2. sin nada desde la pagina
		if (condicion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: condicion ";
		if (fac_cred.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fac_cred ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescondicio WHERE idcondicion = "
					+ idcondicion.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCONDICIO SET condicion=?, cant_dias=?, cuotas=?, lapso=?, fac_cred=?, usuarioact=?, fechaact=? WHERE idcondicion=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, condicion);
					insert.setBigDecimal(2, cant_dias);
					insert.setBigDecimal(3, cuotas);
					insert.setBigDecimal(4, lapso);
					insert.setString(5, fac_cred);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idcondicion);
					insert.setBigDecimal(9, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESCONDICIO(condicion, cant_dias, cuotas, lapso, fac_cred, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, condicion);
					insert.setBigDecimal(2, cant_dias);
					insert.setBigDecimal(3, cuotas);
					insert.setBigDecimal(4, lapso);
					insert.setString(5, fac_cred);
					insert.setString(6, usuarioalt);
					insert.setBigDecimal(7, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientescondicioCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescondicioCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientescondicioUpdate(BigDecimal idcondicion,
			String condicion, BigDecimal cant_dias, BigDecimal cuotas,
			BigDecimal lapso, String fac_cred, BigDecimal ctanetoclie,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (condicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: condicion ";
		if (cant_dias == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cant_dias ";
		if (cuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuotas ";
		if (lapso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: lapso ";
		if (fac_cred == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fac_cred ";
		if (ctanetoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ctanetoclie ";

		// 2. sin nada desde la pagina
		if (condicion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: condicion ";
		if (fac_cred.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fac_cred ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescondicio WHERE idcondicion = "
					+ idcondicion.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCONDICIO SET condicion=?, cant_dias=?, cuotas=?, lapso=?, fac_cred=?, ctanetoclie=?, usuarioact=?, fechaact=? WHERE idcondicion=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, condicion);
					insert.setBigDecimal(2, cant_dias);
					insert.setBigDecimal(3, cuotas);
					insert.setBigDecimal(4, lapso);
					insert.setString(5, fac_cred);
					insert.setBigDecimal(6, ctanetoclie);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idcondicion);
					insert.setBigDecimal(10, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientescondicioUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientescondicioUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// EXPRESOS
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesexpresosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT CE.idexpreso, CE.expreso, CE.cuit, CE.direccion, LO.localidad, CI.tipoiva, CE.valor_seguro, CE.usuarioalt, CE.usuarioact, CE.fechaalt, CE.fechaact"
				+ "  FROM  CLIENTESEXPRESOS  CE, globallocalidades LO, clientestablaiva  CI "
				+ "WHERE LO.idlocalidad = CE.idlocalidad and CI.idtipoiva = CE.idtipoiva and CI.idempresa = CE.idempresa and CE.idempresa="
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresos()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesexpresosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CE.idexpreso, CE.expreso, CE.cuit, CE.direccion, LO.localidad, CI.tipoiva, CE.valor_seguro, CE.usuarioalt, CE.usuarioact, CE.fechaalt, CE.fechaact  FROM  CLIENTESEXPRESOS  CE, globallocalidades LO, clientestablaiva  CI WHERE LO.idlocalidad = CE.idlocalidad and CI.idtipoiva = CE.idtipoiva and CI.idempresa = CE.idempresa and CE.idempresa="
				+ idempresa.toString()
				+ " and (CE.idexpreso::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(CE.expreso) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresos(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesexpresosPK(BigDecimal idexpreso, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT CE.idexpreso, CE.expreso, CE.cuit, CE.direccion, CE.idlocalidad, LO.localidad, "
				+ "       CE.idtipoiva, CI.tipoiva, CE.valor_seguro, "
				+ "       CE.report_hojaarmado, CE.report_hojarutafinal, CE.codigo_dt, CE.report_hojarutafinal_reg, "
				// 20120215 - EJV - Mantis 817 -- >
				+ "       CE.idmedidabulto, CE.calculaflete, CE.discriminaflete, CE.valorapagar1bulto, CE.valorapagarexcedente, CE.calculaiva,"
				// <--
				+ "       CE.usuarioalt, CE.usuarioact, CE.fechaalt,CE.fechaact "
				+ "  FROM  CLIENTESEXPRESOS  CE, globallocalidades LO, clientestablaiva  CI "
				+ "WHERE LO.idlocalidad = CE.idlocalidad and CI.idtipoiva = CE.idtipoiva and CE.idexpreso="
				+ idexpreso.toString() + "and CE.idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesexpresosPK( BigDecimal idexpreso )  "
							+ ex);
		}
		return vecSalida;
	}

	public String getClientesExpresosReport(BigDecimal idexpreso,
			String tipopedido, String tiporeport, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT report_hojaarmado,  report_hojarutafinal, report_hojarutafinal_reg "
				+ "   FROM clientesexpresos WHERE idexpreso="
				+ idexpreso.toString() + "    AND  idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		String report = "";

		try {

			vecSalida = getLista(cQuery);

			if (!vecSalida.isEmpty() && vecSalida.size() != 0) {

				String[] datos = (String[]) vecSalida.get(0);

				if (tipopedido.equalsIgnoreCase("N")) {

					if (tiporeport.equalsIgnoreCase("HA")) {

						report = datos[0];

					} else if (tiporeport.equalsIgnoreCase("HR")) {

						report = datos[1];

					}

				} else if (tipopedido.equalsIgnoreCase("R")) {

					if (tiporeport.equalsIgnoreCase("HA")) {

						report = datos[0];

					} else if (tiporeport.equalsIgnoreCase("HR")) {

						report = datos[2];

					}

				}

			}
			log.warn("No fue posible capturar la plantilla para reporte de "
					+ tiporeport + ", para expreso: " + idexpreso + ".");

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesExpresosReport( BigDecimal idexpreso )  "
							+ ex);
		}

		return report;

	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesexpresosDelete(BigDecimal idexpreso,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESEXPRESOS WHERE idexpreso="
				+ idexpreso.toString() + "and idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESEXPRESOS WHERE idexpreso="
						+ idexpreso.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesexpresosDelete( BigDecimal idexpreso ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesexpresosDelete( BigDecimal idexpreso )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesexpresosCreate(String expreso, String cuit,
			String direccion, BigDecimal idlocalidad, BigDecimal idtipoiva,
			Double valor_seguro, String report_hojaarmado,
			String report_hojarutafinal, BigDecimal codigo_dt,
			String report_hojarutafinal_reg,

			BigDecimal idmedidabulto, String calculaflete,
			String discriminaflete, BigDecimal valorapagar1bulto,
			BigDecimal valorapagarexcedente, String calculaiva,

			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (expreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: expreso ";
		if (cuit == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuit ";
		if (direccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: direccion ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (valor_seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (expreso.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: expreso ";
		if (cuit.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cuit ";
		if (direccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: direccion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO CLIENTESEXPRESOS"
						+ "             (expreso, cuit, direccion, idlocalidad, idtipoiva, valor_seguro, report_hojaarmado, report_hojarutafinal, codigo_dt,  report_hojarutafinal_reg, idmedidabulto, calculaflete, discriminaflete, valorapagar1bulto, valorapagarexcedente, calculaiva, usuarioalt, idempresa ) "
						+ "VALUES (?,?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, expreso);
				insert.setString(2, cuit);
				insert.setString(3, direccion);
				insert.setBigDecimal(4, idlocalidad);
				insert.setBigDecimal(5, idtipoiva);
				insert.setDouble(6, valor_seguro.doubleValue());
				insert.setString(7, report_hojaarmado);
				insert.setString(8, report_hojarutafinal);
				insert.setBigDecimal(9, codigo_dt);
				insert.setString(10, report_hojarutafinal_reg);
				// 20120215 - EJV - Mantis 817 -- >
				insert.setBigDecimal(11, idmedidabulto);
				insert.setString(12, calculaflete);
				insert.setString(13, discriminaflete);
				insert.setBigDecimal(14, valorapagar1bulto);
				insert.setBigDecimal(15, valorapagarexcedente);
				insert.setString(16, calculaiva);
				// <--
				insert.setString(17, usuarioalt);
				insert.setBigDecimal(18, idempresa);

				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesexpresosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesexpresosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesexpresosCreateOrUpdate(BigDecimal idexpreso,
			String expreso, String cuit, String direccion,
			BigDecimal idlocalidad, BigDecimal idtipoiva, Double valor_seguro,
			String report_hojaarmado, String report_hojarutafinal,
			BigDecimal codigo_dt, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (expreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: expreso ";
		if (cuit == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuit ";
		if (direccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: direccion ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (valor_seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro ";

		// 2. sin nada desde la pagina
		if (expreso.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: expreso ";
		if (cuit.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cuit ";
		if (direccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: direccion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesexpresos WHERE idexpreso = "
					+ idexpreso.toString()
					+ "and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESEXPRESOS SET expreso=?, cuit=?, direccion=?, idlocalidad=?, idtipoiva=?, valor_seguro=?, report_hojaarmado=?, report_hojarutafinal=?, codigo_dt=?, usuarioact=?, fechaact=? WHERE idexpreso=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, expreso);
					insert.setString(2, cuit);
					insert.setString(3, direccion);
					insert.setBigDecimal(4, idlocalidad);
					insert.setBigDecimal(5, idtipoiva);
					insert.setDouble(6, valor_seguro.doubleValue());
					insert.setString(7, report_hojaarmado);
					insert.setString(8, report_hojarutafinal);
					insert.setBigDecimal(9, codigo_dt);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idexpreso);
					insert.setBigDecimal(13, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESEXPRESOS(expreso, cuit, direccion, idlocalidad, idtipoiva, valor_seguro, report_hojaarmado, report_hojarutafinal, codigo_dt, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, expreso);
					insert.setString(2, cuit);
					insert.setString(3, direccion);
					insert.setBigDecimal(4, idlocalidad);
					insert.setBigDecimal(5, idtipoiva);
					insert.setDouble(6, valor_seguro.doubleValue());
					insert.setString(7, report_hojaarmado);
					insert.setString(8, report_hojarutafinal);
					insert.setBigDecimal(9, codigo_dt);
					insert.setString(10, usuarioalt);
					insert.setBigDecimal(11, idempresa);

				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesexpresosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesexpresosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesexpresosUpdate(BigDecimal idexpreso, String expreso,
			String cuit, String direccion, BigDecimal idlocalidad,
			BigDecimal idtipoiva, Double valor_seguro,
			String report_hojaarmado, String report_hojarutafinal,
			BigDecimal codigo_dt, String report_hojarutafinal_reg,

			BigDecimal idmedidabulto, String calculaflete,
			String discriminaflete, BigDecimal valorapagar1bulto,
			BigDecimal valorapagarexcedente, String calculaiva,

			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idexpreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpreso ";
		if (expreso == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: expreso ";
		if (cuit == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuit ";
		if (direccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: direccion ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (valor_seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor_seguro ";

		// 2. sin nada desde la pagina
		if (expreso.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: expreso ";
		if (cuit.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cuit ";
		if (direccion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: direccion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesexpresos WHERE idexpreso = "
					+ idexpreso.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE CLIENTESEXPRESOS "
							+ "      SET expreso=?, cuit=?, direccion=?, idlocalidad=?, idtipoiva=?, valor_seguro=?, report_hojaarmado=?, "
							+ "             report_hojarutafinal=?, codigo_dt=?, report_hojarutafinal_reg=?, "
							+ "             idmedidabulto=?, calculaflete=?, discriminaflete=?, valorapagar1bulto=?,valorapagarexcedente=?, calculaiva=?,"
							+ "             usuarioact=?, fechaact=? "
							+ " WHERE idexpreso=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, expreso);
					insert.setString(2, cuit);
					insert.setString(3, direccion);
					insert.setBigDecimal(4, idlocalidad);
					insert.setBigDecimal(5, idtipoiva);
					insert.setDouble(6, valor_seguro.doubleValue());
					insert.setString(7, report_hojaarmado);
					insert.setString(8, report_hojarutafinal);
					insert.setBigDecimal(9, codigo_dt);
					insert.setString(10, report_hojarutafinal_reg);

					// 20120215 - EJV - Mantis 817 -- >
					insert.setBigDecimal(11, idmedidabulto);
					insert.setString(12, calculaflete);
					insert.setString(13, discriminaflete);
					insert.setBigDecimal(14, valorapagar1bulto);
					insert.setBigDecimal(15, valorapagarexcedente);
					insert.setString(16, calculaiva);
					// <--

					insert.setString(17, usuarioact);
					insert.setTimestamp(18, fechaact);
					insert.setBigDecimal(19, idexpreso);
					insert.setBigDecimal(20, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesexpresosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesexpresosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * //******************************** // PARA TRAER LOV clientestablaiva //
	 * para todo (ordena por el segundo campo por defecto) public List
	 * getClientestablaivaAll(long limit, long offset) throws EJBException {
	 * ResultSet rsSalida = null; String cQuery = "" + "select * from
	 * clientestablaiva" + " ORDER BY 2 LIMIT " + limit + " OFFSET " + offset +
	 * ";"; List vecSalida = new ArrayList(); try { Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery);
	 * ResultSetMetaData md = rsSalida.getMetaData(); while (rsSalida.next()) {
	 * int totCampos = md.getColumnCount() - 1; String[] sSalida = new
	 * String[totCampos + 1]; int i = 0; while (i <= totCampos) { sSalida[i] =
	 * rsSalida.getString(++i); } vecSalida.add(sSalida); } } catch
	 * (SQLException sqlException) { log.error("Error SQL en el metodo :
	 * clientestablaiva() " + sqlException); } catch (Exception ex) { log
	 * .error("Salida por exception: en el metodo: clientestablaiva() " + ex); }
	 * return vecSalida; } // para una ocurrencia (ordena por el segundo campo
	 * por defecto)
	 * 
	 * public List getClientestablaivaOcu(long limit, long offset, String
	 * ocurrencia) throws EJBException { ResultSet rsSalida = null; String
	 * cQuery = "" + "select * from clientestablaiva" + " WHERE UPPER(TIPOIVA)
	 * LIKE '%" + ocurrencia.toUpperCase().trim() + "%' ORDER BY 2 LIMIT " +
	 * limit + " OFFSET " + offset + ";"; List vecSalida = new ArrayList(); try
	 * { Statement statement = dbconn.createStatement(); rsSalida =
	 * statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) { log
	 * .error("Error SQL en el metodo : getClientestablaivaOcu(String
	 * ocurrencia) " + sqlException); } catch (Exception ex) { log
	 * .error("Salida por exception: en el metodo: getClientestablaivaOcu(String
	 * ocurrencia) " + ex); } return vecSalida; }
	 */

	// TIPOS DE IVA
	// para todo (ordena por el segundo campo por defecto)
	public List getClientestablaivaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtipoiva,tipoiva,porcent1,descrimina,desglosa,porcent2,letra,ctapromo,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTABLAIVA where idempresa= "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestablaivaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientestablaivaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipoiva,tipoiva,porcent1,descrimina,desglosa,porcent2,letra,ctapromo,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTABLAIVA WHERE idempresa= "
				+ idempresa.toString()
				+ " and (idtipoiva::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipoiva) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestablaivaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientestablaivaPK(BigDecimal idtipoiva, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idtipoiva,tipoiva,porcent1,descrimina,desglosa,porcent2,letra,ctapromo,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESTABLAIVA WHERE idtipoiva="
				+ idtipoiva.toString() + "and idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestablaivaPK( BigDecimal idtipoiva )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientestablaivaLetrasAll(BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT DISTINCT letra FROM clientestablaiva WHERE idempresa= "
				+ idempresa.toString() + " ORDER BY 1 ;";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestablaivaLetrasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientestablaivaDelete(BigDecimal idtipoiva,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTABLAIVA WHERE idtipoiva="
				+ idtipoiva.toString() + "and idempresa="
				+ idempresa.toString();

		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTABLAIVA WHERE idtipoiva="
						+ idtipoiva.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientestablaivaDelete( BigDecimal idtipoiva ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientestablaivaDelete( BigDecimal idtipoiva )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientestablaivaCreate(String tipoiva, Double porcent1,
			String descrimina, String desglosa, Double porcent2, String letra,
			BigDecimal ctapromo, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoiva ";
		if (porcent1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent1 ";
		if (descrimina == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descrimina ";
		if (desglosa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: desglosa ";
		if (porcent2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent2 ";
		if (letra == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: letra ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipoiva.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoiva ";
		if (descrimina.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descrimina ";
		if (desglosa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: desglosa ";
		if (letra.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: letra ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESTABLAIVA(tipoiva, porcent1, descrimina, desglosa, porcent2, letra, ctapromo, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipoiva);
				insert.setDouble(2, porcent1.doubleValue());
				insert.setString(3, descrimina);
				insert.setString(4, desglosa);
				insert.setDouble(5, porcent2.doubleValue());
				insert.setString(6, letra);
				insert.setBigDecimal(7, ctapromo);
				insert.setString(8, usuarioalt);
				insert.setBigDecimal(9, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientestablaivaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestablaivaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientestablaivaCreateOrUpdate(BigDecimal idtipoiva,
			String tipoiva, Double porcent1, String descrimina,
			String desglosa, Double porcent2, String letra,
			BigDecimal ctapromo, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (tipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoiva ";
		if (porcent1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent1 ";
		if (descrimina == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descrimina ";
		if (desglosa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: desglosa ";
		if (porcent2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent2 ";
		if (letra == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: letra ";

		// 2. sin nada desde la pagina
		if (tipoiva.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoiva ";
		if (descrimina.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descrimina ";
		if (desglosa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: desglosa ";
		if (letra.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: letra ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestablaiva WHERE idtipoiva = "
					+ idtipoiva.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTABLAIVA SET tipoiva=?, porcent1=?, descrimina=?, desglosa=?, porcent2=?, letra=?, ctapromo=?, usuarioact=?, fechaact=? WHERE idtipoiva=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoiva);
					insert.setDouble(2, porcent1.doubleValue());
					insert.setString(3, descrimina);
					insert.setString(4, desglosa);
					insert.setDouble(5, porcent2.doubleValue());
					insert.setString(6, letra);
					insert.setBigDecimal(7, ctapromo);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, idtipoiva);
					insert.setBigDecimal(11, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESTABLAIVA(tipoiva, porcent1, descrimina, desglosa, porcent2, letra, ctapromo, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipoiva);
					insert.setDouble(2, porcent1.doubleValue());
					insert.setString(3, descrimina);
					insert.setString(4, desglosa);
					insert.setDouble(5, porcent2.doubleValue());
					insert.setString(6, letra);
					insert.setBigDecimal(7, ctapromo);
					insert.setString(8, usuarioalt);
					insert.setBigDecimal(9, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestablaivaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestablaivaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientestablaivaUpdate(BigDecimal idtipoiva, String tipoiva,
			Double porcent1, String descrimina, String desglosa,
			Double porcent2, String letra, BigDecimal ctapromo,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (tipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoiva ";
		if (porcent1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent1 ";
		if (descrimina == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descrimina ";
		if (desglosa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: desglosa ";
		if (porcent2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porcent2 ";
		if (letra == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: letra ";

		// 2. sin nada desde la pagina
		if (tipoiva.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoiva ";
		if (descrimina.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descrimina ";
		if (desglosa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: desglosa ";
		if (letra.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: letra ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestablaiva WHERE idtipoiva = "
					+ idtipoiva.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTABLAIVA SET tipoiva=?, porcent1=?, descrimina=?, desglosa=?, porcent2=?, letra=?, ctapromo=?, usuarioact=?, fechaact=? WHERE idtipoiva=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoiva);
					insert.setDouble(2, porcent1.doubleValue());
					insert.setString(3, descrimina);
					insert.setString(4, desglosa);
					insert.setDouble(5, porcent2.doubleValue());
					insert.setString(6, letra);
					insert.setBigDecimal(7, ctapromo);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaact);
					insert.setBigDecimal(10, idtipoiva);
					insert.setBigDecimal(11, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientestablaivaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientestablaivaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// VENDEDORES
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesvendedorAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idvendedor,vendedor,comision1,comision2,domicilio,usuarioalt,usuarioact,fechaalt,fechaact,fechabaja,sueldobasico,tipoliquidacion,tasadesercion,valorasociacion FROM CLIENTESVENDEDOR where idempresa= "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesvendedorOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idvendedor,vendedor,comision1,comision2,domicilio,usuarioalt,usuarioact,fechaalt,fechaact,fechabaja,sueldobasico,tipoliquidacion,tasadesercion,valorasociacion FROM CLIENTESVENDEDOR WHERE idempresa= "
				+ idempresa.toString()
				+ " and (idvendedor::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(vendedor) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesvendedorPK(BigDecimal idvendedor,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idvendedor,vendedor,comision1,comision2,domicilio,usuarioalt,usuarioact,fechaalt,fechaact,fechabaja,sueldobasico,tipoliquidacion,tasadesercion,valorasociacion FROM CLIENTESVENDEDOR WHERE idvendedor="
				+ idvendedor.toString()
				+ "and idempresa="
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorPK( BigDecimal idvendedor )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesvendedorDelete(BigDecimal idvendedor,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESVENDEDOR WHERE idvendedor="
				+ idvendedor.toString() + "and idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		Calendar cal = new GregorianCalendar();
		java.sql.Date hoy = new java.sql.Date(cal.getTimeInMillis());
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				java.sql.Date fecha = rsSalida.getDate("fechabaja");
				if (fecha == null) {
					cQuery = "Update CLIENTESVENDEDOR set fechabaja= '" + hoy
							+ "' WHERE idvendedor=" + idvendedor.toString()
							+ "and idempresa=" + idempresa.toString();
					statement.execute(cQuery);
					salida = "Baja Correcta.";
				} else {
					salida = "Este vendedor ya fue dado de baja.";
				}
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesvendedorDelete( BigDecimal idvendedor ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesvendedorDelete( BigDecimal idvendedor )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesvendedorCreate(String vendedor, Double comision1,
			Double comision2, String domicilio, String usuarioalt,
			BigDecimal idempresa, BigDecimal sueldobasico,
			String tipoliquidacion, BigDecimal tasadesercion,
			BigDecimal valorasociacion) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (vendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: vendedor ";
		if (comision1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision1 ";
		if (comision2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision2 ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (vendedor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: vendedor ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESVENDEDOR(vendedor, comision1, comision2, domicilio, usuarioalt,idempresa,sueldobasico,tipoliquidacion,tasadesercion,valorasociacion  ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, vendedor);
				insert.setDouble(2, comision1.doubleValue());
				insert.setDouble(3, comision2.doubleValue());
				insert.setString(4, domicilio);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				insert.setBigDecimal(7, sueldobasico);
				insert.setString(8, tipoliquidacion);
				insert.setBigDecimal(9, tasadesercion);
				insert.setBigDecimal(10, valorasociacion);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesvendedorCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesvendedorCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesvendedorCreateOrUpdate(BigDecimal idvendedor,
			String vendedor, Double comision1, Double comision2,
			String domicilio, String usuarioact, BigDecimal idempresa,
			BigDecimal sueldobasico, String tipoliquidacion,
			BigDecimal tasadesercion, BigDecimal valorasociacion)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (vendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: vendedor ";
		if (comision1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision1 ";
		if (comision2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision2 ";

		// 2. sin nada desde la pagina
		if (vendedor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: vendedor ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) as total FROM clientesvendedor WHERE idvendedor = "
					+ idvendedor.toString()
					+ "and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt("total");
			PreparedStatement insert = null;
			String sql = "";

			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESVENDEDOR SET vendedor=?, comision1=?, comision2=?, domicilio=?, usuarioact=?, fechaact=?, sueldobasico =?, tipoliquidacion=?, tasadesercion=?, valorasociacion=? WHERE idvendedor=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, vendedor);
					insert.setDouble(2, comision1.doubleValue());
					insert.setDouble(3, comision2.doubleValue());
					insert.setString(4, domicilio);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, sueldobasico);
					insert.setString(8, tipoliquidacion);
					insert.setBigDecimal(9, tasadesercion);
					insert.setBigDecimal(10, valorasociacion);
					insert.setBigDecimal(11, idvendedor);
					insert.setBigDecimal(12, idempresa);

				} else {
					String ins = "INSERT INTO CLIENTESVENDEDOR(vendedor, comision1, comision2, domicilio, usuarioalt,idempresa,sueldobasico, tipoliquidacion, tasadesercion,valorasociacion ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, vendedor);
					insert.setDouble(2, comision1.doubleValue());
					insert.setDouble(3, comision2.doubleValue());
					insert.setString(4, domicilio);
					insert.setString(5, usuarioalt);
					insert.setBigDecimal(6, idempresa);
					insert.setBigDecimal(7, sueldobasico);
					insert.setString(8, tipoliquidacion);
					insert.setBigDecimal(9, tasadesercion);
					insert.setBigDecimal(10, valorasociacion);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesvendedorCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesvendedorCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesvendedorUpdate(BigDecimal idvendedor,
			String vendedor, Double comision1, Double comision2,
			String domicilio, String usuarioact, BigDecimal idempresa,
			boolean reingresar, BigDecimal sueldobasico,
			String tipoliquidacion, BigDecimal tasadesercion,
			BigDecimal valorasociacion) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (vendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: vendedor ";
		if (comision1 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision1 ";
		if (comision2 == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comision2 ";

		// 2. sin nada desde la pagina
		if (vendedor.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: vendedor ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) as total,fechabaja FROM clientesvendedor WHERE idvendedor = "
					+ idvendedor.toString()
					+ " and idempresa="
					+ idempresa.toString() + " group by fechabaja";

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			java.sql.Date fecha = null;
			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getInt("total");
				fecha = rsSalida.getDate("fechabaja");
			}
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {

				if (total > 0 && fecha == null) { // si existe hago update
					sql = "UPDATE CLIENTESVENDEDOR SET vendedor=?, comision1=?, comision2=?, domicilio=?, usuarioact=?, fechaact=?, sueldobasico =?, tipoliquidacion=?, tasadesercion=?, valorasociacion=? WHERE idvendedor=? and idempresa=?;";

					insert = dbconn.prepareStatement(sql);
					insert.setString(1, vendedor);
					insert.setDouble(2, comision1.doubleValue());
					insert.setDouble(3, comision2.doubleValue());
					insert.setString(4, domicilio);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, sueldobasico);
					insert.setString(8, tipoliquidacion);
					insert.setBigDecimal(9, tasadesercion);
					insert.setBigDecimal(10, valorasociacion);
					insert.setBigDecimal(11, idvendedor);
					insert.setBigDecimal(12, idempresa);

					int i = insert.executeUpdate();
					if (i > 0)
						salida = "Actualizacion Correcta";
					else
						salida = "Imposible actualizar el registro.";
				} else {
					if (total > 0 && fecha != null && reingresar == true) {
						sql = "UPDATE CLIENTESVENDEDOR SET vendedor=?, comision1=?, comision2=?, domicilio=?, usuarioact=?, fechaact=?, sueldobasico =?, tipoliquidacion=?, tasadesercion=?, valorasociacion=?, fechabaja = null WHERE idvendedor=? and idempresa=?;";

						insert = dbconn.prepareStatement(sql);
						insert.setString(1, vendedor);
						insert.setDouble(2, comision1.doubleValue());
						insert.setDouble(3, comision2.doubleValue());
						insert.setString(4, domicilio);
						insert.setString(5, usuarioact);
						insert.setTimestamp(6, fechaact);
						insert.setBigDecimal(7, sueldobasico);
						insert.setString(8, tipoliquidacion);
						insert.setBigDecimal(9, tasadesercion);
						insert.setBigDecimal(10, valorasociacion);
						insert.setBigDecimal(11, idvendedor);
						insert.setBigDecimal(12, idempresa);

						int i = insert.executeUpdate();
						if (i > 0)
							salida = "Actualizacion Correcta";
						else
							salida = "Imposible actualizar el registro.";
					} else {
						salida = "No se puede actualizar un vendedor dado de baja";
					}

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesvendedorUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesvendedorUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// ZONAS
	// para todo (ordena por el segundo campo por defecto)
	public List getClienteszonasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idzona,zona,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM clienteszonas WHERE idempresa= "
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteszonasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClienteszonasOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idzona,zona,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESZONAS WHERE idempresa="
				+ idempresa.toString()
				+ " and (idzona::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(zona) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteszonasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesZonasLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT z.idzona, z.zona, COALESCE(ce.idexpreso,0) AS idexpreso,"
				+ "       COALESCE(ce.expreso,'ATENCION: Expreso No Asociado') AS expreso , "
				+ "       z.usuarioalt, z.usuarioact, z.fechaalt,z.fechaact "
				+ "  FROM clienteszonas z"
				+ "       LEFT JOIN clientesexpresoszonas cez ON z.idzona = cez.idzona AND z.idempresa = cez.idempresa "
				+ "       LEFT JOIN clientesexpresos ce ON cez.idexpreso = ce.idexpreso AND cez.idempresa = ce.idempresa "
				+ " WHERE z.idempresa= " + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesZonasLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesZonasLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT z.idzona, z.zona, COALESCE(ce.idexpreso,0) AS idexpreso,"
				+ "       COALESCE(ce.expreso,'ATENCION: Expreso No Asociado') AS expreso , "
				+ "       z.usuarioalt, z.usuarioact, z.fechaalt,z.fechaact "
				+ "  FROM clienteszonas z"
				+ "       LEFT JOIN clientesexpresoszonas cez ON z.idzona = cez.idzona AND z.idempresa = cez.idempresa "
				+ "       LEFT JOIN clientesexpresos ce ON cez.idexpreso = ce.idexpreso AND cez.idempresa = ce.idempresa "
				+ " WHERE z.idempresa= " + idempresa.toString()
				+ " and (z.idzona::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(z.zona) LIKE '%" + ocurrencia.toUpperCase() + "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesZonasLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClienteszonasPK(BigDecimal idzona, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT  idzona,zona,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESZONAS WHERE idzona="
				+ idzona.toString() + "and idempresa=" + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteszonasPK( BigDecimal idzona )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clienteszonasDelete(BigDecimal idzona, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESZONAS WHERE idzona="
				+ idzona.toString() + "and idempresa=" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESZONAS WHERE idzona="
						+ idzona.toString() + "and idempresa="
						+ idempresa.toString();
				;
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clienteszonasDelete( BigDecimal idzona ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteszonasDelete( BigDecimal idzona )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clienteszonasCreate(String zona, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (zona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: zona ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (zona.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: zona ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESZONAS(zona, usuarioalt,idempresa ) VALUES (?,?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, zona);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clienteszonasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteszonasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clienteszonasCreateOrUpdate(BigDecimal idzona, String zona,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";
		if (zona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: zona ";

		// 2. sin nada desde la pagina
		if (zona.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: zona ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteszonas WHERE idzona = "
					+ idzona.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESZONAS SET zona=?, usuarioact=?, fechaact=? WHERE idzona=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, zona);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idzona);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESZONAS(zona, usuarioalt,idempresa ) VALUES (?,?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, zona);
					insert.setString(2, usuarioalt);
					insert.setBigDecimal(3, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clienteszonasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteszonasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteszonasUpdate(BigDecimal idzona, String zona,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";
		if (zona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: zona ";

		// 2. sin nada desde la pagina
		if (zona.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: zona ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteszonas WHERE idzona = "
					+ idzona.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESZONAS SET zona=?, usuarioact=?, fechaact=? WHERE idzona=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, zona);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idzona);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clienteszonasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clienteszonasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// LISTAS DE PRECION
	public List getClienteslistasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CL.idlista, CL.descri_lis, GL.moneda, CL.coniva_lis, CL.concuo_lis, CL.decima_lis, CL.usuarioalt, CL.usuarioact, CL.fechaalt, CL.fechaact FROM CLIENTESLISTAS CL, globalmonedas GL where GL.idmoneda = CL.idmoneda and Cl.idempresa="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistas()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClienteslistasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CL.idlista, CL.descri_lis, GL.moneda, CL.coniva_lis, CL.concuo_lis, CL.decima_lis, CL.usuarioalt, CL.usuarioact, CL.fechaalt, CL.fechaact FROM CLIENTESLISTAS CL, globalmonedas GL where GL.idmoneda = CL.idmoneda and CL.idempresa="
				+ idempresa.toString()
				+ " and (CL.idlista::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(CL.descri_lis) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClienteslistasPK(BigDecimal idlista, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT CL.idlista, CL.descri_lis, CL.idmoneda, GL.moneda, CL.coniva_lis, CL.concuo_lis, CL.decima_lis, CL.usuarioalt, CL.usuarioact, CL.fechaalt, CL.fechaact FROM CLIENTESLISTAS CL, globalmonedas GL where GL.idmoneda = CL.idmoneda and idlista="
				+ idlista.toString() + "and idempresa=" + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistasPK( BigDecimal idlista )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clienteslistasDelete(BigDecimal idlista, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESLISTAS WHERE idlista="
				+ idlista.toString() + "and idempresa=" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESLISTAS WHERE idlista="
						+ idlista.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clienteslistasDelete( BigDecimal idlista ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteslistasDelete( BigDecimal idlista )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clienteslistasCreate(String descri_lis, BigDecimal idmoneda,
			String coniva_lis, String concuo_lis, BigDecimal decima_lis,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (descri_lis == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descri_lis ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (descri_lis.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descri_lis ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESLISTAS(descri_lis, idmoneda, coniva_lis, concuo_lis, decima_lis, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, descri_lis);
				insert.setBigDecimal(2, idmoneda);
				insert.setString(3, coniva_lis);
				insert.setString(4, concuo_lis);
				insert.setBigDecimal(5, decima_lis);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clienteslistasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteslistasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clienteslistasCreateOrUpdate(BigDecimal idlista,
			String descri_lis, BigDecimal idmoneda, String coniva_lis,
			String concuo_lis, BigDecimal decima_lis, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (descri_lis == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descri_lis ";

		// 2. sin nada desde la pagina
		if (descri_lis.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descri_lis ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteslistas WHERE idlista = "
					+ idlista.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESLISTAS SET descri_lis=?, idmoneda=?, coniva_lis=?, concuo_lis=?, decima_lis=?, usuarioact=?, fechaact=? WHERE idlista=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descri_lis);
					insert.setBigDecimal(2, idmoneda);
					insert.setString(3, coniva_lis);
					insert.setString(4, concuo_lis);
					insert.setBigDecimal(5, decima_lis);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idlista);
					insert.setBigDecimal(9, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESLISTAS(descri_lis, idmoneda, coniva_lis, concuo_lis, decima_lis, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, descri_lis);
					insert.setBigDecimal(2, idmoneda);
					insert.setString(3, coniva_lis);
					insert.setString(4, concuo_lis);
					insert.setBigDecimal(5, decima_lis);
					insert.setString(6, usuarioalt);
					insert.setBigDecimal(7, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clienteslistasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteslistasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteslistasUpdate(BigDecimal idlista, String descri_lis,
			BigDecimal idmoneda, String coniva_lis, String concuo_lis,
			BigDecimal decima_lis, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (descri_lis == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descri_lis ";

		// 2. sin nada desde la pagina
		if (descri_lis.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descri_lis ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteslistas WHERE idlista = "
					+ idlista.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESLISTAS SET descri_lis=?, idmoneda=?, coniva_lis=?, concuo_lis=?, decima_lis=?, usuarioact=?, fechaact=? WHERE idlista=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descri_lis);
					insert.setBigDecimal(2, idmoneda);
					insert.setString(3, coniva_lis);
					insert.setString(4, concuo_lis);
					insert.setBigDecimal(5, decima_lis);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idlista);
					insert.setBigDecimal(9, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clienteslistasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clienteslistasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// traigo metodo all y Ocu para el lov globalmonedas
	// *************************************************
	public List getClientesglobalmonedasAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT idmoneda,moneda,idpais,usuarioalt,usuarioact,fechaalt,fechaact FROM globalmonedas ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesglobalmonedasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesglobalmonedasOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = "SELECT  idmoneda,moneda,idpais,usuarioalt,usuarioact,fechaalt,fechaact FROM globalmonedas"
				+ " where (idmoneda::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(moneda) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesglobalmonedasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// *************************************

	/**
	 * Metodos para la entidad: clientesClientes Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Feb 12 11:19:56 ART 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesClientesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,cl.idcondicion,"
				+ "       cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,cl.idlista,cl.idtipoclie,cl.observacion,"
				+ "       cl.lcredito,cl.idtipocomp,cl.autorizado,cl.idcredcate,"
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,"
				+ "       ce.idestado,ce.estado,ce.idmotivo,ce.motivo,ce.imagen, ti.tipoiva, "
				+ "       CASE WHEN re.idcliente IS NULL THEN 'N' ELSE 'S' END AS relacionado, "
				// 20110711 - EJV - Mantis 727 -->
				+ "       ccb.idclub, ccb.club, ccb.logo, idclientekosher  "
				// <--
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and  cl.idempresa = ti.idempresa "
				+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and  cl.idempresa = td.idempresa "
				// 20110711 - EJV - Mantis 727 -->
				+ "       INNER JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and  cl.idempresa = ctc.idempresa "
				+ "       INNER JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and  ctc.idempresa = ccb.idempresa "
				// <--
				+ "       LEFT  JOIN vclientesestadoshoy ce ON cl.idcliente = ce.idcliente and  cl.idempresa = ce.idempresa "
				+ "       LEFT  JOIN ( "
				+ "		              SELECT idclienteroot AS idcliente, idempresa "
				+ "		                FROM clientesrelaciones "
				+ "	                   UNION "
				+ " 	              SELECT idclientebranch AS idcliente, idempresa "
				+ "		                FROM clientesrelaciones "
				+ "                   )re ON cl.idcliente = re.idcliente AND cl.idempresa = re.idempresa "

				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesClientesOcu(long limit, long offset, String filtro,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT idcliente,razon,idtipodocumento,tipodocumento,nrodocumento,brutos,idtipoiva,idcondicion,"
				+ "            descuento1,descuento2,descuento3,idctaneto,idmoneda,idlista,idtipoclie,observacion,"
				+ "            lcredito,idtipocomp,autorizado,idcredcate,"
				+ "            idempresa,usuarioalt,usuarioact,fechaalt,fechaact,"
				+ "            idestado,estado,idmotivo,motivo,imagen, tipoiva, relacionado, "
				+ "            idclub, club, logo, idclientekosher, idvendedor, vendedor,"
				// 20121025 - CAMI - Mantis 891 -->
				+ "             fu_mail_cliente(idcliente, idempresa) email    "
				// <--
				+ " FROM ("
				+ "SELECT cl.idcliente,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,cl.idcondicion,"
				+ "       cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto,cl.idmoneda,cl.idlista,cl.idtipoclie,cl.observacion,"
				+ "       cl.lcredito,cl.idtipocomp,cl.autorizado,cl.idcredcate,"
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact,"
				+ "       ce.idestado,ce.estado,ce.idmotivo,ce.motivo,ce.imagen, ti.tipoiva, "
				+ "       CASE WHEN re.idcliente IS NULL THEN 'N' ELSE 'S' END AS relacionado, "

				// 20110711 - EJV - Mantis 727 -->
				+ "       ccb.idclub, ccb.club, ccb.logo, idclientekosher, "
				// <--
				// 20120314 - EJV - Mantis 702 -->
				+ "       cve.idvendedor, cve.vendedor "
				// <--
				//
				// 20121025 - KKCAMI - Mantis 891 -->
				// +
				// "       ,fu_mail_cliente(cl.idcliente, cl.idempresa) email "
				// <--
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva and  cl.idempresa = ti.idempresa "
				+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa  "
				// 20110711 - EJV - Mantis 727 -->
				+ "       INNER JOIN clientestipoclie ctc ON cl.idtipoclie = ctc.idtipoclie and  cl.idempresa = ctc.idempresa "
				+ "       INNER JOIN clientesclub ccb ON ctc.idclub = ccb.idclub and  ctc.idempresa = ccb.idempresa "
				// <--
				// 20120314 - EJV - Mantis 702 -->
				+ "       INNER JOIN clientesprecargaclientes cpc ON cl.idcliente = cpc.idcliente and  cl.idempresa = cpc.idempresa "
				+ "       INNER JOIN clientesvendedor cve ON cpc.idvendedorasignado = cve.idvendedor and  cpc.idempresa = cve.idempresa "
				// <--
				// 20121025 - CAMI - Mantis 891 -->
				// +
				// "		  LEFT JOIN clientesemail clie on cl.idcliente = clie.idcliente and cl.idempresa = clie.idempresa "
				// <---
				+ "       LEFT  JOIN vclientesestadoshoy ce ON cl.idcliente = ce.idcliente and  cl.idempresa = ce.idempresa "

				+ "       LEFT  JOIN ( "
				+ "		              SELECT idclienteroot AS idcliente, idempresa "
				+ "		                FROM clientesrelaciones "
				+ "	                   UNION "
				+ " 	              SELECT idclientebranch AS idcliente, idempresa "
				+ "		                FROM clientesrelaciones "
				+ "                   )re ON cl.idcliente = re.idcliente AND cl.idempresa = re.idempresa "
				// TODO: 20121106 - Tunning !! -->
				+ " ORDER BY cl.idcliente, cl.idempresa "
				// <--
				+ " )  vista "

				+ "  WHERE "
				// + " (UPPER(cl.razon) LIKE '%"
				// + filtro.toUpperCase().trim()
				// + "%' OR cl.idcliente::VARCHAR LIKE '%"
				// + filtro.toUpperCase().trim()
				// + "%' OR cl.idclientekosher::VARCHAR LIKE '%"
				// + filtro.toUpperCase().trim()
				// +
				// "%' OR cl.idcliente  IN (SELECT idcliente FROM clientetarjetascredito WHERE nrotarjeta::VARCHAR LIKE '"
				// + filtro.toUpperCase().trim() + "%' AND idempresa = "
				// + idempresa.toString()
				// + ")  OR cl.nrodocumento::VARCHAR LIKE '"
				// + filtro.toUpperCase().trim() + "%')  AND "
				+ " idempresa = " + idempresa.toString() + " " + filtro

				+ " ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";

		// o("cQuery: " + cQuery);
		List vecSalida = new ArrayList();
		try {
			// log.info(cQuery);
			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesClientesPK(BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva, "
				+ "       cl.idcondicion,co.condicion, cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto, "
				+ "       cl.idmoneda,mo.moneda,cl.idlista,li.descri_lis,cl.idtipoclie,tcl.tipoclie,cl.observacion, "
				+ "       cl.lcredito,cl.idtipocomp,tc.descri_tc,cl.autorizado,cl.idcredcate,cc.credcate, "
				+ "       COALESCE(ve.idvendedor, -1) AS idvendedor, COALESCE(ve.vendedor, '') AS vendedor, "
				+ "       pf.idpreferencia, pf.preferencia, COALESCE(cs.idcategoriasocio, -1), COALESCE(cs.categoriasocio, ''), adidesc,"
				// 20110624 - EJV - Factuaracion FE-CF-MA -->
				+ "       COALESCE(cl.sucursalfactura, -1) AS sucursalfactura, "
				// <--
				// 20110907 - EJV - Mantis 777 -->
				+ "       COALESCE(pro.idpromocion, -1) AS idpromocion, COALESCE(pro.promocion, '') AS promocion, "
				// <--
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact "
				+ "  FROM clientesclientes  cl "
				+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "       INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
				+ "       INNER JOIN clientescondicio co ON cl.idcondicion = co.idcondicion AND cl.idempresa = co.idempresa "
				+ "       INNER JOIN globalmonedas mo ON cl.idmoneda = mo.idmoneda  "
				+ "       INNER JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa "
				+ "       LEFT JOIN clientestipoclie tcl ON cl.idtipoclie = tcl.idtipoclie AND cl.idempresa = tcl.idempresa "
				+ "       LEFT JOIN clienteslistas li ON cl.idlista = li.idlista AND cl.idempresa = li.idempresa "
				+ "       LEFT JOIN clientestipocomp tc ON  cl.idtipocomp = tc.idtipocomp AND cl.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientesprecargaclientes pre ON  cl.idcliente = pre.idcliente AND cl.idempresa = pre.idempresa "
				+ "       LEFT JOIN clientesvendedor ve ON  pre.idvendedorasignado = ve.idvendedor AND pre.idempresa = ve.idempresa "
				+ "       LEFT JOIN clientespreferencias pf ON pre.idpreferencia = pf.idpreferencia AND pre.idempresa = pf.idempresa "
				+ "       LEFT JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa  AND ca.fhasta IS NULL"
				+ "       LEFT JOIN bacotmcategoriassocios cs ON cs.idcategoriasocio = ca.idcategoria AND cs.idempresa = ca.idempresa "
				// 20110907 - EJV - Mantis 777 -->
				+ "       LEFT JOIN clientesprecargaclientes prc ON cl.idcliente = prc.idcliente AND cl.idempresa = prc.idempresa "
				+ "       LEFT JOIN clientespromociones pro ON prc.idpromocion = pro.idpromocion AND prc.idempresa=pro.idempresa "
				// <--
				+ " WHERE cl.idcliente=" + idcliente.toString()
				+ "   AND cl.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesPK( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesClientesONE(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente,cl.razon,es.idestado, es.estado, cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva, "
				+ "       cl.idcondicion,co.condicion, cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto, "
				+ "       cl.idmoneda,mo.moneda,cl.idlista,li.descri_lis,cl.idtipoclie,tcl.tipoclie,cl.observacion, "
				+ "       cl.lcredito,cl.idtipocomp,tc.descri_tc,cl.autorizado,cl.idcredcate,cc.credcate, "
				+ "       COALESCE(ve.idvendedor, -1) AS idvendedor, COALESCE(ve.vendedor, '') AS vendedor, "
				+ "       pf.idpreferencia, pf.preferencia, COALESCE(cs.idcategoriasocio, -1), COALESCE(cs.categoriasocio, ''), adidesc,"
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact "
				+ "  FROM clientesclientes  cl "
				+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "       INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
				+ "       INNER JOIN clientescondicio co ON cl.idcondicion = co.idcondicion AND cl.idempresa = co.idempresa "
				+ "       INNER JOIN globalmonedas mo ON cl.idmoneda = mo.idmoneda  "
				+ "       INNER JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa "
				+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa  "
				+ "       LEFT JOIN clientestipoclie tcl ON cl.idtipoclie = tcl.idtipoclie AND cl.idempresa = tcl.idempresa "
				+ "       LEFT JOIN clienteslistas li ON cl.idlista = li.idlista AND cl.idempresa = li.idempresa "
				+ "       LEFT JOIN clientestipocomp tc ON  cl.idtipocomp = tc.idtipocomp AND cl.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientesprecargaclientes pre ON  cl.idcliente = pre.idcliente AND cl.idempresa = pre.idempresa "
				+ "       LEFT JOIN clientesvendedor ve ON  pre.idvendedorasignado = ve.idvendedor AND pre.idempresa = ve.idempresa "
				+ "       LEFT JOIN clientespreferencias pf ON pre.idpreferencia = pf.idpreferencia AND pre.idempresa = pf.idempresa "
				+ "       LEFT JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa  AND ca.fhasta IS NULL"
				+ "       LEFT JOIN bacotmcategoriassocios cs ON cs.idcategoriasocio = ca.idcategoria AND cs.idempresa = ca.idempresa"
				+ " WHERE cl.idcliente=" + idcliente.toString()
				+ "   AND cl.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesONE( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// Recuperar datos para un cliente, para un domicilio.

	public List getClientesClientesDomiPK(BigDecimal idcliente,
			BigDecimal iddomicilio, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente,cl.razon,cl.idtipodocumento,td.tipodocumento,cl.nrodocumento,cl.brutos,cl.idtipoiva,ti.tipoiva, "
				+ "       cl.idcondicion,co.condicion, cl.descuento1,cl.descuento2,cl.descuento3,cl.idctaneto, "
				+ "       cl.idmoneda,mo.moneda,cl.idlista,li.descri_lis,cl.idtipoclie,tcl.tipoclie,cl.observacion, "
				+ "       cl.lcredito,cl.idtipocomp,tc.descri_tc,cl.autorizado,cl.idcredcate,cc.credcate, "
				+ "       cd.idlocalidad, gl.localidad, gp.idprovincia, gp.provincia, cd.postal, cd.calle, "
				+ "       cd.nro, cd.piso, cd.depto, "
				// 20110624 - EJV - Factuaracion FE-CF-MA -->
				+ "       cl.sucursalfactura, "
				// <--
				// 20110930 - EJV - mantis 771 -->
				+ "       COALESCE(ccb.idclub, -1) idclub, COALESCE(ccb.club, '') club,"
				// <--
				+ "       cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact "
				+ "  FROM clientesclientes  cl "
				+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa  "
				+ "       INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
				+ "       INNER JOIN clientescondicio co ON cl.idcondicion = co.idcondicion AND cl.idempresa = co.idempresa "
				+ "       INNER JOIN globalmonedas mo ON cl.idmoneda = mo.idmoneda  "
				+ "       INNER JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente  AND cl.idempresa = cd.idempresa AND cd.iddomicilio =  "
				+ iddomicilio.toString()
				+ "       INNER JOIN globallocalidades gl ON cd.idlocalidad = gl.idlocalidad  "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia  "
				+ "       LEFT JOIN clientestipoclie tcl ON cl.idtipoclie = tcl.idtipoclie AND cl.idempresa = tcl.idempresa "
				+ "       LEFT JOIN clienteslistas li ON cl.idlista = li.idlista AND cl.idempresa = li.idempresa "
				+ "       LEFT JOIN clientestipocomp tc ON  cl.idtipocomp = tc.idtipocomp AND cl.idempresa = tc.idempresa "
				// 20110930 - EJV - mantis 771 -->
				+ "       LEFT JOIN clientesclub ccb ON tcl.idclub = ccb.idclub AND tcl.idempresa = ccb.idempresa "
				// <--
				+ " WHERE cl.idcliente =" + idcliente.toString()
				+ "   AND cl.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesDomiPK( BigDecimal idcliente, Bigdecimal iddomicilio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesClientesDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException, SQLException {
		ResultSet rsSalida = null;

		String cQuery = "SELECT * FROM CLIENTESCLIENTES WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		dbconn.setAutoCommit(false);

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {

				salida = clienteTarjetasCreditoXClienteDelete(idcliente,
						idempresa);

				if (salida.equalsIgnoreCase("OK")) {

					salida = clientesEmailXClienteDelete(idcliente, idempresa);

					if (salida.equalsIgnoreCase("OK")) {

						salida = clientesDomiciliosXClienteDelete(idcliente,
								idempresa);

						if (salida.equalsIgnoreCase("OK")) {

							cQuery = "DELETE FROM CLIENTESCLIENTES WHERE idcliente="
									+ idcliente.toString()
									+ " AND idempresa = "
									+ idempresa.toString();
							statement.execute(cQuery);
							int i = statement.getUpdateCount();

							if (i <= 0) {

								salida = "Cliente inexistente - eliminado desde otra sesion.";

							}

						}

					}

				}

			} else {
				salida = "Error: Cliente inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar cliente.";
			log
					.error("Error SQL en el metodo : clientesClientesDelete( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar cliente.";
			log
					.error("Salida por exception: en el metodo: clientesClientesDelete( BigDecimal idcliente )  "
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();

		} else {
			dbconn.commit();
			salida = "Baja de cliente correcta.";
		}
		dbconn.setAutoCommit(true);
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	/*
	 * Nota: se creo la variable resumido debido a que lo necesito para
	 * identificar de donde viene si de la base delta o la base delta_jaso en
	 * delta_jaso hay metodos que no los tengo que grabar por eso esta asi.
	 */
	public String clientesClientesCreate(BigDecimal idcliente, String razon,
			BigDecimal idtipodocumento, BigDecimal nrodocumento,
			BigDecimal idcategoria, String brutos, BigDecimal idtipoiva,
			BigDecimal idcondicion, Double descuento1, Double descuento2,
			Double descuento3, BigDecimal idctaneto, BigDecimal idmoneda,
			BigDecimal idlista, BigDecimal idtipoclie, String observacion,
			Double lcredito, BigDecimal idtipocomp, String autorizado,
			BigDecimal idcredcate, Hashtable htDomicilios,
			Hashtable htTarjetas, String[] idmes, BigDecimal idempresa,
			String usuarioalt, BigDecimal prospecto, BigDecimal resumido,
			BigDecimal sucursalfactura) throws EJBException, SQLException {
		String salida = "OK";
		Enumeration en;
		dbconn.setAutoCommit(false);
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo ";
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESCLIENTES"
						+ "  (idcliente, razon, idtipodocumento, nrodocumento, brutos, idtipoiva,  "
						+ "   idcondicion, descuento1, descuento2, descuento3, idctaneto, idmoneda, idlista, "
						+ "   idtipoclie, observacion, lcredito, idtipocomp, autorizado, idcredcate, "
						+ "   idempresa, usuarioalt )"
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setString(2, razon);
				insert.setBigDecimal(3, idtipodocumento);
				insert.setBigDecimal(4, nrodocumento);
				insert.setString(5, brutos);
				insert.setBigDecimal(6, idtipoiva);
				// insert.setBigDecimal(7, idvendedor);
				insert.setBigDecimal(7, idcondicion);
				insert.setDouble(8, descuento1.doubleValue());
				insert.setDouble(9, descuento2.doubleValue());
				insert.setDouble(10, descuento3.doubleValue());
				insert.setBigDecimal(11, idctaneto);
				insert.setBigDecimal(12, idmoneda);
				insert.setBigDecimal(13, idlista);
				insert.setBigDecimal(14, idtipoclie);
				insert.setString(15, observacion);
				insert.setDouble(16, lcredito.doubleValue());
				insert.setBigDecimal(17, idtipocomp);
				insert.setString(18, autorizado);
				insert.setBigDecimal(19, idcredcate);
				insert.setBigDecimal(20, sucursalfactura);
				insert.setBigDecimal(21, idempresa);
				insert.setString(22, usuarioalt);
				int n = insert.executeUpdate();

				if (n == 1) {

					en = htDomicilios.keys();
					while (en.hasMoreElements()) {
						Object[] domicilios = (Object[]) htDomicilios.get(en
								.nextElement());
						BigDecimal iddomicilio = new BigDecimal(domicilios[0]
								.toString());
						BigDecimal idtipodomicilio = new BigDecimal(
								domicilios[1].toString());
						// String tipodomicilio = domicilios[2].toString();
						String esdefault = domicilios[3].toString();
						String calle = domicilios[4].toString();
						String nro = domicilios[5].toString();
						String piso = domicilios[6].toString();
						String depto = domicilios[7].toString();
						BigDecimal idlocalidad = new BigDecimal(domicilios[8]
								.toString());
						// String localidad = domicilios[9].toString();
						String cpa = domicilios[10].toString();
						String postal = domicilios[11].toString();
						String contacto = domicilios[12].toString();
						String cargocontacto = domicilios[13].toString();
						String telefonos = domicilios[14].toString();
						String celular = domicilios[15].toString();
						String fax = domicilios[16].toString();
						String web = domicilios[17].toString();
						BigDecimal idzona = new BigDecimal(domicilios[18]
								.toString());
						// String zona = domicilios[19].toString();
						BigDecimal idexpreso = new BigDecimal(domicilios[20]
								.toString());
						// String expreso = domicilios[21].toString();
						BigDecimal idcobrador = new BigDecimal(domicilios[22]
								.toString());
						// String cobrador = domicilios[23].toString();
						BigDecimal idvendedor = new BigDecimal(domicilios[24]
								.toString());
						// String vendedor = domicilios[25].toString();
						String[] email = (String[]) domicilios[26];
						String statusItem = domicilios[27].toString();
						BigDecimal idanexolocalidad = new BigDecimal(
								domicilios[29].toString());
						String obsentrega = domicilios[30].toString();
						if (statusItem.equalsIgnoreCase("B"))
							continue;

						salida = clientesDomiciliosCreate(idcliente,
								idtipodomicilio, esdefault, calle, nro, piso,
								depto, idlocalidad, cpa, postal, contacto,
								cargocontacto, telefonos, celular, fax, web,
								idanexolocalidad, idcobrador, idvendedor,
								obsentrega, idempresa, usuarioalt);
						if (salida.equalsIgnoreCase("OK")) {

							iddomicilio = GeneralBean.getValorSequencia(
									"seq_clientesdomiclilios", dbconn);

							for (int j = 0; email != null && j < email.length; j++) {

								salida = clientesEmailCreate(iddomicilio,
										idcliente, email[j], idempresa,
										usuarioalt);

								if (!salida.equalsIgnoreCase("OK"))
									break;

							}

						}

					}

					if (salida.equalsIgnoreCase("OK")) {

						// 20090717 - EJV
						if (getTotalEntidadFiltro("clientesdomicilios",
								" WHERE idcliente = " + idcliente
										+ " AND esdefault = 'S' ", idempresa) < 1) {

							salida = "Es necesario marcar un domicilio de entrega como default.";

						}

						if (salida.equalsIgnoreCase("OK")) {

							if (htTarjetas != null && !htTarjetas.isEmpty()) {

								en = htTarjetas.keys();

								while (en.hasMoreElements()) {

									SimpleDateFormat sdf = new SimpleDateFormat(
											"dd/MM/yyyy");

									String[] tarjetasCliente = (String[]) htTarjetas
											.get(en.nextElement());
									// BigDecimal idtarjeta = new BigDecimal(
									// tarjetasCliente[0]);
									BigDecimal idtarjetacredito = new BigDecimal(
											tarjetasCliente[1]);
									// String tarjetacredito =
									// tarjetasCliente[2];
									BigDecimal idtipotarjeta = new BigDecimal(
											tarjetasCliente[3]);
									// String tipotarjeta = tarjetasCliente[4];
									String nrotarjeta = tarjetasCliente[5];
									String nrocontrol = tarjetasCliente[6];
									Timestamp fecha_emision = tarjetasCliente[7] != null
											&& !tarjetasCliente[7].equals("") ? new Timestamp(
											sdf.parse(
													tarjetasCliente[7]
															.replaceAll("-",
																	"/"))
													.getTime())
											: null;
									Timestamp fecha_vencimiento = new Timestamp(
											sdf.parse(
													tarjetasCliente[8]
															.replaceAll("-",
																	"/"))
													.getTime());
									String titular = tarjetasCliente[9];
									BigDecimal orden = new BigDecimal(
											tarjetasCliente[10]);
									String activa = tarjetasCliente[11];
									String statusItem = tarjetasCliente[12];

									if (statusItem.equalsIgnoreCase("B"))
										continue;

									salida = clienteTarjetasCreditoCreate(
											idtarjetacredito, idcliente,
											idtipotarjeta, nrotarjeta,
											nrocontrol, fecha_emision,
											fecha_vencimiento, titular, orden,
											activa, idempresa, usuarioalt);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

							/*
							 * aca pregunto si viene de la base DELTA viene la
							 * variable resumido en 1 y si viene de la base
							 * delta_jaso viene en 0 y dependiendo del valor
							 * ejecuto metodos o no.
							 */
							if (resumido.longValue() == 1
									&& salida.equalsIgnoreCase("OK")) {
								salida = clientesPeriodicidadEntregaGenerar(
										idcliente, idmes, idempresa, usuarioalt);

								if (salida.equalsIgnoreCase("OK"))
									salida = bacoTmCategorizacionesCreate(
											idcliente, idcategoria, null,
											usuarioalt, idempresa);

								// actualizo la tabla clientesprecarga le pongo
								// el
								// idcliente

								// if (salida.equalsIgnoreCase("OK"))
								// if (prospecto.longValue() != 0) {
								// salida = ClientesActualizar(prospecto,
								// idcliente, idempresa);
								// }
								log.debug("Salida antes de grabar estado "
										+ salida);

								if (salida.equalsIgnoreCase("OK"))
									salida = ClientesInsertoEstadoInicial(
											idcliente, new BigDecimal("1"),
											new BigDecimal("1"),
											"Alta del Socio",
											// 20111005 - EJV - Mantis 740 -->
											// "Alta del Socio",
											usuarioalt,
											// <--
											idempresa);
								log
										.info("Estoy pasando por la inicializacion del estado.........."
												+ idcliente);

							}

						}

					}

				}

			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesClientesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesClientesCreate(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}// actualizacion de un registro por PK NOTA: no se tiene en cuenta el //

	// primer
	// registro por PK y los datos de auditoria

	public String clientesClientesCreateOrUpdate(BigDecimal idcliente,
			String razon, BigDecimal idtipodocumento, BigDecimal nrodocumento,
			String brutos, BigDecimal idtipoiva, BigDecimal idcondicion,
			Double descuento1, Double descuento2, Double descuento3,
			BigDecimal idctaneto, BigDecimal idmoneda, BigDecimal idlista,
			BigDecimal idtipoclie, String observacion, Double lcredito,
			BigDecimal idtipocomp, String autorizado, BigDecimal idcredcate,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesClientes WHERE idcliente = "
					+ idcliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCLIENTES SET razon=?, idtipodocumento=?, nrodocumento=?, brutos=?, idtipoiva=?, idcondicion=?, descuento1=?, descuento2=?, descuento3=?, idctaneto=?, idmoneda=?, idlista=?, idtipoclie=?, observacion=?, lcredito=?, idtipocomp=?, autorizado=?, idcredcate=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcliente=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setBigDecimal(19, idempresa);
					insert.setString(20, usuarioact);
					insert.setTimestamp(21, fechaact);
					insert.setBigDecimal(22, idcliente);
				} else {
					String ins = "INSERT INTO CLIENTESCLIENTES(razon, idtipodocumento, nrodocumento, brutos, idtipoiva, idvendedor, idcondicion, descuento1, descuento2, descuento3, idctaneto, idmoneda, idlista, idtipoclie, observacion, lcredito, idtipocomp, autorizado, idcredcate, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setBigDecimal(19, idempresa);
					insert.setString(20, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesClientesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesClientesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * Nota: se creo la variable resumido debido a que lo necesito para
	 * identificar de donde viene si de la base delta o la base delta_jaso en
	 * delta_jaso hay metodos que no los tengo que grabar por eso esta asi.
	 */
	public String clientesClientesUpdate(BigDecimal idcliente, String razon,
			BigDecimal idtipodocumento, BigDecimal nrodocumento, String brutos,
			BigDecimal idtipoiva, BigDecimal idcondicion, Double descuento1,
			Double descuento2, Double descuento3, BigDecimal idctaneto,
			BigDecimal idmoneda, BigDecimal idlista, BigDecimal idtipoclie,
			String observacion, Double lcredito, BigDecimal idtipocomp,
			String autorizado, BigDecimal idcredcate, Hashtable htDomicilios,
			Hashtable htTarjetas, BigDecimal idempresa, String usuarioact,
			BigDecimal resumido, BigDecimal sucursalfactura)
			throws EJBException, SQLException {

		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		Enumeration en;
		dbconn.setAutoCommit(false);

		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (razon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: razon ";
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idtipoiva == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoiva ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (autorizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: autorizado ";
		if (idcredcate == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcredcate ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (razon.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: razon ";
		if (autorizado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: autorizado ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesClientes WHERE idcliente = "
					+ idcliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE CLIENTESCLIENTES "
							+ "      SET razon=?, idtipodocumento=?, nrodocumento=?, brutos=?, idtipoiva=?, "
							+ "             idcondicion=?, descuento1=?, descuento2=?, descuento3=?, idctaneto=?, idmoneda=?, idlista=?, idtipoclie=?, "
							+ "             observacion=?, lcredito=?, idtipocomp=?, autorizado=?, idcredcate=?, sucursalfactura=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcliente=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon);
					insert.setBigDecimal(2, idtipodocumento);
					insert.setBigDecimal(3, nrodocumento);
					insert.setString(4, brutos);
					insert.setBigDecimal(5, idtipoiva);
					// insert.setBigDecimal(6, idvendedor);
					insert.setBigDecimal(6, idcondicion);
					insert.setDouble(7, descuento1.doubleValue());
					insert.setDouble(8, descuento2.doubleValue());
					insert.setDouble(9, descuento3.doubleValue());
					insert.setBigDecimal(10, idctaneto);
					insert.setBigDecimal(11, idmoneda);
					insert.setBigDecimal(12, idlista);
					insert.setBigDecimal(13, idtipoclie);
					insert.setString(14, observacion);
					insert.setDouble(15, lcredito.doubleValue());
					insert.setBigDecimal(16, idtipocomp);
					insert.setString(17, autorizado);
					insert.setBigDecimal(18, idcredcate);
					insert.setBigDecimal(19, sucursalfactura);
					insert.setBigDecimal(20, idempresa);
					insert.setString(21, usuarioact);
					insert.setTimestamp(22, fechaact);
					insert.setBigDecimal(23, idcliente);

				}

				int i = insert.executeUpdate();
				if (i == 1) {

					en = htDomicilios.keys();

					while (en.hasMoreElements()) {

						Object[] domicilios = (Object[]) htDomicilios.get(en
								.nextElement());
						BigDecimal iddomicilio = new BigDecimal(domicilios[0]
								.toString());
						BigDecimal idtipodomicilio = new BigDecimal(
								domicilios[1].toString());
						// String tipodomicilio = domicilios[2].toString();
						String esdefault = domicilios[3].toString();
						String calle = domicilios[4].toString();
						String nro = domicilios[5].toString();
						String piso = domicilios[6].toString();
						String depto = domicilios[7].toString();
						BigDecimal idlocalidad = new BigDecimal(domicilios[8]
								.toString());
						// String localidad = domicilios[9].toString();
						String cpa = domicilios[10].toString();
						String postal = domicilios[11].toString();
						String contacto = domicilios[12].toString();
						String cargocontacto = domicilios[13].toString();
						String telefonos = domicilios[14].toString();
						String celular = domicilios[15].toString();
						String fax = domicilios[16].toString();
						String web = domicilios[17].toString();
						BigDecimal idzona = new BigDecimal(domicilios[18]
								.toString());
						// String zona = domicilios[19].toString();
						BigDecimal idexpreso = new BigDecimal(domicilios[20]
								.toString());
						// String expreso = domicilios[21].toString();
						BigDecimal idcobrador = new BigDecimal(domicilios[22]
								.toString());
						// String cobrador = domicilios[23].toString();
						BigDecimal idvendedor = new BigDecimal(domicilios[24]
								.toString());
						// String cobrador = domicilios[25].toString();
						String[] email = (String[]) domicilios[26];
						String statusItem = domicilios[27].toString();

						/*
						 * nota: aca si ejecuto la base delta viene la variable
						 * resumido tiene valor 1 si viene de delta_jaso tiene 0
						 * entonces si viene de delta_jaso ejecuto el campo
						 * idanexolocalidad = null sino idanexolocalidad = new
						 * BigDecimal(domicilios[29].toString());
						 */
						BigDecimal idanexolocalidad;
						if (resumido.longValue() == 0) {
							idanexolocalidad = new BigDecimal(-1);
						} else {
							idanexolocalidad = new BigDecimal(domicilios[29]
									.toString());
						}

						// BigDecimal idanexolocalidad = new
						// BigDecimal(domicilios[29].toString());
						String obsentrega = domicilios[30].toString();

						// log.debug("Domicilio : " + iddomicilio);
						// log.debug("statusItem: " + statusItem);
						if (statusItem.equalsIgnoreCase("A")) {

							salida = clientesDomiciliosCreate(idcliente,
									idtipodomicilio, esdefault, calle, nro,
									piso, depto, idlocalidad, cpa, postal,
									contacto, cargocontacto, telefonos,
									celular, fax, web, idanexolocalidad,
									idcobrador, idvendedor, obsentrega,
									idempresa, usuarioact);

							if (salida.equalsIgnoreCase("OK")) {

								iddomicilio = GeneralBean.getValorSequencia(
										"seq_clientesdomiclilios", dbconn);

								for (int j = 0; email != null
										&& j < email.length; j++) {

									salida = clientesEmailCreate(iddomicilio,
											idcliente, email[j], idempresa,
											usuarioact);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						} else if (statusItem.equalsIgnoreCase("U")) {
							salida = clientesDomiciliosUpdate(iddomicilio,
									idcliente, idtipodomicilio, esdefault,
									calle, nro, piso, depto, idlocalidad, cpa,
									postal, contacto, cargocontacto, telefonos,
									celular, fax, web, idanexolocalidad,
									idcobrador, idvendedor, obsentrega,
									idempresa, usuarioact);

							if (salida.equalsIgnoreCase("OK")) {

								salida = clientesEmailXDomicilioDelete(
										iddomicilio, idempresa);

								for (int j = 0; salida.equalsIgnoreCase("OK")
										&& email != null && j < email.length; j++) {

									salida = clientesEmailCreate(iddomicilio,
											idcliente, email[j], idempresa,
											usuarioact);

								}

							}

						} else if (statusItem.equalsIgnoreCase("B")) {

							if (iddomicilio.longValue() > 0) {

								salida = clientesEmailXDomicilioDelete(
										idcliente, idempresa);

								if (salida.equalsIgnoreCase("OK"))
									salida = clientesDomiciliosDelete(
											iddomicilio, idempresa);

							}
						}

					}

					if (salida.equalsIgnoreCase("OK")) {

						// 20090717 - EJV
						if (getTotalEntidadFiltro("clientesdomicilios",
								" WHERE idcliente = " + idcliente
										+ " AND esdefault = 'S' ", idempresa) < 1) {

							salida = "Es necesario marcar un domicilio de entrega como default.";

						}

						if (salida.equalsIgnoreCase("OK")) {

							if (htTarjetas != null && !htTarjetas.isEmpty()) {

								en = htTarjetas.keys();

								while (en.hasMoreElements()) {

									SimpleDateFormat sdf = new SimpleDateFormat(
											"dd/MM/yyyy");

									String[] tarjetasCliente = (String[]) htTarjetas
											.get(en.nextElement());
									BigDecimal idtarjeta = new BigDecimal(
											tarjetasCliente[0]);
									BigDecimal idtarjetacredito = new BigDecimal(
											tarjetasCliente[1]);
									// String tarjetacredito =
									// tarjetasCliente[2];
									BigDecimal idtipotarjeta = new BigDecimal(
											tarjetasCliente[3]);
									// String tipotarjeta = tarjetasCliente[4];
									String nrotarjeta = tarjetasCliente[5];
									String nrocontrol = tarjetasCliente[6];
									Timestamp fecha_emision = tarjetasCliente[7] != null
											&& !tarjetasCliente[7].equals("") ? new Timestamp(
											sdf.parse(
													tarjetasCliente[7]
															.replaceAll("-",
																	"/"))
													.getTime())
											: null;
									Timestamp fecha_vencimiento = new Timestamp(
											sdf.parse(
													tarjetasCliente[8]
															.replaceAll("-",
																	"/"))
													.getTime());
									String titular = tarjetasCliente[9];
									BigDecimal orden = new BigDecimal(
											tarjetasCliente[10]);
									String activa = tarjetasCliente[11];
									String statusItem = tarjetasCliente[12];

									// log.info("Tarjetas : " + idtarjeta);
									// log.info("statusItem: " + statusItem);

									if (statusItem.equalsIgnoreCase("A"))
										salida = clienteTarjetasCreditoCreate(
												idtarjetacredito, idcliente,
												idtipotarjeta, nrotarjeta,
												nrocontrol, fecha_emision,
												fecha_vencimiento, titular,
												orden, activa, idempresa,
												usuarioact);
									else if (statusItem.equalsIgnoreCase("U"))
										salida = clienteTarjetasCreditoUpdate(
												idtarjeta, idtarjetacredito,
												idcliente, idtipotarjeta,
												nrotarjeta, nrocontrol,
												fecha_emision,
												fecha_vencimiento, titular,
												orden, activa, idempresa,
												usuarioact);
									else if (statusItem.equalsIgnoreCase("B"))
										if (idtarjeta.longValue() > 0)
											salida = clienteTarjetasCreditoDelete(
													idtarjeta, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}

							}

						}

					}

				} else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesClientesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesClientesUpdate(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	// 20110331 - EJV - Mantis 683 -->
	public String clientesClientesAndClientesPrecargaUpdateDocumento(
			BigDecimal idcliente, BigDecimal idtipodocumento,
			BigDecimal nrodocumento, BigDecimal idempresa, String usuarioact)
			throws EJBException, SQLException {

		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";

		dbconn.setAutoCommit(false);

		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (nrodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {
			int i = 0;
			long total = -1;
			ResultSet rsSalida = null;
			PreparedStatement insert = null;
			String sql = "";
			String filtro = " WHERE idcliente <>  " + idcliente
					+ " AND nrodocumento = " + nrodocumento
					+ " AND idtipodocumento = " + idtipodocumento;

			total = getTotalEntidadFiltro("clientesclientes", filtro, idempresa);

			if (total == 0) {

				if (salida.equalsIgnoreCase("OK")) {

					sql = "UPDATE clientesclientes SET idtipodocumento=?, nrodocumento=?, usuarioact=?, fechaact=? WHERE idcliente=? AND idempresa=?;";

					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtipodocumento);
					insert.setBigDecimal(2, nrodocumento);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idcliente);
					insert.setBigDecimal(6, idempresa);

					if (total == 0) {
						total = -1;
						i = insert.executeUpdate();
						if (i == 1) {

							total = getTotalEntidadFiltro(
									"clientesprecargaclientes", filtro,
									idempresa);

							sql = "UPDATE clientesprecargaclientes SET idtipodocumento=?, nrodocumento=?, usuarioact=?, fechaact=? WHERE idcliente=? AND idempresa=?;";

							insert = dbconn.prepareStatement(sql);
							insert.setBigDecimal(1, idtipodocumento);
							insert.setBigDecimal(2, nrodocumento);
							insert.setString(3, usuarioact);
							insert.setTimestamp(4, fechaact);
							insert.setBigDecimal(5, idcliente);
							insert.setBigDecimal(6, idempresa);

							i = insert.executeUpdate();
							if (i == 1) {

							} else
								salida = "[E2.1]Imposible actualizar el registro precarga.";

						} else
							salida = "[E2.0]Imposible actualizar el registro cliente, el documento esta asociado a otro cliente.";

					} else
						salida = "[E1.1]Imposible actualizar el registro cliente.";
				}

			} else
				salida = "[E1.0]Imposible actualizar el registro cliente, el documento esta asociado a otro cliente.";

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible actualizar documento de cliente.";
			log
					.error("Error SQL public String clientesClientesAndClientesPrecargaUpdateDocumento(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible actualizar documento de cliente.";
			log
					.error("Error excepcion public String clientesClientesAndClientesPrecargaUpdateDocumento(.....)"
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	// <--

	// para el lov de cobradores
	// COBRADORES
	// para todo (ordena por el segundo campo por defecto)
	public List getClientescobradoresAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idcobrador, cobrador, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientescobradores where idempresa ="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescobradoresAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientescobradoresOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idcobrador, cobrador, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientescobradores WHERE idempresa ="
				+ idempresa.toString()
				+ " and (idcobrador::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(cobrador) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescobradoresOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para el lov de tipo de comprobante
	// TIPO DE COMPROBANTE
	// para todo (ordena por el segundo campo por defecto)
	public List getClientestipocompAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtipocomp, descri_tc, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientestipocomp where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipocompAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientestipocompOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtipocomp, descri_tc, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientestipocomp "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtipocomp::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(descri_tc) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipocompOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// ----------------------------------------------------------------------------------------------------------------------------------------------
	// PEDIDOS

	// public String[] pedidosCreate(BigDecimal idcampacabe, BigDecimal
	// idestado,
	// BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
	// Timestamp fechapedido, BigDecimal idcondicion,
	// BigDecimal idvendedor, BigDecimal idexpreso, BigDecimal comision,
	// BigDecimal ordencompra, String obsarmado, String obsentrega,
	// BigDecimal recargo1, BigDecimal recargo2, BigDecimal recargo3,
	// BigDecimal recargo4, BigDecimal bonific1, BigDecimal bonific2,
	// BigDecimal bonific3, BigDecimal idlista, BigDecimal idmoneda,
	// BigDecimal cotizacion, BigDecimal idtipoiva, BigDecimal totaliva,
	// BigDecimal idprioridad, BigDecimal idzona, BigDecimal idtarjeta,
	// BigDecimal cuotas, String origenpedido, BigDecimal total,
	// String tipopedido, Hashtable htArticulos, String usuarioalt,
	// BigDecimal idempresa, Properties properties) throws EJBException,
	// SQLException {
	//
	// String[] salida = new String[] { "OK", "" };
	//
	// if (properties == null || properties.isEmpty())
	// properties = this.props;
	//
	// try {
	//
	// if (tipopedido.equalsIgnoreCase("N")) {
	//
	// salida = pedidosNormalesCreate(idcampacabe, idestado,
	// idcliente, idsucursal, idsucuclie, fechapedido,
	// idcondicion, idvendedor, idexpreso, comision,
	// ordencompra, obsarmado, obsentrega, recargo1, recargo2,
	// recargo3, recargo4, bonific1, bonific2, bonific3,
	// idlista, idmoneda, cotizacion, idtipoiva, totaliva,
	// idprioridad, idzona, idtarjeta, cuotas, origenpedido,
	// total, tipopedido, htArticulos, usuarioalt, idempresa,
	// properties);
	//
	// } else if (tipopedido.equalsIgnoreCase("R")) {
	//
	// salida = pedidosRegalosCreate(idcampacabe, idestado, idcliente,
	// idsucursal, idsucuclie, fechapedido, idcondicion,
	// idvendedor, idexpreso, comision, ordencompra,
	// obsarmado, obsentrega, recargo1, recargo2, recargo3,
	// recargo4, bonific1, bonific2, bonific3, idlista,
	// idmoneda, cotizacion, idtipoiva, totaliva, idprioridad,
	// idzona, idtarjeta, cuotas, origenpedido, total,
	// tipopedido, htArticulos, usuarioalt, idempresa,
	// properties);
	//
	// }
	//
	// } catch (Exception e) {
	// log.error("pedidosCreate(...):" + e);
	// }
	//
	// return salida;
	//
	// }
	//

	public String[] pedidosNormalesCreate(BigDecimal idcampacabe,
			BigDecimal idestado, BigDecimal idcliente, BigDecimal idsucursal,
			BigDecimal idsucuclie, Timestamp fechapedido,
			BigDecimal idcondicion, BigDecimal idvendedor,
			BigDecimal idexpreso, BigDecimal comision, BigDecimal ordencompra,
			String obsarmado, String obsentrega, BigDecimal recargo1,
			BigDecimal recargo2, BigDecimal recargo3, BigDecimal recargo4,
			BigDecimal bonific1, BigDecimal bonific2, BigDecimal bonific3,
			BigDecimal idlista, BigDecimal idmoneda, BigDecimal cotizacion,
			BigDecimal idtipoiva, BigDecimal totaliva, BigDecimal idprioridad,
			BigDecimal idzona, BigDecimal idtarjeta, BigDecimal cuotas,
			String origenpedido, BigDecimal total, String tipopedido,
			Hashtable htArticulos, BigDecimal idlistaReferidos,
			BigDecimal idanexolocalidad, BigDecimal idpromocion,
			BigDecimal idventaespecial, java.sql.Date fechafactura,
			String usuarioalt, BigDecimal idempresa, Properties properties)
			throws EJBException, SQLException {

		String[] salida = new String[] { "OK", "" };
		String[] resultado = new String[] { "", "" };
		BigDecimal idpedido_cabe = null;
		int renglon = 0;
		Enumeration en;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fechapedido == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idcondicion == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idvendedor == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idmoneda == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (usuarioalt == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida[0] = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// 20100804 - EJV - Reasignacion -->
		if (idanexolocalidad == null || idanexolocalidad.longValue() < 0)
			salida[0] = "Error: Anexo-localidad no asociado al domicilio del cliente. ";
		// <--

		// fin validaciones

		// 20120510 -- EJV - Movimientos stock x 2 -->
		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		// dbconn.setAutoCommit(false);

		try {

			if (conn == null)
				return new String[] {
						"E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.",
						"" };

			conn.setAutoCommit(false);
			// <--

			if (salida[0].equalsIgnoreCase("OK")) {

				if (htArticulos != null && !htArticulos.isEmpty()) {

					String ins = ""
							+ "INSERT INTO pedidos_cabe(idestado, idcliente, idsucursal, idsucuclie, fechapedido, "
							+ "  idcondicion, idvendedor, idexpreso, comision, ordencompra, obsarmado,obsentrega, "
							+ "  recargo1,recargo2, recargo3, recargo4, bonific1, bonific2, bonific3, idlista, idmoneda, "
							+ "  cotizacion,idtipoiva, totaliva, idprioridad, idzona, idtarjeta,"
							+ "  cuotas, origenpedido, idanexolocalidad, idpromocion, idventaespecial, fechafactura, usuarioalt, idempresa ) "
							+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					// PreparedStatement insert = dbconn.prepareStatement(ins);
					PreparedStatement insert = conn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idestado);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idsucursal);
					insert.setBigDecimal(4, idsucuclie);
					insert.setTimestamp(5, fechapedido);
					insert.setBigDecimal(6, idcondicion);
					insert.setBigDecimal(7, idvendedor);
					insert.setBigDecimal(8, idexpreso);
					insert.setBigDecimal(9, comision);
					insert.setBigDecimal(10, ordencompra);
					insert.setString(11, obsarmado);
					insert.setString(12, obsentrega);
					insert.setBigDecimal(13, recargo1);
					insert.setBigDecimal(14, recargo2);
					insert.setBigDecimal(15, recargo3);
					insert.setBigDecimal(16, recargo4);
					insert.setBigDecimal(17, bonific1);
					insert.setBigDecimal(18, bonific2);
					insert.setBigDecimal(19, bonific3);
					insert.setBigDecimal(20, idlista);
					insert.setBigDecimal(21, idmoneda);
					insert.setBigDecimal(22, cotizacion);
					insert.setBigDecimal(23, idtipoiva);
					insert.setBigDecimal(24, totaliva);
					insert.setBigDecimal(25, idprioridad);
					insert.setBigDecimal(26, idzona);
					insert.setBigDecimal(27, idtarjeta);
					insert.setBigDecimal(28, cuotas);
					insert.setString(29, origenpedido);
					insert.setBigDecimal(30, idanexolocalidad);
					insert.setBigDecimal(31, idpromocion);
					insert.setBigDecimal(32, idventaespecial);
					insert.setDate(33, fechafactura);
					insert.setString(34, usuarioalt);
					insert.setBigDecimal(35, idempresa);

					int n = insert.executeUpdate();
					if (n != 1)
						salida[0] = "Imposible generar cabecera del pedido.";
					else {
						// faltan recuperar datos
						// -- recupero el numero de sequence que se corresponde
						// con el
						// pedido.
						// select currval('seq_pedidos_cabe')
						idpedido_cabe = GeneralBean.getValorSequencia(
								"seq_pedidos_cabe", conn);
						en = htArticulos.keys();
						// log
						// .info("PED-htArticulos.size();"
						// + htArticulos.size());
						// log.info("PED-htArticulos ;" + htArticulos);
						while (en.hasMoreElements()
								&& salida[0].equalsIgnoreCase("OK")) {
							// log.info("........> ");
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulos
									.get(key);

							// for (int m = 0; m < datosArticulo.length; m++)
							// log.info("PED - datosArticulo [" + m + "]:"
							// + datosArticulo[m]);
							String codigo_st = datosArticulo[0];
							// log.info("DETA: " + codigo_st);

							BigDecimal cantidad = new BigDecimal(
									datosArticulo[10]);
							BigDecimal codigo_dt = new BigDecimal(
									datosArticulo[9]);

							BigDecimal bonificacion = new BigDecimal(
									datosArticulo[4]);

							BigDecimal precio = new BigDecimal(datosArticulo[5]);

							BigDecimal importe = new BigDecimal(
									datosArticulo[11]);

							BigDecimal codigo_md = new BigDecimal(
									datosArticulo[13]);

							BigDecimal iddescuento_suge = new BigDecimal(
									datosArticulo[17]);
							BigDecimal iddescuento_apli = new BigDecimal(
									datosArticulo[18]);

							BigDecimal porcdesc_suge = new BigDecimal(
									datosArticulo[19]);
							BigDecimal porcdesc_apli = new BigDecimal(
									datosArticulo[20]);
							BigDecimal idmotivodescuento = new BigDecimal(
									datosArticulo[21]);

							BigDecimal tipoiva_st = GeneralBean.setNull(
									new BigDecimal(datosArticulo[24]), 0);
							BigDecimal porciva_st = new BigDecimal(
									datosArticulo[26]);
							BigDecimal totaliva_st = new BigDecimal(
									datosArticulo[27]);

							// 20091204 - EJV - Mantis 475 -->
							// BigDecimal cantidad_sb = new BigDecimal(
							// datosArticulo[28]);
							// BigDecimal compromiso_sb = new BigDecimal(
							// datosArticulo[29]);

							BigDecimal cantidad_sb = GeneralBean
									.getCantidadArticuloDeposito(codigo_st,
											codigo_dt, idempresa, conn);
							BigDecimal compromiso_sb = GeneralBean
									.getCantidadReservaArticuloDeposito(
											codigo_st, codigo_dt, idempresa,
											conn);
							// <--

							String inventa_st = datosArticulo[30];

							// log.info("ANTES GENERAR DETA - codigo_st: "
							// + codigo_st);
							// log.info("ANTES GENERAR DETA - KEY: " + key);

							salida[0] = pedidos_DetaCreate(idpedido_cabe,
									codigo_st, fechapedido, new BigDecimal(
											++renglon), precio, new BigDecimal(
											0), cantidad, bonificacion,
									codigo_md, new BigDecimal(0), codigo_dt,
									"N", iddescuento_suge, iddescuento_apli,
									porcdesc_suge, porcdesc_apli,
									idmotivodescuento, tipoiva_st, porciva_st,
									totaliva_st, cantidad_sb, compromiso_sb,
									usuarioalt, idempresa, conn);

							if (salida[0].equalsIgnoreCase("OK")) {

								if (inventa_st.equalsIgnoreCase("N"))
									continue;

								resultado = stockStockBisCantPediCreateUpdate(
										codigo_st, codigo_dt, cantidad,
										usuarioalt, idempresa, conn);

								// Guardar alertas de stock con cantidad en
								// cero.
								salida[0] = resultado[0];
								salida[1] += resultado[1];

								// EJV - REFERIDOS
								// 20100630 -- >

								if (idlista.longValue() == idlistaReferidos
										.longValue()) {

									java.sql.Date fecha = new java.sql.Date(
											Calendar.getInstance()
													.getTimeInMillis());
									BigDecimal puntos = getBacoRefCatalogoPuntos(
											codigo_st, fecha, idempresa);
									// 20120314 - EJV - Mantis 702 -->
									BigDecimal puntosTotal = puntos
											.multiply(cantidad);
									// <--

									// 20120410 - EJV - Mantis 702 -->
									BigDecimal puntosCtaCte = getBacoRefCtaCtePuntosCliente(
											idcliente, idempresa, conn);

									if (puntosCtaCte.subtract(puntosTotal)
											.doubleValue() >= 0) {
										// <--
										salida[0] = bacoRefCatalogoUpdateCantidades(
												codigo_st, new BigDecimal(0),
												cantidad, fecha, idempresa,
												usuarioalt, conn);

										if (salida[0].equalsIgnoreCase("OK")) {

											bacoRefCtaCteCreate(
													idcliente,
													new BigDecimal(6),
													new BigDecimal(0),
													// 20120314 - EJV - Mantis
													// 702
													// -->
													// puntos.negate(),
													puntosTotal.negate(),
													// <--
													fecha,
													"CANJE AUTOMATICO DE PUNTOS - PEDIDO "
															+ idpedido_cabe,
													idpedido_cabe, idempresa,
													usuarioalt, conn);
										}

									} else {

										salida[0] = "Saldo del socio de puntos a canjear insuficiente [ "
												+ puntosCtaCte
												+ " ], se necesitan [ "
												+ puntosTotal + " ] puntos";

									}

								}

								// < --

							}

						}

					}

				} else {

					salida[0] = "El pedido que se intenta generar para el cliente ("
							+ idcliente + "), carece de detalle.";

				}

			}

			// 20090918 -- TODO:
			if (salida[0].equalsIgnoreCase("OK")) {

				if (properties == null || properties.isEmpty())
					properties = this.props;

				try {

					String conmutador = "";

					if (conmutador.equals("")) {
						BCBean b = new BCBean();
						b.InterFacesGenerarPedido(idpedido_cabe, idcampacabe,
								idcliente, idsucuclie, fechapedido,
								idcondicion, obsarmado, obsentrega, totaliva,
								idprioridad, idzona, idtarjeta, cuotas,
								origenpedido, total, cotizacion, htArticulos,
								usuarioalt, idempresa, properties);

					} else if (conmutador.equals("D1")) {

						// PRUEBAS PARA LA GENERACION DE CAMPANIA EN BACO ...

						// BCBean.getSetCampaniaActivaBaco(idempresa,
						// usuarioalt, dbconn, dbconn);

					} else {

						log
								.warn(" ----------------               !!  ATENCION !!            ----------------");
						log
								.warn("|                                                                                  |");
						log
								.warn("|  INTERFACE PEDIDOS DELTA < - >BACO APAGADA       |");
						log
								.warn("|                                                                                  |");
						log
								.warn(" ----------------                      ***                      -----------------");

					}

				} catch (Exception eBC) {
					log
							.error("EXC - pedidosNormalesCreate(.....), al ejecutarse INTERFACE BACO / pedido ["
									+ idpedido_cabe + "] : " + eBC);
				}

			}

		} catch (SQLException sqlException) {
			salida[0] = "SQLE: Imposible generar pedido.";
			log.error("Error SQL public String[] pedidosNormalesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida[0] = "EX: Imposible generar pedido.";
			log
					.error("Error excepcion public String[] pedidosNormalesCreate(.....)"
							+ ex);
		}
		if (!salida[0].equalsIgnoreCase("OK")) {
			conn.rollback();
		} else {

			// ACA VA COMMMMITTTTTTTTTT !!!!!!

			conn.commit();
			salida[0] = idpedido_cabe.toString();
		}

		// conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	public String[] pedidosRegalosCreate(BigDecimal idcampacabe,
			BigDecimal idpedido_regalos_padre, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idcondicion,
			BigDecimal idvendedor, BigDecimal idexpreso, BigDecimal comision,
			BigDecimal ordencompra, String obsarmado, String obsentrega,
			BigDecimal recargo1, BigDecimal recargo2, BigDecimal recargo3,
			BigDecimal recargo4, BigDecimal bonific1, BigDecimal bonific2,
			BigDecimal bonific3, BigDecimal idlista, BigDecimal idmoneda,
			BigDecimal cotizacion, BigDecimal idtipoiva, BigDecimal totaliva,
			BigDecimal idprioridad, BigDecimal idzona, BigDecimal idtarjeta,
			BigDecimal cuotas, String origenpedido, BigDecimal total,
			String tipopedido, Hashtable htArticulos, String transformacion,
			String usuarioalt, BigDecimal idempresa, Properties properties)
			throws EJBException, SQLException {

		String[] salida = new String[] { "OK", "" };
		String[] resultado = new String[] { "", "" };
		BigDecimal idpedido_cabe = null;

		boolean reservaStock = true;

		int renglon = 0;
		Enumeration en;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fechapedido == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idcondicion == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		// if (idvendedor == null)
		// salida[0] =
		// "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";

		if (idmoneda == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (usuarioalt == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida[0] = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		dbconn.setAutoCommit(false);
		try {
			if (salida[0].equalsIgnoreCase("OK")) {

				if (htArticulos != null && !htArticulos.isEmpty()) {

					String ins = ""
							+ "INSERT INTO pedidos_regalos_cabe(idpedido_regalos_padre, idestado, idcliente, idsucursal, idsucuclie, fechapedido, "
							+ "  idcondicion, idvendedor, idexpreso, comision, ordencompra, obsarmado,obsentrega, "
							+ "  recargo1,recargo2, recargo3, recargo4, bonific1, bonific2, bonific3, idlista, idmoneda, "
							+ "  cotizacion,idtipoiva, totaliva, idprioridad, idzona, idtarjeta,"
							+ "  cuotas, origenpedido, transformacion, usuarioalt, idempresa ) "
							+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					PreparedStatement insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idpedido_regalos_padre);
					insert.setBigDecimal(2, idestado);
					insert.setBigDecimal(3, idcliente);
					insert.setBigDecimal(4, idsucursal);
					insert.setBigDecimal(5, idsucuclie);
					insert.setTimestamp(6, fechapedido);
					insert.setBigDecimal(7, idcondicion);
					insert.setBigDecimal(8, idvendedor);
					insert.setBigDecimal(9, idexpreso);
					insert.setBigDecimal(10, comision);
					insert.setBigDecimal(11, ordencompra);
					insert.setString(12, obsarmado);
					insert.setString(13, obsentrega);
					insert.setBigDecimal(14, recargo1);
					insert.setBigDecimal(15, recargo2);
					insert.setBigDecimal(16, recargo3);
					insert.setBigDecimal(17, recargo4);
					insert.setBigDecimal(18, bonific1);
					insert.setBigDecimal(19, bonific2);
					insert.setBigDecimal(20, bonific3);
					insert.setBigDecimal(21, idlista);
					insert.setBigDecimal(22, idmoneda);
					insert.setBigDecimal(23, cotizacion);
					insert.setBigDecimal(24, idtipoiva);
					insert.setBigDecimal(25, totaliva);
					insert.setBigDecimal(26, idprioridad);
					insert.setBigDecimal(27, idzona);
					insert.setBigDecimal(28, idtarjeta);
					insert.setBigDecimal(29, cuotas);
					insert.setString(30, origenpedido);
					insert.setString(31, transformacion);
					insert.setString(32, usuarioalt);
					insert.setBigDecimal(33, idempresa);

					int n = insert.executeUpdate();
					if (n != 1)
						salida[0] = "Imposible generar cabecera del pedido.";
					else {
						// faltan recuperar datos
						// -- recupero el numero de sequence que se corresponde
						// con el
						// pedido.
						// select currval('seq_pedidos_cabe')
						idpedido_cabe = GeneralBean.getValorSequencia(
								"seq_pedidos_regalos_cabe", dbconn);

						// 20101109 - EJV - Mantis 602
						// Si.no.hay.proceso.de.transformacion.es.hijo.de.algun.otro.pedido.incluido.el.mismo.-->
						if (transformacion.equalsIgnoreCase("N")) {

							// 20101109 - EJV - Mantis 602
							// Si no es pedido padre no debe resrvar stock.
							if (idpedido_regalos_padre == null
									|| idpedido_regalos_padre.longValue() < 1)
								idpedido_regalos_padre = idpedido_cabe;
							else
								reservaStock = false;

							salida[0] = pedidosRegalosCabeUpdPedidoPadre(
									idpedido_cabe, idpedido_regalos_padre,
									idempresa, usuarioalt);

						}
						// <--

						en = htArticulos.keys();
						// log.info("htArticulos.size();" + htArticulos.size());
						while (en.hasMoreElements()
								&& salida[0].equalsIgnoreCase("OK")) {
							// log.info("........> ");
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulos
									.get(key);

							// for (int m = 0; m < datosArticulo.length; m++)
							// log.info("datosArticulo [" + m + "]:"
							// + datosArticulo[m]);
							String codigo_st = datosArticulo[0];
							// log.info("DETA: " + codigo_st);

							BigDecimal cantidad = new BigDecimal(
									datosArticulo[10]);
							BigDecimal codigo_dt = new BigDecimal(
									datosArticulo[9]);

							BigDecimal bonificacion = new BigDecimal(
									datosArticulo[4]);

							BigDecimal precio = new BigDecimal(datosArticulo[5]);

							BigDecimal importe = new BigDecimal(
									datosArticulo[11]);

							BigDecimal codigo_md = new BigDecimal(
									datosArticulo[13]);

							BigDecimal iddescuento_suge = new BigDecimal(
									datosArticulo[17]);
							BigDecimal iddescuento_apli = new BigDecimal(
									datosArticulo[18]);

							BigDecimal porcdesc_suge = new BigDecimal(
									datosArticulo[19]);
							BigDecimal porcdesc_apli = new BigDecimal(
									datosArticulo[20]);
							BigDecimal idmotivodescuento = new BigDecimal(
									datosArticulo[21]);

							BigDecimal tipoiva_st = GeneralBean.setNull(
									new BigDecimal(datosArticulo[24]), 0);
							BigDecimal porciva_st = new BigDecimal(
									datosArticulo[26]);
							BigDecimal totaliva_st = new BigDecimal(
									datosArticulo[27]);
							BigDecimal cantidad_sb = new BigDecimal(
									datosArticulo[28]);
							BigDecimal compromiso_sb = new BigDecimal(
									datosArticulo[29]);
							String inventa_st = datosArticulo[30];

							salida[0] = pedidos_regalos_DetaCreate(
									idpedido_cabe, codigo_st, fechapedido,
									new BigDecimal(++renglon), precio,
									new BigDecimal(0), cantidad, bonificacion,
									codigo_md, new BigDecimal(0), codigo_dt,
									"R", iddescuento_suge, iddescuento_apli,
									porcdesc_suge, porcdesc_apli,
									idmotivodescuento, tipoiva_st, porciva_st,
									totaliva_st, cantidad_sb, compromiso_sb,
									usuarioalt, idempresa);

							if (salida[0].equalsIgnoreCase("OK")) {

								if (inventa_st.equalsIgnoreCase("N")
										|| !reservaStock)
									continue;

								resultado = stockStockBisCantPediCreateUpdate(
										codigo_st, codigo_dt, cantidad,
										usuarioalt, idempresa, dbconn);

								// Guardar alertas de stock con cantidad en
								// cero.
								salida[0] = resultado[0];
								salida[1] += resultado[1];

							}

						}

					}

				}

			}

			// 20090918 -- TODO:
			if (salida[0].equalsIgnoreCase("OK")) {

				try {

					String conmutador = "OFF";

					if (conmutador.equals("")) {

						if (properties == null || properties.isEmpty())
							properties = this.props;
						BCBean b = new BCBean();
						b.InterFacesGenerarPedido(idpedido_cabe, idcampacabe,
								idcliente, idsucuclie, fechapedido,
								idcondicion, obsarmado, obsentrega, totaliva,
								idprioridad, idzona, idtarjeta, cuotas,
								origenpedido, total, cotizacion, htArticulos,
								usuarioalt, idempresa, properties);

					} else if (conmutador
							.equals("POR AHORA ESTO TAMBIEN QUEDA OUT")) {

						// PRUEBAS PARA LA GENERACION DE CAMPANIA EN BACO ...

						// BCBean.getSetCampaniaActivaBaco(idempresa,
						// usuarioalt, dbconn, dbconn);

					} else {
						log
								.warn("----------------                        !!  ATENCION !!                       ----------------");
						log
								.warn("|                                                                                                      |");
						log
								.warn("| INTERFACE PEDIDOS REGALOS DELTA < - >BACO NO SE UTILIZA     |");
						log
								.warn("|                                                                                                       |");
						log
								.warn("----------------                                   ***                               -----------------");
					}

				} catch (Exception eBC) {
					log
							.error("EXC - pedidosRegalosCreate(.....), al ejecutarse INTERFACE BACO / pedido ["
									+ idpedido_cabe + "] : " + eBC);
				}

			}

		} catch (SQLException sqlException) {
			salida[0] = "SQLE: Imposible generar pedido.";
			log.error("Error SQL public String[] pedidosRegalosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida[0] = "EX: Imposible generar pedido.";
			log
					.error("Error excepcion public String[] pedidosRegalosCreate(.....)"
							+ ex);
		}

		if (!salida[0].equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {

			// ACA VA COMMMMITTTTTTTTTT !!!!!!

			dbconn.commit();
			salida[0] = idpedido_cabe.toString();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	public String[] pedidosRegalosUpdate(BigDecimal idpedido_regalos_cabe,
			BigDecimal idcampacabe, BigDecimal idpedido_regalos_padre,
			BigDecimal idestado, BigDecimal idcliente, BigDecimal idsucursal,
			BigDecimal idsucuclie, Timestamp fechapedido,
			BigDecimal idcondicion, BigDecimal idvendedor,
			BigDecimal idexpreso, BigDecimal comision, BigDecimal ordencompra,
			String obsarmado, String obsentrega, BigDecimal recargo1,
			BigDecimal recargo2, BigDecimal recargo3, BigDecimal recargo4,
			BigDecimal bonific1, BigDecimal bonific2, BigDecimal bonific3,
			BigDecimal idlista, BigDecimal idmoneda, BigDecimal cotizacion,
			BigDecimal idtipoiva, BigDecimal totaliva, BigDecimal idprioridad,
			BigDecimal idzona, BigDecimal idtarjeta, BigDecimal cuotas,
			String origenpedido, BigDecimal total, String tipopedido,
			Hashtable htArticulos, String transformacion, String usuarioalt,
			BigDecimal idempresa, Properties properties) throws EJBException,
			SQLException {

		String[] salida = new String[] { "OK", "" };
		String[] resultado = new String[] { "", "" };

		boolean reservaStock = true;

		int renglon = 0;
		Enumeration en;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fechapedido == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idcondicion == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		// if (idvendedor == null)
		// salida[0] =
		// "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";

		if (idmoneda == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (usuarioalt == null)
			salida[0] = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida[0] = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		dbconn.setAutoCommit(false);
		try {
			if (salida[0].equalsIgnoreCase("OK")) {

				if (htArticulos != null && !htArticulos.isEmpty()) {

					String upd = ""
							+ "UPDATE pedidos_regalos_cabe "
							+ "      SET idpedido_regalos_padre=?,  idsucursal=?, idsucuclie=?, fechapedido=?, "
							+ "             idcondicion=?, idexpreso=?, comision=?, obsarmado=?,obsentrega=?, "
							+ "             recargo1=?,recargo2=?, recargo3=?, recargo4=?, bonific1=?, bonific2=?, bonific3=?, "
							+ "             idlista=?, idmoneda=?, idtipoiva=?, totaliva=?, idprioridad=?, idzona=?, idtarjeta=?,"
							+ "             cuotas=?, origenpedido=?, usuarioact=?, fechaact=? "
							+ "WHERE idpedido_regalos_cabe=? "
							+ "    AND idempresa=? ";
					PreparedStatement update = dbconn.prepareStatement(upd);
					// seteo de campos:
					update.setBigDecimal(1, idpedido_regalos_padre);
					// update.setBigDecimal(2, idestado);
					// update.setBigDecimal(3, idcliente);
					update.setBigDecimal(2, idsucursal);
					update.setBigDecimal(3, idsucuclie);
					update.setTimestamp(4, fechapedido);
					update.setBigDecimal(5, idcondicion);
					// update.setBigDecimal(8, idvendedor);
					update.setBigDecimal(6, idexpreso);
					update.setBigDecimal(7, comision);
					// update.setBigDecimal(11, ordencompra);
					update.setString(8, obsarmado);
					update.setString(9, obsentrega);
					update.setBigDecimal(10, recargo1);
					update.setBigDecimal(11, recargo2);
					update.setBigDecimal(12, recargo3);
					update.setBigDecimal(13, recargo4);
					update.setBigDecimal(14, bonific1);
					update.setBigDecimal(15, bonific2);
					update.setBigDecimal(16, bonific3);
					update.setBigDecimal(17, idlista);
					update.setBigDecimal(18, idmoneda);
					// update.setBigDecimal(23, cotizacion);
					update.setBigDecimal(19, idtipoiva);
					update.setBigDecimal(20, totaliva);
					update.setBigDecimal(21, idprioridad);
					update.setBigDecimal(22, idzona);
					update.setBigDecimal(23, idtarjeta);
					update.setBigDecimal(24, cuotas);
					update.setString(25, origenpedido);
					update.setString(26, usuarioalt);
					update.setTimestamp(27, new Timestamp(Calendar
							.getInstance().getTimeInMillis()));
					update.setBigDecimal(28, idpedido_regalos_cabe);
					update.setBigDecimal(29, idempresa);

					int n = update.executeUpdate();
					if (n != 1)
						salida[0] = "Imposible modificar cabecera del pedido.";
					else {

						// 20101109 - EJV - Mantis 602
						// Si.no.hay.proceso.de.transformacion.es.hijo.de.algun.otro.pedido.incluido.el.mismo.-->
						if (transformacion.equalsIgnoreCase("N")) {

							// 20101109 - EJV - Mantis 602
							// Si no es pedido padre no debe resrvar stock.
							if (idpedido_regalos_padre != null
									&& idpedido_regalos_padre.longValue() > 0
									&& idpedido_regalos_padre.longValue() != idpedido_regalos_cabe
											.longValue())
								reservaStock = false;

							// salida[0] = pedidosRegalosCabeUpdPedidoPadre(
							// idpedido_regalos_cabe,
							// idpedido_regalos_padre, idempresa,
							// usuarioalt);

						}
						// <--

						// --------------------INICIA.ELIMINAR.DETALLE.ACTUAL--------------------->

						/*
						 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
						 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
						 * codigo_dt
						 * ,entrega,usuarioalt,usuarioact,fechaalt,fechaact
						 */

						Iterator iterDetalle = getPedidosRegalosDetaXPedido(
								idpedido_regalos_cabe, idempresa).iterator();

						while (iterDetalle.hasNext()
								&& salida[0].equalsIgnoreCase("OK")) {

							String[] datos = (String[]) iterDetalle.next();

							BigDecimal idpedido_regalos_deta = new BigDecimal(
									datos[0]);
							String inventa_st = datos[13];
							String articu_sb = datos[2];
							BigDecimal deposi_sb = new BigDecimal(datos[11]);
							BigDecimal canti_sb = new BigDecimal(datos[7]);
							BigDecimal pedid_sb = new BigDecimal(datos[7])
									.negate();
							BigDecimal cantidadEnReserva = new BigDecimal(0);

							// for(int r=0;r<datos.length ;r++)log.info("datos["
							// + r
							// + "]: " + datos[r]);

							if (inventa_st.equalsIgnoreCase("N"))
								continue;

							cantidadEnReserva = GeneralBean
									.getCantidadReservaArticuloDeposito(
											articu_sb, deposi_sb, idempresa,
											dbconn);

							if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

								salida[0] = StockBean
										.stockStockBisCantidadesUpdate(
												articu_sb, deposi_sb, canti_sb,
												pedid_sb, dbconn, usuarioalt,
												idempresa);

								if (!salida[0].equalsIgnoreCase("OK"))
									break;

								salida[0] = pedidos_Regalos_DetaDelete(
										idpedido_regalos_deta, idempresa);

								if (!salida[0].equalsIgnoreCase("OK"))
									break;

							} else {
								salida[0] = "No es posible Modificar el pedido, la cantidad en reserva ["
										+ cantidadEnReserva
										+ "] es menor a la del pedido ["
										+ pedid_sb.abs()
										+ "]. Art.: "
										+ articu_sb + " - Dep.: " + deposi_sb;
								break;
							}

						}

						// <--------------------FINAL.ELIMINAR.DETALLE.ACTUAL---------------------

						// --------------------INICIA.CREAR.DETALLE.NUEVO--------------------->
						en = htArticulos.keys();
						// log.info("htArticulos.size();" + htArticulos.size());
						while (en.hasMoreElements()
								&& salida[0].equalsIgnoreCase("OK")) {
							// log.info("........> ");
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulos
									.get(key);

							// for (int m = 0; m < datosArticulo.length; m++)
							// log.info("datosArticulo [" + m + "]:"
							// + datosArticulo[m]);
							String codigo_st = datosArticulo[0];
							// log.info("DETA: " + codigo_st);

							BigDecimal cantidad = new BigDecimal(
									datosArticulo[10]);
							BigDecimal codigo_dt = new BigDecimal(
									datosArticulo[9]);

							BigDecimal bonificacion = new BigDecimal(
									datosArticulo[4]);

							BigDecimal precio = new BigDecimal(datosArticulo[5]);

							BigDecimal importe = new BigDecimal(
									datosArticulo[11]);

							BigDecimal codigo_md = new BigDecimal(
									datosArticulo[13]);

							BigDecimal iddescuento_suge = new BigDecimal(
									datosArticulo[17]);
							BigDecimal iddescuento_apli = new BigDecimal(
									datosArticulo[18]);

							BigDecimal porcdesc_suge = new BigDecimal(
									datosArticulo[19]);
							BigDecimal porcdesc_apli = new BigDecimal(
									datosArticulo[20]);
							BigDecimal idmotivodescuento = new BigDecimal(
									datosArticulo[21]);

							BigDecimal tipoiva_st = GeneralBean.setNull(
									new BigDecimal(datosArticulo[24]), 0);
							BigDecimal porciva_st = new BigDecimal(
									datosArticulo[26]);
							BigDecimal totaliva_st = new BigDecimal(
									datosArticulo[27]);
							BigDecimal cantidad_sb = new BigDecimal(
									datosArticulo[28]);
							BigDecimal compromiso_sb = new BigDecimal(
									datosArticulo[29]);
							String inventa_st = datosArticulo[30];

							salida[0] = pedidos_regalos_DetaCreate(
									idpedido_regalos_cabe, codigo_st,
									fechapedido, new BigDecimal(++renglon),
									precio, new BigDecimal(0), cantidad,
									bonificacion, codigo_md, new BigDecimal(0),
									codigo_dt, "R", iddescuento_suge,
									iddescuento_apli, porcdesc_suge,
									porcdesc_apli, idmotivodescuento,
									tipoiva_st, porciva_st, totaliva_st,
									cantidad_sb, compromiso_sb, usuarioalt,
									idempresa);

							if (salida[0].equalsIgnoreCase("OK")) {

								if (inventa_st.equalsIgnoreCase("N")
										|| !reservaStock)
									continue;

								resultado = stockStockBisCantPediCreateUpdate(
										codigo_st, codigo_dt, cantidad,
										usuarioalt, idempresa, dbconn);

								// Guardar alertas de stock con cantidad en
								// cero.
								salida[0] = resultado[0];
								salida[1] += resultado[1];

							}

						}
						// --------------------FINAL.CREAR.DETALLE.NUEVO--------------------->

					}

				}

			}

			// 20090918 -- TODO:
			// if (salida[0].equalsIgnoreCase("OK")) {
			//
			// try {
			//
			// String conmutador = "OFF";
			//
			// if (conmutador.equals("")) {
			//
			// if (properties == null || properties.isEmpty())
			// properties = this.props;
			//
			// BCBean.InterFacesGenerarPedido(idpedido_regalos_cabe,
			// idcampacabe, idcliente, idsucuclie,
			// fechapedido, idcondicion, obsarmado,
			// obsentrega, totaliva, idprioridad, idzona,
			// idtarjeta, cuotas, origenpedido, total,
			// cotizacion, htArticulos, usuarioalt, idempresa,
			// properties);
			//
			// } else if (conmutador
			// .equals("POR AHORA ESTO TAMBIEN QUEDA OUT")) {
			//
			// // PRUEBAS PARA LA GENERACION DE CAMPANIA EN BACO ...
			//
			// // BCBean.getSetCampaniaActivaBaco(idempresa,
			// // usuarioalt, dbconn, dbconn);
			//
			// } else {
			// log
			// .warn("----------------      !!  ATENCION !!         ----------------");
			// log
			// .warn("|                                                             |");
			// log
			// .warn("| INTERFACE PEDIDOS REGALOS DELTA < - >BACO NO SE UTILIZA     |");
			// log
			// .warn("|                                                             |");
			// log
			// .warn("----------------              ***            -----------------");
			// }
			//
			// } catch (Exception eBC) {
			// log
			// .error("EXC - pedidosRegalsCreate(.....), al ejecutarse INTERFACE BACO / pedido ["
			// + idpedido_regalos_cabe + "] : " + eBC);
			// }
			//
			// }

		} catch (SQLException sqlException) {
			salida[0] = "SQLE: Imposible generar pedido.";
			log.error("Error SQL public String[] pedidosRegalosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida[0] = "EX: Imposible generar pedido.";
			log
					.error("Error excepcion public String[] pedidosRegalosUpdate(.....)"
							+ ex);
		}

		if (!salida[0].equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {

			// ACA VA COMMMMITTTTTTTTTT !!!!!!

			dbconn.commit();
			salida[0] = idpedido_regalos_cabe.toString();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	/**
	 * Actualizar cabecera pedido - setear pedido padre.
	 */

	public String pedidosRegalosCabeUpdPedidoPadre(BigDecimal idpedido_cabe,
			BigDecimal idpedido_regalos_padre, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";

		if (idpedido_regalos_padre != null
				&& idpedido_cabe != idpedido_regalos_padre) {
			int idestado = -1;
			idestado = getPedidoRegalosEstadoPedido(idpedido_regalos_padre,
					idempresa);

			if (idestado == -100)
				salida = "Se produjo un error al intentar recuperar estado de pedido padre.";
			else if (idestado == -90)
				salida = "No fue posible recuperar estado de pedido padre.";
			else if (idestado != 4)
				salida = "Solo se puede asignar un pedido padre cuando el estado de este ultimo es 4, el actual estado del mismo es "
						+ idestado + ".";
		}

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_regalos_cabe WHERE idpedido_regalos_cabe = "
					+ idpedido_cabe.toString() + " AND idempresa =" + idempresa;

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE pedidos_regalos_cabe SET idpedido_regalos_padre=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_regalos_cabe=?  AND idempresa=? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idpedido_regalos_padre);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_cabe);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible asignar pedido padre de pedido Nro.: "
								+ idpedido_cabe;

				} else {

					log.info("Asignar pedido padre no encuentra registro");
					salida = "Pedido Nro.:(" + idpedido_cabe
							+ "), posiblemente actualizado desde otra sesion.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "SQLE - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log
					.error("Error SQL public String pedidosRegalosCabeUpdPedidoPadre(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log
					.error("Error excepcion public String pedidosRegalosCabeUpdPedidoPadre(.....)"
							+ ex);
		}

		return salida;

	}

	/**
	 * Actualizar cabecera pedido - cambiar estado.
	 */

	public String pedidosRegalosCabeUpdEstado(BigDecimal idpedido_cabe,
			BigDecimal nuevoidestado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_regalos_cabe WHERE idpedido_regalos_cabe = "
					+ idpedido_cabe.toString() + " AND idempresa =" + idempresa;

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE pedidos_regalos_cabe SET idestado=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_regalos_cabe=?  AND idempresa=? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, nuevoidestado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_cabe);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible actualizar estado de pedido Nro.: "
								+ idpedido_cabe;

				} else {

					log.info("Cambiar estado no encuentra registro");
					salida = "Pedido Nro.:(" + idpedido_cabe
							+ "), posiblemente actualizado desde otra sesion.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "SQLE - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log
					.error("Error SQL public String pedidosRegalosCabeUpdEstado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log
					.error("Error excepcion public String pedidosRegalosCabeUpdEstado(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidos_Cabe Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Sep 04 11:02:26 GMT-03:00 2008
	 * 
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosHistoricoClienteAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_cabe,es.estado,pc.idcliente,pc.idsucursal,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'N' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idcliente = "
				+ idcliente.toString()
				+ " AND pc.idempresa = "
				+ idempresa.toString()
				+ " UNION ALL "
				+ "SELECT pc.idpedido_regalos_cabe,es.estado,pc.idcliente,pc.idsucursal,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idcliente = "
				+ idcliente.toString()
				+ " AND pc.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY fechapedido DESC  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosHistoricoClienteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosHistoricoClienteOcu(long limit, long offset,
			String ocurrencia, BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_cabe,es.estado,pc.idsucursal,pc.idcliente,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'N' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE (pc.idpedido_cabe::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER (es.estado) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND pc.idcliente = "
				+ idcliente.toString()
				+ " AND pc.idempresa = "
				+ idempresa.toString()
				+ " UNION ALL "
				+ "SELECT pc.idpedido_regalos_cabe,es.estado,pc.idsucursal,pc.idcliente,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE (pc.idpedido_regalos_cabe::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER (es.estado) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')   AND pc.idcliente = "
				+ idcliente.toString()
				+ " AND pc.idempresa = "
				+ idempresa.toString()

				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_CabeOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosRegalosClienteAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_regalos_cabe,es.idestado,es.estado,pc.idcliente,pc.idsucursal,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idcliente = " + idcliente.toString()
				+ "      AND pc.idempresa = "
				+ idempresa.toString()
				// EJV - 20101115 - MANTIS 602
				+ "    AND pc.idpedido_regalos_padre IS NULL"
				+ "  ORDER BY fechapedido DESC  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosClienteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosRegalosClienteOcu(long limit, long offset,
			String ocurrencia, BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_regalos_cabe,es.idestado,es.estado,pc.idsucursal,pc.idcliente,cd.calle || ' ' || cd.nro as direccion, "
				+ "       pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "       recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "       pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "                 AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE  (pc.idpedido_regalos_cabe::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER (es.estado) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')   AND pc.idcliente = "
				+ idcliente.toString() + " AND pc.idempresa = "
				+ idempresa.toString()
				// EJV - 20101115 - MANTIS 602
				+ "    AND pc.idpedido_regalos_padre IS NULL"

				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosClienteOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public int getPedidoRegalosReservaStock(BigDecimal idpedido_regalos_cabe,
			BigDecimal idempresa) throws EJBException {

		int retorno = -100;
		String cQuery = ""
				+ "SELECT COALESCE(idpedido_regalos_padre, 0) AS idpedido_regalos_padre, transformacion "
				+ "  FROM pedidos_regalos_cabe   "
				+ "WHERE idestado <> 99 AND  idpedido_regalos_cabe="
				+ idpedido_regalos_cabe.toString() + "  AND  idempresa = "
				+ idempresa.toString();

		Statement st = null;
		ResultSet rs = null;
		String transformacion = "";
		BigDecimal idpedido_regalos_padre = new BigDecimal(0);

		try {

			st = dbconn.createStatement();
			rs = st.executeQuery(cQuery);

			if (rs != null) {

				if (rs.next()) {

					transformacion = rs.getString("transformacion");
					idpedido_regalos_padre = rs
							.getBigDecimal("idpedido_regalos_padre");

					if (transformacion.equalsIgnoreCase("S")) {
						// Pedido padre, reservo stock.
						retorno = 1;
					} else {

						if (idpedido_regalos_padre.longValue() == idpedido_regalos_cabe
								.longValue()) {
							// Pedido padre de si mismo, reservo stock.
							retorno = 1;
						} else if (idpedido_regalos_padre.longValue() == 0) {
							// Pedido padre, sin transformacion, datos
							// incongruentes. Esta condicion no deberia darse
							// jamas.
							retorno = -95;
							log
									.warn("getPedidoRegalosReservaStock: no fue posible validar si el pedido reservo stock: "
											+ retorno);

						} else {
							// Pedido hijo, no reservo stock.
							retorno = 0;
						}

					}

				} else {

					retorno = -96;
					log
							.warn("getPedidoRegalosReservaStock: no fue posible validar si el pedido reservo stock: "
									+ retorno);
				}

			} else {

				retorno = -97;
				log
						.warn("getPedidoRegalosReservaStock: no fue posible validar si el pedido reservo stock: "
								+ retorno);
			}

		} catch (SQLException sqle) {
			retorno = -98;
			log
					.error("Salida por SQLexception: en el metodo: getPedidoRegalosReservaStock( BigDecimal idpedido_cabe, idempresa )  "
							+ sqle);

		} catch (Exception ex) {
			retorno = -99;
			log
					.error("Salida por exception: en el metodo: getPedidoRegalosReservaStock( BigDecimal idpedido_cabe, idempresa )  "
							+ ex);
		}
		return retorno;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosHistoricoClientePK(BigDecimal idpedido_cabe,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT pc.idpedido_cabe, es.estado, pc.idcliente, pc.idsucursal, cd.calle, cd.nro , "
				+ "       cd.piso, cd.depto, cd.cpa, cd.postal, cd.contacto, gl.localidad, gp.provincia,  "
				+ "       pc.fechapedido, co.condicion, COALESCE(ve.vendedor, ''), ex.expreso, pc.comision, pc.ordencompra, pc.obsarmado, "
				+ "       pc.obsentrega, pc.recargo1, pc.recargo2, pc.recargo3, pc.recargo4, pc.bonific1, pc.bonific2,  "
				+ "       pc.bonific3, lp.descri_lis, gm.moneda, pc.cotizacion, ti.tipoiva, pc.totaliva, pr.prioridad, z.zona, "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN '' ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS tarjeta,  "
				+ "       pc.cuotas, pc.origenpedido, pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact  "
				+ "  FROM pedidos_cabe pc  "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "	             AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN globallocalidades gl ON cd.idlocalidad = gl.idlocalidad "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				// 20100212 - EJV - MANTIS 421 --->
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientesvendedor ve ON pc.idvendedor = ve.idvendedor AND  pc.idempresa = ve.idempresa   "
				// +
				// "       INNER JOIN clientesvendedor ve ON pc.idvendedor = ve.idvendedor AND  pc.idempresa = ve.idempresa   "
				// <--
				+ "       INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND  pc.idempresa = ex.idempresa   "
				+ "       INNER JOIN clienteslistas lp ON pc.idlista = lp.idlista  AND  pc.idempresa = lp.idempresa "
				+ "       INNER JOIN globalmonedas gm ON pc.idmoneda = gm.idmoneda  "
				+ "       INNER JOIN clientestablaiva ti ON pc.idtipoiva = ti.idtipoiva  AND  pc.idempresa = ti.idempresa "
				+ "       INNER JOIN pedidosprioridades  pr ON pc.idprioridad = pr.idprioridad "
				+ "       INNER JOIN clienteszonas z ON pc.idzona = z.idzona  AND  pc.idempresa = z.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idpedido_cabe = " + idpedido_cabe.toString()
				+ "   AND pc.idcliente = " + idcliente.toString()
				+ "   AND pc.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosHistoricoClientePK( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosHistoricoClientePK(BigDecimal idpedido_cabe,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT pc.idpedido_regalos_cabe, es.estado, pc.idcliente, pc.idsucursal, cd.calle, cd.nro , "
				+ "       cd.piso, cd.depto, cd.cpa, cd.postal, cd.contacto, gl.localidad, gp.provincia,  "
				+ "       pc.fechapedido, co.condicion, COALESCE(ve.vendedor, ''), ex.expreso, pc.comision, pc.ordencompra, pc.obsarmado, "
				+ "       pc.obsentrega, pc.recargo1, pc.recargo2, pc.recargo3, pc.recargo4, pc.bonific1, pc.bonific2,  "
				+ "       pc.bonific3, lp.descri_lis, gm.moneda, pc.cotizacion, ti.tipoiva, pc.totaliva, pr.prioridad, z.zona, "
				+ "       CASE WHEN pc.idtarjeta < 0 THEN '' ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS tarjeta,  "
				+ "       pc.cuotas, pc.origenpedido, pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact  "
				+ "  FROM pedidos_regalos_cabe pc  "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "	             AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN globallocalidades gl ON cd.idlocalidad = gl.idlocalidad "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia "
				+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "       INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "       LEFT JOIN clientesvendedor ve ON pc.idvendedor = ve.idvendedor AND  pc.idempresa = ve.idempresa   "
				+ "       INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND  pc.idempresa = ex.idempresa   "
				+ "       INNER JOIN clienteslistas lp ON pc.idlista = lp.idlista  AND  pc.idempresa = lp.idempresa "
				+ "       INNER JOIN globalmonedas gm ON pc.idmoneda = gm.idmoneda  "
				+ "       INNER JOIN clientestablaiva ti ON pc.idtipoiva = ti.idtipoiva  AND  pc.idempresa = ti.idempresa "
				+ "       INNER JOIN pedidosprioridades  pr ON pc.idprioridad = pr.idprioridad "
				+ "       INNER JOIN clienteszonas z ON pc.idzona = z.idzona  AND  pc.idempresa = z.idempresa "
				+ "       LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta AND pc.idempresa = tc.idempresa "
				+ "       LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idpedido_regalos_cabe = "
				+ idpedido_cabe.toString() + "   AND pc.idcliente = "
				+ idcliente.toString() + "   AND pc.idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosHistoricoClientePK( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// 

	// 20110120 - EJV - Mantis - 661 -->

	public List getPedidosEntregasHistoricoClientePK(BigDecimal idpedido_cabe,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT pc.idpedido_regalos_entrega_cabe, es.estado, pc.idcliente, pc.idsucursal, cd.calle, cd.nro , "
				+ "        cd.piso, cd.depto, cd.cpa, cd.postal, cd.contacto, gl.localidad, gp.provincia,   "
				+ "        pc.fechapedido, co.condicion, COALESCE(ve.vendedor, ''), ex.expreso, rc.comision, rc.ordencompra, pc.obsarmado, "
				+ "        pc.obsentrega, rc.recargo1, rc.recargo2, rc.recargo3, rc.recargo4, rc.bonific1, rc.bonific2,   "
				+ "        rc.bonific3, lp.descri_lis, gm.moneda, rc.cotizacion, ti.tipoiva, rc.totaliva, pr.prioridad, z.zona,  "
				+ "        CASE WHEN rc.idtarjeta < 0 THEN '' ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS tarjeta, "
				+ "        rc.cuotas, rc.origenpedido, pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact   "
				+ "   FROM pedidos_regalos_entregas_cabe pc  "
				+ "        INNER JOIN pedidos_regalos_cabe rc ON pc.idpedido_regalos_cabe = rc.idpedido_regalos_cabe AND pc.idempresa = rc.idempresa "
				+ "        INNER JOIN pedidosdomiciliosentrega cd ON pc.idcliente = cd.idcliente  "
				+ " 	             AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "        INNER JOIN clientesanexolocalidades al ON cd.idanexolocalidad = al.idanexolocalidad AND cd.idempresa = al.idempresa "
				+ "        INNER JOIN globallocalidades gl ON al.idlocalidad = gl.idlocalidad  "
				+ "        INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia  "
				+ "        INNER JOIN pedidosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "        INNER JOIN clientescondicio co ON rc.idcondicion = co.idcondicion AND  rc.idempresa = co.idempresa "
				+ "        LEFT JOIN clientesvendedor ve ON rc.idvendedor = ve.idvendedor AND  rc.idempresa = ve.idempresa "
				+ "        INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND  pc.idempresa = ex.idempresa    "
				+ "        INNER JOIN clienteslistas lp ON rc.idlista = lp.idlista  AND  rc.idempresa = lp.idempresa  "
				+ "        INNER JOIN globalmonedas gm ON rc.idmoneda = gm.idmoneda   "
				+ "        INNER JOIN clientestablaiva ti ON rc.idtipoiva = ti.idtipoiva  AND  rc.idempresa = ti.idempresa "
				+ "        INNER JOIN pedidosprioridades  pr ON pc.idprioridad = pr.idprioridad  "
				+ "        INNER JOIN clienteszonas z ON pc.idzona = z.idzona  AND  pc.idempresa = z.idempresa "
				+ "        LEFT JOIN clientetarjetascredito tc ON rc.idtarjeta = tc.idtarjeta AND rc.idempresa = tc.idempresa "
				+ "        LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito AND tc.idempresa = tm.idempresa "
				+ " WHERE pc.idpedido_regalos_entrega_cabe = "
				+ idpedido_cabe.toString() + "   AND pc.idcliente = "
				+ idcliente.toString() + "   AND pc.idempresa = "
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEntregasHistoricoClientePK( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	public List getPedidosHistoricoDetalle(BigDecimal idpedido_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_deta,pd.idpedido_cabe,pd.codigo_st, descrip_st,pd.fecha,pd.renglon,pd.precio,pd.saldo,pd.cantidad, "
				+ "       pd.bonific,sm.descrip_md,pd.cantuni,dt.descrip_dt,pd.entrega,pd.iddescuento_suge,pd.iddescuento_apli, "
				+ "       pd.porcdesc_suge,pd.porcdesc_apli,COALESCE(md.motivodescuento,'S/M')AS motivodescuento,pd.idempresa, "
				+ "       pd.usuarioalt,pd.usuarioact,pd.fechaalt,pd.fechaact "
				+ " FROM pedidos_deta pd "
				+ "      INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND  pd.idempresa = st.idempresa "
				+ "      INNER JOIN stockmedidas sm ON pd.codigo_md = sm.codigo_md  AND  pd.idempresa = sm.idempresa "
				+ "      INNER JOIN stockdepositos dt ON pd.codigo_dt = dt.codigo_dt  AND  pd.idempresa = dt.idempresa "
				+ "      LEFT JOIN pedidosmotivosdescuento md ON pd.idmotivodescuento = md.idmotivodescuento  AND  pd.idempresa = md.idempresa "
				+ " WHERE pd.idpedido_cabe=" + idpedido_cabe.toString()
				+ " AND pd.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosHistoricoDetalle( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosHistoricoDetalle(BigDecimal idpedido_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_regalos_deta,pd.idpedido_regalos_cabe,pd.codigo_st, descrip_st,pd.fecha,pd.renglon,pd.precio,pd.saldo,pd.cantidad, "
				+ "       pd.bonific,sm.descrip_md,pd.cantuni,dt.descrip_dt,pd.entrega,pd.iddescuento_suge,pd.iddescuento_apli, "
				+ "       pd.porcdesc_suge,pd.porcdesc_apli,COALESCE(md.motivodescuento,'S/M')AS motivodescuento,pd.idempresa, "
				+ "       pd.usuarioalt,pd.usuarioact,pd.fechaalt,pd.fechaact "
				+ " FROM pedidos_regalos_deta pd "
				+ "      INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND  pd.idempresa = st.idempresa "
				+ "      INNER JOIN stockmedidas sm ON pd.codigo_md = sm.codigo_md  AND  pd.idempresa = sm.idempresa "
				+ "      INNER JOIN stockdepositos dt ON pd.codigo_dt = dt.codigo_dt  AND  pd.idempresa = dt.idempresa "
				+ "      LEFT JOIN pedidosmotivosdescuento md ON pd.idmotivodescuento = md.idmotivodescuento  AND  pd.idempresa = md.idempresa "
				+ " WHERE pd.idpedido_regalos_cabe=" + idpedido_cabe.toString()
				+ " AND pd.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosHistoricoDetalle( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// 20110120 - EJV - Mantis - 661 -->

	public List getPedidosEntregasHistoricoDetalle(BigDecimal idpedido_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_regalos_entrega_deta,pd.idpedido_regalos_entrega_cabe,pd.codigo_st, descrip_st,pd.fecha,pd.renglon,0 AS precio,0 AS saldo,pd.cantidad, "
				+ "        0 AS bonific,sm.descrip_md, 0 AS cantuni,dt.descrip_dt,pd.entrega, 0 AS iddescuento_suge,0 AS iddescuento_apli,  "
				+ "        0 AS porcdesc_suge, 0 AS porcdesc_apli, 'S/M' AS motivodescuento,pd.idempresa,  "
				+ "        pd.usuarioalt,pd.usuarioact,pd.fechaalt,pd.fechaact  "
				+ "  FROM pedidos_regalos_entregas_deta pd  "
				+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND  pd.idempresa = st.idempresa "
				+ "       INNER JOIN stockmedidas sm ON st.unimed_st = sm.codigo_md  AND  st.idempresa = sm.idempresa "
				+ "       INNER JOIN stockdepositos dt ON pd.codigo_dt = dt.codigo_dt  AND  pd.idempresa = dt.idempresa  "
				+ " WHERE pd.idpedido_regalos_entrega_cabe="
				+ idpedido_cabe.toString() + " AND pd.idempresa = "
				+ idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEntregasHistoricoDetalle( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	public List getPedidosRegalosDetalleEntrega(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""

				+ " SELECT pd.idpedido_regalos_entrega_deta,pc.idpedido_regalos_cabe,pd.codigo_st, descrip_st,pd.fecha,rd.renglon,rd.precio,rd.saldo,pd.cantidad, "
				+ "        rd.bonific,sm.descrip_md,rd.cantuni,dt.descrip_dt,pd.entrega,rd.iddescuento_suge,rd.iddescuento_apli,  "
				+ "        rd.porcdesc_suge,rd.porcdesc_apli,COALESCE(md.motivodescuento,'S/M')AS motivodescuento,pd.idempresa,  "
				+ "        pd.usuarioalt,pd.usuarioact,pd.fechaalt,pd.fechaact  "
				+ "  FROM pedidos_regalos_entregas_deta pd "
				+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
				+ "       INNER JOIN pedidos_regalos_deta rd ON pc.idpedido_regalos_cabe = rd.idpedido_regalos_cabe AND pc.idempresa = rd.idempresa  "
				+ "              AND pd.codigo_st = rd.codigo_st AND pd.idempresa = rd.idempresa   AND pd.idempresa = rd.idempresa AND pd.codigo_dt = rd.codigo_dt "
				+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND  pd.idempresa = st.idempresa "
				+ "       INNER JOIN stockmedidas sm ON rd.codigo_md = sm.codigo_md  AND  rd.idempresa = sm.idempresa "
				+ "       INNER JOIN stockdepositos dt ON rd.codigo_dt = dt.codigo_dt  AND  rd.idempresa = dt.idempresa "
				+ "       LEFT JOIN pedidosmotivosdescuento md ON rd.idmotivodescuento = md.idmotivodescuento  AND  rd.idempresa = md.idempresa "
				+ "  WHERE pd.idpedido_regalos_entrega_cabe= "
				+ idpedido_regalos_entrega_cabe.toString()
				+ "  AND pd.idempresa =  " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosDetalleEntrega( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosDetalleEntregaPK(BigDecimal idpedido_cabe,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT pc.idpedido_regalos_cabe, es.estado, pc.idcliente, pc.idsucursal, cd.calle, cd.nro ,  "
				+ "       cd.piso, cd.depto, cd.cpa, cd.postal, cd.contacto, gl.localidad, gp.provincia,   "
				+ "       pc.fechapedido, ex.expreso, pc.obsarmado, pc.obsentrega, pr.prioridad, z.zona,  "
				+ "       pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact   "
				+ "  FROM pedidos_regalos_entregas_cabe pc   "
				+ "       INNER JOIN pedidosdomiciliosentrega cd ON pc.idcliente = cd.idcliente  "
				+ "              AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON cd.idanexolocalidad = ax.idanexolocalidad AND cd.idempresa = ax.idempresa "
				// 20100804 - EJV - Reasignacion -->
				// +
				+ "       INNER JOIN clientesanexolocalidades xl ON pc.idanexolocalidad = xl.idanexolocalidad AND pc.idempresa = xl.idempresa "
				// <--
				+ "       INNER JOIN globallocalidades gl ON ax.idlocalidad = gl.idlocalidad  "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia  "
				+ "       INNER JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso AND  ez.idempresa = ex.idempresa    "
				+ "       INNER JOIN pedidosprioridades  pr ON pc.idprioridad = pr.idprioridad  "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona  AND  ez.idempresa = z.idempresa  "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "  WHERE pc.idpedido_regalos_entrega_cabe = "
				+ idpedido_cabe.toString() + "   AND pc.idcliente = "
				+ idcliente.toString() + "   AND pc.idempresa = "
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosDetalleEntregaPK( BigDecimal idpedido_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	public boolean isClienteConPedidosPendientes(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		boolean existenPendientes = true;
		String cQuery = "";
		try {
			cQuery += "SELECT COUNT(1)AS total FROM pedidos_cabe  "
					+ " WHERE idcliente = " + idcliente.toString()
					+ "   AND idempresa = " + idempresa.toString()
					+ "   AND idestado = 1;";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {
				if (rsSalida.next()) {
					existenPendientes = rsSalida.getLong(1) > 0 ? true : false;
				} else {
					existenPendientes = false;
				}
			} else {
				log
						.warn("isClienteConPedidosPendientes(..): No fue posible comprobar si el cliente tiene pedidos pendientes.");
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo :  isClienteConPedidosPendientes( BigDecimal idcliente, BigDecimal idempresa )  "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo:  isClienteConPedidosPendientes( BigDecimal idcliente, BigDecimal idempresa)  "
							+ ex);
		}

		return existenPendientes;

	}

	// PEDIDOS DETALLE .
	// ///////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Metodos para la entidad: pedidos_Deta Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Tue Mar 27 11:56:57 CEST 2007
	 * 
	 */

	public String pedidos_DetaCreate(BigDecimal idpedido_cabe,
			String codigo_st, Timestamp fecha, BigDecimal renglon,
			BigDecimal precio, BigDecimal saldo, BigDecimal cantidad,
			BigDecimal bonific, BigDecimal codigo_md, BigDecimal cantuni,
			BigDecimal codigo_dt, String entrega, BigDecimal iddescuento_suge,
			BigDecimal iddescuento_apli, BigDecimal porcdesc_suge,
			BigDecimal porcdesc_apli, BigDecimal idmotivodescuento,
			BigDecimal tipoiva_st, BigDecimal porciva_st,
			BigDecimal totaliva_st, BigDecimal cantidad_sb,
			BigDecimal compromiso_sb, String usuarioalt, BigDecimal idempresa,
			// 20120510 -- EJV - Movimientos stock x 2 -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (precio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio ";
		if (saldo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: saldo ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (bonific == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bonific ";
		if (codigo_md == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_md ";
		if (cantuni == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantuni ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO PEDIDOS_DETA"
						+ "           (idpedido_cabe, codigo_st, fecha, renglon, precio, saldo, "
						+ "            cantidad, bonific, codigo_md, cantuni, codigo_dt, entrega, "
						+ "            iddescuento_suge, iddescuento_apli, porcdesc_suge, porcdesc_apli ,"
						+ "            idmotivodescuento, tipoiva_st, porciva_st, totaliva_st, cantidad_sb, compromiso_sb, usuarioalt,idempresa ) "
						+ "    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idpedido_cabe);
				insert.setString(2, codigo_st);
				insert.setTimestamp(3, fecha);
				insert.setBigDecimal(4, renglon);
				insert.setBigDecimal(5, precio);
				insert.setBigDecimal(6, saldo);
				insert.setBigDecimal(7, cantidad);
				insert.setBigDecimal(8, bonific);
				insert.setBigDecimal(9, codigo_md);
				insert.setBigDecimal(10, cantuni);
				insert.setBigDecimal(11, codigo_dt);
				insert.setString(12, entrega);
				insert.setBigDecimal(13, iddescuento_suge);
				insert.setBigDecimal(14, iddescuento_apli);
				insert.setBigDecimal(15, porcdesc_suge);
				insert.setBigDecimal(16, porcdesc_apli);
				insert.setBigDecimal(17, idmotivodescuento);

				insert.setBigDecimal(18, tipoiva_st);
				insert.setBigDecimal(19, porciva_st);
				insert.setBigDecimal(20, totaliva_st);

				insert.setBigDecimal(21, cantidad_sb);
				insert.setBigDecimal(22, compromiso_sb);

				insert.setString(23, usuarioalt);
				insert.setBigDecimal(24, idempresa);

				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar detalle de pedido.";
			}
		} catch (SQLException sqlException) {
			salida = "SQLE-Imposible generar detalle para pedido, artculo: "
					+ codigo_st;
			log.error("Error SQL public String pedidos_DetaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "EX-Imposible generar detalle para pedido, artculo: "
					+ codigo_st;
			log.error("Error excepcion public String pedidos_DetaCreate(.....)"
					+ ex);
		}
		return salida;
	}

	public String pedidos_regalos_DetaCreate(BigDecimal idpedido_cabe,
			String codigo_st, Timestamp fecha, BigDecimal renglon,
			BigDecimal precio, BigDecimal saldo, BigDecimal cantidad,
			BigDecimal bonific, BigDecimal codigo_md, BigDecimal cantuni,
			BigDecimal codigo_dt, String entrega, BigDecimal iddescuento_suge,
			BigDecimal iddescuento_apli, BigDecimal porcdesc_suge,
			BigDecimal porcdesc_apli, BigDecimal idmotivodescuento,
			BigDecimal tipoiva_st, BigDecimal porciva_st,
			BigDecimal totaliva_st, BigDecimal cantidad_sb,
			BigDecimal compromiso_sb, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (precio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio ";
		if (saldo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: saldo ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (bonific == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bonific ";
		if (codigo_md == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_md ";
		if (cantuni == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantuni ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO pedidos_regalos_deta"
						+ "           (idpedido_regalos_cabe, codigo_st, fecha, renglon, precio, saldo, "
						+ "            cantidad, bonific, codigo_md, cantuni, codigo_dt, entrega, "
						+ "            iddescuento_suge, iddescuento_apli, porcdesc_suge, porcdesc_apli ,"
						+ "            idmotivodescuento, tipoiva_st, porciva_st, totaliva_st, cantidad_sb, compromiso_sb, usuarioalt,idempresa ) "
						+ "    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idpedido_cabe);
				insert.setString(2, codigo_st);
				insert.setTimestamp(3, fecha);
				insert.setBigDecimal(4, renglon);
				insert.setBigDecimal(5, precio);
				insert.setBigDecimal(6, saldo);
				insert.setBigDecimal(7, cantidad);
				insert.setBigDecimal(8, bonific);
				insert.setBigDecimal(9, codigo_md);
				insert.setBigDecimal(10, cantuni);
				insert.setBigDecimal(11, codigo_dt);
				insert.setString(12, entrega);
				insert.setBigDecimal(13, iddescuento_suge);
				insert.setBigDecimal(14, iddescuento_apli);
				insert.setBigDecimal(15, porcdesc_suge);
				insert.setBigDecimal(16, porcdesc_apli);
				insert.setBigDecimal(17, idmotivodescuento);

				insert.setBigDecimal(18, tipoiva_st);
				insert.setBigDecimal(19, porciva_st);
				insert.setBigDecimal(20, totaliva_st);

				insert.setBigDecimal(21, cantidad_sb);
				insert.setBigDecimal(22, compromiso_sb);

				insert.setString(23, usuarioalt);
				insert.setBigDecimal(24, idempresa);

				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar detalle de pedido.";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar detalle para pedido, artculo: "
					+ codigo_st;
			log
					.error("Error SQL public String pedidos_regalos_DetaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar detalle para pedido, artculo: "
					+ codigo_st;
			log
					.error("Error excepcion public String pedidos_regalos_DetaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidos_Regalos_DetaDelete(BigDecimal idpedido_regalos_deta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOS_REGALOS_DETA WHERE idpedido_regalos_deta="
				+ idpedido_regalos_deta.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOS_REGALOS_DETA WHERE idpedido_regalos_deta="
						+ idpedido_regalos_deta.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				int i = statement.executeUpdate(cQuery);
				if (i != 1)
					salida = "Error al eliminar detalle de pedido:.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible eliminar el registro detalle pedidos regalos.";
			log
					.error("Error SQL en el metodo : pedidos_Regalos_DetaDelete( BigDecimal idpedido_regalos_deta, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible eliminar el registro detalle pedidos regalos.";
			log
					.error("Salida por exception: en el metodo: pedidos_Regalos_DetaDelete( BigDecimal idpedido_regalos_deta, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// por primary key (primer campo por defecto)
	public List getPedidosRegalosDetaXPedido(BigDecimal idpedido_regalos_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_regalos_deta, pd.idpedido_regalos_cabe, pd.codigo_st, pd.fecha, pd.renglon, pd.precio, "
				+ "       pd.saldo, pd.cantidad, pd.bonific, pd.codigo_md, pd.cantuni,"
				+ "       pd.codigo_dt, pd.entrega, COALESCE(st.inventa_st, 'S') AS inventa_st, "
				+ "       pd.usuarioalt, pd.usuarioact, pd.fechaalt, pd.fechaact"
				+ "  FROM pedidos_regalos_deta pd "
				+ "        INNER JOIN stockstock st ON pd.codigo_st  = st.codigo_st AND pd.idempresa = st.idempresa "
				+ "WHERE pd.idpedido_regalos_cabe="
				+ idpedido_regalos_cabe.toString() + "  AND pd.idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosDetaXPedido( BigDecimal idpedido_cabe, idempresa )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesclientesLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "" + " SELECT " + " cl.idcliente, " + " cl.razon "
				+ " FROM " + " clientesclientes cl " + " WHERE cl.idempresa = "
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesclientesLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesclientesLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "" + " SELECT " + " cl.idcliente, " + " cl.razon "
				+ " FROM " + " clientesclientes cl " + " WHERE cl.idempresa= "
				+ idempresa.toString() + " and (cl.idcliente::VARCHAR LIKE '%"
				+ ocurrencia + "%' OR " + " UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesclientesLovOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesclientesIngMovLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente, cl.razon, cl.idcondicion, cc.condicion, gtd.tipodocumento, cl.nrodocumento, "
				+ "       cs.idlista, cs.descri_lis, gm.idmoneda, gm.moneda, cti.idtipoiva, cti.tipoiva "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN globaltiposdocumentos gtd ON cl.idtipodocumento = gtd.idtipodocumento AND cl.idempresa = gtd.idempresa "
				+ "       INNER JOIN clientescondicio cc ON cl.idcondicion = cc.idcondicion AND cl.idempresa = cc.idempresa "
				+ "       INNER JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda  "
				+ "       INNER JOIN clientestablaiva cti ON cl.idtipoiva = cti.idtipoiva "
				+ "       LEFT JOIN clienteslistas cs ON cl.idlista = cs.idlista  AND cl.idempresa = cs.idempresa "
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesclientesLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesclientesIngMovLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cl.idcliente, cl.razon, cl.idcondicion, cc.condicion, gtd.tipodocumento, cl.nrodocumento, "
				+ "       cs.idlista, cs.descri_lis, gm.idmoneda, gm.moneda, cti.idtipoiva, cti.tipoiva "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN globaltiposdocumentos gtd ON cl.idtipodocumento = gtd.idtipodocumento AND cl.idempresa = gtd.idempresa "
				+ "       INNER JOIN clientescondicio cc ON cl.idcondicion = cc.idcondicion AND cl.idempresa = cc.idempresa "
				+ "       INNER JOIN globalmonedas gm ON cl.idmoneda = gm.idmoneda  "
				+ "       INNER JOIN clientestablaiva cti ON cl.idtipoiva = cti.idtipoiva "
				+ "       LEFT JOIN clienteslistas cs ON cl.idlista = cs.idlista  AND cl.idempresa = cs.idempresa "
				+ " WHERE cl.idempresa= " + idempresa.toString()
				+ " and (cl.idcliente::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(cl.razon) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesclientesLovOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	// SUCURSAL ALL
	public List getSucursalAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select idsucursal,sucursal from clientessucursales where idempresa="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getSucursalAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// SUCURSAL OCU
	public List getSucursalOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "select idsucursal,sucursal from clientessucursales"
				+ " where idempresa= " + idempresa.toString()
				+ " and (idsucursal::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(sucursal) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSucursalOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// SUCURSAL CLIENTE ALL
	public List getSucuclieAll(long limit, long offset, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select * from vdomicilioscliente where idempresa= "
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log.error("Salida por exception: en el metodo: getSucuclieAll()  "
					+ ex);
		}
		return vecSalida;
	}

	// SUCURSAL OCU
	public List getSucuclieOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "select * from vdomicilioscliente"
				+ " where idempresa= " + idempresa.toString()
				+ " and (iddomicilio::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(calle) LIKE '%" + ocurrencia.toUpperCase() + "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSucuclieOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/*
	 * consultas a la MOVCLI
	 */
	/*
	 * traer la cuenta corriente de un cliente parametros: idcliente tipo (P o
	 * H) : pendiente o historico select * from vclientesmovcli select * from
	 * vclientesmovcli where saldo <> 0 and idcliente = 1 order by fechamov
	 */

	public List getCtaCteCliente(BigDecimal idcliente, String tipo)
			throws EJBException {

		String cQuery = "";
		List vecSalida = new ArrayList();
		try {
			if (tipo.equalsIgnoreCase("P"))
				cQuery = ""
						+ "SELECT mc.idcliente, mc.razon, mc.fechamov, mc.sucursal, mc.comprob, mc.tipomovs, mc.idtipomov, mc.tipomov, mc.importe, mc.saldo, "
						+ "             mc.idcondicion, mc.condicion, mc.idtipocomp, mc.tipocomp, mc.sucucli, mc.nrointerno, mc.idexpreso, mc.expreso, mc.letraiva, "
						+ "             COALESCE(de.nrointerno_mc, -1) conremito, "
						+ "             mc.idempresa "
						+ "   FROM vclientesmovcli mc "
						+ "             LEFT JOIN ( "
						+ "                                SELECT DISTINCT ON (nrointerno_mc) nrointerno_mc, idremitocliente, idempresa "
						+ "                                   FROM clientesremitos "
						+ "                                 WHERE nrointerno_mc IS NOT NULL  "
						+ "                                 ORDER BY   nrointerno_mc, idremitocliente ASC"
						+ "                              ) de ON mc.nrointerno = de.nrointerno_mc AND mc.idempresa = de.idempresa "
						+ "WHERE mc.saldo <> 0 AND mc.idcliente = "
						+ idcliente.toString() + " ORDER BY mc.fechamov";
			else
				cQuery = ""
						+ "SELECT mc.idcliente, mc.razon, mc.fechamov, mc.sucursal, mc.comprob, mc.tipomovs, mc.idtipomov, mc.tipomov, mc.importe, mc.saldo, "
						+ "             mc.idcondicion, mc.condicion, mc.idtipocomp, mc.tipocomp, mc.sucucli, mc.nrointerno, mc.idexpreso, mc.expreso, mc.letraiva, "
						+ "             COALESCE(de.nrointerno_mc, -1) conremito, "
						+ "             mc.idempresa "
						+ "   FROM vclientesmovcli mc"
						+ "             LEFT JOIN ( "
						+ "                                SELECT DISTINCT ON (nrointerno_mc) nrointerno_mc, idremitocliente, idempresa "
						+ "                                   FROM clientesremitos "
						+ "                                 WHERE nrointerno_mc IS NOT NULL  "
						+ "                                 ORDER BY   nrointerno_mc, idremitocliente ASC"
						+ "                              ) de ON mc.nrointerno = de.nrointerno_mc AND mc.idempresa = de.idempresa "
						+ " WHERE idcliente = " + idcliente.toString()
						+ " ORDER BY mc.fechamov";

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCtaCteCliente(BigDecimal idcliente, String tipo )  "
							+ ex);
		}
		return vecSalida;
	}

	// traigo el saldo directamente de la base de datos.
	public Double getCtaCteClienteSaldo(BigDecimal idcliente, String tipo)
			throws EJBException {

		Double salida = new Double("0");
		String cQuery = "";
		ResultSet rsSalida = null;
		try {
			if (tipo.equalsIgnoreCase("P"))
				cQuery = "select sum(saldo) as saldo from vclientesmovcli where saldo <> 0 and idcliente = "
						+ idcliente.toString() + " group by idcliente ";
			else
				cQuery = "select sum(saldo) as saldo from vclientesmovcli where idcliente = "
						+ idcliente.toString() + "  group by idcliente ";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = new Double(rsSalida.getDouble("saldo"));
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getCtaCteCliente(BigDecimal idcliente, String tipo ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCtaCteCliente(BigDecimal idcliente, String tipo )  "
							+ ex);
		}
		return salida;
	}

	// para sacar el listado de clientes con saldo

	public List getClientesConSaldo(String fechahasta, int orderby)
			throws EJBException {

		String cQuery = "";
		List vecSalida = new ArrayList();
		try {

			cQuery += "SELECT idcliente, razon, sum(saldo)AS saldo ";
			cQuery += " FROM vclientesmovcli ";
			cQuery += " WHERE fechamov::date <= to_date('" + fechahasta
					+ "', 'dd/mm/yyyy') ";
			cQuery += "GROUP BY idcliente, razon ";
			cQuery += "HAVING sum(saldo) > 0 order by " + orderby;

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesConSaldo(String fechahasta, int orderby )   "
							+ ex);
		}
		return vecSalida;
	}

	// totalizacion del metodo anterior

	// --------------------------------------------------------------------------------------
	public Double getClientesConSaldo(String fechahasta) throws EJBException {
		ResultSet rsSalida = null;
		Double salida = new Double("0");
		String cQuery = "";
		try {
			cQuery += "SELECT sum(saldo)AS saldo  ";
			cQuery += "  FROM vclientesmovcli  ";
			cQuery += " WHERE fechamov::date <= to_date('" + fechahasta
					+ "', 'dd/mm/yyyy') ";
			cQuery += " HAVING sum(saldo) > 0  ";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = new Double(rsSalida.getDouble("saldo"));
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo :  getClientesConSaldo( String fechahasta )  "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo:  getClientesConSaldo( String fechahasta )  "
							+ ex);
		}
		return salida;
	}

	// ------------------------------------------------------------------------
	// LOCALIDADES
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalLocalidadesAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, "
				+ "       l.cpostal, l.idtipoiva, l.usuarioalt, l.usuarioact, "
				+ "       l.fechaalt, l.fechaact "
				+ "  FROM GLOBALLOCALIDADES l "
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidades()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalLocalidadesOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, "
				+ "       l.cpostal, l.idtipoiva, l.usuarioalt, l.usuarioact, "
				+ "       l.fechaalt, l.fechaact "
				+ "  FROM GLOBALLOCALIDADES l "
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia "
				+ " WHERE  (l.cpostal::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(l.localidad) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	// EJV -20100108 - Visualizacion con Obsequios - Mantis 478
	// ---->

	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalLocalidadesObseqAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, "
				+ "       l.cpostal, bo.idobsequio,l.idtipoiva, ct.idclusterlogistica, ct.clusterlogistica, l.usuarioalt, l.usuarioact, "
				+ "       l.fechaalt, l.fechaact "
				+ "  FROM GLOBALLOCALIDADES l "
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia "
				+ "        LEFT JOIN bacoobsequioslocalidad bo ON l.idlocalidad = bo.idlocalidad AND bo.idempresa = "

				+ idempresa.toString()

				// 20110331 - EJV - Mantis 685 -->
				+ "       LEFT JOIN bacoclusterslogistica ct ON bo.idclusterlogistica = ct.idclusterlogistica  AND bo.idempresa = ct.idempresa"
				// <--

				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesObseqAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalLocalidadesObseqOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad, p.provincia, "
				+ "       l.cpostal, bo.idobsequio, l.idtipoiva, ct.idclusterlogistica, ct.clusterlogistica,l.usuarioalt, l.usuarioact, "
				+ "       l.fechaalt, l.fechaact "
				+ "  FROM GLOBALLOCALIDADES l "
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia "
				+ "        LEFT JOIN bacoobsequioslocalidad bo ON l.idlocalidad = bo.idlocalidad AND bo.idempresa = "
				+ idempresa.toString()
				// 20110331 - EJV - Mantis 685 -->
				+ "       LEFT JOIN bacoclusterslogistica ct ON bo.idclusterlogistica = ct.idclusterlogistica  AND bo.idempresa = ct.idempresa"
				// <--

				+ " WHERE  (l.cpostal::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(l.localidad) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesObseqOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getGlobalLocalidadesObseqPK(BigDecimal idlocalidad,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad,l.idprovincia, p.provincia,"
				+ "       l.cpostal, l.idlocalidadbaco, bo.idobsequio, l.idtipoiva, l.usuarioalt,l.usuarioact, l.fechaalt, l.fechaact"
				+ " FROM  globallocalidades l"
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia and l.idlocalidad="
				+ idlocalidad.toString()
				+ "       LEFT JOIN bacoobsequioslocalidad bo ON l.idlocalidad = bo.idlocalidad AND bo.idempresa = "
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesObseqPK( BigDecimal idlocalidad )  "
							+ ex);
		}
		return vecSalida;
	}

	// <----

	public List getGlobalLocalidadesPK(BigDecimal idlocalidad)
			throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlocalidad, l.localidad,l.idprovincia, p.provincia,"
				+ "       l.cpostal, l.idlocalidadbaco, l.idtipoiva, l.usuarioalt,l.usuarioact, l.fechaalt, l.fechaact"
				+ " FROM  globallocalidades l"
				+ "       INNER JOIN globalprovincias p ON p.idprovincia = l.idprovincia and l.idlocalidad="
				+ idlocalidad.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalLocalidadesPK( BigDecimal idlocalidad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalLocalidadesDelete(BigDecimal idlocalidad)
			throws EJBException {

		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALLOCALIDADES WHERE idlocalidad="
				+ idlocalidad.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALLOCALIDADES WHERE idlocalidad="
						+ idlocalidad.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalLocalidadesDelete( BigDecimal idlocalidad ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalLocalidadesDelete( BigDecimal idlocalidad )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String[] globalLocalidadesCreate(String localidad,
			BigDecimal idprovincia, String cpostal, BigDecimal idtipoiva,
			BigDecimal idlocalidadbaco, String usuarioalt) throws EJBException {
		String salida = "OK";
		String idlocalidad = "-1";
		String[] resultado = new String[] { "", "" };
		// validaciones de datos:
		// 1. nulidad de campos
		if (localidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: localidad ";
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (cpostal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cpostal ";
		// 2. sin nada desde la pagina
		if (localidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: localidad ";
		if (cpostal.trim().equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cpostal ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("OK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO GLOBALLOCALIDADES(localidad, idprovincia, cpostal, idtipoiva, idlocalidadbaco, usuarioalt ) "
						+ "     VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, localidad);
				insert.setBigDecimal(2, idprovincia);
				insert.setString(3, cpostal);
				insert.setBigDecimal(4, idtipoiva);
				insert.setBigDecimal(5, idlocalidadbaco);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar localidad";
				else
					idlocalidad = GeneralBean.getValorSequencia(
							"seq_localidades", dbconn).toString();
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible dar de alta el registro de localidad.";
			log.error("Error SQL public String globalLocalidadesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible dar de alta el registro de localidad.";
			log
					.error("Error excepcion public String globalLocalidadesCreate(.....)"
							+ ex);
		}

		resultado = new String[] { salida, idlocalidad };
		return resultado;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalLocalidadesCreateOrUpdate(BigDecimal idlocalidad,
			String localidad, BigDecimal idprovincia, String cpostal,
			BigDecimal idtipoiva, BigDecimal idlocalidadbaco, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (localidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: localidad ";
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";

		// 2. sin nada desde la pagina
		if (localidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: localidad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalLocalidades WHERE idlocalidad = "
					+ idlocalidad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALLOCALIDADES SET localidad=?, idprovincia=?, cpostal=?, idtipoiva=?, idlocalidadbaco=?, usuarioact=?, fechaact=? WHERE idlocalidad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, localidad);
					insert.setBigDecimal(2, idprovincia);
					insert.setString(3, cpostal);
					insert.setBigDecimal(4, idtipoiva);
					insert.setBigDecimal(5, idlocalidadbaco);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idlocalidad);
				} else {
					String ins = "INSERT INTO GLOBALLOCALIDADES(localidad, idprovincia, cpostal, idtipoiva, idlocalidadbaco, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, localidad);
					insert.setBigDecimal(2, idprovincia);
					insert.setString(3, cpostal);
					insert.setBigDecimal(4, idtipoiva);
					insert.setBigDecimal(5, idlocalidadbaco);
					insert.setString(6, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalLocalidadesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalLocalidadesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalLocalidadesUpdate(BigDecimal idlocalidad,
			String localidad, BigDecimal idprovincia, String cpostal,
			BigDecimal idtipoiva, BigDecimal idlocalidadbaco, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (localidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: localidad ";
		if (idprovincia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprovincia ";

		// 2. sin nada desde la pagina
		if (localidad.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: localidad ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalLocalidades WHERE idlocalidad = "
					+ idlocalidad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALLOCALIDADES SET localidad=?, idprovincia=?, cpostal=?, idtipoiva=?, idlocalidadbaco=?, usuarioact=?, fechaact=? WHERE idlocalidad=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, localidad);
					insert.setBigDecimal(2, idprovincia);
					insert.setString(3, cpostal);
					insert.setBigDecimal(4, idtipoiva);
					insert.setBigDecimal(5, idlocalidadbaco);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idlocalidad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String globalLocalidadesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalLocalidadesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getClientesprovinciaLovAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT  idprovincia,provincia,usuarioalt,usuarioact,fechaalt,fechaact FROM globalprovincias ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesprovinciaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesprovinciaLovOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = "SELECT  idprovincia,provincia,usuarioalt,usuarioact,fechaalt,fechaact FROM globalprovincias "
				+ " where (idprovincia::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(provincia) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesprovinciaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// tipos tarjetas
	public List getClientetipostarjetasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtipotarjeta,tipotarjeta,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTETIPOSTARJETAS where idempresa= "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetipostarjetasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientetipostarjetasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipotarjeta,tipotarjeta,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTETIPOSTARJETAS WHERE idempresa="
				+ idempresa.toString()
				+ " and (idtipotarjeta::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipotarjeta) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetipostarjetasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientetipostarjetasPK(BigDecimal idtipotarjeta,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipotarjeta,tipotarjeta,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTETIPOSTARJETAS WHERE idtipotarjeta="
				+ idtipotarjeta.toString()
				+ "and idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetipostarjetasPK( BigDecimal idtipotarjeta )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientetipostarjetasDelete(BigDecimal idtipotarjeta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTETIPOSTARJETAS WHERE idtipotarjeta="
				+ idtipotarjeta.toString()
				+ "and idempresa="
				+ idempresa.toString();

		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTETIPOSTARJETAS WHERE idtipotarjeta="
						+ idtipotarjeta.toString()
						+ "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientetipostarjetasDelete( BigDecimal idtipotarjeta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientetipostarjetasDelete( BigDecimal idtipotarjeta )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientetipostarjetasCreate(String tipotarjeta,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipotarjeta ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Tipo Tarjeta ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTETIPOSTARJETAS(tipotarjeta, usuarioalt,idempresa ) VALUES (?,?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipotarjeta);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientetipostarjetasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientetipostarjetasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientetipostarjetasCreateOrUpdate(BigDecimal idtipotarjeta,
			String tipotarjeta, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (tipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipotarjeta ";

		// 2. sin nada desde la pagina
		if (tipotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Tipo Tarjeta ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientetipostarjetas WHERE idtipotarjeta = "
					+ idtipotarjeta.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTETIPOSTARJETAS SET tipotarjeta=?, usuarioact=?, fechaact=? WHERE idtipotarjeta=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipotarjeta);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idtipotarjeta);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTETIPOSTARJETAS(tipotarjeta, usuarioalt,idempresa ) VALUES (?,?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipotarjeta);
					insert.setString(2, usuarioalt);
					insert.setBigDecimal(3, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientetipostarjetasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientetipostarjetasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientetipostarjetasUpdate(BigDecimal idtipotarjeta,
			String tipotarjeta, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (tipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipotarjeta ";

		// 2. sin nada desde la pagina
		if (tipotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: Tipo Tarjeta ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientetipostarjetas WHERE idtipotarjeta = "
					+ idtipotarjeta.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTETIPOSTARJETAS SET tipotarjeta=?, usuarioact=?, fechaact=? WHERE idtipotarjeta=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipotarjeta);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idtipotarjeta);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientetipostarjetasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientetipostarjetasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// tarjetas de credito marca
	public List getClientetarjetascreditomarcasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtarjetacredito,tarjetacredito,formato,metodoasociado,filtroarchivo,formulavalidacion,coddigitovermarca,"
				+ "             usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTETARJETASCREDITOMARCAS where idempresa= "
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetarjetascreditomarcasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientetarjetascreditomarcasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtarjetacredito,tarjetacredito,formato,metodoasociado,filtroarchivo,formulavalidacion,coddigitovermarca,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTETARJETASCREDITOMARCAS WHERE idempresa="
				+ idempresa.toString()
				+ " and (idtarjetacredito::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tarjetacredito) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetarjetascreditomarcasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientetarjetascreditomarcasPK(BigDecimal idtarjetacredito,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtarjetacredito,tarjetacredito,formato,metodoasociado,filtroarchivo,formulavalidacion,coddigitovermarca,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTETARJETASCREDITOMARCAS WHERE idtarjetacredito="
				+ idtarjetacredito.toString() + "and idempresa="
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientetarjetascreditomarcasPK( BigDecimal idtarjetacredito )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientetarjetascreditomarcasDelete(
			BigDecimal idtarjetacredito, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTETARJETASCREDITOMARCAS WHERE idtarjetacredito="
				+ idtarjetacredito.toString()
				+ "and idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTETARJETASCREDITOMARCAS WHERE idtarjetacredito="
						+ idtarjetacredito.toString()
						+ "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientetarjetascreditomarcasDelete( BigDecimal idtarjetacredito ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientetarjetascreditomarcasDelete( BigDecimal idtarjetacredito )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientetarjetascreditomarcasCreate(String tarjetacredito,
			String formato, String metodoasociado, String filtroarchivo,
			String formulavalidacion, String usuarioalt, BigDecimal idempresa,
			BigDecimal coddigitovermarca) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarjetacredito ";
		if (formato == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formato ";
		if (metodoasociado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: metodoasociado ";
		if (filtroarchivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: filtroarchivo ";
		if (formulavalidacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formulavalidacion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tarjetacredito.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tarjetacredito ";
		if (formato.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formato ";
		if (metodoasociado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: metodoasociado ";
		if (filtroarchivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: filtroarchivo ";
		if (formulavalidacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formulavalidacion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTETARJETASCREDITOMARCAS(tarjetacredito, formato, metodoasociado, filtroarchivo, formulavalidacion, usuarioalt, idempresa,coddigitovermarca ) VALUES (?,?,?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tarjetacredito);
				insert.setString(2, formato);
				insert.setString(3, metodoasociado);
				insert.setString(4, filtroarchivo);
				insert.setString(5, formulavalidacion);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				insert.setBigDecimal(8, coddigitovermarca);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientetarjetascreditomarcasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientetarjetascreditomarcasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientetarjetascreditomarcasCreateOrUpdate(
			BigDecimal idtarjetacredito, String tarjetacredito, String formato,
			String metodoasociado, String filtroarchivo,
			String formulavalidacion, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (tarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarjetacredito ";
		if (formato == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formato ";
		if (metodoasociado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: metodoasociado ";
		if (filtroarchivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: filtroarchivo ";
		if (formulavalidacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formulavalidacion ";

		// 2. sin nada desde la pagina
		if (tarjetacredito.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tarjetacredito ";
		if (formato.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formato ";
		if (metodoasociado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: metodoasociado ";
		if (filtroarchivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: filtroarchivo ";
		if (formulavalidacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formulavalidacion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientetarjetascreditomarcas WHERE idtarjetacredito = "
					+ idtarjetacredito.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTETARJETASCREDITOMARCAS SET tarjetacredito=?, formato=?, metodoasociado=?, filtroarchivo=?, formulavalidacion=?, usuarioact=?, fechaact=? WHERE idtarjetacredito=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tarjetacredito);
					insert.setString(2, formato);
					insert.setString(3, metodoasociado);
					insert.setString(4, filtroarchivo);
					insert.setString(5, formulavalidacion);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idtarjetacredito);
					insert.setBigDecimal(9, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTETARJETASCREDITOMARCAS(tarjetacredito, formato, metodoasociado, filtroarchivo, formulavalidacion, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tarjetacredito);
					insert.setString(2, formato);
					insert.setString(3, metodoasociado);
					insert.setString(4, filtroarchivo);
					insert.setString(5, formulavalidacion);
					insert.setString(6, usuarioalt);
					insert.setBigDecimal(7, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientetarjetascreditomarcasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientetarjetascreditomarcasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientetarjetascreditomarcasUpdate(
			BigDecimal idtarjetacredito, String tarjetacredito, String formato,
			String metodoasociado, String filtroarchivo,
			String formulavalidacion, String usuarioact, BigDecimal idempresa,
			BigDecimal coddigitovermarca) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (tarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarjetacredito ";
		if (formato == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formato ";
		if (metodoasociado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: metodoasociado ";
		if (filtroarchivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: filtroarchivo ";
		if (formulavalidacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: formulavalidacion ";

		// 2. sin nada desde la pagina
		if (tarjetacredito.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tarjetacredito ";
		if (formato.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formato ";
		if (metodoasociado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: metodoasociado ";
		if (filtroarchivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: filtroarchivo ";
		if (formulavalidacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: formulavalidacion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientetarjetascreditomarcas WHERE idtarjetacredito = "
					+ idtarjetacredito.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTETARJETASCREDITOMARCAS SET tarjetacredito=?, formato=?, metodoasociado=?, filtroarchivo=?, formulavalidacion=?, usuarioact=?, fechaact=?,coddigitovermarca=? WHERE idtarjetacredito=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tarjetacredito);
					insert.setString(2, formato);
					insert.setString(3, metodoasociado);
					insert.setString(4, filtroarchivo);
					insert.setString(5, formulavalidacion);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, coddigitovermarca);
					insert.setBigDecimal(9, idtarjetacredito);
					insert.setBigDecimal(10, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientetarjetascreditomarcasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientetarjetascreditomarcasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clienteTarjetasCredito Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Feb 14 13:43:20 ART 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClienteTarjetasCreditoAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,cli.razon,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision,t.fecha_vencimiento,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesclientes cli ON  t.idcliente = cli.idcliente AND t.idempresa = cli.idempresa "
				+ " WHERE t.idempresa = " + idempresa.toString()
				+ " ORDER BY 5, t.orden   LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasCreditoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClienteTarjetasClienteActivas(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision::DATE,t.fecha_vencimiento::DATE,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesclientes cli ON  t.idcliente = cli.idcliente AND t.idempresa = cli.idempresa "
				+ " WHERE t.idcliente = " + idcliente.toString()
				+ " AND t.idempresa = " + idempresa.toString()
				+ " AND t.activa = 'S' " + " ORDER BY t.orden  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasClienteActivas()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClienteTarjetasCliente(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision::DATE,t.fecha_vencimiento::DATE,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesclientes cli ON  t.idcliente = cli.idcliente AND t.idempresa = cli.idempresa "
				+ " WHERE t.idcliente = " + idcliente.toString()
				+ " AND t.idempresa = " + idempresa.toString()
				+ " ORDER BY   t.orden  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}

			closeResultset(rsSalida);

		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClienteTarjetasCliente() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClienteTarjetasCreditoOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,cli.razon,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision,t.fecha_vencimiento,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesclientes cli ON  t.idcliente = cli.idcliente AND t.idempresa = cli.idempresa "
				+ " where t.idempresa= " + idempresa.toString()
				+ "   and (UPPER(t.nrotarjeta) LIKE '%"
				+ ocurrencia.toUpperCase() + "%' OR "
				+ "    (cli.idcliente::varchar) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') "
				+ " ORDER BY 5, t.orden LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasCreditoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClienteTarjetasCreditoPK(BigDecimal idtarjeta,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito,t.idcliente,cli.razon,t.idtipotarjeta,tt.tipotarjeta,"
				+ "       t.nrotarjeta,t.nrocontrol,t.fecha_emision,t.fecha_vencimiento,t.titular,t.orden,t.activa,"
				+ "       t.idempresa,t.usuarioalt,t.usuarioact,t.fechaalt,t.fechaact"
				+ "  FROM clientetarjetascredito t "
				+ "       INNER JOIN clientetarjetascreditomarcas tm ON t.idtarjetacredito = tm.idtarjetacredito AND t.idempresa = tm.idempresa "
				+ "       INNER JOIN clientetipostarjetas tt ON  t.idtipotarjeta = tt.idtipotarjeta AND t.idempresa = tt.idempresa "
				+ "       INNER JOIN clientesclientes cli ON  t.idcliente = cli.idcliente AND t.idempresa = cli.idempresa "
				+ " WHERE t.idtarjeta=" + idtarjeta.toString()
				+ "   AND t.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteTarjetasCreditoPK( BigDecimal idtarjeta )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clienteTarjetasCreditoDelete(BigDecimal idtarjeta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTETARJETASCREDITO WHERE idtarjeta="
				+ idtarjeta.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTETARJETASCREDITO WHERE idtarjeta="
						+ idtarjeta.toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				int i = statement.getUpdateCount();
				if (i > 1) {
					salida = "Instruccion delete (tarjetas de credito) devuelve mas de una fila.";
				} else if (i < 1) {
					salida = "Instruccion delete (tarjetas de credito) devuelve cero filas.";
				}

			} else {
				salida = "Error: Tarjeta credito inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar tarjeta credito.";
			log
					.error("Error SQL en el metodo : clienteTarjetasCreditoDelete( BigDecimal idtarjeta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteTarjetasCreditoDelete( BigDecimal idtarjeta )  "
							+ ex);
		}
		return salida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clienteTarjetasCreditoXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();

			String cQuery = "DELETE FROM CLIENTETARJETASCREDITO WHERE idcliente="
					+ idcliente.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar tarjeta credito asociadas al cliente.";
			log
					.error("Error SQL en el metodo : clienteTarjetasCreditoDeleteAll( ... ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteTarjetasCreditoDeleteAll( ... )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clienteTarjetasCreditoCreate(BigDecimal idtarjetacredito,
			BigDecimal idcliente, BigDecimal idtipotarjeta, String nrotarjeta,
			String nrocontrol, Timestamp fecha_emision,
			Timestamp fecha_vencimiento, String titular, BigDecimal orden,
			String activa, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (nrotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrotarjeta ";
		if (nrocontrol == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol ";
		// if (fecha_emision == null)
		// salida = "Error: No se puede dejar sin datos (nulo) el campo:
		// fecha_emision ";
		if (fecha_vencimiento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento ";
		if (titular == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: titular ";
		if (orden == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: orden ";
		if (activa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activa ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (nrotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrotarjeta ";
		if (nrocontrol.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrocontrol ";
		if (titular.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: titular ";
		if (activa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activa ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTETARJETASCREDITO(idtarjetacredito, idcliente, idtipotarjeta, nrotarjeta, nrocontrol, fecha_emision, fecha_vencimiento, titular, orden, activa, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idtarjetacredito);
				insert.setBigDecimal(2, idcliente);
				insert.setBigDecimal(3, idtipotarjeta);
				insert.setString(4, nrotarjeta);
				insert.setString(5, nrocontrol);
				insert.setTimestamp(6, fecha_emision);
				insert.setTimestamp(7, fecha_vencimiento);
				insert.setString(8, titular);
				insert.setBigDecimal(9, orden);
				insert.setString(10, activa);
				insert.setBigDecimal(11, idempresa);
				insert.setString(12, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar tarjeta de credito.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible generar tarjeta.";
			log
					.error("Error SQL public String clienteTarjetasCreditoCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible generar tarjeta.";
			log
					.error("Error excepcion public String clienteTarjetasCreditoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clienteTarjetasCreditoCreateOrUpdate(BigDecimal idtarjeta,
			BigDecimal idtarjetacredito, BigDecimal idcliente,
			BigDecimal idtipotarjeta, String nrotarjeta, String nrocontrol,
			Timestamp fecha_emision, Timestamp fecha_vencimiento,
			String titular, BigDecimal orden, String activa,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjeta ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (nrotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrotarjeta ";
		if (nrocontrol == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol ";
		// if (fecha_emision == null)
		// salida = "Error: No se puede dejar sin datos (nulo) el campo:
		// fecha_emision ";
		if (fecha_vencimiento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento ";
		if (titular == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: titular ";
		if (orden == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: orden ";
		if (activa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activa ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nrotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrotarjeta ";
		if (nrocontrol.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrocontrol ";
		if (titular.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: titular ";
		if (activa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activa ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteTarjetasCredito WHERE idtarjeta = "
					+ idtarjeta.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTETARJETASCREDITO SET idtarjetacredito=?, idcliente=?, idtipotarjeta=?, nrotarjeta=?, nrocontrol=?, fecha_emision=?, fecha_vencimiento=?, titular=?, orden=?, activa=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtarjeta=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idtipotarjeta);
					insert.setString(4, nrotarjeta);
					insert.setString(5, nrocontrol);
					insert.setTimestamp(6, fecha_emision);
					insert.setTimestamp(7, fecha_vencimiento);
					insert.setString(8, titular);
					insert.setBigDecimal(9, orden);
					insert.setString(10, activa);
					insert.setBigDecimal(11, idempresa);
					insert.setString(12, usuarioact);
					insert.setTimestamp(13, fechaact);
					insert.setBigDecimal(14, idtarjeta);
				} else {
					String ins = "INSERT INTO CLIENTETARJETASCREDITO(idtarjetacredito, idcliente, idtipotarjeta, nrotarjeta, nrocontrol, fecha_emision, fecha_vencimiento, titular, orden, activa, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idtipotarjeta);
					insert.setString(4, nrotarjeta);
					insert.setString(5, nrocontrol);
					insert.setTimestamp(6, fecha_emision);
					insert.setTimestamp(7, fecha_vencimiento);
					insert.setString(8, titular);
					insert.setBigDecimal(9, orden);
					insert.setString(10, activa);
					insert.setBigDecimal(11, idempresa);
					insert.setString(12, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clienteTarjetasCreditoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteTarjetasCreditoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteTarjetasCreditoUpdate(BigDecimal idtarjeta,
			BigDecimal idtarjetacredito, BigDecimal idcliente,
			BigDecimal idtipotarjeta, String nrotarjeta, String nrocontrol,
			Timestamp fecha_emision, Timestamp fecha_vencimiento,
			String titular, BigDecimal orden, String activa,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjeta ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtipotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta ";
		if (nrotarjeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrotarjeta ";
		if (nrocontrol == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol ";
		// if (fecha_emision == null)
		// salida = "Error: No se puede dejar sin datos (nulo) el campo:
		// fecha_emision ";
		if (fecha_vencimiento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento ";
		if (titular == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: titular ";
		if (orden == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: orden ";
		if (activa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: activa ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nrotarjeta.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrotarjeta ";
		if (nrocontrol.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nrocontrol ";
		if (titular.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: titular ";
		if (activa.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: activa ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteTarjetasCredito WHERE idtarjeta = "
					+ idtarjeta.toString()
					+ " AND idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "    UPDATE CLIENTETARJETASCREDITO "
							+ "   SET idtarjetacredito=?, idcliente=?, idtipotarjeta=?, nrotarjeta=?, nrocontrol=?, fecha_emision=?, fecha_vencimiento=?, titular=?, orden=?, activa=?, idempresa=?, usuarioact=?, fechaact=? "
							+ " WHERE idtarjeta=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idtipotarjeta);
					insert.setString(4, nrotarjeta);
					insert.setString(5, nrocontrol);
					insert.setTimestamp(6, fecha_emision);
					insert.setTimestamp(7, fecha_vencimiento);
					insert.setString(8, titular);
					insert.setBigDecimal(9, orden);
					insert.setString(10, activa);
					insert.setBigDecimal(11, idempresa);
					insert.setString(12, usuarioact);
					insert.setTimestamp(13, fechaact);
					insert.setBigDecimal(14, idtarjeta);
					insert.setBigDecimal(15, idempresa);
				}

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar tarjeta de credito ("
							+ idtarjeta + ").";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar tarjeta de credito (" + idtarjeta
					+ ").";
			log
					.error("Error SQL public String clienteTarjetasCreditoUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar tarjeta de credito (" + idtarjeta
					+ ").";
			log
					.error("Error excepcion public String clienteTarjetasCreditoUpdate(.....)"
							+ ex);
		}
		return salida;
	} /*
	 * // tarjetas de credito public List getClientetarjetascreditoAll(long
	 * limit, long offset, BigDecimal idempresa) throws EJBException { ResultSet
	 * rsSalida = null; String cQuery = "SELECT
	 * CLIENTETARJETASCREDITO.idtarjeta,
	 * clientetarjetascreditomarcas.tarjetacredito
	 * ,clientesclientes.razon,clientetipostarjetas
	 * .tipotarjeta,CLIENTETARJETASCREDITO
	 * .nrotarjeta,CLIENTETARJETASCREDITO.nrocontrol
	 * ,CLIENTETARJETASCREDITO.fecha_emision
	 * ,CLIENTETARJETASCREDITO.fecha_vencimiento
	 * ,CLIENTETARJETASCREDITO.titular,CLIENTETARJETASCREDITO
	 * .orden,CLIENTETARJETASCREDITO
	 * .activa,CLIENTETARJETASCREDITO.usuarioalt,CLIENTETARJETASCREDITO
	 * .usuarioact
	 * ,CLIENTETARJETASCREDITO.fechaalt,CLIENTETARJETASCREDITO.fechaact FROM
	 * CLIENTETARJETASCREDITO
	 * ,clientetarjetascreditomarcas,clientesclientes,clientetipostarjetas where
	 * clientetarjetascreditomarcas.idtarjetacredito =
	 * CLIENTETARJETASCREDITO.idtarjetacredito and
	 * clientetarjetascreditomarcas.idempresa = CLIENTETARJETASCREDITO.idempresa
	 * and clientesclientes.idcliente = CLIENTETARJETASCREDITO.idcliente and
	 * clientesclientes.idempresa = CLIENTETARJETASCREDITO.idempresa and
	 * clientetipostarjetas.idtipotarjeta = CLIENTETARJETASCREDITO.idtipotarjeta
	 * and clientetipostarjetas.idempresa = CLIENTETARJETASCREDITO.idempresa and
	 * CLIENTETARJETASCREDITO.idempresa = " + idempresa.toString() + "ORDER BY 2
	 * LIMIT " + limit + " OFFSET " + offset + ";"; List vecSalida = new
	 * ArrayList(); try { Statement statement = dbconn.createStatement();
	 * rsSalida = statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) { log
	 * .error("Error SQL en el metodo : getClientetarjetascreditoAll() " +
	 * sqlException); } catch (Exception ex) { log .error("Salida por exception:
	 * en el metodo: getClientetarjetascreditoAll() " + ex); } return vecSalida;
	 * } // para una ocurrencia (ordena por el segundo campo por defecto)
	 * 
	 * public List getClientetarjetascreditoOcu(long limit, long offset, String
	 * ocurrencia, BigDecimal idempresa) throws EJBException { ResultSet
	 * rsSalida = null; String cQuery = "SELECT
	 * CLIENTETARJETASCREDITO.idtarjeta,
	 * clientetarjetascreditomarcas.tarjetacredito
	 * ,clientesclientes.razon,clientetipostarjetas
	 * .tipotarjeta,CLIENTETARJETASCREDITO
	 * .nrotarjeta,CLIENTETARJETASCREDITO.nrocontrol
	 * ,CLIENTETARJETASCREDITO.fecha_emision
	 * ,CLIENTETARJETASCREDITO.fecha_vencimiento
	 * ,CLIENTETARJETASCREDITO.titular,CLIENTETARJETASCREDITO
	 * .orden,CLIENTETARJETASCREDITO
	 * .activa,CLIENTETARJETASCREDITO.usuarioalt,CLIENTETARJETASCREDITO
	 * .usuarioact
	 * ,CLIENTETARJETASCREDITO.fechaalt,CLIENTETARJETASCREDITO.fechaact FROM
	 * CLIENTETARJETASCREDITO
	 * ,clientetarjetascreditomarcas,clientesclientes,clientetipostarjetas where
	 * clientetarjetascreditomarcas.idtarjetacredito =
	 * CLIENTETARJETASCREDITO.idtarjetacredito and
	 * clientetarjetascreditomarcas.idempresa = CLIENTETARJETASCREDITO.idempresa
	 * and clientesclientes.idcliente = CLIENTETARJETASCREDITO.idcliente and
	 * clientesclientes.idempresa = CLIENTETARJETASCREDITO.idempresa and
	 * clientetipostarjetas.idtipotarjeta = CLIENTETARJETASCREDITO.idtipotarjeta
	 * and clientetipostarjetas.idempresa = CLIENTETARJETASCREDITO.idempresa and
	 * CLIENTETARJETASCREDITO.idempresa = " + idempresa.toString() + " and
	 * (CLIENTETARJETASCREDITO.idtarjeta LIKE '%" + ocurrencia + "%' OR " + "
	 * UPPER(clientetarjetascreditomarcas.tarjetacredito) LIKE '%" +
	 * ocurrencia.toUpperCase() + "%') " + " ORDER BY 2 LIMIT " + limit + "
	 * OFFSET " + offset + ";"; List vecSalida = new ArrayList(); try {
	 * Statement statement = dbconn.createStatement(); rsSalida =
	 * statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) { log
	 * .error("Error SQL en el metodo : getClientetarjetascreditoOcu(String
	 * ocurrencia) " + sqlException); } catch (Exception ex) { log
	 * .error("Salida por exception: en el metodo:
	 * getClientetarjetascreditoOcu(String ocurrencia) " + ex); } return
	 * vecSalida; } // por primary key (primer campo por defecto)
	 * 
	 * public List getClientetarjetascreditoPK(BigDecimal idtarjeta, BigDecimal
	 * idempresa) throws EJBException { ResultSet rsSalida = null; String cQuery
	 * = "" + "SELECT
	 * CLIENTETARJETASCREDITO.idtarjeta,CLIENTETARJETASCREDITO.idtarjetacredito
	 * ,clientetarjetascreditomarcas
	 * .tarjetacredito,CLIENTETARJETASCREDITO.idcliente
	 * ,clientesclientes.razon,CLIENTETARJETASCREDITO
	 * .idtipotarjeta,clientetipostarjetas
	 * .tipotarjeta,CLIENTETARJETASCREDITO.nrotarjeta
	 * ,CLIENTETARJETASCREDITO.nrocontrol
	 * ,CLIENTETARJETASCREDITO.fecha_emision,CLIENTETARJETASCREDITO
	 * .fecha_vencimiento
	 * ,CLIENTETARJETASCREDITO.titular,CLIENTETARJETASCREDITO.orden
	 * ,CLIENTETARJETASCREDITO
	 * .activa,CLIENTETARJETASCREDITO.usuarioalt,CLIENTETARJETASCREDITO
	 * .usuarioact
	 * ,CLIENTETARJETASCREDITO.fechaalt,CLIENTETARJETASCREDITO.fechaact " + "
	 * FROM
	 * CLIENTETARJETASCREDITO,clientetarjetascreditomarcas,clientesclientes,
	 * clientetipostarjetas " + " where
	 * clientetarjetascreditomarcas.idtarjetacredito =
	 * CLIENTETARJETASCREDITO.idtarjetacredito and clientesclientes.idcliente =
	 * CLIENTETARJETASCREDITO.idcliente and clientetipostarjetas.idtipotarjeta =
	 * CLIENTETARJETASCREDITO.idtipotarjeta and
	 * CLIENTETARJETASCREDITO.idtarjeta=" + idtarjeta.toString() + "and
	 * CLIENTETARJETASCREDITO.idempresa=" + idempresa.toString(); List vecSalida
	 * = new ArrayList(); try { Statement statement = dbconn.createStatement();
	 * rsSalida = statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) { log
	 * .error("Error SQL en el metodo : getClientetarjetascreditoPK( BigDecimal
	 * idtarjeta ) " + sqlException); } catch (Exception ex) { log
	 * .error("Salida por exception: en el metodo: getClientetarjetascreditoPK(
	 * BigDecimal idtarjeta ) " + ex); } return vecSalida; } // ELIMINACION DE
	 * UN REGISTRO por primary key (primer campo por defecto)
	 * 
	 * public String clientetarjetascreditoDelete(BigDecimal idtarjeta,
	 * BigDecimal idempresa) throws EJBException { ResultSet rsSalida = null;
	 * String cQuery = "SELECT * FROM CLIENTETARJETASCREDITO WHERE
	 * idtarjeta=" + idtarjeta.toString() + "and idempresa=" +
	 * idempresa.toString(); ; String salida = "NOOK"; try { Statement statement
	 * = dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); if
	 * (rsSalida.next()) { cQuery =
	 * "DELETE FROM CLIENTETARJETASCREDITO WHERE idtarjeta=" +
	 * idtarjeta.toString() + "and idempresa=" + idempresa.toString(); ;
	 * statement.execute(cQuery); salida = "Baja Correcta."; } else { salida =
	 * "Error: Registro inexistente"; } } catch (SQLException sqlException) {
	 * salida = "Imposible eliminar el registro."; log .error("Error SQL en el
	 * metodo : clientetarjetascreditoDelete( BigDecimal idtarjeta ) " +
	 * sqlException); } catch (Exception ex) { salida = "Imposible eliminar el
	 * registro."; log .error("Salida por exception: en el metodo:
	 * clientetarjetascreditoDelete( BigDecimal idtarjeta ) " + ex); } return
	 * salida; } // grabacion de un nuevo registro NOTA: no se tiene en cuenta
	 * el primer // registro por PK y los datos de auditoria solo usuarioalt
	 * 
	 * public String clientetarjetascreditoCreate(BigDecimal idtarjetacredito,
	 * BigDecimal idcliente, BigDecimal idtipotarjeta, String nrotarjeta, String
	 * nrocontrol, Timestamp fecha_emision, Timestamp fecha_vencimiento, String
	 * titular, BigDecimal orden, String activa, String usuarioalt, BigDecimal
	 * idempresa) throws EJBException { String salida = "NOOK"; // validaciones
	 * de datos: // 1. nulidad de campos if (idtarjetacredito == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
	 * if (idcliente == null) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: idcliente "; if (idtipotarjeta == null) salida = "Error:
	 * No se puede dejar sin datos (nulo) el campo: idtipotarjeta "; if
	 * (nrotarjeta == null) salida = "Error: No se puede dejar sin datos (nulo)
	 * el campo: nrotarjeta "; if (nrocontrol == null) salida = "Error: No se
	 * puede dejar sin datos (nulo) el campo: nrocontrol "; if (fecha_emision ==
	 * null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * fecha_emision "; if (fecha_vencimiento == null) salida = "Error: No se
	 * puede dejar sin datos (nulo) el campo: fecha_vencimiento "; if (titular
	 * == null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * titular "; if (orden == null) salida = "Error: No se puede dejar sin
	 * datos (nulo) el campo: orden "; if (activa == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: activa "; if
	 * (usuarioalt == null) salida = "Error: No se puede dejar sin datos (nulo)
	 * el campo: usuarioalt "; // 2. sin nada desde la pagina if
	 * (nrotarjeta.equalsIgnoreCase("")) salida = "Error: No se puede dejar
	 * vacio el campo: nrotarjeta "; if (nrocontrol.equalsIgnoreCase("")) salida
	 * = "Error: No se puede dejar vacio el campo: nrocontrol "; if
	 * (titular.equalsIgnoreCase("")) salida = "Error: No se puede dejar vacio
	 * el campo: titular "; if (activa.equalsIgnoreCase("")) salida =
	 * "Error: No se puede dejar vacio el campo: activa "; if
	 * (usuarioalt.equalsIgnoreCase("")) salida = "Error: No se puede dejar
	 * vacio el campo: usuarioalt "; // fin validaciones boolean bError = true;
	 * if (salida.equalsIgnoreCase("NOOK")) bError = false; try { if (!bError) {
	 * String ins = "INSERT INTO CLIENTETARJETASCREDITO(idtarjetacredito,
	 * idcliente, idtipotarjeta, nrotarjeta, nrocontrol, fecha_emision,
	 * fecha_vencimiento, titular, orden, activa, usuarioalt,idempresa ) VALUES
	 * (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"; PreparedStatement insert =
	 * dbconn.prepareStatement(ins); // seteo de campos: insert.setBigDecimal(1,
	 * idtarjetacredito); insert.setBigDecimal(2, idcliente);
	 * insert.setBigDecimal(3, idtipotarjeta); insert.setString(4, nrotarjeta);
	 * insert.setString(5, nrocontrol); insert.setTimestamp(6, fecha_emision);
	 * insert.setTimestamp(7, fecha_vencimiento); insert.setString(8, titular);
	 * insert.setBigDecimal(9, orden); insert.setString(10, activa);
	 * insert.setString(11, usuarioalt); insert.setBigDecimal(12, idempresa);
	 * int n = insert.executeUpdate(); if (n == 1) salida = "Alta Correcta"; } }
	 * catch (SQLException sqlException) { salida =
	 * "Imposible dar de alta el registro."; log .error("Error SQL public String
	 * clientetarjetascreditoCreate(.....)" + sqlException); } catch (Exception
	 * ex) { salida = "Imposible dar de alta el registro."; log .error("Error
	 * excepcion public String clientetarjetascreditoCreate(.....)" + ex); }
	 * return salida; } // actualizacion de un registro por PK NOTA: no se tiene
	 * en cuenta el primer // registro por PK y los datos de auditoria
	 * 
	 * public String clientetarjetascreditoCreateOrUpdate(BigDecimal idtarjeta,
	 * BigDecimal idtarjetacredito, BigDecimal idcliente, BigDecimal
	 * idtipotarjeta, String nrotarjeta, String nrocontrol, Timestamp
	 * fecha_emision, Timestamp fecha_vencimiento, String titular, BigDecimal
	 * orden, String activa, String usuarioact, BigDecimal idempresa) throws
	 * EJBException { Calendar hoy = new GregorianCalendar(); Timestamp fechaact
	 * = new Timestamp(hoy.getTime().getTime()); String salida = "NOOK"; //
	 * validaciones de datos: // 1. nulidad de campos if (idtarjeta == null)
	 * salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjeta
	 * "; if (idtarjetacredito == null) salida = "Error: No se puede dejar sin
	 * datos (nulo) el campo: idtarjetacredito "; if (idcliente == null) salida
	 * = "Error: No se puede dejar sin datos (nulo) el campo: idcliente "; if
	 * (idtipotarjeta == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta "; if
	 * (nrotarjeta == null) salida = "Error: No se puede dejar sin datos (nulo)
	 * el campo: nrotarjeta "; if (nrocontrol == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol "; if
	 * (fecha_emision == null) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: fecha_emision "; if (fecha_vencimiento == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento
	 * "; if (titular == null) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: titular "; if (orden == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: orden "; if (activa
	 * == null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * activa "; // 2. sin nada desde la pagina if
	 * (nrotarjeta.equalsIgnoreCase("")) salida = "Error: No se puede dejar
	 * vacio el campo: nrotarjeta "; if (nrocontrol.equalsIgnoreCase("")) salida
	 * = "Error: No se puede dejar vacio el campo: nrocontrol "; if
	 * (titular.equalsIgnoreCase("")) salida = "Error: No se puede dejar vacio
	 * el campo: titular "; if (activa.equalsIgnoreCase("")) salida =
	 * "Error: No se puede dejar vacio el campo: activa "; // fin validaciones
	 * boolean bError = true; if (salida.equalsIgnoreCase("NOOK")) bError =
	 * false; try { ResultSet rsSalida = null; String cQuery = "SELECT COUNT(*)
	 * FROM clientetarjetascredito WHERE idtarjeta = " + idtarjeta.toString() +
	 * "and idempresa=" + idempresa.toString(); ; Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); int
	 * total = 0; if (rsSalida != null && rsSalida.next()) total =
	 * rsSalida.getInt(1); PreparedStatement insert = null; String sql = ""; if
	 * (!bError) { if (total > 0) { // si existe hago update sql = "UPDATE
	 * CLIENTETARJETASCREDITO SET idtarjetacredito=?, idcliente=?,
	 * idtipotarjeta=?, nrotarjeta=?, nrocontrol=?, fecha_emision=?,
	 * fecha_vencimiento=?, titular=?, orden=?, activa=?, usuarioact=?,
	 * fechaact=? WHERE idtarjeta=? and idempresa=?;"; insert =
	 * dbconn.prepareStatement(sql); insert.setBigDecimal(1, idtarjetacredito);
	 * insert.setBigDecimal(2, idcliente); insert.setBigDecimal(3,
	 * idtipotarjeta); insert.setString(4, nrotarjeta); insert.setString(5,
	 * nrocontrol); insert.setTimestamp(6, fecha_emision);
	 * insert.setTimestamp(7, fecha_vencimiento); insert.setString(8, titular);
	 * insert.setBigDecimal(9, orden); insert.setString(10, activa);
	 * insert.setString(11, usuarioact); insert.setTimestamp(12, fechaact);
	 * insert.setBigDecimal(13, idtarjeta); insert.setBigDecimal(14, idempresa);
	 * } else { String ins = "INSERT INTO
	 * CLIENTETARJETASCREDITO(idtarjetacredito, idcliente, idtipotarjeta,
	 * nrotarjeta, nrocontrol, fecha_emision, fecha_vencimiento, titular, orden,
	 * activa, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
	 * ?)"; insert = dbconn.prepareStatement(ins); // seteo de campos: String
	 * usuarioalt = usuarioact; // esta variable va a // proposito
	 * insert.setBigDecimal(1, idtarjetacredito); insert.setBigDecimal(2,
	 * idcliente); insert.setBigDecimal(3, idtipotarjeta); insert.setString(4,
	 * nrotarjeta); insert.setString(5, nrocontrol); insert.setTimestamp(6,
	 * fecha_emision); insert.setTimestamp(7, fecha_vencimiento);
	 * insert.setString(8, titular); insert.setBigDecimal(9, orden);
	 * insert.setString(10, activa); insert.setString(11, usuarioalt);
	 * insert.setBigDecimal(12, idempresa); } insert.executeUpdate(); salida =
	 * "Alta Correcta."; } } catch (SQLException sqlException) { salida =
	 * "Imposible dar de alta el registro."; log .error("Error SQL public String
	 * clientetarjetascreditoCreateOrUpdate(.....)" + sqlException); } catch
	 * (Exception ex) { salida = "Imposible dar de alta el registro."; log
	 * .error("Error excepcion public String
	 * clientetarjetascreditoCreateOrUpdate(.....)" + ex); } return salida; }
	 * 
	 * public String clientetarjetascreditoUpdate(BigDecimal idtarjeta,
	 * BigDecimal idtarjetacredito, BigDecimal idcliente, BigDecimal
	 * idtipotarjeta, String nrotarjeta, String nrocontrol, Timestamp
	 * fecha_emision, Timestamp fecha_vencimiento, String titular, BigDecimal
	 * orden, String activa, String usuarioact, BigDecimal idempresa) throws
	 * EJBException { Calendar hoy = new GregorianCalendar(); Timestamp fechaact
	 * = new Timestamp(hoy.getTime().getTime()); String salida = "NOOK"; //
	 * validaciones de datos: // 1. nulidad de campos if (idtarjeta == null)
	 * salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjeta
	 * "; if (idtarjetacredito == null) salida = "Error: No se puede dejar sin
	 * datos (nulo) el campo: idtarjetacredito "; if (idcliente == null) salida
	 * = "Error: No se puede dejar sin datos (nulo) el campo: idcliente "; if
	 * (idtipotarjeta == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idtipotarjeta "; if
	 * (nrotarjeta == null) salida = "Error: No se puede dejar sin datos (nulo)
	 * el campo: nrotarjeta "; if (nrocontrol == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: nrocontrol "; if
	 * (fecha_emision == null) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: fecha_emision "; if (fecha_vencimiento == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: fecha_vencimiento
	 * "; if (titular == null) salida = "Error: No se puede dejar sin datos
	 * (nulo) el campo: titular "; if (orden == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: orden "; if (activa
	 * == null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * activa "; // 2. sin nada desde la pagina if
	 * (nrotarjeta.equalsIgnoreCase("")) salida = "Error: No se puede dejar
	 * vacio el campo: nrotarjeta "; if (nrocontrol.equalsIgnoreCase("")) salida
	 * = "Error: No se puede dejar vacio el campo: nrocontrol "; if
	 * (titular.equalsIgnoreCase("")) salida = "Error: No se puede dejar vacio
	 * el campo: titular "; if (activa.equalsIgnoreCase("")) salida =
	 * "Error: No se puede dejar vacio el campo: activa "; // fin validaciones
	 * boolean bError = true; if (salida.equalsIgnoreCase("NOOK")) bError =
	 * false; try { ResultSet rsSalida = null; String cQuery = "SELECT COUNT(*)
	 * FROM clientetarjetascredito WHERE idtarjeta = " + idtarjeta.toString() +
	 * "and idempresa=" + idempresa.toString(); ; Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); int
	 * total = 0; if (rsSalida != null && rsSalida.next()) total =
	 * rsSalida.getInt(1); PreparedStatement insert = null; String sql = ""; if
	 * (!bError) { if (total > 0) { // si existe hago update sql = "UPDATE
	 * CLIENTETARJETASCREDITO SET idtarjetacredito=?, idcliente=?,
	 * idtipotarjeta=?, nrotarjeta=?, nrocontrol=?, fecha_emision=?,
	 * fecha_vencimiento=?, titular=?, orden=?, activa=?, usuarioact=?,
	 * fechaact=? WHERE idtarjeta=? and idempresa=?;"; insert =
	 * dbconn.prepareStatement(sql); insert.setBigDecimal(1, idtarjetacredito);
	 * insert.setBigDecimal(2, idcliente); insert.setBigDecimal(3,
	 * idtipotarjeta); insert.setString(4, nrotarjeta); insert.setString(5,
	 * nrocontrol); insert.setTimestamp(6, fecha_emision);
	 * insert.setTimestamp(7, fecha_vencimiento); insert.setString(8, titular);
	 * insert.setBigDecimal(9, orden); insert.setString(10, activa);
	 * insert.setString(11, usuarioact); insert.setTimestamp(12, fechaact);
	 * insert.setBigDecimal(13, idtarjeta); insert.setBigDecimal(14, idempresa);
	 * }
	 * 
	 * int i = insert.executeUpdate(); if (i > 0) salida = "Actualizacion
	 * Correcta"; else salida = "Imposible actualizar el registro."; } } catch
	 * (SQLException sqlException) { salida = "Imposible actualizar el
	 * registro."; log .error("Error SQL public String
	 * clientetarjetascreditoUpdate(.....)" + sqlException); } catch (Exception
	 * ex) { salida = "Imposible actualizar el registro."; log .error("Error
	 * excepcion public String clientetarjetascreditoUpdate(.....)" + ex); }
	 * return salida; }
	 */

	public List getClientesTarjetaMarcasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtarjetacredito,tarjetacredito,usuarioalt,usuarioact,fechaalt,fechaact FROM clientetarjetascreditomarcas where idempresa= "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetaMarcasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesTarjetaMarcasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtarjetacredito,tarjetacredito,usuarioalt,usuarioact,fechaalt,fechaact FROM clientetarjetascreditomarcas"
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtarjetacredito::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tarjetacredito) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetaMarcasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// **********

	public List getClientesTipoTarjetasLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtipotarjeta,tipotarjeta,usuarioalt,usuarioact,fechaalt,fechaact FROM clientetipostarjetas where idempresa ="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoTarjetasLovAll()  "
							+ ex);
		}

		return vecSalida;

	}

	public List getClientesTipoTarjetasLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipotarjeta,tipotarjeta,usuarioalt,usuarioact,fechaalt,fechaact FROM clientetipostarjetas "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtipotarjeta::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tipotarjeta) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoTarjetasLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// detalle tarjeta del cliente
	// filtro por ocurrencia y por cliente
	public List getClientesDetalleTarjetaOcu(String idcliente, long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT CLIENTETARJETASCREDITO.idtarjeta,clientetarjetascreditomarcas.tarjetacredito,clientetipostarjetas.tipotarjeta,CLIENTETARJETASCREDITO.nrotarjeta,CLIENTETARJETASCREDITO.nrocontrol,CLIENTETARJETASCREDITO.fecha_emision,CLIENTETARJETASCREDITO.fecha_vencimiento,CLIENTETARJETASCREDITO.titular,CLIENTETARJETASCREDITO.orden,CLIENTETARJETASCREDITO.activa,CLIENTETARJETASCREDITO.usuarioalt,CLIENTETARJETASCREDITO.usuarioact,CLIENTETARJETASCREDITO.fechaalt,CLIENTETARJETASCREDITO.fechaact FROM CLIENTETARJETASCREDITO,clientetarjetascreditomarcas,clientesclientes,clientetipostarjetas where clientetarjetascreditomarcas.idtarjetacredito = CLIENTETARJETASCREDITO.idtarjetacredito and  clientetarjetascreditomarcas.idempresa = CLIENTETARJETASCREDITO.idempresa and clientesclientes.idcliente = CLIENTETARJETASCREDITO.idcliente and clientesclientes.idempresa = CLIENTETARJETASCREDITO.idempresa and clientetipostarjetas.idtipotarjeta = CLIENTETARJETASCREDITO.idtipotarjeta and clientetipostarjetas.idempresa = CLIENTETARJETASCREDITO.idempresa"
				+ " and CLIENTETARJETASCREDITO.idcliente = '"
				+ idcliente.toString()
				+ "'"
				+ " and CLIENTETARJETASCREDITO.idempresa= "
				+ idempresa.toString()
				+ " and (CLIENTETARJETASCREDITO.idtarjeta::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(clientetarjetascreditomarcas.tarjetacredito) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDetalleTarjetaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// traigo el total de registros por cliente
	public List getClientesDetalleTarjetaAll(String idcliente, long limit,
			long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT CLIENTETARJETASCREDITO.idtarjeta,clientetarjetascreditomarcas.tarjetacredito,"
				+ "       clientetipostarjetas.tipotarjeta,CLIENTETARJETASCREDITO.nrotarjeta,CLIENTETARJETASCREDITO.nrocontrol,"
				+ "       CLIENTETARJETASCREDITO.fecha_emision,CLIENTETARJETASCREDITO.fecha_vencimiento,"
				+ "       CLIENTETARJETASCREDITO.titular,CLIENTETARJETASCREDITO.orden,CLIENTETARJETASCREDITO.activa,"
				+ "       CLIENTETARJETASCREDITO.usuarioalt,CLIENTETARJETASCREDITO.usuarioact,CLIENTETARJETASCREDITO.fechaalt,CLIENTETARJETASCREDITO.fechaact "
				+ "  FROM CLIENTETARJETASCREDITO,clientetarjetascreditomarcas,clientesclientes,clientetipostarjetas "
				+ " where clientetarjetascreditomarcas.idtarjetacredito = CLIENTETARJETASCREDITO.idtarjetacredito "
				+ "   and clientetarjetascreditomarcas.idempresa = CLIENTETARJETASCREDITO.idempresa "
				+ "   and clientesclientes.idcliente = CLIENTETARJETASCREDITO.idcliente "
				+ "   and clientesclientes.idempresa = CLIENTETARJETASCREDITO.idempresa "
				+ "   and clientetipostarjetas.idtipotarjeta = CLIENTETARJETASCREDITO.idtipotarjeta "
				+ "   and clientetipostarjetas.idempresa = CLIENTETARJETASCREDITO.idempresa"
				+ "   and CLIENTETARJETASCREDITO.idcliente = '"
				+ idcliente.toString() + "'"
				+ "and CLIENTETARJETASCREDITO.idempresa="
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDetalleTarjetaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getMaximoCliente(BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		BigDecimal idcliente = BigDecimal.valueOf(0);
		ResultSet rsSalida = null;
		String cQuery = "SELECT COALESCE(MAX(idcliente), 0) + 1 as idcliente "
				+ " FROM clientesclientes WHERE idempresa = "
				+ idempresa.toString() + " AND idcliente <= 699999 ";
		// solicitud villera de amelia 15-09-2009
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next()) {
				idcliente = rsSalida.getBigDecimal("idcliente");
			} else {
				log.warn("getMaximoCliente()- Error al recuperar idcliente: ");
			}
		} catch (SQLException sqlException) {
			log.error("getMaximoCliente()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getMaximoCliente()- Salida por exception: " + ex);
		}
		return idcliente;
	}

	// Clientes Sucursales
	public List getClientesClieSucAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT CLS.idsucursal,CLI.razon,TS.tiposucursal,CLS.nombre_suc,CLS.domici_suc,"
				+ "       CLS.telefo_suc,GL.localidad,CV.vendedor,CCO.cobrador,CE.expreso,"
				+ "       CLS.usuarioalt,CLS.usuarioact,CLS.fechaalt,CLS.fechaact, CLS.idempresa "
				+ "  FROM CLIENTESCLIESUC CLS"
				+ "       LEFT JOIN CLIENTESCLIENTES CLI  ON (CLI.idcliente  = CLS.idcliente and CLI.idempresa = CLS.idempresa)"
				+ "       LEFT JOIN clientestipossucursales TS  ON (TS.idtiposucursal = CLS.idtiposucursal and TS.idempresa = CLS.idempresa) "
				+ "       LEFT JOIN globallocalidades GL  ON (GL.idlocalidad  = CLS.idlocalidad ) "
				+ "       LEFT JOIN clientesvendedor CV ON (CV.idvendedor = CLS.idvendedor and CV.idempresa = CLS.idempresa)"
				+ "       LEFT JOIN clientescobradores CCO ON (CCO.idcobrador = CLS.idcobrador and CCO.idempresa = CLS.idempresa)"
				+ "       LEFT JOIN clientesexpresos CE ON (CE.idexpreso = CLS.idexpreso and CE.idempresa = CLS.idempresa)"
				+ "  where CLS.idempresa = " + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClieSucAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)
	public List getClientesClieSucOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CLS.idsucursal,CLI.razon,TS.tiposucursal,CLS.nombre_suc,CLS.domici_suc,CLS.telefo_suc,GL.localidad,CV.vendedor,CCO.cobrador,CE.expreso,CLS.usuarioalt,CLS.usuarioact,CLS.fechaalt,CLS.fechaact, CLS.idempresa FROM CLIENTESCLIESUC CLS LEFT JOIN CLIENTESCLIENTES CLI  ON (CLI.idcliente  = CLS.idcliente and CLI.idempresa = CLS.idempresa)LEFT JOIN clientestipossucursales TS  ON (TS.idtiposucursal = CLS.idtiposucursal and TS.idempresa = CLS.idempresa) LEFT JOIN globallocalidades GL  ON (GL.idlocalidad  = CLS.idlocalidad ) LEFT JOIN clientesvendedor CV ON (CV.idvendedor = CLS.idvendedor and CV.idempresa = CLS.idempresa) LEFT JOIN clientescobradores CCO ON (CCO.idcobrador = CLS.idcobrador and CCO.idempresa = CLS.idempresa) LEFT JOIN clientesexpresos CE ON (CE.idexpreso = CLS.idexpreso and CE.idempresa = CLS.idempresa) where CLS.idempresa = "
				+ idempresa.toString()
				+ " and (CLS.idsucursal::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(CLS.nombre_suc) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClieSucOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesClieSucPK(BigDecimal idsucursal, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT CLS.idsucursal,CLS.idcliente,CLI.razon,CLS.idtiposucursal,TS.tiposucursal,CLS.nombre_suc,CLS.domici_suc,CLS.telefo_suc,CLS.idlocalidad,GL.localidad,CLS.idvendedor,CV.vendedor,CLS.idcobrador,CCO.cobrador,CLS.idexpreso,CE.expreso,CLS.usuarioalt,CLS.usuarioact,CLS.fechaalt,CLS.fechaact, CLS.idempresa FROM CLIENTESCLIESUC CLS LEFT JOIN CLIENTESCLIENTES CLI  ON (CLI.idcliente  = CLS.idcliente)LEFT JOIN clientestipossucursales TS  ON (TS.idtiposucursal = CLS.idtiposucursal) LEFT JOIN globallocalidades GL  ON (GL.idlocalidad  = CLS.idlocalidad) LEFT JOIN clientesvendedor CV ON (CV.idvendedor = CLS.idvendedor) LEFT JOIN clientescobradores CCO ON (CCO.idcobrador = CLS.idcobrador) LEFT JOIN clientesexpresos CE ON (CE.idexpreso = CLS.idexpreso) where CLS.idsucursal="
				+ idsucursal.toString()
				+ "and CLS.idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClieSucPK( BigDecimal idsucursal )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesClieSucDelete(BigDecimal idsucursal,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESCLIESUC WHERE idsucursal="
				+ idsucursal.toString() + "and idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESCLIESUC WHERE idsucursal="
						+ idsucursal.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesClieSucDelete( BigDecimal idsucursal ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesClieSucDelete( BigDecimal idsucursal )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesClieSucCreate(BigDecimal idcliente,
			BigDecimal idtiposucursal, String nombre_suc, String domici_suc,
			String telefo_suc, String idlocalidad, String idvendedor,
			String idcobrador, String idexpreso, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtiposucursal ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESCLIESUC(idcliente, idtiposucursal, nombre_suc, domici_suc, telefo_suc, idlocalidad, idvendedor, idcobrador, idexpreso, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idtiposucursal);
				insert.setString(3, nombre_suc);
				insert.setString(4, domici_suc);
				insert.setString(5, telefo_suc);
				if (idlocalidad != "" && !idlocalidad.equalsIgnoreCase("")) {
					insert.setBigDecimal(6, new BigDecimal(idlocalidad));
				} else {
					insert.setBigDecimal(6, null);
				}
				if (idvendedor != "" && !idvendedor.equalsIgnoreCase("")) {
					insert.setBigDecimal(7, new BigDecimal(idvendedor));
				} else {
					insert.setBigDecimal(7, null);
				}
				if (idcobrador != "" && !idcobrador.equalsIgnoreCase("")) {
					insert.setBigDecimal(8, new BigDecimal(idcobrador));
				} else {
					insert.setBigDecimal(8, null);
				}
				if (idexpreso != "" && !idexpreso.equalsIgnoreCase("")) {
					insert.setBigDecimal(9, new BigDecimal(idexpreso));
				} else {
					insert.setBigDecimal(9, null);
				}
				insert.setString(10, usuarioalt);
				insert.setBigDecimal(11, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesClieSucCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesClieSucCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesClieSucCreateOrUpdate(BigDecimal idsucursal,
			BigDecimal idcliente, BigDecimal idtiposucursal, String nombre_suc,
			String domici_suc, String telefo_suc, String idlocalidad,
			String idvendedor, String idcobrador, String idexpreso,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idsucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucursal ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtiposucursal ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesClieSuc WHERE idsucursal = "
					+ idsucursal.toString()
					+ "and idempresa ="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCLIESUC SET idcliente=?, idtiposucursal=?, nombre_suc=?, domici_suc=?, telefo_suc=?, idlocalidad=?, idvendedor=?, idcobrador=?, idexpreso=?, usuarioact=?, fechaact=?, idempresa=? WHERE idsucursal=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idtiposucursal);
					insert.setString(3, nombre_suc);
					insert.setString(4, domici_suc);
					insert.setString(5, telefo_suc);
					if (idlocalidad != null
							&& !idlocalidad.equalsIgnoreCase("null")) {
						insert.setBigDecimal(6, new BigDecimal(idlocalidad));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idvendedor != null
							&& !idvendedor.equalsIgnoreCase("null")) {
						insert.setBigDecimal(7, new BigDecimal(idvendedor));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idcobrador != null
							&& !idcobrador.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8, new BigDecimal(idcobrador));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idexpreso != null
							&& !idexpreso.equalsIgnoreCase("null")) {
						insert.setBigDecimal(9, new BigDecimal(idexpreso));
					} else {
						insert.setBigDecimal(9, null);
					}
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idsucursal);
					insert.setBigDecimal(13, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESCLIESUC(idcliente, idtiposucursal, nombre_suc, domici_suc, telefo_suc, idlocalidad, idvendedor, idcobrador, idexpreso, usuarioalt,idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idtiposucursal);
					insert.setString(3, nombre_suc);
					insert.setString(4, domici_suc);
					insert.setString(5, telefo_suc);
					if (idlocalidad != "" && !idlocalidad.equalsIgnoreCase("")) {
						insert.setBigDecimal(6, new BigDecimal(idlocalidad));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idvendedor != "" && !idvendedor.equalsIgnoreCase("")) {
						insert.setBigDecimal(7, new BigDecimal(idvendedor));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idcobrador != "" && !idcobrador.equalsIgnoreCase("")) {
						insert.setBigDecimal(8, new BigDecimal(idcobrador));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idexpreso != "" && !idexpreso.equalsIgnoreCase("")) {
						insert.setBigDecimal(9, new BigDecimal(idexpreso));
					} else {
						insert.setBigDecimal(9, null);
					}
					insert.setString(10, usuarioalt);
					insert.setBigDecimal(11, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesClieSucCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesClieSucCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesClieSucUpdate(BigDecimal idsucursal,
			BigDecimal idcliente, BigDecimal idtiposucursal, String nombre_suc,
			String domici_suc, String telefo_suc, String idlocalidad,
			String idvendedor, String idcobrador, String idexpreso,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idsucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucursal ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idtiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtiposucursal ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesClieSuc WHERE idsucursal = "
					+ idsucursal.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCLIESUC SET idcliente=?, idtiposucursal=?, nombre_suc=?, domici_suc=?, telefo_suc=?, idlocalidad=?, idvendedor=?, idcobrador=?, idexpreso=?, usuarioact=?, fechaact=? WHERE idsucursal=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idtiposucursal);
					insert.setString(3, nombre_suc);
					insert.setString(4, domici_suc);
					insert.setString(5, telefo_suc);
					if (idlocalidad != null
							&& !idlocalidad.equalsIgnoreCase("null")) {
						insert.setBigDecimal(6, new BigDecimal(idlocalidad));
					} else {
						insert.setBigDecimal(6, null);
					}
					if (idvendedor != null
							&& !idvendedor.equalsIgnoreCase("null")) {
						insert.setBigDecimal(7, new BigDecimal(idvendedor));
					} else {
						insert.setBigDecimal(7, null);
					}
					if (idcobrador != null
							&& !idcobrador.equalsIgnoreCase("null")) {
						insert.setBigDecimal(8, new BigDecimal(idcobrador));
					} else {
						insert.setBigDecimal(8, null);
					}
					if (idexpreso != null
							&& !idexpreso.equalsIgnoreCase("null")) {
						insert.setBigDecimal(9, new BigDecimal(idexpreso));
					} else {
						insert.setBigDecimal(9, null);
					}
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idsucursal);
					insert.setBigDecimal(13, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesClieSucUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesClieSucUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// para el lov de sucursales
	public List getClientessucursalesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtiposucursal,tiposucursal,usuarioalt,usuarioact,fechaalt,fechaact FROM clientestipossucursales where idempresa= "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientessucursalesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientessucursalesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtiposucursal,tiposucursal,usuarioalt,usuarioact,fechaalt,fechaact FROM clientestipossucursales"
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtiposucursal::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tiposucursal) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientessucursalesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// detalle tarjeta del cliente
	// filtro por ocurrencia y por cliente
	public List getClientesDetalleDomicilioOcu(String idcliente, long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT CLS.idsucursal,TS.tiposucursal,CLS.nombre_suc,CLS.domici_suc,CLS.telefo_suc,GL.localidad,CV.vendedor,CCO.cobrador,CE.expreso,CLS.usuarioalt,CLS.usuarioact,CLS.fechaalt,CLS.fechaact FROM CLIENTESCLIESUC CLS LEFT JOIN CLIENTESCLIENTES CLI  ON (CLI.idcliente  = CLS.idcliente and CLI.idempresa = CLS.idempresa)LEFT JOIN clientestipossucursales TS  ON (TS.idtiposucursal = CLS.idtiposucursal and TS.idempresa = CLS.idempresa) LEFT JOIN globallocalidades GL  ON (GL.idlocalidad  = CLS.idlocalidad) LEFT JOIN clientesvendedor CV ON (CV.idvendedor = CLS.idvendedor and CV.idempresa = CLS.idempresa) LEFT JOIN clientescobradores CCO ON (CCO.idcobrador = CLS.idcobrador and CCO.idempresa = CLS.idempresa) LEFT JOIN clientesexpresos CE ON (CE.idexpreso = CLS.idexpreso and CE.idempresa = CLS.idempresa)"
				+ " where CLS.idcliente = '"
				+ idcliente.toString()
				+ "'"
				+ " and CLS.idempresa= "
				+ idempresa.toString()
				+ " and (CLS.idsucursal::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(CLS.nombre_suc) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDetalleDomicilioOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// traigo el total de registros por cliente
	public List getClientesDetalleDomicilioAll(String idcliente, long limit,
			long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CLS.idsucursal,TS.tiposucursal,CLS.nombre_suc,CLS.domici_suc,CLS.telefo_suc,GL.localidad,CV.vendedor,CCO.cobrador,CE.expreso,CLS.usuarioalt,CLS.usuarioact,CLS.fechaalt,CLS.fechaact FROM CLIENTESCLIESUC CLS LEFT JOIN CLIENTESCLIENTES CLI  ON (CLI.idcliente  = CLS.idcliente and CLI.idempresa = CLS.idempresa)LEFT JOIN clientestipossucursales TS  ON (TS.idtiposucursal = CLS.idtiposucursal and TS.idempresa = CLS.idempresa) LEFT JOIN globallocalidades GL  ON (GL.idlocalidad  = CLS.idlocalidad) LEFT JOIN clientesvendedor CV ON (CV.idvendedor = CLS.idvendedor and CV.idempresa = CLS.idempresa) LEFT JOIN clientescobradores CCO ON (CCO.idcobrador = CLS.idcobrador and CCO.idempresa = CLS.idempresa) LEFT JOIN clientesexpresos CE ON (CE.idexpreso = CLS.idexpreso and CE.idempresa = CLS.idempresa)"
				+ " where CLS.idcliente = '"
				+ idcliente.toString()
				+ "'"
				+ " and CLS.idempresa ="
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDetalleDomicilioAll()  "
							+ ex);
		}

		return vecSalida;

	}

	// clientes estados
	public List getClientesestadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idestado,estado,fechasn,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientesestados WHERE idempresa= "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesestadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT  idestado,estado,fechasn,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM clientesestados            " + " WHERE idempresa= "
				+ idempresa.toString() + "     AND (idestado::VARCHAR LIKE '%"
				+ ocurrencia + "%' OR " + "             UPPER(ESTADO) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesestadosPK(BigDecimal idestado, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT  idestado,estado,fechasn,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM clientesestados WHERE idestado="
				+ idestado.toString() + "     AND idempresa="
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosPK( BigDecimal idestado )  "
							+ ex);
		}
		return vecSalida;
	}

	public String getRequiereFechasn(BigDecimal idestado, BigDecimal idempresa)
			throws EJBException {
		String fechasn = "E";
		ResultSet rsSalida = null;
		String cQuery = "SELECT  COALESCE(fechasn, 'E') AS fechasn  FROM CLIENTESESTADOS WHERE idestado="
				+ idestado.toString() + "and idempresa=" + idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {
				if (rsSalida.next()) {
					fechasn = rsSalida.getString("fechasn");
				} else
					log.warn("getRequiereFechasn(): !rsNext ");
			} else
				log.warn("getRequiereFechasn(): rs-Null ");
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getRequiereFechasn( BigDecimal idestado ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getRequiereFechasn( BigDecimal idestado )  "
							+ ex);
		}
		return fechasn;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesestadosDelete(BigDecimal idestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESESTADOS WHERE idestado="
				+ idestado.toString() + "and idempresa=" + idempresa.toString();

		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESESTADOS WHERE idestado="
						+ idestado.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesestadosDelete( BigDecimal idestado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesestadosDelete( BigDecimal idestado )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesestadosCreate(String estado, String fechasn,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Estado ";
		if (fechasn == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechasn ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (fechasn.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fechasn ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESESTADOS(estado, fechasn, usuarioalt,idempresa ) VALUES (?,?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, estado);
				insert.setString(2, fechasn);
				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesestadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesestadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesestadosCreateOrUpdate(BigDecimal idestado,
			String estado, String fechasn, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Estado ";
		if (fechasn == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechasn ";

		// 2. sin nada desde la pagina
		if (fechasn.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fechasn ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestados WHERE idestado = "
					+ idestado.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESESTADOS SET estado=?, fechasn=?, usuarioact=?, fechaact=? WHERE idestado=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setString(2, fechasn);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
					insert.setBigDecimal(6, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESESTADOS(estado, fechasn, usuarioalt,idempresa ) VALUES (?,?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, estado);
					insert.setString(2, fechasn);
					insert.setString(3, usuarioalt);
					insert.setBigDecimal(4, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesestadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesestadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesestadosUpdate(BigDecimal idestado, String estado,
			String fechasn, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: Estado ";
		if (fechasn == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechasn ";

		// 2. sin nada desde la pagina
		if (fechasn.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: fechasn ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestados WHERE idestado = "
					+ idestado.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESESTADOS SET estado=?, fechasn=?, usuarioact=?, fechaact=? WHERE idestado=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setString(2, fechasn);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
					insert.setBigDecimal(6, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesestadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesestadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes motivos
	public List getClientesmotivosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT m.idmotivo,m.motivo,e.idestado, e.estado,m.observaciones,m.usuarioalt,m.usuarioact,"
				+ "       m.fechaalt,m.fechaact "
				+ "  FROM clientesmotivos m "
				+ "       INNER JOIN clientesestados e  ON m.idestado = e.idestado and m.idempresa = e.idempresa"
				+ " WHERE e.idempresa = " + idempresa.toString()
				+ "ORDER BY 3, 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesmotivosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesmotivosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT m.idmotivo,m.motivo,e.idestado, e.estado,m.observaciones,m.usuarioalt,m.usuarioact,"
				+ "       m.fechaalt,m.fechaact "
				+ "  FROM clientesmotivos m "
				+ "       INNER JOIN clientesestados e  ON m.idestado = e.idestado and m.idempresa = e.idempresa"
				+ " WHERE m.idempresa =  " + idempresa.toString()
				+ "   AND (m.idmotivo::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ "       UPPER(m.motivo) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 3, 2  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesmotivosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesmotivosPK(BigDecimal idmotivo, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT m.idmotivo,m.motivo,e.idestado, e.estado,m.observaciones,m.usuarioalt,m.usuarioact,"
				+ "       m.fechaalt,m.fechaact "
				+ "  FROM clientesmotivos m "
				+ "       INNER JOIN clientesestados e  ON m.idestado = e.idestado and m.idempresa = e.idempresa"
				+ " WHERE m.idmotivo=" + idmotivo.toString()
				+ "and m.idempresa=" + idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesmotivosPK( BigDecimal idmotivo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesmotivosDelete(BigDecimal idmotivo,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESMOTIVOS WHERE idmotivo="
				+ idmotivo.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESMOTIVOS WHERE idmotivo="
						+ idmotivo.toString() + "and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesmotivosDelete( BigDecimal idmotivo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesmotivosDelete( BigDecimal idmotivo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesmotivosCreate(String motivo, BigDecimal idestado,
			String observaciones, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESMOTIVOS(motivo, idestado, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, motivo);
				insert.setBigDecimal(2, idestado);
				insert.setString(3, observaciones);
				insert.setString(4, usuarioalt);
				insert.setBigDecimal(5, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesmotivosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesmotivosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesmotivosCreateOrUpdate(BigDecimal idmotivo,
			String motivo, BigDecimal idestado, String observaciones,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivo ";
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";

		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesmotivos WHERE idmotivo = "
					+ idmotivo.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESMOTIVOS SET motivo=?, idestado=?, observaciones=?, usuarioact=?, fechaact=? WHERE idmotivo=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivo);
					insert.setBigDecimal(2, idestado);
					insert.setString(3, observaciones);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivo);
					insert.setBigDecimal(7, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESMOTIVOS(motivo, idestado, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, motivo);
					insert.setBigDecimal(2, idestado);
					insert.setString(3, observaciones);
					insert.setString(4, usuarioalt);
					insert.setBigDecimal(5, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesmotivosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesmotivosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesmotivosUpdate(BigDecimal idmotivo, String motivo,
			BigDecimal idestado, String observaciones, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivo ";
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";

		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesmotivos WHERE idmotivo = "
					+ idmotivo.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESMOTIVOS SET motivo=?, idestado=?, observaciones=?, usuarioact=?, fechaact=? WHERE idmotivo=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivo);
					insert.setBigDecimal(2, idestado);
					insert.setString(3, observaciones);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivo);
					insert.setBigDecimal(7, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesmotivosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesmotivosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov estados
	public List getClientesEstadosLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idestado, estado, usuarioalt, usuarioact, fechaalt, fechaact"
				+ "  FROM  clientesestados WHERE idempresa="
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEstadosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesEstadosLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idestado, estado, usuarioalt, usuarioact, fechaalt, fechaact"
				+ "   FROM  clientesestados" + " WHERE idempresa= "
				+ idempresa.toString() + " AND (idestado::VARCHAR LIKE '%"
				+ ocurrencia + "%' OR " + " UPPER(estado) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEstadosLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// estados clientes
	public List getClientesestadosclientesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,CEC.fechahasta,"
				+ "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,"
				+ "       CEC.fbaja,CEC.observaciones,CEC.usuarioalt,CEC.usuarioact,CEC.fechaalt,CEC.fechaact"
				+ "  FROM CLIENTESESTADOSCLIENTES CEC "
				+ "       INNER JOIN clientesclientes CLI  ON (CEC.idcliente = CLI.idcliente and CEC.idempresa   = CLI.idempresa ) "
				+ "       INNER JOIN clientesestados CE ON (CEC.idestado  = CE.idestado and CEC.idempresa    = CE.idempresa)"
				+ "       INNER JOIN clientesmotivos CM ON (CEC.idmotivo  = CM.idmotivo and CEC.idempresa   = CM.idempresa )"
				+ " WHERE CEC.idempresa= " + idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosclientes()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesestadosclientesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = " "
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,CEC.fechahasta,"
				+ "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,"
				+ "       CEC.fbaja,CEC.observaciones,CEC.usuarioalt,CEC.usuarioact,CEC.fechaalt,CEC.fechaact"
				+ "  FROM CLIENTESESTADOSCLIENTES CEC "
				+ "       INNER JOIN clientesclientes CLI  ON (CEC.idcliente = CLI.idcliente and CEC.idempresa   = CLI.idempresa ) "
				+ "       INNER JOIN clientesestados CE ON (CEC.idestado  = CE.idestado and CEC.idempresa    = CE.idempresa)"
				+ "       INNER JOIN clientesmotivos CM ON (CEC.idmotivo  = CM.idmotivo and CEC.idempresa   = CM.idempresa )"
				+ " WHERE CEC.idempresa= " + idempresa.toString()
				+ "   AND (CEC.idcliente::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(CLI.razon) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosclientesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesestadosclientesPK(BigDecimal idestadocliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.idestado,CE.estado,"
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// " CM.idmotivo,CM.motivo,CEC.fechadesde,CEC.fechahasta,CEC.fbaja,CEC.observaciones,"
				+ " CM.idmotivo,CM.motivo,CEC.fechadesde,CEC.fbaja,CEC.observaciones,"
				+ "       CEC.usuarioalt,CEC.usuarioact,CEC.fechaalt,CEC.fechaact "
				+ "  FROM CLIENTESESTADOSCLIENTES CEC "
				+ "       INNER JOIN clientesclientes CLI  ON (CEC.idcliente   = CLI.idcliente and CEC.idempresa   = CLI.idempresa ) "
				+ "       INNER JOIN clientesestados CE ON (CEC.idestado    = CE.idestado and CEC.idempresa    = CE.idempresa) "
				+ "       INNER JOIN clientesmotivos CM ON (CEC.idmotivo   = CM.idmotivo and CEC.idempresa   = CM.idempresa )"
				+ " WHERE CEC.idestadocliente=" + idestadocliente.toString()
				+ "   AND CEC.idempresa=" + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosclientesPK( BigDecimal idestadocliente )  "
							+ ex);
		}
		return vecSalida;
	}

	public boolean isExisteEstadoPeriodo(BigDecimal idestadocliente,
			BigDecimal idcliente, java.sql.Date fdesde, java.sql.Date fhasta,
			BigDecimal idempresa, Connection conn) throws EJBException {
		boolean existePeriodo = true;
		PreparedStatement pstatement = null;
		ResultSet rs = null;
		String sql = ""
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// "SELECT idestadocliente,idcliente, idestado, fechadesde, fechahasta "
				+ "SELECT idestadocliente,idcliente, idestado, fechadesde "
				+ "  FROM clientesestadosclientes "
				// +
				// " WHERE ( fechadesde::date BETWEEN ? AND  ?  OR fechahasta::date BETWEEN ? AND  ?)"
				+ " WHERE ( fechadesde::date BETWEEN ? AND  ?  )"
				+ "  AND idestadocliente <> ? AND idcliente =?  AND idempresa =?"
				+ "  AND fbaja is null ";
		try {

			pstatement = conn.prepareStatement(sql);
			pstatement.setDate(1, fdesde);
			pstatement.setDate(2, fhasta);
			// pstatement.setDate(3, fdesde);
			// pstatement.setDate(4, fhasta);
			pstatement.setBigDecimal(3, idestadocliente);
			pstatement.setBigDecimal(4, idcliente);
			pstatement.setBigDecimal(5, idempresa);

			rs = pstatement.executeQuery();

			if (rs != null) {
				if (!rs.next())
					existePeriodo = false;
			} else
				log.warn("isExisteEstadoPeriodo[ RS VACIO ]:  " + idcliente
						+ "/" + idempresa);

		} catch (Exception e) {
			// TODO: handle exception
		}

		return existePeriodo;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesestadosclientesDelete(BigDecimal idestadocliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESESTADOSCLIENTES WHERE idestadocliente="
				+ idestadocliente.toString()
				+ "and idempresa="
				+ idempresa.toString();

		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESESTADOSCLIENTES WHERE idestadocliente="
						+ idestadocliente.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesestadosclientesDelete( BigDecimal idestadocliente ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesestadosclientesDelete( BigDecimal idestadocliente )  "
							+ ex);
		}
		return salida;
	}

	public String clientesEstadosClientesSetFBajaPK(BigDecimal idcliente,
			BigDecimal idestadocliente, Timestamp fbaja, String usuarioact,
			BigDecimal idempresa) throws EJBException, SQLException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		BigDecimal idestadoactual = getEstadoActualCliente(idcliente,
				idempresa, dbconn);
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestadocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadocliente ";
		if (fbaja == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fbaja (0)";
		if (idestadoactual.intValue() < 0)
			salida = "No fue posible recuperar y corroborar el estado actual del cliente.";
		if (idestadoactual.intValue() == 6)
			salida = "No es posible actualizar estados del cliente, ya que su estado actual es: INCOBRABLE.";

		// 2. sin nada desde la pagina
		// fin validaciones

		dbconn.setAutoCommit(false);

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestadosclientes WHERE idestadocliente = "
					+ idestadocliente.toString()
					+ " and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESESTADOSCLIENTES SET fbaja=?, usuarioact=?, fechaact=? WHERE idestadocliente=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);

					insert.setTimestamp(1, fbaja);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idestadocliente);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i == 0)
						salida = "Imposible actualizar fecha de baja del estado seleccionado.";

					if (salida.equalsIgnoreCase("OK"))
						salida = setClientesEstadosHoyCliente(idcliente,
								idempresa, dbconn);

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesEstadosClientesSetFBajaPK(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesEstadosClientesSetFBajaPK(.....)"
							+ ex);
		}

		if (salida.equalsIgnoreCase("OK"))
			dbconn.commit();
		else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return salida;
	}

	public String clientesEstadosClientesSetFBajaAFuturo(BigDecimal idcliente,
			Timestamp fbaja, java.sql.Date fechadesde, String usuarioact,
			BigDecimal idempresa, Connection conn) throws EJBException,
			SQLException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		BigDecimal idestadoactual = getEstadoActualCliente(idcliente,
				idempresa, conn);
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fbaja == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fbaja (1) ";
		if (idestadoactual.intValue() < 0)
			salida = "No fue posible recuperar y corroborar el estado actual del cliente.";
		if (idestadoactual.intValue() == 6)
			salida = "No es posible actualizar estados del cliente, ya que su estado actual es: INCOBRABLE.";
		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestadosclientes WHERE idcliente = "
					+ idcliente.toString()
					+ " and idempresa="
					+ idempresa.toString();

			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE clientesestadosclientes SET fbaja=?, usuarioact=?, fechaact=? WHERE idcliente=? AND fechadesde >=? AND idempresa =? "
							// 20111011 - EJV - Mantis 794 -- >
							+ "     AND fbaja IS NULL ;";
					// <--
					insert = conn.prepareStatement(sql);

					insert.setTimestamp(1, fbaja);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idcliente);
					insert.setDate(5, fechadesde);
					insert.setBigDecimal(6, idempresa);
					insert.executeUpdate();

				}

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible actualizar el fecha de baja a futuro.";
			log
					.error("Error SQL public String clientesEstadosClientesSetFBajaAFuturo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible actualizar el fecha de baja a futuro.";
			log
					.error("Error excepcion public String clientesEstadosClientesSetFBajaAFuturo(.....)"
							+ ex);
		}

		// 20090929 - Posible error en transaccion - Mantis 390
		// if (salida.equalsIgnoreCase("OK"))
		// dbconn. commit();
		// else
		// dbconn. rollback();
		//
		// dbconn .setAutoCommit(true);

		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesestadosclientesCreate(BigDecimal idcliente,
			BigDecimal idestado, BigDecimal idmotivo, java.sql.Date fechadesde,
			java.sql.Date fhasta, Timestamp fbaja, String observaciones,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {
		String salida = "OK";

		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		try {

			// <--

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";
			conn.setAutoCommit(false);

			salida = clientesestadosclientesCreate(idcliente, idestado,
					idmotivo, fechadesde, fhasta, fbaja, observaciones,
					usuarioalt, idempresa, conn);

		} catch (Exception e) {
			salida = "(EX)clientesestadosclientesCreate - Sobrecarga: Se produjo un error al cambiar estado de cliente;";
			log.error("(EX)clientesestadosclientesCreate: " + e);

		}

		if (salida.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	public String clientesestadosclientesCreate(BigDecimal idcliente,
			BigDecimal idestado, BigDecimal idmotivo, java.sql.Date fechadesde,
			java.sql.Date fhasta, Timestamp fbaja, String observaciones,
			String usuarioalt, BigDecimal idempresa, Connection conn)
			throws EJBException {
		String salida = "OK";
		BigDecimal idestadoactual = getEstadoActualCliente(idcliente,
				idempresa, conn);
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";

		if (idestadoactual.intValue() < 0)
			salida = "No fue posible recuperar y corroborar el estado actual del cliente.";
		if (idestadoactual.intValue() == 6
				&& gb.isManager(usuarioalt).equalsIgnoreCase("N"))
			salida = "No es posible actualizar estados del cliente, ya que su estado actual es: INCOBRABLE.";

		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (fechadesde != null && fhasta != null) {

			if (isExisteEstadoPeriodo(new BigDecimal(-1), idcliente,
					new java.sql.Date(fechadesde.getTime()), new java.sql.Date(
							fhasta.getTime()), idempresa, conn))
				salida = "Error: Ya existe estado para el rango de fechas seleccionado. ";
		}
		// fin validaciones
		String qDML = "";
		PreparedStatement pstatement = null;
		try {
			if (salida.equalsIgnoreCase("OK")) {

				// String ins =
				// "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, fechahasta, fbaja, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?)";
				qDML = "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, fbaja, observaciones, usuarioalt,idempresa ) VALUES   (?, ?, ?, ?, ?, ?, ?, ?)";
				pstatement = conn.prepareStatement(qDML);
				pstatement.clearParameters();
				// seteo de campos:
				pstatement.setBigDecimal(1, idcliente);
				pstatement.setBigDecimal(2, idestado);
				pstatement.setBigDecimal(3, GeneralBean.setNull(idmotivo, 1));
				pstatement.setDate(4, fechadesde);
				// insert.setDate(5, fhasta);
				pstatement.setTimestamp(5, fbaja);
				pstatement.setString(6, observaciones);
				pstatement.setString(7, usuarioalt);
				pstatement.setBigDecimal(8, idempresa);
				int n = pstatement.executeUpdate();
				if (n != 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesestadosclientesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesestadosclientesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String setEstadoClienteCreate(BigDecimal idestadocliente,
			BigDecimal idcliente, BigDecimal idestado, BigDecimal idmotivo,
			java.sql.Date fechadesde, java.sql.Date fhasta, Timestamp fbaja,
			String observaciones, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {
		String salida = "OK";

		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		try {

			// <--

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";
			conn.setAutoCommit(false);

			salida = setEstadoClienteCreate(idestadocliente, idcliente,
					idestado, idmotivo, fechadesde, fhasta, fbaja,
					observaciones, usuarioalt, idempresa, conn);

		} catch (Exception e) {
			salida = "(EX)setEstadoClienteCreate - Sobrecarga: Se produjo un error al cambiar estado de cliente;";
			log.error("(EX)setEstadoClienteCreate: " + e);

		}

		if (salida.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	public String setEstadoClienteCreate(BigDecimal idestadocliente,
			BigDecimal idcliente, BigDecimal idestado, BigDecimal idmotivo,
			java.sql.Date fechadesde, java.sql.Date fhasta, Timestamp fbaja,
			String observaciones, String usuarioalt, BigDecimal idempresa,
			Connection conn) throws EJBException, SQLException {
		String salida = "OK";
		String fechasn = getRequiereFechasn(idestado, idempresa);
		java.sql.Date freactivacion = null;
		BigDecimal idestadoactivo = new BigDecimal(1);
		BigDecimal idmotivoactivo = new BigDecimal(7);

		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";

		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";

		if (!fechasn.equalsIgnoreCase("N") && !fechasn.equalsIgnoreCase("S")) {
			salida = "Error: estado mal definido o no es posible recuperar atributo fechasn";
		}

		if (fhasta == null && fechasn.equalsIgnoreCase("S"))
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";

		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (fechadesde != null && fhasta != null) {

			if (isExisteEstadoPeriodo(new BigDecimal(-1), idcliente,
					new java.sql.Date(fechadesde.getTime()), new java.sql.Date(
							fhasta.getTime()), idempresa, conn))
				salida = "Error: Ya existe estado para el rango de fechas seleccionado. ";
		}

		// 20110916 - EJV - Mantis 776 -->
		// dbconn.setAutoCommit(false);
		// <--

		try {
			if (salida.equalsIgnoreCase("OK")) {

				if (idestado.intValue() == 4) {

					salida = clientesEstadosClientesSetFBajaAFuturo(idcliente,
							fbaja, fechadesde, usuarioalt, idempresa, conn);

					// EJV - 20090724 TODO: el modelo DELTA a la fecha difiere
					// del existente en BACO. Es necesario analizar este
					// circuito y llegar a una definicion robusta, por lo que se
					// ve en el modelo BACO, hay "parches" varios.
					// El registro que se genera a continuacion es a mero titulo
					// informativo.
					if (salida.equalsIgnoreCase("OK")) {
						BigDecimal idsector = new BigDecimal(1);
						BigDecimal idsubmotivo = new BigDecimal(1);
						BigDecimal idnumerogestion = new BigDecimal(1);
						BigDecimal idresultado = new BigDecimal(1);
						BigDecimal idrellamada = new BigDecimal(1);
						java.sql.Date fecharellamada = null;
						String cerrada = "";
						// EJV - 20090724: No se llego a testear, por eso se
						// comenta.
						// ----------------------------------------------------
						// clientesGestionAutomaticaCreate(idcliente, idsector,
						// idmotivo, idsubmotivo, idnumerogestion,
						// idresultado, observaciones, idrellamada,
						// fecharellamada, cerrada, idempresa, usuarioalt);
					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					salida = clientesestadosclientesCreate(idcliente, idestado,
							idmotivo, fechadesde, fhasta, null, observaciones,
							usuarioalt, idempresa, conn);

					if (salida.equalsIgnoreCase("OK")) {

						if (fechasn.equalsIgnoreCase("S")) {

							freactivacion = fhasta;

							salida = clientesestadosclientesCreate(idcliente,
									idestadoactivo, idmotivoactivo,
									freactivacion, fhasta, null, observaciones,
									usuarioalt, idempresa, conn);

						}

						if (salida.equalsIgnoreCase("OK")) {
							salida = setClientesEstadosHoyCliente(idcliente,
									idempresa, conn);
						}

					}

				}

			}

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible actualizar estsado para el cliente.";
			log.error("Error SQL public String setEstadoCliente(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible actualizar estsado para el cliente.";
			log.error("Error excepcion public String setEstadoCliente(.....)"
					+ ex);
		}
		// 20110916 - EJV - Mantis 776 -->
		// if (salida.equalsIgnoreCase("OK"))
		// dbconn.commit();
		// else
		// dbconn.rollback();
		//
		// dbconn.setAutoCommit(true);
		// <--
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesestadosclientesCreateOrUpdate(
			BigDecimal idestadocliente, BigDecimal idcliente,
			BigDecimal idestado, String idmotivo, java.sql.Date fechadesde,
			java.sql.Date fechahasta, Timestamp fbaja, String observaciones,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestadocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadocliente ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (fbaja == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fbaja (2) ";
		if (isExisteEstadoPeriodo(idestadocliente, idcliente,
				new java.sql.Date(fechadesde.getTime()), new java.sql.Date(
						fechahasta.getTime()), idempresa, dbconn))
			salida = "Error: Ya existe estado para el rango de fechas seleccionado. ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestadosclientes WHERE idestadocliente = "
					+ idestadocliente.toString()
					+ "and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					// 20090722 EJV - Normalizar Estados como VB6BACO
					// sql =
					// "UPDATE CLIENTESESTADOSCLIENTES SET idcliente=?, idestado=?, idmotivo=?, fechadesde=?, fechahasta=?, fbaja=?, observaciones=?, usuarioact=?, fechaact=? WHERE idestadocliente=? and idempresa =?;";
					sql = "UPDATE CLIENTESESTADOSCLIENTES SET idcliente=?, idestado=?, idmotivo=?, fechadesde=?,  fbaja=?, observaciones=?, usuarioact=?, fechaact=? WHERE idestadocliente=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idestado);
					if (idmotivo != null && !idmotivo.equalsIgnoreCase("null")) {
						insert.setBigDecimal(3, new BigDecimal(idmotivo));
					} else {
						insert.setBigDecimal(3, null);
					}
					insert.setDate(4, fechadesde);
					// insert.setDate(5, fechahasta);
					insert.setTimestamp(5, fbaja);
					insert.setString(6, observaciones);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idestadocliente);
					insert.setBigDecimal(10, idempresa);
				} else {
					// String ins =
					// "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, fechahasta, fbaja, observaciones, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?)";
					String ins = "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, fbaja, observaciones, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idestado);
					if (idmotivo != "" && !idmotivo.equalsIgnoreCase("")) {
						insert.setBigDecimal(3, new BigDecimal(idmotivo));
					} else {
						insert.setBigDecimal(3, null);
					}

					insert.setDate(4, fechadesde);
					// insert.setDate(5, fechahasta);
					insert.setTimestamp(5, fbaja);
					insert.setString(6, observaciones);
					insert.setString(7, usuarioalt);
					insert.setBigDecimal(8, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesestadosclientesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesestadosclientesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesestadosclientesUpdate(BigDecimal idestadocliente,
			BigDecimal idcliente, BigDecimal idestado, String idmotivo,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			Timestamp fbaja, String observaciones, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestadocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadocliente ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (isExisteEstadoPeriodo(idestadocliente, idcliente, fechadesde,
				fechahasta, idempresa, dbconn))
			salida = "Error: Ya existe estado para el rango de fechas seleccionado. ";

		// if (fbaja == null)
		// salida = "Error: No se puede dejar sin datos (nulo) el campo: fbaja
		// ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesestadosclientes WHERE idestadocliente = "
					+ idestadocliente.toString()
					+ " and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					// 20090722 EJV - Normalizar Estados como VB6BACO
					// sql =
					// "UPDATE CLIENTESESTADOSCLIENTES SET idcliente=?, idestado=?, idmotivo=?, fechadesde=?, fechahasta=?, fbaja=?, observaciones=?, usuarioact=?, fechaact=? WHERE idestadocliente=? and idempresa =?;";
					sql = "UPDATE CLIENTESESTADOSCLIENTES SET idcliente=?, idestado=?, idmotivo=?, fechahasta=?, fbaja=?, observaciones=?, usuarioact=?, fechaact=? WHERE idestadocliente=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idestado);
					if (idmotivo != null && !idmotivo.equalsIgnoreCase("null")) {
						insert.setBigDecimal(3, new BigDecimal(idmotivo));
					} else {
						insert.setBigDecimal(3, null);
					}
					insert.setDate(4, fechadesde);
					// insert.setDate(5, fechahasta);
					insert.setTimestamp(5, fbaja);
					insert.setString(6, observaciones);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idestadocliente);
					insert.setBigDecimal(10, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesestadosclientesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesestadosclientesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesEstadosHoy Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Jul 21 16:41:04 GYT 2009
	 */

	public String setClientesEstadosHoyCliente(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		// 2. sin nada desde la pagina

		// fin validaciones
		int rows = 0;

		try {
			if (salida.equalsIgnoreCase("OK")) {

				String qDML = "DELETE FROM CLIENTESESTADOSHOY WHERE idcliente=? AND idempresa=?";
				PreparedStatement pstatement = dbconn.prepareStatement(qDML);
				pstatement = conn.prepareStatement(qDML);
				// seteo de campos:
				pstatement.setBigDecimal(1, idcliente);
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();

				qDML = ""
						+ "INSERT INTO clientesestadoshoy "
						+ "       (idestadocliente,idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioalt, fechaalt, fechaact ) "
						+ "SELECT idestadocliente, idcliente, idestado, idmotivo, fechadesde, observaciones, idempresa, usuarioact, fechaalt, fechaact "
						+ "  FROM vclientesestadoshoy_snapshot WHERE idcliente = ? AND idempresa = ?;";
				pstatement = conn.prepareStatement(qDML);
				pstatement.setBigDecimal(1, idcliente);
				pstatement.setBigDecimal(2, idempresa);
				rows = pstatement.executeUpdate();
				if (rows != 1)
					salida = "No se pudo generar estado de clientes actual, es posible que fecha desde del prximo estado sea superior a la del da o que no exista un estado definido.";

			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String setClientesEstadosHoyCliente(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String setClientesEstadosHoyCliente(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * Retorna el codigo de estado actual.
	 */

	public BigDecimal getEstadoActualCliente(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) throws EJBException {
		ResultSet rsSalida = null;
		BigDecimal idestado = new BigDecimal(-1);
		String cQuery = ""
				+ "SELECT idestado FROM clientesestadoshoy WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";

		// log.info("QUERY" + cQuery);

		try {
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null) {
				if (rsSalida.next()) {
					idestado = rsSalida.getBigDecimal(1);
				} else {
					log
							.warn("getEstadoActualCliente(): El cliente no tiene definido un estado actual.");
				}
			} else {
				log
						.warn("getEstadoActualCliente(): Imposible recuperar el estado actual del cliente.");
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getEstadoActualCliente( BigDecimal idestadocliente ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEstadoActualCliente( BigDecimal idestadocliente )  "
							+ ex);
		}
		return idestado;
	}

	/*
	 * Retorna el codigo de estado actual.
	 */

	public BigDecimal getIdestadoclienteActualCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		BigDecimal idestadocliente = new BigDecimal(-1);
		String cQuery = ""
				+ "SELECT idestadocliente FROM clientesestadoshoy WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null) {
				if (rsSalida.next()) {
					idestadocliente = rsSalida.getBigDecimal(1);
				} else {
					log.warn("El cliente no tiene definido un estado actual.");
				}
			} else {
				log
						.warn("Imposible recuperar el identificador unico para el estado actual del cliente.");
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getIdestadoclienteActualCliente( BigDecimal idestadocliente ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getIdestadoclienteActualCliente( BigDecimal idestadocliente )  "
							+ ex);
		}
		return idestadocliente;
	}

	/**
	 * Metodos para la entidad: clientesGestionAutomatica Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Jul 24 11:17:12 GYT 2009
	 */

	public String clientesGestionAutomaticaCreate(BigDecimal idcliente,
			BigDecimal idsector, BigDecimal idmotivo, BigDecimal idsubmotivo,
			BigDecimal idnumerogestion, BigDecimal idresultado,
			String observaciones, BigDecimal idrellamada, Date fecharellamada,
			String cerrada, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idsector == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsector ";
		if (idmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivo ";
		if (idsubmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsubmotivo ";
		if (idnumerogestion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idnumerogestion ";
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO clientesgestionautomatica "
						+ "            (idcliente, idsector, idmotivo, idsubmotivo, idnumerogestion, idresultado, "
						+ "             observaciones, idrellamada, fecharellamada, cerrada, idempresa, usuarioalt )"
						+ "     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idsector);
				insert.setBigDecimal(3, idmotivo);
				insert.setBigDecimal(4, idsubmotivo);
				insert.setBigDecimal(5, idnumerogestion);
				insert.setBigDecimal(6, idresultado);
				insert.setString(7, observaciones);
				insert.setBigDecimal(8, idrellamada);
				insert.setDate(9, fecharellamada);
				insert.setString(10, cerrada);
				insert.setBigDecimal(11, idempresa);
				insert.setString(12, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar inicio de gestin autmatica.";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible generar inicio de gestin autmatica.";
			log
					.error("Error SQL public String clientesGestionAutomaticaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible generar inicio de gestin autmatica.";
			log
					.error("Error excepcion public String clientesGestionAutomaticaCreate(.....)"
							+ ex);
		}

		return salida;
	}

	// lov motivos
	public List getClientesMotivosLovAll(BigDecimal idestado, long limit,
			long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idmotivo, motivo, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientesmotivos where idestado="
				+ idestado.toString()
				+ "and idempresa="
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMotivosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesMotivosLovOcu(BigDecimal idestado, long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT idmotivo, motivo, usuarioalt, usuarioact, fechaalt, fechaact  FROM  clientesmotivos WHERE clientesmotivos.idestado="
				+ idestado.toString()
				+ " and idempresa= "
				+ idempresa.toString()
				+ " and (idmotivo::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(motivo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMotivosLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// pedidos estados
	public List getPedidosestadosAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSESTADOS ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosestados()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosestadosOcu(long limit, long offset, String ocurrencia)
			throws EJBException {

		String cQuery = "SELECT  idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSESTADOS "
				+ " where (idestado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosestadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosestadosPK(BigDecimal idestado) throws EJBException {

		String cQuery = "SELECT  idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM PEDIDOSESTADOS WHERE idestado="
				+ idestado.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosestadosPK( BigDecimal idestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosestadosDelete(BigDecimal idestado) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSESTADOS WHERE idestado="
				+ idestado.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSESTADOS WHERE idestado="
						+ idestado.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosestadosDelete( BigDecimal idestado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosestadosDelete( BigDecimal idestado )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosestadosCreate(String estado, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSESTADOS(estado, usuarioalt ) VALUES (?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, estado);
				insert.setString(2, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String pedidosestadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosestadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosestadosCreateOrUpdate(BigDecimal idestado,
			String estado, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosestados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSESTADOS SET estado=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idestado);
				} else {
					String ins = "INSERT INTO PEDIDOSESTADOS(estado, usuarioalt ) VALUES (?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, estado);
					insert.setString(2, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosestadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosestadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosestadosUpdate(BigDecimal idestado, String estado,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosestados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSESTADOS SET estado=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String pedidosestadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosestadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov estados pedidos
	public List getPedidosEstadosAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM pedidosestados ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEstadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosEstadosOcu(long limit, long offset, String ocurrencia)
			throws EJBException {

		String cQuery = "SELECT  idestado,estado,usuarioalt,usuarioact,fechaalt,fechaact FROM pedidosestados "
				+ " where (idestado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(estado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEstadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vPedidosEstado Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Apr 16 08:42:22 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosEstadoAll(long limit, long offset, String filtro,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa "
				+ "  FROM VPEDIDOSESTADO  " + filtro + " AND  idempresa = "
				+ idempresa.toString() + "  ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosEstadoPreconfAll(long limit, long offset,
			BigDecimal idestado, String tipopedido, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa "
				+ "  FROM VPEDIDOSESTADO WHERE "
				+ (idestado.longValue() > 0 ? " idestado = "
						+ idestado.toString() + " AND " : "") + " idempresa = "
				+ idempresa.toString() + " AND UPPER(tipopedido) = '"
				+ tipopedido.toUpperCase() + "' ORDER BY 1 DESC  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoPreconfAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVPedidosEstadoOcu(long limit, long offset,
			BigDecimal idestado, String tipopedido, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa "
				+ "  FROM VPEDIDOSESTADO WHERE  "
				+ (idestado.longValue() > 0 ? " idestado = "
						+ idestado.toString() + " AND " : "")
				+ "  ( idcliente::VARCHAR  LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(razon)  LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND UPPER(tipopedido) = '" + tipopedido.toUpperCase()
				+ "' AND idempresa = " + idempresa.toString()
				+ " ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosRegalosAdministrarAll(long limit, long offset,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pe.idpedido_cabe, pe.idestado, pe.estado, pe.idcliente, pe.razon, pe.tipopedido, pe.origenpedido, pe.fechapedido, "
				+ "             pd.stockpedido, pd.insumido, pd.disponible, pd.porcentajeinsumido, pd.porcentajedisponible,"
				+ "             pe.fechaalt, pe.usuarioalt, pe.idempresa "
				+ "  FROM vpedidosregalosestado pe  "
				+ "            INNER JOIN vpedidosregalosdisponibilidad pd ON pe.idpedido_cabe = pd.idpedido_regalos_cabe AND pe.idempresa = pd.idempresa "
				+ " WHERE "
				+ (idestado.longValue() > 0 ? " pe.idestado = "
						+ idestado.toString() + " AND " : "")
				+ " pe.idempresa = "
				+ idempresa.toString()
				+ " AND pe.idestado IN (1, 3) AND pe.tipopedido = 'R'   ORDER BY 1 DESC  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosAdministrarAll(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosRegalosAdministrarOcu(long limit, long offset,
			BigDecimal idestado, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pe.idpedido_cabe, pe.idestado, pe.estado, pe.idcliente, pe.razon, pe.tipopedido, pe.origenpedido, pe.fechapedido, "
				+ "             pd.stockpedido, pd.insumido, pd.disponible, pd.porcentajeinsumido, pd.porcentajedisponible,"
				+ "             pe.fechaalt, pe.usuarioalt, pe.idempresa "
				+ "  FROM vpedidosregalosestado pe  "
				+ "            INNER JOIN vpedidosregalosdisponibilidad pd ON pe.idpedido_cabe = pd.idpedido_regalos_cabe AND pe.idempresa = pd.idempresa "
				+ " WHERE "
				+ (idestado.longValue() > 0 ? " pe.idestado = "
						+ idestado.toString() + " AND " : "")
				+ "  ( pe.idcliente::VARCHAR  LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(pe.razon)  LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND pe.tipopedido = 'R' AND pe.idestado IN (1, 3) AND pe.idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosAdministrarOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosEstadoPK(BigDecimal idpedido_cabe,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, fechaalt, usuarioalt, idempresa "
				+ "  FROM vpedidosestado WHERE idpedido_cabe = "
				+ idpedido_cabe.toString() + " AND UPPER(tipopedido) = '"
				+ tipopedido.toUpperCase() + "' AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoPK()  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosRegalosEstadoPK(BigDecimal idpedido_cabe,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, fechaalt, usuarioalt, idempresa "
				+ "  FROM vpedidosregalosestado WHERE idpedido_cabe = "
				+ idpedido_cabe.toString()
				+ " AND UPPER(tipopedido) = 'R' AND idempresa = "
				+ idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosRegalosEstadoPK()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: pedidosPrioridades Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Mar 29 11:25:48 ART 2007
	 * 
	 */
	public List getPedidosPrioridadesAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idprioridad,prioridad,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM PEDIDOSPRIORIDADES ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosPrioridades()  "
							+ ex);
		}
		return vecSalida;
	}

	// pedidos detalle
	// para todo (ordena por el segundo campo por defecto)
	public List getPedidos_detaDetalleAll(String idpedido_cabe, long limit,
			long offset) throws EJBException {

		String cQuery = "select * from vpedidosdeta WHERE idpedido_cabe='"
				+ idpedido_cabe.toString() + "'" + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_detaDetalleAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidos_detaDetalleOcu(String idpedido_cabe, long limit,
			long offset, String ocurrencia) throws EJBException {

		String cQuery = "select * from vpedidosdeta WHERE idpedido_cabe::VARCHAR='"
				+ idpedido_cabe.toString()
				+ "'"
				+ "and UPPER(codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_detaDetalleOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)
	public List getPedidos_detaDetallePK(BigDecimal idpedido_deta)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,precio,saldo,cantidad,bonific,codigo_md,cantuni,"
				+ "       codigo_dt,entrega,usuarioalt,usuarioact,fechaalt,fechaact"
				+ " FROM pedidos_deta WHERE idpedido_deta="
				+ idpedido_deta.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_detaPK( BigDecimal idpedido_deta )  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)
	public List getPedidosDetaXPedido(BigDecimal idpedido_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_deta, pd.idpedido_cabe, pd.codigo_st, pd.fecha, pd.renglon, pd.precio, "
				+ "       pd.saldo, pd.cantidad, pd.bonific, pd.codigo_md, pd.cantuni,"
				+ "       pd.codigo_dt, pd.entrega, COALESCE(st.inventa_st, 'S') AS inventa_st, "
				+ "       pd.usuarioalt, pd.usuarioact, pd.fechaalt, pd.fechaact"
				+ "  FROM pedidos_deta pd "
				+ "        INNER JOIN stockstock st ON pd.codigo_st  = st.codigo_st AND pd.idempresa = st.idempresa "
				+ "WHERE pd.idpedido_cabe=" + idpedido_cabe.toString()
				+ "  AND pd.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosDetaXPedido( BigDecimal idpedido_cabe, idempresa )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidos_detaDetalleDelete(BigDecimal idpedido_deta)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOS_DETA WHERE idpedido_deta="
				+ idpedido_deta.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOS_DETA WHERE idpedido_deta="
						+ idpedido_deta.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidos_detaDelete( BigDecimal idpedido_deta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidos_detaDelete( BigDecimal idpedido_deta )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidos_detaDetalleCreate(BigDecimal idpedido_cabe,
			String codigo_st, Timestamp fecha, BigDecimal renglon,
			Double precio, Double saldo, Double cantidad, Double bonific,
			BigDecimal codigo_md, Double cantuni, BigDecimal codigo_dt,
			String entrega, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (precio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio ";
		if (saldo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: saldo ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (bonific == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bonific ";
		if (codigo_md == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_md ";
		if (cantuni == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantuni ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOS_DETA(idpedido_cabe, codigo_st, fecha, renglon, precio, saldo, cantidad, bonific, codigo_md, cantuni, codigo_dt, entrega, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idpedido_cabe);
				insert.setString(2, codigo_st);
				insert.setTimestamp(3, fecha);
				insert.setBigDecimal(4, renglon);
				insert.setDouble(5, precio.doubleValue());
				insert.setDouble(6, saldo.doubleValue());
				insert.setDouble(7, cantidad.doubleValue());
				insert.setDouble(8, bonific.doubleValue());
				insert.setBigDecimal(9, codigo_md);
				insert.setDouble(10, cantuni.doubleValue());
				insert.setBigDecimal(11, codigo_dt);
				insert.setString(12, entrega);
				insert.setString(13, usuarioalt);
				insert.setBigDecimal(14, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidos_detaDetalleCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidos_detaDetalleCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidos_detaDetalleCreateOrUpdate(BigDecimal idpedido_deta,
			BigDecimal idpedido_cabe, String codigo_st, Timestamp fecha,
			BigDecimal renglon, Double precio, Double saldo, Double cantidad,
			Double bonific, BigDecimal codigo_md, Double cantuni,
			BigDecimal codigo_dt, String entrega, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_deta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_deta ";
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (precio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio ";
		if (saldo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: saldo ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (bonific == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bonific ";
		if (codigo_md == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_md ";
		if (cantuni == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantuni ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_deta WHERE idpedido_deta = "
					+ idpedido_deta.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_DETA SET idpedido_cabe=?, codigo_st=?, fecha=?, renglon=?, precio=?, saldo=?, cantidad=?, bonific=?, codigo_md=?, cantuni=?, codigo_dt=?, entrega=?, usuarioact=?, fechaact=? WHERE idpedido_deta=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idpedido_cabe);
					insert.setString(2, codigo_st);
					insert.setTimestamp(3, fecha);
					insert.setBigDecimal(4, renglon);
					insert.setDouble(5, precio.doubleValue());
					insert.setDouble(6, saldo.doubleValue());
					insert.setDouble(7, cantidad.doubleValue());
					insert.setDouble(8, bonific.doubleValue());
					insert.setBigDecimal(9, codigo_md);
					insert.setDouble(10, cantuni.doubleValue());
					insert.setBigDecimal(11, codigo_dt);
					insert.setString(12, entrega);
					insert.setString(13, usuarioact);
					insert.setTimestamp(14, fechaact);
					insert.setBigDecimal(15, idpedido_deta);
				} else {
					String ins = "INSERT INTO PEDIDOS_DETA(idpedido_cabe, codigo_st, fecha, renglon, precio, saldo, cantidad, bonific, codigo_md, cantuni, codigo_dt, entrega, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idpedido_cabe);
					insert.setString(2, codigo_st);
					insert.setTimestamp(3, fecha);
					insert.setBigDecimal(4, renglon);
					insert.setDouble(5, precio.doubleValue());
					insert.setDouble(6, saldo.doubleValue());
					insert.setDouble(7, cantidad.doubleValue());
					insert.setDouble(8, bonific.doubleValue());
					insert.setBigDecimal(9, codigo_md);
					insert.setDouble(10, cantuni.doubleValue());
					insert.setBigDecimal(11, codigo_dt);
					insert.setString(12, entrega);
					insert.setString(13, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidos_detaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidos_detaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidos_detaDetalleUpdate(BigDecimal idpedido_deta,
			BigDecimal idpedido_cabe, String codigo_st, Timestamp fecha,
			BigDecimal renglon, Double precio, Double saldo, Double cantidad,
			Double bonific, BigDecimal codigo_md, Double cantuni,
			BigDecimal codigo_dt, String entrega, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_deta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_deta ";
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (precio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio ";
		if (saldo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: saldo ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (bonific == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bonific ";
		if (codigo_md == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_md ";
		if (cantuni == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantuni ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_deta WHERE idpedido_deta = "
					+ idpedido_deta.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_DETA SET idpedido_cabe=?, codigo_st=?, fecha=?, renglon=?, precio=?, saldo=?, cantidad=?, bonific=?, codigo_md=?, cantuni=?, codigo_dt=?, entrega=?, usuarioact=?, fechaact=? WHERE idpedido_deta=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idpedido_cabe);
					insert.setString(2, codigo_st);
					insert.setTimestamp(3, fecha);
					insert.setBigDecimal(4, renglon);
					insert.setDouble(5, precio.doubleValue());
					insert.setDouble(6, saldo.doubleValue());
					insert.setDouble(7, cantidad.doubleValue());
					insert.setDouble(8, bonific.doubleValue());
					insert.setBigDecimal(9, codigo_md);
					insert.setDouble(10, cantuni.doubleValue());
					insert.setBigDecimal(11, codigo_dt);
					insert.setString(12, entrega);
					insert.setString(13, usuarioact);
					insert.setTimestamp(14, fechaact);
					insert.setBigDecimal(15, idpedido_deta);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String pedidos_detaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String pedidos_detaUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	// traigo el total por cliente
	public long getPedidos_detaDetalleAllTotal(String idpedido_cabe)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM PEDIDOS_DETA WHERE idpedido_cabe ='"
				+ idpedido_cabe.toString() + "'";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getPedidos_detaDetalleAllTotal()- Error al recuperar total: "
								+ idpedido_cabe);
			}
		} catch (SQLException sqlException) {
			log.error("getPedidos_detaDetalleAllTotal()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPedidos_detaDetalleAllTotal()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	public long getPedidos_detaDetalleOcuTotal(String idpedido_cabe,
			String[] campos, String ocurrencia) throws EJBException {
		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM PEDIDOS_DETA WHERE idpedido_cabe::VARCHAR = '"
				+ idpedido_cabe.toString() + "'";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += " and UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += like;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getPedidos_detaDetalleOcuTotal()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getPedidos_detaDetalleOcuTotal()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPedidos_detaDetalleOcuTotal()- Salida por exception: "
							+ ex);
		}
		return total;
	}

	// replica TM

	/*
	 * 20090330 - EJV
	 * 
	 * public String pedidosTMCreate(BigDecimal idestado, BigDecimal idcliente,
	 * BigDecimal idsucursal, BigDecimal idsucuclie, Timestamp fechapedido,
	 * BigDecimal idcondicion, BigDecimal idvendedor, BigDecimal idexpreso,
	 * BigDecimal comision, String ordencompra, String obseraviones, BigDecimal
	 * recargo1, BigDecimal recargo2, BigDecimal recargo3, BigDecimal recargo4,
	 * BigDecimal bonific1, BigDecimal bonific2, BigDecimal bonific3, BigDecimal
	 * idlista, BigDecimal idmoneda, BigDecimal cotizacion, BigDecimal
	 * idtipoiva, BigDecimal totaliva, BigDecimal idprioridad, Hashtable
	 * htArticulos, String usuarioalt, BigDecimal idempresa) throws
	 * EJBException, SQLException { String salida = "OK"; BigDecimal
	 * idpedido_cabe = null; int renglon = 0; Enumeration en; // validaciones de
	 * datos: // 1. nulidad de campos if (idestado == null) salida = "Error: No
	 * se puede dejar sin datos (nulo) el campo: idestado "; if (idcliente ==
	 * null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * idcliente "; if (fechapedido == null) salida = "Error: No se puede dejar
	 * sin datos (nulo) el campo: fechapedido "; if (idcondicion == null) salida
	 * = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion "; if
	 * (idvendedor == null) salida = "Error: No se puede dejar sin datos (nulo)
	 * el campo: idvendedor "; if (idmoneda == null) salida = "Error: No se
	 * puede dejar sin datos (nulo) el campo: idmoneda "; if (usuarioalt ==
	 * null) salida = "Error: No se puede dejar sin datos (nulo) el campo:
	 * usuarioalt "; // 2. sin nada desde la pagina if
	 * (usuarioalt.equalsIgnoreCase("")) salida = "Error: No se puede dejar
	 * vacio el campo: usuarioalt "; // fin validaciones try { if
	 * (salida.equalsIgnoreCase("OK")) { dbconn.setAutoCommit(fa lse); if
	 * (htArticulos != null && !htArticulos.isEmpty()) {
	 * 
	 * String ins = "" + "INSERT INTO PEDIDOS_CABE(idestado, idcliente,
	 * idsucursal, idsucuclie, fechapedido, " + " idcondicion, idvendedor,
	 * idexpreso, comision, ordencompra, obseraviones, recargo1," + " recargo2,
	 * recargo3, recargo4, bonific1, bonific2, bonific3, idlista, idmoneda,
	 * " + " cotizacion,idtipoiva, totaliva, idprioridad, usuarioalt, idempresa
	 * ) " + "VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
	 * ?, ?, ?, ?, ?, ?)"; PreparedStatement insert =
	 * dbconn.prepareStatement(ins); // seteo de campos: insert.setBigDecimal(1,
	 * idestado); insert.setBigDecimal(2, idcliente); insert.setBigDecimal(3,
	 * idsucursal); insert.setBigDecimal(4, idsucuclie); insert.setTimestamp(5,
	 * fechapedido); insert.setBigDecimal(6, idcondicion);
	 * insert.setBigDecimal(7, idvendedor); insert.setBigDecimal(8, idexpreso);
	 * insert.setBigDecimal(9, comision); insert.setString(10, ordencompra);
	 * insert.setString(11, obseraviones); insert.setBigDecimal(12, recargo1);
	 * insert.setBigDecimal(13, recargo2); insert.setBigDecimal(14, recargo3);
	 * insert.setBigDecimal(15, recargo4); insert.setBigDecimal(16, bonific1);
	 * insert.setBigDecimal(17, bonific2); insert.setBigDecimal(18, bonific3);
	 * insert.setBigDecimal(19, idlista); insert.setBigDecimal(20, idmoneda);
	 * insert.setBigDecimal(21, cotizacion); insert.setBigDecimal(22,
	 * idtipoiva); insert.setBigDecimal(23, totaliva); insert.setBigDecimal(24,
	 * idprioridad); insert.setString(25, usuarioalt); insert.setBigDecimal(26,
	 * idempresa); int n = insert.executeUpdate(); if (n != 1) salida =
	 * "Imposible generar cabecera del pedido."; else { // faltan recuperar
	 * datos // -- recupero el numero de sequence que se corresponde // con el
	 * // pedido. // select currval('seq_pedidos_cabe') idpedido_cabe =
	 * GeneralBean.getValorSequencia( "seq_pedidos_cabe", dbconn); en =
	 * htArticulos.keys();
	 * 
	 * while (en.hasMoreElements()) { String key = (String) en.nextElement();
	 * String[] datosArticulo = (String[]) htArticulos .get(key); String
	 * codigo_st = datosArticulo[0]; BigDecimal cantidad = new BigDecimal(
	 * datosArticulo[10]); BigDecimal codigo_dt = new BigDecimal(
	 * datosArticulo[9]); BigDecimal precio = new BigDecimal(datosArticulo[4]);
	 * BigDecimal importe = new BigDecimal( datosArticulo[11]); BigDecimal
	 * codigo_md = new BigDecimal( datosArticulo[13]); // TODO:PORCENTAJE
	 * BigDecimal PORCENTAJE = new BigDecimal(1);
	 * 
	 * salida = pedidos_DetaCreate(idpedido_cabe, codigo_st, fechapedido, new
	 * BigDecimal( ++renglon), precio, new BigDecimal( 0), cantidad, new
	 * BigDecimal(0), codigo_md, new BigDecimal(0), codigo_dt, "N", PORCENTAJE,
	 * PORCENTAJE, PORCENTAJE, PORCENTAJE, PORCENTAJE, usuarioalt, idempresa);
	 * if (!salida.equalsIgnoreCase("OK")) break; } } } } } catch (SQLException
	 * sqlException) { salida = "Imposible dar de alta el registro.";
	 * log.error("Error SQL public String pedidosTMCreate(.....)" +
	 * sqlException); } catch (Exception ex) { salida = "Imposible dar de alta
	 * el registro."; log.error("Error excepcion public String
	 * pedidosTMCreate(.....)" + ex); } if (!salida.equalsIgnoreCase("OK")) {
	 * dbconn. rollback(); } else { salida = idpedido_cabe.toString(); }
	 * 
	 * dbconn.setAutoCommit(tr ue); return salida; }
	 */

	public List getPedidosPrioridadesTMAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idprioridad,prioridad,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM PEDIDOSPRIORIDADES ORDER BY 1  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosPrioridades()  "
							+ ex);
		}
		return vecSalida;
	}

	// replica SAS
	public String pedidosSASCreate(BigDecimal idestado, BigDecimal idcliente,
			BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idcondicion,
			BigDecimal idvendedor, BigDecimal idexpreso, BigDecimal comision,
			String ordencompra, String obseraviones, BigDecimal recargo1,
			BigDecimal recargo2, BigDecimal recargo3, BigDecimal recargo4,
			BigDecimal bonific1, BigDecimal bonific2, BigDecimal bonific3,
			BigDecimal idlista, BigDecimal idmoneda, BigDecimal cotizacion,
			BigDecimal idtipoiva, BigDecimal totaliva, BigDecimal idprioridad,
			Hashtable htArticulos, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {
		String salida = "OK";
		BigDecimal idpedido_cabe = null;
		int renglon = 0;
		Enumeration en;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fechapedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		// 20120510 -- EJV - Movimientos stock x 2 -->
		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		// dbconn.setAutoCommit(false);

		try {

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);
			// <--

			if (salida.equalsIgnoreCase("OK")) {

				if (htArticulos != null && !htArticulos.isEmpty()) {

					String ins = ""
							+ "INSERT INTO PEDIDOS_CABE(idestado, idcliente, idsucursal, idsucuclie, fechapedido, "
							+ "  idcondicion, idvendedor, idexpreso, comision, ordencompra, obseraviones, recargo1,"
							+ "  recargo2, recargo3, recargo4, bonific1, bonific2, bonific3, idlista, idmoneda, "
							+ "  cotizacion,idtipoiva, totaliva, idprioridad, usuarioalt, idempresa ) "
							+ "VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					PreparedStatement insert = conn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idestado);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idsucursal);
					insert.setBigDecimal(4, idsucuclie);
					insert.setTimestamp(5, fechapedido);
					insert.setBigDecimal(6, idcondicion);
					insert.setBigDecimal(7, idvendedor);
					insert.setBigDecimal(8, idexpreso);
					insert.setBigDecimal(9, comision);
					insert.setString(10, ordencompra);
					insert.setString(11, obseraviones);
					insert.setBigDecimal(12, recargo1);
					insert.setBigDecimal(13, recargo2);
					insert.setBigDecimal(14, recargo3);
					insert.setBigDecimal(15, recargo4);
					insert.setBigDecimal(16, bonific1);
					insert.setBigDecimal(17, bonific2);
					insert.setBigDecimal(18, bonific3);
					insert.setBigDecimal(19, idlista);
					insert.setBigDecimal(20, idmoneda);
					insert.setBigDecimal(21, cotizacion);
					insert.setBigDecimal(22, idtipoiva);
					insert.setBigDecimal(23, totaliva);
					insert.setBigDecimal(24, idprioridad);
					insert.setString(25, usuarioalt);
					insert.setBigDecimal(26, idempresa);
					int n = insert.executeUpdate();
					if (n != 1)
						salida = "Imposible generar cabecera del pedido.";
					else {
						// faltan recuperar datos
						// -- recupero el numero de sequence que se corresponde
						// con el
						// pedido.
						// select currval('seq_pedidos_cabe')
						idpedido_cabe = GeneralBean.getValorSequencia(
								"seq_pedidos_cabe", conn);
						en = htArticulos.keys();

						while (en.hasMoreElements()) {
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulos
									.get(key);
							String codigo_st = datosArticulo[0];
							BigDecimal cantidad = new BigDecimal(
									datosArticulo[10]);
							BigDecimal codigo_dt = new BigDecimal(
									datosArticulo[9]);
							BigDecimal precio = new BigDecimal(datosArticulo[4]);
							BigDecimal importe = new BigDecimal(
									datosArticulo[11]);
							BigDecimal codigo_md = new BigDecimal(
									datosArticulo[13]);

							// TODO: 20090827 - EJV / Campos agregados para que
							// no de error el metodo, falta implementar la carga
							// de estos datos desde donde se esta invocando
							// dicho
							// metodo (pedidosDistribuidoresCreate).
							// BigDecimal tipoiva_st = GeneralBean.setNull(
							// new BigDecimal(datosArticulo[24]), 0);
							// BigDecimal porciva_st = new BigDecimal(
							// datosArticulo[26]);
							// BigDecimal totaliva_st = new BigDecimal(
							// datosArticulo[27]);
							BigDecimal TIPOIVA_ST = null;
							BigDecimal PORCIVA_ST = new BigDecimal(0);
							BigDecimal TOTALIVA_ST = new BigDecimal(0);

							BigDecimal CANTIDAD_SB = new BigDecimal(0);
							BigDecimal COMPROMISO_SB = new BigDecimal(0);

							// TODO:PORCENTAJE
							BigDecimal PORCENTAJE = new BigDecimal(1);
							salida = pedidos_DetaCreate(idpedido_cabe,
									codigo_st, fechapedido, new BigDecimal(
											++renglon), precio, new BigDecimal(
											0), cantidad, new BigDecimal(0),
									codigo_md, new BigDecimal(0), codigo_dt,
									"N", PORCENTAJE, PORCENTAJE, PORCENTAJE,
									PORCENTAJE, PORCENTAJE, TIPOIVA_ST,
									PORCIVA_ST, TOTALIVA_ST, CANTIDAD_SB,
									COMPROMISO_SB, usuarioalt, idempresa, conn);
							if (!salida.equalsIgnoreCase("OK"))
								break;
						}
					}

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String pedidosSASCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String pedidosSASCreate(.....)"
					+ ex);
		}
		if (!salida.equalsIgnoreCase("OK")) {
			conn.rollback();
		} else {
			conn.commit();
			salida = idpedido_cabe.toString();
		}

		// dbconn.setAutoCommit(true);
		conn.close();
		return salida;
	}

	public List getPedidosPrioridadesSASAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idprioridad,prioridad,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM PEDIDOSPRIORIDADES ORDER BY 1  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosPrioridades()  "
							+ ex);
		}
		return vecSalida;
	}

	// replica Distribuidores
	public String pedidosDistribuidoresCreate(BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idcondicion,
			BigDecimal idvendedor, BigDecimal idexpreso, BigDecimal comision,
			String ordencompra, String obseraviones, BigDecimal recargo1,
			BigDecimal recargo2, BigDecimal recargo3, BigDecimal recargo4,
			BigDecimal bonific1, BigDecimal bonific2, BigDecimal bonific3,
			BigDecimal idlista, BigDecimal idmoneda, BigDecimal cotizacion,
			BigDecimal idtipoiva, BigDecimal totaliva, BigDecimal idprioridad,
			Hashtable htArticulos, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {
		String salida = "OK";
		BigDecimal idpedido_cabe = null;
		int renglon = 0;
		Enumeration en;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (fechapedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idcondicion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcondicion ";
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idmoneda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		dbconn.setAutoCommit(false);

		try {
			if (salida.equalsIgnoreCase("OK")) {

				if (htArticulos != null && !htArticulos.isEmpty()) {

					String ins = ""
							+ "INSERT INTO PEDIDOS_CABE(idestado, idcliente, idsucursal, idsucuclie, fechapedido, "
							+ "  idcondicion, idvendedor, idexpreso, comision, ordencompra, obseraviones, recargo1,"
							+ "  recargo2, recargo3, recargo4, bonific1, bonific2, bonific3, idlista, idmoneda, "
							+ "  cotizacion,idtipoiva, totaliva, idprioridad, usuarioalt,idempresa ) "
							+ "VALUES (?,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					PreparedStatement insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idestado);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idsucursal);
					insert.setBigDecimal(4, idsucuclie);
					insert.setTimestamp(5, fechapedido);
					insert.setBigDecimal(6, idcondicion);
					insert.setBigDecimal(7, idvendedor);
					insert.setBigDecimal(8, idexpreso);
					insert.setBigDecimal(9, comision);
					insert.setString(10, ordencompra);
					insert.setString(11, obseraviones);
					insert.setBigDecimal(12, recargo1);
					insert.setBigDecimal(13, recargo2);
					insert.setBigDecimal(14, recargo3);
					insert.setBigDecimal(15, recargo4);
					insert.setBigDecimal(16, bonific1);
					insert.setBigDecimal(17, bonific2);
					insert.setBigDecimal(18, bonific3);
					insert.setBigDecimal(19, idlista);
					insert.setBigDecimal(20, idmoneda);
					insert.setBigDecimal(21, cotizacion);
					insert.setBigDecimal(22, idtipoiva);
					insert.setBigDecimal(23, totaliva);
					insert.setBigDecimal(24, idprioridad);
					insert.setString(25, usuarioalt);
					insert.setBigDecimal(26, idempresa);
					int n = insert.executeUpdate();
					if (n != 1)
						salida = "Imposible generar cabecera del pedido.";
					else {
						// faltan recuperar datos
						// -- recupero el numero de sequence que se corresponde
						// con el
						// pedido.
						// select currval('seq_pedidos_cabe')
						idpedido_cabe = GeneralBean.getValorSequencia(
								"seq_pedidos_cabe", dbconn);
						en = htArticulos.keys();

						while (en.hasMoreElements()) {
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulos
									.get(key);
							String codigo_st = datosArticulo[0];
							BigDecimal cantidad = new BigDecimal(
									datosArticulo[10]);
							BigDecimal codigo_dt = new BigDecimal(
									datosArticulo[9]);
							BigDecimal precio = new BigDecimal(datosArticulo[4]);
							BigDecimal importe = new BigDecimal(
									datosArticulo[11]);
							BigDecimal codigo_md = new BigDecimal(
									datosArticulo[13]);

							// TODO: 20090827 - EJV / Campos agregados para que
							// no de error el metodo, falta implementar la carga
							// de estos datos desde donde se esta invocando
							// dicho
							// metodo (pedidosDistribuidoresCreate).
							// BigDecimal tipoiva_st = GeneralBean.setNull(
							// new BigDecimal(datosArticulo[24]), 0);
							// BigDecimal porciva_st = new BigDecimal(
							// datosArticulo[26]);
							// BigDecimal totaliva_st = new BigDecimal(
							// datosArticulo[27]);
							BigDecimal TIPOIVA_ST = null;
							BigDecimal PORCIVA_ST = new BigDecimal(0);
							BigDecimal TOTALIVA_ST = new BigDecimal(0);

							BigDecimal CANTIDAD_SB = new BigDecimal(0);
							BigDecimal COMPROMISO_SB = new BigDecimal(0);

							// TODO:PORCENTAJE
							BigDecimal PORCENTAJE = new BigDecimal(1);
							salida = pedidos_DetaCreate(idpedido_cabe,
									codigo_st, fechapedido, new BigDecimal(
											++renglon), precio, new BigDecimal(
											0), cantidad, new BigDecimal(0),
									codigo_md, new BigDecimal(0), codigo_dt,
									"N", PORCENTAJE, PORCENTAJE, PORCENTAJE,
									PORCENTAJE, PORCENTAJE, TIPOIVA_ST,
									PORCIVA_ST, TOTALIVA_ST, CANTIDAD_SB,
									COMPROMISO_SB, usuarioalt, idempresa,
									dbconn);
							if (!salida.equalsIgnoreCase("OK"))
								break;

						}
					}

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosDistribuidoresCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosDistribuidoresCreate(.....)"
							+ ex);
		}
		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();
		} else {
			dbconn.commit();
			salida = idpedido_cabe.toString();
		}

		dbconn.setAutoCommit(true);
		return salida;
	}

	public List getPedidosPrioridadesDistribuidoresAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idprioridad,prioridad,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM PEDIDOSPRIORIDADES ORDER BY 1  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosPrioridades()  "
							+ ex);
		}
		return vecSalida;
	}

	// TM campa Cabecera
	public List getBacotmcampacabeAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idcampacabe,campacabe,fdesde,fhasta,descuento,total,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCAMPACABE "
				+ " where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampacabe()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacotmcampacabeOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcampacabe,campacabe,fdesde,fhasta,descuento,total,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCAMPACABE "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcampacabe::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(campacabe) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampacabe(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacotmcampacabePK(BigDecimal idcampacabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcampacabe,campacabe,fdesde,fhasta,descuento,total,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCAMPACABE WHERE idcampacabe="
				+ idcampacabe.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampacabePK( BigDecimal idcampacabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacotmcampacabeDelete(BigDecimal idcampacabe,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMCAMPACABE WHERE idcampacabe = "
				+ idcampacabe.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMCAMPACABE WHERE idcampacabe="
						+ idcampacabe.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacotmcampacabeDelete( BigDecimal idcampacabe ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacotmcampacabeDelete( BigDecimal idcampacabe )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacotmcampacabeCreate(String campacabe, Timestamp fdesde,
			Timestamp fhasta, BigDecimal descuento, BigDecimal total,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (campacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campacabe ";
		if (fdesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fdesde ";
		if (fhasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fhasta ";
		if (descuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descuento ";
		if (total == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (campacabe.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campacabe ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMCAMPACABE(campacabe, fdesde, fhasta, descuento, total, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, campacabe);
				insert.setTimestamp(2, fdesde);
				insert.setTimestamp(3, fhasta);
				insert.setBigDecimal(4, descuento);
				insert.setBigDecimal(5, total);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacotmcampacabeCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmcampacabeCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacotmcampacabeCreateOrUpdate(BigDecimal idcampacabe,
			String campacabe, Timestamp fdesde, Timestamp fhasta,
			BigDecimal descuento, BigDecimal total, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (campacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campacabe ";
		if (fdesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fdesde ";
		if (fhasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fhasta ";
		if (descuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descuento ";
		if (total == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total ";

		// 2. sin nada desde la pagina
		if (campacabe.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campacabe ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmcampacabe WHERE idcampacabe = "
					+ idcampacabe.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total2 = 0;
			if (rsSalida != null && rsSalida.next())
				total2 = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total2 > 0) { // si existe hago update
					sql = "UPDATE BACOTMCAMPACABE SET campacabe=?, fdesde=?, fhasta=?, descuento=?, total=?, usuarioact=?, fechaact=? WHERE idcampacabe=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, campacabe);
					insert.setTimestamp(2, fdesde);
					insert.setTimestamp(3, fhasta);
					insert.setBigDecimal(4, descuento);
					insert.setBigDecimal(5, total);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idcampacabe);
				} else {
					String ins = "INSERT INTO BACOTMCAMPACABE(campacabe, fdesde, fhasta, descuento, total, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, campacabe);
					insert.setTimestamp(2, fdesde);
					insert.setTimestamp(3, fhasta);
					insert.setBigDecimal(4, descuento);
					insert.setBigDecimal(5, total);
					insert.setString(6, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacotmcampacabeCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmcampacabeCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacotmcampacabeUpdate(BigDecimal idcampacabe,
			String campacabe, Timestamp fdesde, Timestamp fhasta,
			BigDecimal descuento, BigDecimal total, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (campacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: campacabe ";
		if (fdesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fdesde ";
		if (fhasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fhasta ";
		if (descuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descuento ";
		if (total == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: total ";

		// 2. sin nada desde la pagina
		if (campacabe.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: campacabe ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmcampacabe WHERE idcampacabe = "
					+ idcampacabe.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total2 = 0;
			if (rsSalida != null && rsSalida.next())
				total2 = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total2 > 0) { // si existe hago update
					sql = "UPDATE BACOTMCAMPACABE SET campacabe=?, fdesde=?, fhasta=?, descuento=?, total=?, usuarioact=?, fechaact=? WHERE idcampacabe=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, campacabe);
					insert.setTimestamp(2, fdesde);
					insert.setTimestamp(3, fhasta);
					insert.setBigDecimal(4, descuento);
					insert.setBigDecimal(5, total);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idcampacabe);
					insert.setBigDecimal(9, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacotmcampacabeUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacotmcampacabeUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// TM campa Detalle
	public List getBacotmcampadetaAll(String idcampacabe, long limit,
			long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = "select * from vcabeceradeta WHERE idcampacabe = '"
				+ idcampacabe.toString() + "'" + " and idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampadetaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacotmcampadetaOcu(String idcampacabe, long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select * from vcabeceradeta WHERE idcampacabe='"
				+ idcampacabe.toString() + "'" + " and idempresa = "
				+ idempresa.toString() + " and (idcampadeta::VARCHAR LIKE '%"
				+ ocurrencia + "%' OR " + " codigo_st LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(descrip_st) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampadeta(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacotmcampadetaPK(BigDecimal idcampadeta,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcampadeta,idcampacabe,codigo_st,observaciones,stock_estimado,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCAMPADETA WHERE idcampadeta="
				+ idcampadeta.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmcampadetaPK( BigDecimal idcampadeta )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacotmcampadetaDelete(BigDecimal idcampadeta,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMCAMPADETA WHERE idcampadeta = "
				+ idcampadeta.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMCAMPADETA WHERE idcampadeta = "
						+ idcampadeta.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacotmcampadetaDelete( BigDecimal idcampadeta ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacotmcampadetaDelete( BigDecimal idcampadeta )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacotmcampadetaCreate(BigDecimal idcampacabe,
			String codigo_st, String observaciones, BigDecimal stock_estimado,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (observaciones == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: observaciones ";
		if (stock_estimado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: stock_estimado ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (observaciones.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: observaciones ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMCAMPADETA(idcampacabe, codigo_st, observaciones, stock_estimado, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcampacabe);
				insert.setString(2, codigo_st);
				insert.setString(3, observaciones);
				insert.setBigDecimal(4, stock_estimado);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacotmcampadetaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmcampadetaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacotmcampadetaCreateOrUpdate(BigDecimal idcampadeta,
			BigDecimal idcampacabe, String codigo_st, String observaciones,
			BigDecimal stock_estimado, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcampadeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampadeta ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (observaciones == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: observaciones ";
		if (stock_estimado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: stock_estimado ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (observaciones.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: observaciones ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmcampadeta WHERE idcampadeta = "
					+ idcampadeta.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCAMPADETA SET idcampacabe=?, codigo_st=?, observaciones=?, stock_estimado=?, usuarioact=?, fechaact=? WHERE idcampadeta=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcampacabe);
					insert.setString(2, codigo_st);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, stock_estimado);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idcampadeta);
					insert.setBigDecimal(8, idempresa);
				} else {
					String ins = "INSERT INTO BACOTMCAMPADETA(idcampacabe, codigo_st, observaciones, stock_estimado, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcampacabe);
					insert.setString(2, codigo_st);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, stock_estimado);
					insert.setString(5, usuarioalt);
					insert.setBigDecimal(6, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacotmcampadetaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmcampadetaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacotmcampadetaUpdate(BigDecimal idcampadeta,
			BigDecimal idcampacabe, String codigo_st, String observaciones,
			BigDecimal stock_estimado, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcampadeta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampadeta ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (observaciones == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: observaciones ";
		if (stock_estimado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: stock_estimado ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (observaciones.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: observaciones ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmcampadeta WHERE idcampadeta = "
					+ idcampadeta.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCAMPADETA SET idcampacabe=?, codigo_st=?, observaciones=?, stock_estimado=?, usuarioact=?, fechaact=? WHERE idcampadeta=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcampacabe);
					insert.setString(2, codigo_st);
					insert.setString(3, observaciones);
					insert.setBigDecimal(4, stock_estimado);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idcampadeta);
					insert.setBigDecimal(8, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacotmcampadetaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacotmcampadetaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// lov articulos
	public List getClientesArticulosLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT codigo_st,descrip_st,id_indi_st, '',usuarioalt,usuarioact,fechaalt,fechaact, "
				+ "     id_indi_st AS serializable " + " FROM stockstock "
				+ " where idempresa = " + idempresa.toString()
				+ " ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesArticulosLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesArticulosLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT  codigo_st,descrip_st,id_indi_st AS serializable,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM stockstock" + " WHERE idempresa = "
				+ idempresa.toString() + " and UPPER(codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase() + "%' OR "
				+ " UPPER(descrip_st) LIKE '%" + ocurrencia.toUpperCase()
				+ "%'" + " ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesArticulosLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getBacotmcampadetaAllTotal(String idcampacabe,
			BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM vcabeceradeta WHERE idcampacabe ='"
				+ idcampacabe.toString()
				+ "'"
				+ " and idempresa = "
				+ idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getBacotmcampadetaAllTotal()- Error al recuperar total: "
								+ idcampacabe);
			}
		} catch (SQLException sqlException) {
			log.error("getBacotmcampadetaAllTotal()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getBacotmcampadetaAllTotal()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	public long getBacotmcampadetaOcuTotal(String idcampacabe, String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM vcabeceradeta WHERE idcampacabe::VARCHAR = '"
				+ idcampacabe.toString() + "'";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += " UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += len > 0 ? " AND (" + like + ")" : "";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getBacotmcampadetaOcuTotal()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getBacotmcampadetaOcuTotal()- Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log.error("getBacotmcampadetaOcuTotal()- Salida por exception: "
					+ ex);
		}
		return total;
	}

	// TM categorias Socios

	public List getTMCategoriasSociosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcategoriasocio,categoriasocio,observaciones,adidesc,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCATEGORIASSOCIOS "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "ORDER BY 4 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTMCategoriasSocios()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getTMCategoriasSociosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcategoriasocio,categoriasocio,observaciones,adidesc,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCATEGORIASSOCIOS "
				+ " WHERE idempresa = " + idempresa.toString()
				+ " and (idcategoriasocio::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(categoriasocio) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 4 DESC LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTMCategoriasSociosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getTMCategoriasSociosPK(BigDecimal idcategoriasocio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcategoriasocio,categoriasocio,observaciones,adidesc,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMCATEGORIASSOCIOS WHERE idcategoriasocio = "
				+ idcategoriasocio.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getTMCategoriasSociosPK( BigDecimal idcategoriasocio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String TMCategoriasSociosDelete(BigDecimal idcategoriasocio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMCATEGORIASSOCIOS WHERE idcategoriasocio = "
				+ idcategoriasocio.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMCATEGORIASSOCIOS WHERE idcategoriasocio = "
						+ idcategoriasocio.toString()
						+ " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : TMCategoriasSociosDelete( BigDecimal idcategoriasocio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: TMCategoriasSociosDelete( BigDecimal idcategoriasocio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String TMCategoriasSociosCreate(String categoriasocio,
			String observaciones, Double adidesc, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (categoriasocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoriasocio ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (categoriasocio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoriasocio ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMCATEGORIASSOCIOS(categoriasocio, observaciones, adidesc,idempresa, usuarioalt ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, categoriasocio);
				insert.setString(2, observaciones);
				insert.setDouble(3, adidesc.doubleValue());
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String TMCategoriasSociosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String TMCategoriasSociosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String TMCategoriasSociosCreateOrUpdate(BigDecimal idcategoriasocio,
			String categoriasocio, String observaciones, Double adidesc,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategoriasocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoriasocio ";
		if (categoriasocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoriasocio ";

		// 2. sin nada desde la pagina
		if (categoriasocio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoriasocio ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM BACOTMCATEGORIASSOCIOS WHERE idcategoriasocio = "
					+ idcategoriasocio.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCATEGORIASSOCIOS SET categoriasocio=?, observaciones=?, adidesc=?, usuarioact=?, fechaact=? WHERE idcategoriasocio=? and idempresa = ?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, categoriasocio);
					insert.setString(2, observaciones);
					insert.setDouble(3, adidesc.doubleValue());
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idcategoriasocio);
				} else {
					String ins = "INSERT INTO BACOTMCATEGORIASSOCIOS(categoriasocio, observaciones, adidesc,idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, categoriasocio);
					insert.setString(2, observaciones);
					insert.setDouble(3, adidesc.doubleValue());
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String TMCategoriasSociosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String TMCategoriasSociosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String TMCategoriasSociosUpdate(BigDecimal idcategoriasocio,
			String categoriasocio, String observaciones, Double adidesc,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategoriasocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoriasocio ";
		if (categoriasocio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoriasocio ";

		// 2. sin nada desde la pagina
		if (categoriasocio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: categoriasocio ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM BACOTMCATEGORIASSOCIOS WHERE idcategoriasocio = "
					+ idcategoriasocio.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCATEGORIASSOCIOS SET categoriasocio=?, observaciones=?, adidesc=?, usuarioact=?, fechaact=? WHERE idcategoriasocio=? and idempresa =? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, categoriasocio);
					insert.setString(2, observaciones);
					insert.setDouble(3, adidesc.doubleValue());
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcategoriasocio);
					insert.setBigDecimal(7, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String TMCategoriasSociosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String TMCategoriasSociosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// TM motivos
	public List getBacoTmMotivosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idmotivo,motivo,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM BACOTMMOTIVOS where idempresa = "
				+ idempresa.toString() + "ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmMotivosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoTmMotivosOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idmotivo,motivo,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMMOTIVOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idmotivo::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(motivo) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmMotivosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoTmMotivosPK(BigDecimal idmotivo, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT  idmotivo,motivo,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMMOTIVOS WHERE idmotivo = "
				+ idmotivo.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmMotivosPK( BigDecimal idmotivo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoTmMotivosDelete(BigDecimal idmotivo, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMMOTIVOS WHERE idmotivo = "
				+ idmotivo.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMMOTIVOS WHERE idmotivo = "
						+ idmotivo.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoTmMotivosDelete( BigDecimal idmotivo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoTmMotivosDelete( BigDecimal idmotivo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoTmMotivosCreate(String motivo, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMMOTIVOS(motivo,idempresa,usuarioalt ) VALUES (?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, motivo);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoTmMotivosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmMotivosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoTmMotivosCreateOrUpdate(BigDecimal idmotivo,
			String motivo, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivo ";
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";

		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmMotivos WHERE idmotivo = "
					+ idmotivo.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMMOTIVOS SET motivo=?, usuarioact=?, fechaact=? WHERE idmotivo=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivo);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idmotivo);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO BACOTMMOTIVOS(motivo,idempresa, usuarioalt ) VALUES (?,?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, motivo);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoTmMotivosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmMotivosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoTmMotivosUpdate(BigDecimal idmotivo, String motivo,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivo ";
		if (motivo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivo ";

		// 2. sin nada desde la pagina
		if (motivo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmMotivos WHERE idmotivo = "
					+ idmotivo.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMMOTIVOS SET motivo=?, usuarioact=?, fechaact=? WHERE idmotivo=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivo);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idmotivo);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoTmMotivosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoTmMotivosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// TM categorizaciones
	public List getBacoTmCategorizacionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT BC.idcategorizacion,CC.idcliente,CC.razon,BS.categoriasocio,BC.fhasta,"
				+ "       BC.usuarioalt,BC.usuarioact,BC.fechaalt,BC.fechaact "
				+ "  FROM BACOTMCATEGORIZACIONES BC LEFT JOIN clientesclientes CC ON BC.idcliente = CC.idcliente AND BC.idempresa = CC.idempresa"
				+ "        LEFT JOIN bacotmcategoriassocios BS  ON BC.idcategoria  = BS.idcategoriasocio AND BC.idempresa = BS.idempresa "
				+ " WHERE BC.idempresa =  " + idempresa.toString()
				+ "ORDER BY 3, 5  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmCategorizacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoTmCategorizacionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT BC.idcategorizacion,CC.idcliente,CC.razon,BS.categoriasocio,BC.fhasta,"
				+ "       BC.usuarioalt,BC.usuarioact,BC.fechaalt,BC.fechaact "
				+ "  FROM BACOTMCATEGORIZACIONES BC LEFT JOIN clientesclientes CC ON BC.idcliente = CC.idcliente AND BC.idempresa = CC.idempresa"
				+ "        LEFT JOIN bacotmcategoriassocios BS  ON BC.idcategoria  = BS.idcategoriasocio AND BC.idempresa = BS.idempresa "
				+ " WHERE BC.idempresa =  " + idempresa.toString()
				+ " and (UPPER(CC.razon) LIKE '%" + ocurrencia.toUpperCase()
				+ "%' OR " + " BC.idcliente::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 3, 5  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmCategorizacionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// TM categorizaciones
	public List getBacoTmCategorizacionesClienteAll(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT BC.idcategorizacion,CC.idcliente,CC.razon,BS.categoriasocio,BC.fhasta,"
				+ "       BC.usuarioalt,BC.usuarioact,BC.fechaalt,BC.fechaact "
				+ "  FROM BACOTMCATEGORIZACIONES BC LEFT JOIN clientesclientes CC ON BC.idcliente = CC.idcliente AND BC.idempresa = CC.idempresa"
				+ "       LEFT JOIN bacotmcategoriassocios BS  ON BC.idcategoria  = BS.idcategoriasocio AND BC.idempresa = BS.idempresa "
				+ " WHERE CC.idcliente = " + idcliente.toString()
				+ "   AND CC.idempresa = " + idempresa.toString()
				+ "ORDER BY 3, 5  ;";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmCategorizacionesClienteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoTmCategorizacionesPK(BigDecimal idcategorizacion,
			BigDecimal idempresa) throws EJBException {

		String cQuery = " "
				+ "SELECT BC.idcategorizacion,BC.idcliente,CC.razon,"
				+ "       BS.idcategoriasocio,BS.categoriasocio,BC.fhasta,"
				+ "       BC.usuarioalt,BC.usuarioact,BC.fechaalt,BC.fechaact "
				+ "  FROM BACOTMCATEGORIZACIONES BC "
				+ "       LEFT JOIN clientesclientes CC ON BC.idcliente = CC.idcliente AND BC.idempresa = CC.idempresa"
				+ "       LEFT JOIN bacotmcategoriassocios BS  ON BC.idcategoria  = BS.idcategoriasocio AND BC.idempresa = BS.idempresa "
				+ " WHERE BC.idcategorizacion = " + idcategorizacion.toString()
				+ " AND BC.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmCategorizacionesPK( BigDecimal idcategorizacion )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getBacoTmCategoriaActualCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = " "
				+ "SELECT BC.idcategorizacion,BC.idcliente,CC.razon,"
				+ "       BS.idcategoriasocio,BS.categoriasocio,BC.fhasta,"
				+ "       BC.usuarioalt,BC.usuarioact,BC.fechaalt,BC.fechaact "
				+ "  FROM BACOTMCATEGORIZACIONES BC "
				+ "       LEFT JOIN clientesclientes CC ON BC.idcliente = CC.idcliente AND BC.idempresa = CC.idempresa"
				+ "       LEFT JOIN bacotmcategoriassocios BS  ON BC.idcategoria  = BS.idcategoriasocio AND BC.idempresa = BS.idempresa "
				+ " WHERE BC.fhasta IS NULL AND BC.idcliente = "
				+ idcliente.toString() + "   AND BC.idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmCategoriaActualCliente( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoTmCategorizacionesDelete(BigDecimal idcategorizacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMCATEGORIZACIONES WHERE idcategorizacion = "
				+ idcategorizacion.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMCATEGORIZACIONES WHERE idcategorizacion = "
						+ idcategorizacion.toString()
						+ " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoTmCategorizacionesDelete( BigDecimal idcategorizacion ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoTmCategorizacionesDelete( BigDecimal idcategorizacion )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoTmCategorizacionesCreate(BigDecimal idcliente,
			BigDecimal idcategoria, Date fhasta, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoria ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {

				salida = bacoTmCategorizacionesUpdateUltima(idcliente,
						usuarioalt, idempresa);

				if (salida.equalsIgnoreCase("OK")) {

					String ins = "INSERT INTO BACOTMCATEGORIZACIONES(idcliente, idcategoria, fhasta, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?)";
					PreparedStatement insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcategoria);
					insert.setDate(3, fhasta);
					insert.setString(4, usuarioalt);
					insert.setBigDecimal(5, idempresa);

					int n = insert.executeUpdate();

					if (n != 1)
						salida = "Imposible generar categorizaciones del cliente.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta categorizacion(1).";
			log
					.error("Error SQL public String bacoTmCategorizacionesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta categorizacion(2).";
			log
					.error("Error excepcion public String bacoTmCategorizacionesCreate(.....)"
							+ ex);
		}

		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoTmCategorizacionesCreateOrUpdate(
			BigDecimal idcategorizacion, BigDecimal idcliente,
			BigDecimal idcategoria, Date fhasta, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategorizacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategorizacion ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoria ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmCategorizaciones WHERE idcategorizacion = "
					+ idcategorizacion.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCATEGORIZACIONES SET idcliente=?, idcategoria=?, fhasta=?, usuarioact=?, fechaact=? WHERE idcategorizacion=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcategoria);
					insert.setDate(3, fhasta);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcategorizacion);
					insert.setBigDecimal(7, idempresa);
				} else {
					String ins = "INSERT INTO BACOTMCATEGORIZACIONES(idcliente, idcategoria, fhasta, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcategoria);
					insert.setDate(3, fhasta);
					insert.setString(4, usuarioalt);
					insert.setBigDecimal(5, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoTmCategorizacionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmCategorizacionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoTmCategorizacionesUpdate(BigDecimal idcategorizacion,
			BigDecimal idcliente, BigDecimal idcategoria, Date fhasta,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcategorizacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategorizacion ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcategoria ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmCategorizaciones WHERE idcategorizacion = "
					+ idcategorizacion.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMCATEGORIZACIONES SET idcliente=?, idcategoria=?, fhasta=?, usuarioact=?, fechaact=? WHERE idcategorizacion=? and idempresa =? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcategoria);
					insert.setDate(3, fhasta);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcategorizacion);
					insert.setBigDecimal(7, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoTmCategorizacionesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoTmCategorizacionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoTmCategorizacionesUpdateUltima(BigDecimal idcliente,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		BigDecimal idcategorizacion = new BigDecimal(-1);
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {

			ResultSet rsSalida = null;
			String cQuery = ""
					+ "SELECT COALESCE(MAX(idcategorizacion), -1) FROM bacoTmCategorizaciones "
					+ " WHERE idcliente = " + idcliente.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next())
				idcategorizacion = rsSalida.getBigDecimal(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (idcategorizacion.longValue() > 0) { // si existe hago update
					sql = "    UPDATE BACOTMCATEGORIZACIONES "
							+ "   SET fhasta=?, usuarioact=?, fechaact=? "
							+ " WHERE idcategorizacion=? and idempresa =? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setDate(1, new java.sql.Date(hoy.getTimeInMillis()));
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idcategorizacion);
					insert.setBigDecimal(5, idempresa);
					int i = insert.executeUpdate();
					if (i != 1)
						salida = "Error en la actualizacin de ltima categorizacin.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoTmCategorizacionesUpdateUltima(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoTmCategorizacionesUpdateUltima(.....)"
							+ ex);
		}
		return salida;
	}

	// lov tm categorizaciones
	public List getClientesCategorizacionesLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idcategoriasocio,categoriasocio,usuarioalt,usuarioact,fechaalt,fechaact FROM bacotmcategoriassocios "
				+ " where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategorizacionesLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesCategorizacionesLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcategoriasocio,categoriasocio,usuarioalt,usuarioact,fechaalt,fechaact FROM bacotmcategoriassocios "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcategoriasocio::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(categoriasocio) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategorizacionesLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// TM resultados
	public List getBacotmresultadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idresultado,resultado,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMRESULTADOS where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmresultadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacotmresultadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idresultado,resultado,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMRESULTADOS "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idresultado::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(resultado) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmresultados(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacotmresultadosPK(BigDecimal idresultado,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idresultado,resultado,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOTMRESULTADOS WHERE idresultado="
				+ idresultado.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacotmresultadosPK( BigDecimal idresultado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacotmresultadosDelete(BigDecimal idresultado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMRESULTADOS WHERE idresultado="
				+ idresultado.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {

				bacoTmResultadosMotivosDelete(idresultado, idempresa);

				cQuery = "DELETE FROM BACOTMRESULTADOS WHERE idresultado="
						+ idresultado.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacotmresultadosDelete( BigDecimal idresultado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacotmresultadosDelete( BigDecimal idresultado )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacotmresultadosCreate(String resultado, String[] idmotivos,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {
		String salida = "OK";
		BigDecimal idresultado = null;
		// validaciones de datos:
		// 1. nulidad de campos
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		dbconn.setAutoCommit(false);

		try {
			if (salida.equalsIgnoreCase("OK")) {

				String ins = "INSERT INTO BACOTMRESULTADOS(resultado,idempresa,usuarioalt ) VALUES (?,?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:

				insert.setString(1, resultado);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();

				if (n == 1) {

					idresultado = GeneralBean.getValorSequencia(
							"seq_bacotmresultados", dbconn);

					if (idresultado == null)
						salida = "Error al recuperar id resultado llamado.";

					if (salida.equalsIgnoreCase("OK")) {

						for (int j = 0; idmotivos != null
								&& j < idmotivos.length; j++) {
							BigDecimal idmotivo = new BigDecimal(idmotivos[j]);
							bacoTmResultadosMotivosCreate(idresultado,
									idmotivo, idempresa, usuarioalt);

						}

					}

				} else
					salida = "Error al crear nuevo resultado de llamado.";

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: Imposible dar de alta resultado llamado.";
			log.error("Error SQL public String bacotmresultadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "EX: Imposible dar de alta resultado llamado.";
			log
					.error("Error excepcion public String bacotmresultadosCreate(.....)"
							+ ex);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
			salida = idresultado + "";
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	public String bacoTmResultadosMotivosCreate(BigDecimal idresultado,
			BigDecimal idmotivo, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina

		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO bacotmresultadosmotivos(idresultado,idmotivo,idempresa,usuarioalt ) VALUES (?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idresultado);
				insert.setBigDecimal(2, idmotivo);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoTmMotivosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmMotivosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoTmResultadosMotivosDelete(BigDecimal idresultado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM bacotmresultadosmotivos WHERE idresultado="
				+ idresultado.toString()
				+ " and idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM bacotmresultadosmotivos WHERE idresultado="
						+ idresultado.toString()
						+ " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
			}

		} catch (SQLException sqlException) {
			salida = "SQL: Error al regenerar resultados-motivos.";
			log
					.error("Error SQL en el metodo : bacoTmResultadosMotivosDelete( BigDecimal idresultado ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: Error al regenerar resultados-motivos.";
			log
					.error("Salida por exception: en el metodo: bacoTmResultadosMotivosDelete( BigDecimal idresultado )  "
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacotmresultadosCreateOrUpdate(BigDecimal idresultado,
			String resultado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmresultados WHERE idresultado = "
					+ idresultado.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMRESULTADOS SET resultado=?, usuarioact=?, fechaact=? WHERE idresultado=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, resultado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idresultado);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO BACOTMRESULTADOS(resultado,idempresa,usuarioalt ) VALUES (?,?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, resultado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacotmresultadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacotmresultadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacotmresultadosUpdate(BigDecimal idresultado,
			String resultado, String[] idmotivos, BigDecimal idempresa,
			String usuarioact) throws EJBException, SQLException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";

		// 2. sin nada desde la pagina
		// fin validaciones

		dbconn.setAutoCommit(false);

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacotmresultados WHERE idresultado = "
					+ idresultado.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMRESULTADOS SET resultado=?, usuarioact=?, fechaact=? WHERE idresultado=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, resultado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idresultado);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "Imposible actualizar el registro.";

					if (salida.equalsIgnoreCase("OK")) {

						salida = bacoTmResultadosMotivosDelete(idresultado,
								idempresa);

						if (salida.equalsIgnoreCase("OK")) {

							for (int j = 0; idmotivos != null
									&& j < idmotivos.length; j++) {
								BigDecimal idmotivo = new BigDecimal(
										idmotivos[j]);
								bacoTmResultadosMotivosCreate(idresultado,
										idmotivo, idempresa, usuarioact);

							}

						}

					}
				}

			} else
				salida = "Resultado de llamdo inexistente.";

		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacotmresultadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacotmresultadosUpdate(.....)"
							+ ex);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
			salida = idresultado + "";
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);
		return salida;
	}

	/**
	 * Motivos Resultados Asociar
	 */

	public List getResultadosMotivosAsociar(BigDecimal idresultado,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (idresultado.longValue() > 0)
			cQuery = ""
					+ "SELECT m.idmotivo, m.motivo, CASE WHEN res.idresultado IS NULL THEN 0 ELSE 1 END AS asociado"
					+ "  FROM bacotmmotivos m "
					+ "       LEFT JOIN ( "
					+ "                  SELECT mr.idresultado, mr.idmotivo, mr.idempresa"
					+ "                     FROM bacotmresultados r "
					+ "                         LEFT JOIN bacotmresultadosmotivos mr "
					+ "                                ON r.idresultado = mr.idresultado "
					+ "                               AND r.idempresa = mr.idempresa "
					+ "                               AND r.idresultado = "
					+ idresultado
					+ "                  ) res ON m.idmotivo = res.idmotivo AND m.idempresa = res.idempresa"
					+ " AND m.idempresa =  " + idempresa.toString()
					+ "ORDER BY 2 ";
		else
			cQuery = "" + "SELECT m.idmotivo, m.motivo, 0 AS asociado"
					+ "  FROM bacotmmotivos m " + " WHERE m.idempresa =  "
					+ idempresa.toString() + "ORDER BY 2 ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getResultadosMotivosAsociar(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getBacoTmResultadosMotivosAll(BigDecimal idempresa)
			throws EJBException {

		String cQuery = "";

		cQuery = ""
				+ "SELECT m.idmotivo, m.motivo, rm.idresultado"
				+ "  FROM bacotmmotivos m "
				+ "       INNER JOIN bacotmresultadosmotivos rm ON m.idmotivo = rm.idmotivo AND m.idempresa = rm.idempresa "
				+ " AND m.idempresa =  " + idempresa.toString()
				+ "ORDER BY 3, 2 ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmResultadosMotivosAll(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientespreciosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idprecio,codigo_st,idlista,precio_pre,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESPRECIOS where idempresa= "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesprecios()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientespreciosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idprecio,codigo_st,idlista,precio_pre,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESPRECIOS WHERE idempresa= "
				+ idempresa.toString()
				+ " and (idprecio::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientespreciosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientespreciosPK(BigDecimal idprecio, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT  idprecio,codigo_st,idlista,precio_pre,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESPRECIOS WHERE idprecio="
				+ idprecio.toString() + "and idempresa=" + idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientespreciosPK( BigDecimal idprecio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientespreciosDelete(BigDecimal idprecio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT * FROM CLIENTESPRECIOS WHERE idprecio="
				+ idprecio.toString() + "and idempresa=" + idempresa.toString();
		ResultSet rsSalida = null;
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESPRECIOS WHERE idprecio="
						+ idprecio.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientespreciosDelete( BigDecimal idprecio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientespreciosDelete( BigDecimal idprecio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientespreciosCreate(String codigo_st, BigDecimal idlista,
			Double precio_pre, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (precio_pre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio_pre ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESPRECIOS(codigo_st, idlista, precio_pre, usuarioalt, idempresa ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, codigo_st);
				insert.setBigDecimal(2, idlista);
				insert.setDouble(3, precio_pre.doubleValue());
				insert.setString(4, usuarioalt);
				insert.setBigDecimal(5, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientespreciosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientespreciosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientespreciosCreateOrUpdate(BigDecimal idprecio,
			String codigo_st, BigDecimal idlista, Double precio_pre,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprecio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecio ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (precio_pre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio_pre ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			ResultSet rsSalida2 = null;
			// String cQuery = "SELECT COUNT(*) FROM clientesprecios WHERE
			// codigo_st = '"
			// + codigo_st.toString()
			// + "' and idlista = " + idlista.toString();;

			String cQuery = "select idprecio as total from clientesprecios where codigo_st = '"
					+ codigo_st.toString()
					+ "' and idlista = "
					+ idlista.toString()
					+ "and idempresa="
					+ idempresa.toString();

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPRECIOS SET codigo_st=?, idlista=?, precio_pre=?, usuarioact=?, fechaact=? WHERE idprecio=? and idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, codigo_st);
					insert.setBigDecimal(2, idlista);
					insert.setDouble(3, precio_pre.doubleValue());
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setInt(6, total);
					insert.setBigDecimal(7, idempresa);
					insert.executeUpdate();
					salida = "Modificacion Correcta.";
					log.error("el valor de idprecio es" + total);
				} else {
					String ins = "INSERT INTO CLIENTESPRECIOS(codigo_st, idlista, precio_pre, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					insert.setString(1, codigo_st);
					insert.setBigDecimal(2, idlista);
					insert.setDouble(3, precio_pre.doubleValue());
					insert.setString(4, usuarioalt);
					insert.setBigDecimal(5, idempresa);
					insert.executeUpdate();
					salida = "Alta Correcta.";
					log.error("el valor de idprecio es" + total);
				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientespreciosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientespreciosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientespreciosUpdate(BigDecimal idprecio, String codigo_st,
			BigDecimal idlista, Double precio_pre, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idprecio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprecio ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (precio_pre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: precio_pre ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesprecios WHERE idprecio = "
					+ idprecio.toString()
					+ "and idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPRECIOS SET codigo_st=?, idlista=?, precio_pre=?, usuarioact=?, fechaact=? WHERE idprecio=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, codigo_st);
					insert.setBigDecimal(2, idlista);
					insert.setDouble(3, precio_pre.doubleValue());
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idprecio);
					insert.setBigDecimal(7, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientespreciosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientespreciosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public BigDecimal getClientesArtLista(String codigo_st, BigDecimal idlista)
			throws EJBException {
		/**
		 * Entidad: Usuarios
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer usuario por ocurrencia.
		 */
		BigDecimal total = BigDecimal.valueOf(0);
		ResultSet rsSalida = null;
		String cQuery = "select idprecio as total from clientesprecios where codigo_st = '"
				+ codigo_st.toString()
				+ "' and idlista = "
				+ idlista.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getBigDecimal("total");
			} else {
				log.warn("getClientesArtLista()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getClientesArtLista()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getClientesArtLista()- Salida por exception: " + ex);
		}
		return total;
	}

	// lov campaas
	public List getClientesCampanaLovAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT idcampacabe,campacabe,fDesde,fHasta FROM bacotmcampacabe ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCampanaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesCampanaLovOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = "SELECT idcampacabe,campacabe,fDesde,fHasta FROM bacotmcampacabe WHERE UPPER(campacabe) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCampanaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// lov resultado
	public List getClientesResultadoLovAll(long limit, long offset)
			throws EJBException {

		String cQuery = "SELECT idresultado,resultado  FROM bacotmresultados ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesResultadoLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesResultadoLovOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = "SELECT idresultado,resultado  FROM bacotmresultados "
				+ " where (idresultado::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(resultado) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesResultadoLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientestipossucursalesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idtiposucursal,tiposucursal,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTIPOSSUCURSALES where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipossucursalesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientestipossucursalesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtiposucursal,tiposucursal,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTIPOSSUCURSALES "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idtiposucursal::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(tiposucursal) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipossucursalesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientestipossucursalesPK(BigDecimal idtiposucursal,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtiposucursal,tiposucursal,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTIPOSSUCURSALES "
				+ " WHERE idtiposucursal = "
				+ idtiposucursal.toString()
				+ " and idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestipossucursalesPK( BigDecimal idtiposucursal )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientestipossucursalesDelete(BigDecimal idtiposucursal,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTIPOSSUCURSALES "
				+ " WHERE idtiposucursal = " + idtiposucursal.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTIPOSSUCURSALES "
						+ " WHERE idtiposucursal = "
						+ idtiposucursal.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientestipossucursalesDelete( BigDecimal idtiposucursal ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientestipossucursalesDelete( BigDecimal idtiposucursal )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientestipossucursalesCreate(String tiposucursal,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tiposucursal ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tiposucursal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tiposucursal ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESTIPOSSUCURSALES(tiposucursal, usuarioalt, idempresa ) VALUES (?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tiposucursal);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestipossucursalesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestipossucursalesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientestipossucursalesCreateOrUpdate(
			BigDecimal idtiposucursal, String tiposucursal, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtiposucursal ";
		if (tiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tiposucursal ";

		// 2. sin nada desde la pagina
		if (tiposucursal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tiposucursal ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestipossucursales "
					+ " WHERE idtiposucursal = " + idtiposucursal.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOSSUCURSALES SET tiposucursal=?, usuarioact=?, fechaact=? WHERE idtiposucursal=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tiposucursal);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idtiposucursal);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESTIPOSSUCURSALES(tiposucursal, usuarioalt,idempresa ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tiposucursal);
					insert.setString(2, usuarioalt);
					insert.setBigDecimal(3, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestipossucursalesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestipossucursalesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientestipossucursalesUpdate(BigDecimal idtiposucursal,
			String tiposucursal, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtiposucursal ";
		if (tiposucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tiposucursal ";

		// 2. sin nada desde la pagina
		if (tiposucursal.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tiposucursal ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestipossucursales "
					+ " WHERE idtiposucursal = " + idtiposucursal.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOSSUCURSALES SET tiposucursal=?, usuarioact=?, fechaact=? WHERE idtiposucursal=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tiposucursal);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idtiposucursal);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientestipossucursalesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientestipossucursalesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientescobradores
	// para todo (ordena por el segundo campo por defecto)
	public List getClientescobradorAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idcobrador,cobrador,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESCOBRADORES where idempresa = "
				+ idempresa.toString()
				+ "ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescobradorAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientescobradorOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcobrador,cobrador,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM CLIENTESCOBRADORES "
				+ " where idempresa= "
				+ idempresa.toString()
				+ " and (idcobrador::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(cobrador) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescobradorOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientescobradorPK(BigDecimal idcobrador,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idcobrador,cobrador,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESCOBRADORES "
				+ " WHERE idcobrador = "
				+ idcobrador.toString()
				+ " and idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientescobradorPK( BigDecimal idcobrador )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientescobradorDelete(BigDecimal idcobrador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESCOBRADORES "
				+ " WHERE idcobrador = " + idcobrador.toString()
				+ " and idempresa = " + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESCOBRADORES WHERE idcobrador = "
						+ idcobrador.toString() + " and idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientescobradorDelete( BigDecimal idcobrador ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientescobradorDelete( BigDecimal idcobrador )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientescobradorCreate(String cobrador, String usuarioalt,
			BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (cobrador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cobrador ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (cobrador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cobrador ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESCOBRADORES(cobrador, usuarioalt, idempresa ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, cobrador);
				insert.setString(2, usuarioalt);
				insert.setBigDecimal(3, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientescobradorCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescobradorCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientescobradorCreateOrUpdate(BigDecimal idcobrador,
			String cobrador, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcobrador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcobrador ";
		if (cobrador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cobrador ";

		// 2. sin nada desde la pagina
		if (cobrador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cobrador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescobradores WHERE idcobrador = "
					+ idcobrador.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCOBRADORES SET cobrador=?, usuarioact=?, fechaact=? WHERE idcobrador=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, cobrador);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idcobrador);
					insert.setBigDecimal(5, idempresa);
				} else {
					String ins = "INSERT INTO CLIENTESCOBRADORES(cobrador, usuarioalt, idempresa ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, cobrador);
					insert.setString(2, usuarioalt);
					insert.setBigDecimal(3, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientescobradorCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientescobradorCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientescobradorUpdate(BigDecimal idcobrador,
			String cobrador, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcobrador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcobrador ";
		if (cobrador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cobrador ";

		// 2. sin nada desde la pagina
		if (cobrador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cobrador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientescobradores WHERE idcobrador = "
					+ idcobrador.toString()
					+ " and idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESCOBRADORES SET cobrador=?, usuarioact=?, fechaact=? WHERE idcobrador=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, cobrador);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idcobrador);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientescobradorUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientescobradorUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesTipoComp Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Jun 14 10:37:09 ART 2007
	 * 
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesTipoCompAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipocomp,tipomov_tc,descri_tc,cuotas_tc,vtacont_tc,st_stok_tc,"
				+ "       st_prec_tc,st_remi_tc,comi_tc,imprime_tc,bonif_tc,mod_mon_tc,ingb_tc,contad_tc,"
				+ "       ctaiva_tc,ctivani_tc,ctgrava_tc,ctexent_tc,ranking_tc,transpo_tc,bon_x_art,"
				+ "       remdesp_tc,mod_con_tc,dere1_tc,reca1_tc,ctare1_tc,recai1_tc,recgr1_tc,dere2_tc,"
				+ "       reca2_tc,ctare2_tc,recai2_tc,recgr2_tc,dere3_tc,reca3_tc,ctare3_tc,recai3_tc,"
				+ "       recgr3_tc,dere4_tc,reca4_tc,ctare4_tc,recai4_tc,recgr4_tc,centr1_tc,centr2_tc,"
				+ "       iva_x_art,jasper_tc,imp_int_tc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESTIPOCOMP WHERE idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoCompAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesTipoCompOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipocomp,tipomov_tc,descri_tc,cuotas_tc,vtacont_tc,st_stok_tc,st_prec_tc,st_remi_tc,"
				+ "       comi_tc,imprime_tc,bonif_tc,mod_mon_tc,ingb_tc,contad_tc,ctaiva_tc,ctivani_tc,ctgrava_tc,"
				+ "       ctexent_tc,ranking_tc,transpo_tc,bon_x_art,remdesp_tc,mod_con_tc,dere1_tc,reca1_tc,"
				+ "       ctare1_tc,recai1_tc,recgr1_tc,dere2_tc,reca2_tc,ctare2_tc,recai2_tc,recgr2_tc,dere3_tc,"
				+ "       reca3_tc,ctare3_tc,recai3_tc,recgr3_tc,dere4_tc,reca4_tc,ctare4_tc,recai4_tc,recgr4_tc,"
				+ "       centr1_tc,centr2_tc,iva_x_art, jasper_tc,imp_int_tc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESTIPOCOMP "
				+ " WHERE (idtipocomp::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(descri_tc) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoCompOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesTipoCompPK(BigDecimal idtipocomp,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipocomp,tipomov_tc,descri_tc,cuotas_tc,vtacont_tc,st_stok_tc,st_prec_tc,st_remi_tc,"
				+ "       comi_tc,imprime_tc,bonif_tc,mod_mon_tc,ingb_tc,contad_tc,ctaiva_tc,ctivani_tc,ctgrava_tc,"
				+ "       ctexent_tc,ranking_tc,transpo_tc,bon_x_art,remdesp_tc,mod_con_tc,dere1_tc,reca1_tc,"
				+ "       ctare1_tc,recai1_tc,recgr1_tc,dere2_tc,reca2_tc,ctare2_tc,recai2_tc,recgr2_tc,dere3_tc,"
				+ "       reca3_tc,ctare3_tc,recai3_tc,recgr3_tc,dere4_tc,reca4_tc,ctare4_tc,recai4_tc,recgr4_tc,"
				+ "       centr1_tc,centr2_tc,iva_x_art, jasper_tc, imp_int_tc, idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESTIPOCOMP " + " WHERE idtipocomp="
				+ idtipocomp.toString() + " AND idempresa = "
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoCompPK( BigDecimal idtipocomp )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesTipoCompDelete(BigDecimal idtipocomp)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTIPOCOMP WHERE idtipocomp="
				+ idtipocomp.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTIPOCOMP WHERE idtipocomp="
						+ idtipocomp.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesTipoCompDelete( BigDecimal idtipocomp ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesTipoCompDelete( BigDecimal idtipocomp )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesTipoCompCreate(BigDecimal tipomov_tc,
			String descri_tc, String cuotas_tc, String vtacont_tc,
			String st_stok_tc, String st_prec_tc, String st_remi_tc,
			String comi_tc, String imprime_tc, BigDecimal bonif_tc,
			String mod_mon_tc, String ingb_tc, BigDecimal contad_tc,
			BigDecimal ctaiva_tc, BigDecimal ctivani_tc, BigDecimal ctgrava_tc,
			BigDecimal ctexent_tc, String ranking_tc, String transpo_tc,
			String bon_x_art, String remdesp_tc, String mod_con_tc,
			String dere1_tc, String reca1_tc, BigDecimal ctare1_tc,
			String recai1_tc, String recgr1_tc, String dere2_tc,
			String reca2_tc, BigDecimal ctare2_tc, String recai2_tc,
			String recgr2_tc, String dere3_tc, String reca3_tc,
			BigDecimal ctare3_tc, String recai3_tc, String recgr3_tc,
			String dere4_tc, String reca4_tc, BigDecimal ctare4_tc,
			String recai4_tc, String recgr4_tc, BigDecimal centr1_tc,
			BigDecimal centr2_tc, String iva_x_art, BigDecimal imp_int_tc,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		// 2. sin nada desde la pagina

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO CLIENTESTIPOCOMP"
						+ "   (tipomov_tc, descri_tc, cuotas_tc, vtacont_tc, st_stok_tc, st_prec_tc, "
						+ "   st_remi_tc, comi_tc, imprime_tc, bonif_tc, mod_mon_tc, ingb_tc, "
						+ "   contad_tc, ctaiva_tc, ctivani_tc, ctgrava_tc, ctexent_tc, ranking_tc, "
						+ "   transpo_tc, bon_x_art, remdesp_tc, mod_con_tc, dere1_tc, reca1_tc, ctare1_tc, "
						+ "   recai1_tc, recgr1_tc, dere2_tc, reca2_tc, ctare2_tc, recai2_tc, recgr2_tc, "
						+ "   dere3_tc, reca3_tc, ctare3_tc, recai3_tc, recgr3_tc, dere4_tc, reca4_tc, "
						+ "   ctare4_tc, recai4_tc, recgr4_tc, centr1_tc, centr2_tc, iva_x_art, imp_int_tc, "
						+ "   idempresa, usuarioalt ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, tipomov_tc);
				insert.setString(2, descri_tc);
				insert.setString(3, cuotas_tc);
				insert.setString(4, vtacont_tc);
				insert.setString(5, st_stok_tc);
				insert.setString(6, st_prec_tc);
				insert.setString(7, st_remi_tc);
				insert.setString(8, comi_tc);
				insert.setString(9, imprime_tc);
				insert.setBigDecimal(10, bonif_tc);
				insert.setString(11, mod_mon_tc);
				insert.setString(12, ingb_tc);
				insert.setBigDecimal(13, contad_tc);
				insert.setBigDecimal(14, ctaiva_tc);
				insert.setBigDecimal(15, ctivani_tc);
				insert.setBigDecimal(16, ctgrava_tc);
				insert.setBigDecimal(17, ctexent_tc);
				insert.setString(18, ranking_tc);
				insert.setString(19, transpo_tc);
				insert.setString(20, bon_x_art);
				insert.setString(21, remdesp_tc);
				insert.setString(22, mod_con_tc);
				insert.setString(23, dere1_tc);
				insert.setString(24, reca1_tc);
				insert.setBigDecimal(25, ctare1_tc);
				insert.setString(26, recai1_tc);
				insert.setString(27, recgr1_tc);
				insert.setString(28, dere2_tc);
				insert.setString(29, reca2_tc);
				insert.setBigDecimal(30, ctare2_tc);
				insert.setString(31, recai2_tc);
				insert.setString(32, recgr2_tc);
				insert.setString(33, dere3_tc);
				insert.setString(34, reca3_tc);
				insert.setBigDecimal(35, ctare3_tc);
				insert.setString(36, recai3_tc);
				insert.setString(37, recgr3_tc);
				insert.setString(38, dere4_tc);
				insert.setString(39, reca4_tc);
				insert.setBigDecimal(40, ctare4_tc);
				insert.setString(41, recai4_tc);
				insert.setString(42, recgr4_tc);
				insert.setBigDecimal(43, centr1_tc);
				insert.setBigDecimal(44, centr2_tc);
				insert.setString(45, iva_x_art);
				insert.setBigDecimal(46, imp_int_tc);
				insert.setBigDecimal(47, idempresa);
				insert.setString(48, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesTipoCompCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesTipoCompCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesTipoCompCreateOrUpdate(BigDecimal idtipocomp,
			BigDecimal tipomov_tc, String descri_tc, String cuotas_tc,
			String vtacont_tc, String st_stok_tc, String st_prec_tc,
			String st_remi_tc, String comi_tc, String imprime_tc,
			BigDecimal bonif_tc, String mod_mon_tc, String ingb_tc,
			BigDecimal contad_tc, BigDecimal ctaiva_tc, BigDecimal ctivani_tc,
			BigDecimal ctgrava_tc, BigDecimal ctexent_tc, String ranking_tc,
			String transpo_tc, String bon_x_art, String remdesp_tc,
			String mod_con_tc, String dere1_tc, String reca1_tc,
			BigDecimal ctare1_tc, String recai1_tc, String recgr1_tc,
			String dere2_tc, String reca2_tc, BigDecimal ctare2_tc,
			String recai2_tc, String recgr2_tc, String dere3_tc,
			String reca3_tc, BigDecimal ctare3_tc, String recai3_tc,
			String recgr3_tc, String dere4_tc, String reca4_tc,
			BigDecimal ctare4_tc, String recai4_tc, String recgr4_tc,
			BigDecimal centr1_tc, BigDecimal centr2_tc, String iva_x_art,
			BigDecimal imp_int_tc, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipocomp == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocomp ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesTipoComp WHERE idtipocomp = "
					+ idtipocomp.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOCOMP SET tipomov_tc=?, descri_tc=?, cuotas_tc=?, vtacont_tc=?, st_stok_tc=?, st_prec_tc=?, st_remi_tc=?, comi_tc=?, imprime_tc=?, bonif_tc=?, mod_mon_tc=?, ingb_tc=?, contad_tc=?, ctaiva_tc=?, ctivani_tc=?, ctgrava_tc=?, ctexent_tc=?, ranking_tc=?, transpo_tc=?, bon_x_art=?, remdesp_tc=?, mod_con_tc=?, dere1_tc=?, reca1_tc=?, ctare1_tc=?, recai1_tc=?, recgr1_tc=?, dere2_tc=?, reca2_tc=?, ctare2_tc=?, recai2_tc=?, recgr2_tc=?, dere3_tc=?, reca3_tc=?, ctare3_tc=?, recai3_tc=?, recgr3_tc=?, dere4_tc=?, reca4_tc=?, ctare4_tc=?, recai4_tc=?, recgr4_tc=?, centr1_tc=?, centr2_tc=?, iva_x_art=?, imp_int_tc, idempresa=?, usuarioact=?, fechaact=? WHERE idtipocomp=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, tipomov_tc);
					insert.setString(2, descri_tc);
					insert.setString(3, cuotas_tc);
					insert.setString(4, vtacont_tc);
					insert.setString(5, st_stok_tc);
					insert.setString(6, st_prec_tc);
					insert.setString(7, st_remi_tc);
					insert.setString(8, comi_tc);
					insert.setString(9, imprime_tc);
					insert.setBigDecimal(10, bonif_tc);
					insert.setString(11, mod_mon_tc);
					insert.setString(12, ingb_tc);
					insert.setBigDecimal(13, contad_tc);
					insert.setBigDecimal(14, ctaiva_tc);
					insert.setBigDecimal(15, ctivani_tc);
					insert.setBigDecimal(16, ctgrava_tc);
					insert.setBigDecimal(17, ctexent_tc);
					insert.setString(18, ranking_tc);
					insert.setString(19, transpo_tc);
					insert.setString(20, bon_x_art);
					insert.setString(21, remdesp_tc);
					insert.setString(22, mod_con_tc);
					insert.setString(23, dere1_tc);
					insert.setString(24, reca1_tc);
					insert.setBigDecimal(25, ctare1_tc);
					insert.setString(26, recai1_tc);
					insert.setString(27, recgr1_tc);
					insert.setString(28, dere2_tc);
					insert.setString(29, reca2_tc);
					insert.setBigDecimal(30, ctare2_tc);
					insert.setString(31, recai2_tc);
					insert.setString(32, recgr2_tc);
					insert.setString(33, dere3_tc);
					insert.setString(34, reca3_tc);
					insert.setBigDecimal(35, ctare3_tc);
					insert.setString(36, recai3_tc);
					insert.setString(37, recgr3_tc);
					insert.setString(38, dere4_tc);
					insert.setString(39, reca4_tc);
					insert.setBigDecimal(40, ctare4_tc);
					insert.setString(41, recai4_tc);
					insert.setString(42, recgr4_tc);
					insert.setBigDecimal(43, centr1_tc);
					insert.setBigDecimal(44, centr2_tc);
					insert.setString(45, iva_x_art);
					insert.setBigDecimal(46, imp_int_tc);
					insert.setBigDecimal(47, idempresa);
					insert.setString(48, usuarioact);
					insert.setTimestamp(49, fechaact);
					insert.setBigDecimal(50, idtipocomp);
				} else {
					String ins = "INSERT INTO CLIENTESTIPOCOMP(tipomov_tc, descri_tc, cuotas_tc, vtacont_tc, st_stok_tc, st_prec_tc, st_remi_tc, comi_tc, imprime_tc, bonif_tc, mod_mon_tc, ingb_tc, contad_tc, ctaiva_tc, ctivani_tc, ctgrava_tc, ctexent_tc, ranking_tc, transpo_tc, bon_x_art, remdesp_tc, mod_con_tc, dere1_tc, reca1_tc, ctare1_tc, recai1_tc, recgr1_tc, dere2_tc, reca2_tc, ctare2_tc, recai2_tc, recgr2_tc, dere3_tc, reca3_tc, ctare3_tc, recai3_tc, recgr3_tc, dere4_tc, reca4_tc, ctare4_tc, recai4_tc, recgr4_tc, centr1_tc, centr2_tc, iva_x_art, imp_int_tc, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, tipomov_tc);
					insert.setString(2, descri_tc);
					insert.setString(3, cuotas_tc);
					insert.setString(4, vtacont_tc);
					insert.setString(5, st_stok_tc);
					insert.setString(6, st_prec_tc);
					insert.setString(7, st_remi_tc);
					insert.setString(8, comi_tc);
					insert.setString(9, imprime_tc);
					insert.setBigDecimal(10, bonif_tc);
					insert.setString(11, mod_mon_tc);
					insert.setString(12, ingb_tc);
					insert.setBigDecimal(13, contad_tc);
					insert.setBigDecimal(14, ctaiva_tc);
					insert.setBigDecimal(15, ctivani_tc);
					insert.setBigDecimal(16, ctgrava_tc);
					insert.setBigDecimal(17, ctexent_tc);
					insert.setString(18, ranking_tc);
					insert.setString(19, transpo_tc);
					insert.setString(20, bon_x_art);
					insert.setString(21, remdesp_tc);
					insert.setString(22, mod_con_tc);
					insert.setString(23, dere1_tc);
					insert.setString(24, reca1_tc);
					insert.setBigDecimal(25, ctare1_tc);
					insert.setString(26, recai1_tc);
					insert.setString(27, recgr1_tc);
					insert.setString(28, dere2_tc);
					insert.setString(29, reca2_tc);
					insert.setBigDecimal(30, ctare2_tc);
					insert.setString(31, recai2_tc);
					insert.setString(32, recgr2_tc);
					insert.setString(33, dere3_tc);
					insert.setString(34, reca3_tc);
					insert.setBigDecimal(35, ctare3_tc);
					insert.setString(36, recai3_tc);
					insert.setString(37, recgr3_tc);
					insert.setString(38, dere4_tc);
					insert.setString(39, reca4_tc);
					insert.setBigDecimal(40, ctare4_tc);
					insert.setString(41, recai4_tc);
					insert.setString(42, recgr4_tc);
					insert.setBigDecimal(43, centr1_tc);
					insert.setBigDecimal(44, centr2_tc);
					insert.setString(45, iva_x_art);
					insert.setBigDecimal(46, imp_int_tc);
					insert.setBigDecimal(47, idempresa);
					insert.setString(48, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesTipoCompCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesTipoCompCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesTipoCompUpdate(BigDecimal idtipocomp,
			BigDecimal tipomov_tc, String descri_tc, String cuotas_tc,
			String vtacont_tc, String st_stok_tc, String st_prec_tc,
			String st_remi_tc, String comi_tc, String imprime_tc,
			BigDecimal bonif_tc, String mod_mon_tc, String ingb_tc,
			BigDecimal contad_tc, BigDecimal ctaiva_tc, BigDecimal ctivani_tc,
			BigDecimal ctgrava_tc, BigDecimal ctexent_tc, String ranking_tc,
			String transpo_tc, String bon_x_art, String remdesp_tc,
			String mod_con_tc, String dere1_tc, String reca1_tc,
			BigDecimal ctare1_tc, String recai1_tc, String recgr1_tc,
			String dere2_tc, String reca2_tc, BigDecimal ctare2_tc,
			String recai2_tc, String recgr2_tc, String dere3_tc,
			String reca3_tc, BigDecimal ctare3_tc, String recai3_tc,
			String recgr3_tc, String dere4_tc, String reca4_tc,
			BigDecimal ctare4_tc, String recai4_tc, String recgr4_tc,
			BigDecimal centr1_tc, BigDecimal centr2_tc, String iva_x_art,
			BigDecimal imp_int_tc, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipocomp == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocomp ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesTipoComp WHERE idtipocomp = "
					+ idtipocomp.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOCOMP SET tipomov_tc=?, descri_tc=?, cuotas_tc=?, vtacont_tc=?, st_stok_tc=?, st_prec_tc=?, st_remi_tc=?, comi_tc=?, imprime_tc=?, bonif_tc=?, mod_mon_tc=?, ingb_tc=?, contad_tc=?, ctaiva_tc=?, ctivani_tc=?, ctgrava_tc=?, ctexent_tc=?, ranking_tc=?, transpo_tc=?, bon_x_art=?, remdesp_tc=?, mod_con_tc=?, dere1_tc=?, reca1_tc=?, ctare1_tc=?, recai1_tc=?, recgr1_tc=?, dere2_tc=?, reca2_tc=?, ctare2_tc=?, recai2_tc=?, recgr2_tc=?, dere3_tc=?, reca3_tc=?, ctare3_tc=?, recai3_tc=?, recgr3_tc=?, dere4_tc=?, reca4_tc=?, ctare4_tc=?, recai4_tc=?, recgr4_tc=?, centr1_tc=?, centr2_tc=?, iva_x_art=?, imp_int_tc=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipocomp=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, tipomov_tc);
					insert.setString(2, descri_tc);
					insert.setString(3, cuotas_tc);
					insert.setString(4, vtacont_tc);
					insert.setString(5, st_stok_tc);
					insert.setString(6, st_prec_tc);
					insert.setString(7, st_remi_tc);
					insert.setString(8, comi_tc);
					insert.setString(9, imprime_tc);
					insert.setBigDecimal(10, bonif_tc);
					insert.setString(11, mod_mon_tc);
					insert.setString(12, ingb_tc);
					insert.setBigDecimal(13, contad_tc);
					insert.setBigDecimal(14, ctaiva_tc);
					insert.setBigDecimal(15, ctivani_tc);
					insert.setBigDecimal(16, ctgrava_tc);
					insert.setBigDecimal(17, ctexent_tc);
					insert.setString(18, ranking_tc);
					insert.setString(19, transpo_tc);
					insert.setString(20, bon_x_art);
					insert.setString(21, remdesp_tc);
					insert.setString(22, mod_con_tc);
					insert.setString(23, dere1_tc);
					insert.setString(24, reca1_tc);
					insert.setBigDecimal(25, ctare1_tc);
					insert.setString(26, recai1_tc);
					insert.setString(27, recgr1_tc);
					insert.setString(28, dere2_tc);
					insert.setString(29, reca2_tc);
					insert.setBigDecimal(30, ctare2_tc);
					insert.setString(31, recai2_tc);
					insert.setString(32, recgr2_tc);
					insert.setString(33, dere3_tc);
					insert.setString(34, reca3_tc);
					insert.setBigDecimal(35, ctare3_tc);
					insert.setString(36, recai3_tc);
					insert.setString(37, recgr3_tc);
					insert.setString(38, dere4_tc);
					insert.setString(39, reca4_tc);
					insert.setBigDecimal(40, ctare4_tc);
					insert.setString(41, recai4_tc);
					insert.setString(42, recgr4_tc);
					insert.setBigDecimal(43, centr1_tc);
					insert.setBigDecimal(44, centr2_tc);
					insert.setString(45, iva_x_art);
					insert.setBigDecimal(46, imp_int_tc);
					insert.setBigDecimal(47, idempresa);
					insert.setString(48, usuarioact);
					insert.setTimestamp(49, fechaact);
					insert.setBigDecimal(50, idtipocomp);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesTipoCompUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesTipoCompUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesAnexov Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Fri Jun 22 15:59:02 ART 2007
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesAnexovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cav.cuit_an,cav.razon_an,iva_an,cav.sucur_an,cav.compr_an,cav.compro_has,cav.postal,cav.loca_an,cav.pcia_an,"
				+ "       cav.tipom_an,cav.inter_an,cav.impor_an,cav.fcha_an,cav.com_venta,cav.com_cobra,cav.com_vende,cav.moneda_an,"
				+ "       cav.cambio_an,cav.form_an,cav.tipmovs_an,cav.anulada,cav.domici_an,cav.expreso_an,cav.idempresa,"
				+ "       gl.localidad,gp.provincia,gm.moneda,cti.tipoiva,ce.expreso,"
				+ "       cav.usuarioalt,cav.usuarioact,cav.fechaalt,cav.fechaact "
				+ "  FROM clientesanexov cav  "
				+ "       INNER JOIN globallocalidades gl ON cav.loca_an = gl.idlocalidad "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia"
				+ "       INNER JOIN clientestablaiva cti ON cav.iva_an = cti.idtipoiva AND cav.idempresa = cti.idempresa"
				+ "       INNER JOIN globalmonedas gm ON cav.moneda_an = gm.idmoneda"
				+ "       LEFT JOIN clientesexpresos ce ON cav.expreso_an = ce.idexpreso AND cav.idempresa = ce.idempresa"
				+ " WHERE cav.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesAnexovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cav.cuit_an,cav.razon_an,iva_an,cav.sucur_an,cav.compr_an,cav.compro_has,cav.postal,cav.loca_an,cav.pcia_an,"
				+ "       cav.tipom_an,cav.inter_an,cav.impor_an,cav.fcha_an,cav.com_venta,cav.com_cobra,cav.com_vende,cav.moneda_an,"
				+ "       cav.cambio_an,cav.form_an,cav.tipmovs_an,cav.anulada,cav.domici_an,cav.expreso_an,cav.idempresa,"
				+ "       gl.localidad,gp.provincia,gm.moneda,cti.tipoiva,ce.expreso,"
				+ "       cav.usuarioalt,cav.usuarioact,cav.fechaalt,cav.fechaact "
				+ "  FROM clientesanexov cav  "
				+ "       INNER JOIN globallocalidades gl ON cav.loca_an = gl.idlocalidad "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia"
				+ "       INNER JOIN clientestablaiva cti ON cav.iva_an = cti.idtipoiva AND cav.idempresa = cti.idempresa "
				+ "       INNER JOIN globalmonedas gm ON cav.moneda_an = gm.idmoneda"
				+ "       LEFT JOIN clientesexpresos ce ON cav.expreso_an = ce.idexpreso AND cav.idempresa = ce.idempresa "
				+ " WHERE (cav.cuit_an LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(cav.razon_an) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND cav.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesAnexovPK(String cuit_an, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT cav.cuit_an,cav.razon_an,iva_an,cav.sucur_an,cav.compr_an,cav.compro_has,cav.postal,cav.loca_an,cav.pcia_an,"
				+ "       cav.tipom_an,cav.inter_an,cav.impor_an,cav.fcha_an,cav.com_venta,cav.com_cobra,cav.com_vende,cav.moneda_an,"
				+ "       cav.cambio_an,cav.form_an,cav.tipmovs_an,cav.anulada,cav.domici_an,cav.expreso_an,cav.idempresa,"
				+ "       gl.localidad,gp.provincia,gm.moneda,cti.tipoiva,ce.expreso,"
				+ "       cav.usuarioalt,cav.usuarioact,cav.fechaalt,cav.fechaact "
				+ "  FROM clientesanexov cav  "
				+ "       INNER JOIN globallocalidades gl ON cav.loca_an = gl.idlocalidad "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia"
				+ "       INNER JOIN clientestablaiva cti ON cav.iva_an = cti.idtipoiva AND cav.idempresa = cti.idempresa "
				+ "       INNER JOIN globalmonedas gm ON cav.moneda_an = gm.idmoneda"
				+ "       LEFT JOIN clientesexpresos ce ON cav.expreso_an = ce.idexpreso AND cav.idempresa = ce.idempresa "
				+ " WHERE cav.cuit_an='" + cuit_an.toString()
				+ "' AND cav.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexovPK( String cuit_an )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesAnexovDelete(String cuit_an) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESANEXOV WHERE cuit_an="
				+ cuit_an.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESANEXOV WHERE cuit_an="
						+ cuit_an.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesAnexovDelete( String cuit_an ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesAnexovDelete( String cuit_an )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesAnexovCreate(String cuit_an, String razon_an,
			BigDecimal iva_an, BigDecimal sucur_an, BigDecimal compr_an,
			BigDecimal compro_has, String postal, BigDecimal loca_an,
			BigDecimal pcia_an, BigDecimal tipom_an, BigDecimal inter_an,
			Double impor_an, Timestamp fcha_an, Double com_venta,
			Double com_cobra, BigDecimal com_vende, BigDecimal moneda_an,
			Double cambio_an, String form_an, String tipmovs_an,
			String anulada, String domici_an, BigDecimal expreso_an,
			// 20110621 - EJV - Factuaracion FE-CF-MA -->
			String condicionletra,
			// <--
			BigDecimal idempresa, String usuarioalt,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ " INSERT INTO CLIENTESANEXOV "
						+ "(cuit_an, razon_an, iva_an, sucur_an, compr_an, compro_has, postal, loca_an, pcia_an, tipom_an,"
						+ " inter_an, impor_an, fcha_an, com_venta, com_cobra, com_vende, moneda_an, cambio_an, "
						+ " form_an, tipmovs_an, anulada, domici_an, expreso_an, letraiva,idempresa, usuarioalt ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, cuit_an);
				insert.setString(2, razon_an);
				insert.setBigDecimal(3, iva_an);
				insert.setBigDecimal(4, sucur_an);
				insert.setBigDecimal(5, compr_an);
				insert.setBigDecimal(6, compro_has);
				insert.setString(7, postal);
				insert.setBigDecimal(8, loca_an);
				insert.setBigDecimal(9, pcia_an);
				insert.setBigDecimal(10, tipom_an);
				insert.setBigDecimal(11, inter_an);
				insert.setDouble(12, impor_an.doubleValue());
				insert.setTimestamp(13, fcha_an);
				insert.setDouble(14, com_venta.doubleValue());
				insert.setDouble(15, com_cobra.doubleValue());
				insert.setBigDecimal(16, com_vende);
				insert.setBigDecimal(17, moneda_an);
				insert.setDouble(18, cambio_an.doubleValue());
				insert.setString(19, form_an);
				insert.setString(20, tipmovs_an);
				insert.setString(21, anulada);
				insert.setString(22, domici_an);
				insert.setBigDecimal(23, expreso_an);
				// 20110621 - EJV - Factuaracion FE-CF-MA -->
				insert.setString(24, condicionletra);
				// <--
				insert.setBigDecimal(25, idempresa);
				insert.setString(26, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar datos de anexo de ventas.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesAnexovCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesAnexovCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesAnexovCreateOrUpdate(String cuit_an, String razon_an,
			BigDecimal iva_an, BigDecimal sucur_an, BigDecimal compr_an,
			BigDecimal compro_has, String postal, BigDecimal loca_an,
			BigDecimal pcia_an, BigDecimal tipom_an, BigDecimal inter_an,
			Double impor_an, Timestamp fcha_an, Double com_venta,
			Double com_cobra, BigDecimal com_vende, BigDecimal moneda_an,
			Double cambio_an, String form_an, String tipmovs_an,
			String anulada, String domici_an, BigDecimal expreso_an,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesAnexov WHERE cuit_an = "
					+ cuit_an.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESANEXOV SET razon_an=?, iva_an=?, sucur_an=?, compr_an=?, compro_has=?, postal=?, loca_an=?, pcia_an=?, tipom_an=?, inter_an=?, impor_an=?, fcha_an=?, com_venta=?, com_cobra=?, com_vende=?, moneda_an=?, cambio_an=?, form_an=?, tipmovs_an=?, anulada=?, domici_an=?, expreso_an=?, idempresa=?, usuarioact=?, fechaact=? WHERE cuit_an=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon_an);
					insert.setBigDecimal(2, iva_an);
					insert.setBigDecimal(3, sucur_an);
					insert.setBigDecimal(4, compr_an);
					insert.setBigDecimal(5, compro_has);
					insert.setString(6, postal);
					insert.setBigDecimal(7, loca_an);
					insert.setBigDecimal(8, pcia_an);
					insert.setBigDecimal(9, tipom_an);
					insert.setBigDecimal(10, inter_an);
					insert.setDouble(11, impor_an.doubleValue());
					insert.setTimestamp(12, fcha_an);
					insert.setDouble(13, com_venta.doubleValue());
					insert.setDouble(14, com_cobra.doubleValue());
					insert.setBigDecimal(15, com_vende);
					insert.setBigDecimal(16, moneda_an);
					insert.setDouble(17, cambio_an.doubleValue());
					insert.setString(18, form_an);
					insert.setString(19, tipmovs_an);
					insert.setString(20, anulada);
					insert.setString(21, domici_an);
					insert.setBigDecimal(22, expreso_an);
					insert.setBigDecimal(23, idempresa);
					insert.setString(24, usuarioact);
					insert.setTimestamp(25, fechaact);
					insert.setString(26, cuit_an);
				} else {
					String ins = "INSERT INTO CLIENTESANEXOV(razon_an, iva_an, sucur_an, compr_an, compro_has, postal, loca_an, pcia_an, tipom_an, inter_an, impor_an, fcha_an, com_venta, com_cobra, com_vende, moneda_an, cambio_an, form_an, tipmovs_an, anulada, domici_an, expreso_an, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, razon_an);
					insert.setBigDecimal(2, iva_an);
					insert.setBigDecimal(3, sucur_an);
					insert.setBigDecimal(4, compr_an);
					insert.setBigDecimal(5, compro_has);
					insert.setString(6, postal);
					insert.setBigDecimal(7, loca_an);
					insert.setBigDecimal(8, pcia_an);
					insert.setBigDecimal(9, tipom_an);
					insert.setBigDecimal(10, inter_an);
					insert.setDouble(11, impor_an.doubleValue());
					insert.setTimestamp(12, fcha_an);
					insert.setDouble(13, com_venta.doubleValue());
					insert.setDouble(14, com_cobra.doubleValue());
					insert.setBigDecimal(15, com_vende);
					insert.setBigDecimal(16, moneda_an);
					insert.setDouble(17, cambio_an.doubleValue());
					insert.setString(18, form_an);
					insert.setString(19, tipmovs_an);
					insert.setString(20, anulada);
					insert.setString(21, domici_an);
					insert.setBigDecimal(22, expreso_an);
					insert.setBigDecimal(23, idempresa);
					insert.setString(24, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesAnexovCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesAnexovCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesAnexovUpdate(String cuit_an, String razon_an,
			BigDecimal iva_an, BigDecimal sucur_an, BigDecimal compr_an,
			BigDecimal compro_has, String postal, BigDecimal loca_an,
			BigDecimal pcia_an, BigDecimal tipom_an, BigDecimal inter_an,
			Double impor_an, Timestamp fcha_an, Double com_venta,
			Double com_cobra, BigDecimal com_vende, BigDecimal moneda_an,
			Double cambio_an, String form_an, String tipmovs_an,
			String anulada, String domici_an, BigDecimal expreso_an,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesAnexov WHERE cuit_an = "
					+ cuit_an.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESANEXOV SET razon_an=?, iva_an=?, sucur_an=?, compr_an=?, compro_has=?, postal=?, loca_an=?, pcia_an=?, tipom_an=?, inter_an=?, impor_an=?, fcha_an=?, com_venta=?, com_cobra=?, com_vende=?, moneda_an=?, cambio_an=?, form_an=?, tipmovs_an=?, anulada=?, domici_an=?, expreso_an=?, idempresa=?, usuarioact=?, fechaact=? WHERE cuit_an=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, razon_an);
					insert.setBigDecimal(2, iva_an);
					insert.setBigDecimal(3, sucur_an);
					insert.setBigDecimal(4, compr_an);
					insert.setBigDecimal(5, compro_has);
					insert.setString(6, postal);
					insert.setBigDecimal(7, loca_an);
					insert.setBigDecimal(8, pcia_an);
					insert.setBigDecimal(9, tipom_an);
					insert.setBigDecimal(10, inter_an);
					insert.setDouble(11, impor_an.doubleValue());
					insert.setTimestamp(12, fcha_an);
					insert.setDouble(13, com_venta.doubleValue());
					insert.setDouble(14, com_cobra.doubleValue());
					insert.setBigDecimal(15, com_vende);
					insert.setBigDecimal(16, moneda_an);
					insert.setDouble(17, cambio_an.doubleValue());
					insert.setString(18, form_an);
					insert.setString(19, tipmovs_an);
					insert.setString(20, anulada);
					insert.setString(21, domici_an);
					insert.setBigDecimal(22, expreso_an);
					insert.setBigDecimal(23, idempresa);
					insert.setString(24, usuarioact);
					insert.setTimestamp(25, fechaact);
					insert.setString(26, cuit_an);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesAnexovUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesAnexovUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesMovCli Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Wed Dec 13 10:54:31 GMT-03:00 2006
	 */
	// 20110909 - EJV - Mantis 777 REPLICADO EN GENERAL ORIGINAL CLIENTES
	public boolean isExisteComprobanteMovCli(BigDecimal sucursal,
			BigDecimal comprob, String tipomovs, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsExiste = null;
		boolean existe = false;
		String cQuery = " " + " SELECT 1 FROM clientesmovcli  WHERE sucursal="
				+ sucursal + " AND comprob=" + comprob + " AND tipomovs='"
				+ tipomovs + "' AND idempresa=" + idempresa.toString()
				+ " UNION SELECT 1 FROM clientesanexov WHERE sucur_an="
				+ sucursal + " AND compr_an=" + comprob + " AND tipmovs_an='"
				+ tipomovs + "' AND idempresa=" + idempresa.toString();

		try {
			Statement statement = dbconn.createStatement();
			rsExiste = statement.executeQuery(cQuery);
			if (rsExiste.next()) {
				existe = true;
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : isExisteComprobanteMovCli( BigDecimal sucursal ...) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isExisteComprobanteMovCli( BigDecimal sucursal ...)  "
							+ ex);
		}
		return existe;
	}

	/**
	 * TODO: FACTIBLE DE PASAR A LA CLASE COMMON !!! Metodos para la entidad:
	 * globalTipoMovimientos Copyrigth(r) sysWarp S.R.L. Fecha de creacion: Thu
	 * Aug 09 17:08:30 ART 2007
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalTipoMovimientosAll(long limit, long offset)
			throws EJBException {

		String cQuery = ""
				+ "SELECT tipomov,siglatipomov,desctipomov,observaciones,usuarioalt,usuarioact,fechaalt,fechaact "
				+ " FROM GLOBALTIPOMOVIMIENTOS ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTipoMovimientosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalTipoMovimientosOcu(long limit, long offset,
			String ocurrencia) throws EJBException {

		String cQuery = ""
				+ "SELECT tipomov,siglatipomov,desctipomov,observaciones,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALTIPOMOVIMIENTOS WHERE (UPPER(SIGLATIPOMOV) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTipoMovimientosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalTipoMovimientosPK(BigDecimal tipomov)
			throws EJBException {

		String cQuery = ""
				+ "SELECT tipomov, siglatipomov, desctipomov, observaciones, usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM GLOBALTIPOMOVIMIENTOS WHERE tipomov="
				+ tipomov.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTipoMovimientosPK( BigDecimal tipomov )  "
							+ ex);
		}
		return vecSalida;
	}

	public String getGTMSigla(BigDecimal tipomov) throws EJBException {
		ResultSet rsSalida = null;
		String sigla = "";
		String cQuery = "" + "SELECT siglatipomov "
				+ "  FROM GLOBALTIPOMOVIMIENTOS WHERE tipomov="
				+ tipomov.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next()) {
				sigla = rsSalida.getString(1);
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getGTMSigla( BigDecimal tipomov ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGTMSigla( BigDecimal tipomov )  "
							+ ex);
		}
		return sigla;
	}

	/**
	 * =======================================================================
	 * =======================================================================
	 * INICIO ................................................................
	 * EJV ...................................................................
	 * 20070822 ..............................................................
	 * INGRESO DE MOVIMIENTOS DE CLIENTES VERSION PREELIMINAR ................
	 * Soloamente se contempla documentos que no mueven STOCK, o que lo hacen.
	 * descontando del mismo. ................................................
	 * =======================================================================
	 * =======================================================================
	 * =======================================================================
	 * =======================================================================
	 */

	public String clientesMovimientoClienteCreate(
			BigDecimal idcliente,
			String cuit_an,
			String razon_an,
			String domici_an,
			BigDecimal loca_an,
			BigDecimal pcia_an,
			String postal,
			BigDecimal iva_an,
			Timestamp fechamov,
			BigDecimal sucursal,
			BigDecimal comprob,
			BigDecimal comprob_has,
			BigDecimal tipomov,
			String tipomovs,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			String condicionletra,
			// <--
			BigDecimal saldo, BigDecimal importe, BigDecimal cambio,
			BigDecimal moneda, String unamode, String tipocomp,
			BigDecimal condicion, BigDecimal nrointerno, BigDecimal com_venta,
			BigDecimal com_cobra,
			BigDecimal com_vende,
			String anulada,
			BigDecimal retoque,
			BigDecimal expreso,
			BigDecimal sucucli,
			BigDecimal remito,
			BigDecimal credito,
			int ejercicioactivo,
			String observaciones,
			// 20110628 - EJV - Factuaracion FE-CF-MA -->
			BigDecimal por_per,
			// <--
			// 20110930 - EJV - mantis 771 -->
			BigDecimal idtarjeta,
			int cuotas,
			BigDecimal idclub,
			// <--
			// 20121005 - EJV - Mantis 882 -->
			BigDecimal idmotivonc,
			// <--
			Hashtable htCuentasContCli, Hashtable htArticulos,
			Hashtable htIdentificadoresIngresos, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {

		String salida = "OK";
		BigDecimal nrointernomovcliente = null;
		BigDecimal nrointernomovclientecobranza = null;
		BigDecimal nrocobranza = null;
		BigDecimal nroint_mt = null;
		Enumeration en;
		String keyenum = "";

		/*
		 * INICIA VARIABLES STOCK
		 */

		BigDecimal comprob_ms = BigDecimal.valueOf(-1);
		BigDecimal nrointerno_ms = BigDecimal.valueOf(-1);
		// Enumeration en;
		String tipomov_ms = "S"; // TODO
		String sistema_ms = "C"; // TODO
		BigDecimal cuencom_st = new BigDecimal(0);
		BigDecimal cuencos_st = new BigDecimal(0);
		BigDecimal importe_cs = new BigDecimal(0);
		String tipo_cs = "H";
		String sistema_cs = "C";
		BigDecimal centr1_cs = new BigDecimal(0);
		BigDecimal centr2_cs = new BigDecimal(0);

		// BigDecimal totalDebe = new BigDecimal(0);
		// BigDecimal totalHaber = new BigDecimal(0);

		// 20070604 EJV Lineas detalle por Remito.
		int maxLineasXremito = 0;
		int indice = 0;
		Hashtable htArticulosImagen = htArticulos;
		Hashtable htArticulosPaginados = null;
		String[] resultado = new String[2];
		// 20110617 - EJV - Factuaracion FE-CF-MA -->
		Connection conn = null;
		// <--

		//

		/*
		 * FINALIZA VARIABLES STOCK
		 */

		try {

			// 20110617 - EJV - Factuaracion FE-CF-MA -->

			conn = GeneralBean.getTransaccionConn(this.clase, this.url,
					this.usuario, this.clave);
			// <--

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			GeneralBean.setLockedTable("cajasucursalescontadores",
					"ACCESS EXCLUSIVE", conn);

			if (salida.equalsIgnoreCase("OK")) {// 0.0

				comprob = GeneralBean.getCajaSucursalesContadoresProximo(
						sucursal, condicionletra, tipomov, idempresa, conn);
				if (comprob.longValue() > -1) {// 0.1

					if (!isExisteComprobanteMovCli(sucursal, comprob, tipomovs,
							idempresa)) {// 0.2
						// <--

						nrointernomovcliente = GeneralBean.getContador(
								new BigDecimal(8), idempresa, conn);
						if (nrointernomovcliente.longValue() > -1) {// A

							if (idcliente != null && idcliente.longValue() > 0) {// A.0

								// CLIENTE
								salida = clientesMovCliCreate(idcliente,
										fechamov, sucursal, comprob,
										comprob_has, tipomov, tipomovs, saldo,
										importe, cambio, moneda, unamode,
										tipocomp, condicion,
										nrointernomovcliente, com_venta,
										com_cobra, com_vende, anulada, retoque,
										expreso, sucucli, remito, credito,
										observaciones, condicionletra,
										// 20121005 - EJV - Mantis 882 -->
										idmotivonc,
										// <--
										usuarioalt, idempresa, conn);
							} else {
								// ANEXO

								salida = clientesAnexovCreate(cuit_an,
										razon_an, iva_an, sucucli, comprob,
										null, postal, loca_an, pcia_an,
										tipomov, nrointernomovcliente,
										new Double(importe.doubleValue()),
										fechamov, new Double(0), new Double(0),
										null, new BigDecimal(1), new Double(1),
										null, tipomovs, null, domici_an, null,
										// 20110621 - EJV - Factuaracion
										// FE-CF-MA -->
										condicionletra,
										// <--
										idempresa, usuarioalt, conn);

							}// A.0

							// 20120903 - EJV - Mantis 883 -->
							if (tipomov.intValue() < 3) {

								// 20110930 - EJV - Mantis 771 -->

								if (idtarjeta.longValue() > 0
										&& importe.signum() == 1) {
									// 

									if (cuotas < 1) {
										salida = "Valor de cuota invalido.";
									} else {
										// <--
										BigDecimal import_cuo = importe.divide(
												new BigDecimal(cuotas), 6,
												BigDecimal.ROUND_HALF_UP);

										BigDecimal totalCuotas = import_cuo
												.multiply(new BigDecimal(cuotas));

										Calendar cal = new GregorianCalendar();
										cal.setTime(fechamov);
										java.sql.Date venci_cuo = new java.sql.Date(
												cal.getTimeInMillis());
										int periodo_cuo = 0;
										for (int c = 1; c <= cuotas; c++) {

											if (c == cuotas) {
												import_cuo = import_cuo
														.add(importe
																.subtract(totalCuotas));
											}

											periodo_cuo = Integer
													.parseInt(cal
															.get(Calendar.YEAR)
															+ GeneralBean
																	.strZero(
																			""
																					+ (cal
																							.get(Calendar.MONTH) + 1),
																			2));

											// CUOTAS
											salida = clientesMovcuotaCreate(
													new BigDecimal(c),
													nrointernomovcliente,
													import_cuo, venci_cuo,
													import_cuo, condicion,
													idtarjeta, periodo_cuo,
													null, null, idclub,
													idempresa, usuarioalt, conn);

											if (!salida.equalsIgnoreCase("OK"))
												break;

											cal.add(Calendar.MONTH, 1);
											venci_cuo = new java.sql.Date(cal
													.getTimeInMillis());

										}
									}
								}

								// <--
							}

							// <--

							log.info("ANTES DE IC ");

							if (salida.equalsIgnoreCase("OK")) {// B
								log.info("INICIA IC ");
								en = htCuentasContCli.keys();

								while (en.hasMoreElements()) {// B.0

									log.info("RECORRE DE IC ");
									keyenum = en.nextElement().toString();
									String[] datos = (String[]) htCuentasContCli
											.get(keyenum);

									if (Double.parseDouble(datos[1]) > 0) {

										log.info("VALOR MAYOR A CERO DE IC ");

										if (!GeneralBean.isExisteCtaImputable(
												new BigDecimal(datos[0]),
												ejercicioactivo, idempresa,
												conn)) {
											salida = "La cuenta : "
													+ datos[0]
													+ " no existe o no es imputable. ["
													+ keyenum + "]";

										} else
											log.info("CUENTA CORRECTA:  "
													+ datos[0] + " -  * -"
													+ datos[1]);

										if (!salida.equalsIgnoreCase("OK"))
											break;

										BigDecimal porcentaje_percepcion = new BigDecimal(
												0);
										if (keyenum.equalsIgnoreCase("PIB"))
											porcentaje_percepcion = por_per;

										salida = clientesContCliCreate(
												new BigDecimal(datos[0]),
												new BigDecimal(datos[1]),
												keyenum, nrointernomovcliente,
												null, null,
												porcentaje_percepcion,
												usuarioalt, idempresa, conn);

									} else
										log.info(" IC VALE CERO:  " + datos[0]
												+ " -  * -" + datos[1]);

									if (!salida.equalsIgnoreCase("OK"))
										break;

								}// B.0

								// INICIA ACTUALIZACION STOCK - SOLO SALIDA
								if (salida.equalsIgnoreCase("OK")) {// C

									// 20070604 EJV Lineas detalle por Remito.
									try {
										maxLineasXremito = Integer
												.parseInt(GeneralBean
														.getValorSetupVariables(
																"maxLineasXremito",
																idempresa, conn));
									} catch (Exception e) {
										salida = "Imposible recuperar lineas detalle remito.";
										log.error("maxLineasXremito: " + e);
									}
									//

									if (htArticulos != null
											&& !htArticulos.isEmpty()) {// D

										while (salida.equalsIgnoreCase("OK")) {// E

											comprob_ms = BigDecimal.valueOf(-1);
											nrointerno_ms = BigDecimal
													.valueOf(-1);
											tipomov_ms = "S"; // TODO
											sistema_ms = "C"; // TODO
											cuencom_st = new BigDecimal(0);
											cuencos_st = new BigDecimal(0);
											importe_cs = new BigDecimal(0);
											tipo_cs = "H";
											sistema_cs = "C";
											centr1_cs = new BigDecimal(0);
											centr2_cs = new BigDecimal(0);
											// totalDebe = new BigDecimal(0);
											// totalHaber = new BigDecimal(0);

											indice = 0;
											htArticulosPaginados = new Hashtable();
											Enumeration enu = htArticulosImagen
													.keys();
											while (enu.hasMoreElements()
													&& indice < maxLineasXremito) {
												Object elemento = enu
														.nextElement();
												htArticulosPaginados.put(
														elemento,
														htArticulosImagen
																.get(elemento));
												htArticulosImagen
														.remove(elemento);
												indice++;
											}

											if (htArticulosPaginados.isEmpty())
												break;
											en = htArticulosPaginados.keys();
											/*
								 * */

											// 20070604 EJV Lineas detalle por
											// Remito.
											// 20061101 - nrointerno_ms permite
											// duplicados
											nrointerno_ms = GeneralBean
													.getContador(
															new BigDecimal(5),
															idempresa, conn);
											// comprob_ms = nrointerno_ms;
											comprob_ms = nrointernomovcliente;

											// TODO: ESTE METODO NO ES NECESARIO
											// ??
											// salida = stockAnexosCreate

											if (salida.equalsIgnoreCase("OK")) {// F

												Hashtable listaMS = new Hashtable();
												Hashtable listaSCS = new Hashtable();

												while (en.hasMoreElements()) {// G

													String key = (String) en
															.nextElement();
													String[] datosArticulo = (String[]) htArticulosPaginados
															.get(key);
													String articulo = datosArticulo[0];
													BigDecimal cantArtMov = new BigDecimal(
															datosArticulo[10]);
													BigDecimal origen = new BigDecimal(
															datosArticulo[9]);
													BigDecimal costo = new BigDecimal(
															datosArticulo[4]);

													importe_cs = new BigDecimal(
															datosArticulo[11]);
													cuencom_st = new BigDecimal(
															datosArticulo[12] == null ? "-1"
																	: datosArticulo[12]);
													cuencos_st = new BigDecimal(
															datosArticulo[16] == null ? "-1"
																	: datosArticulo[16]);

													if ((GeneralBean
															.getCantidadArticuloDeposito(
																	articulo,
																	origen,
																	idempresa,
																	conn)
															.compareTo(cantArtMov)) < 0
															&& !GeneralBean
																	.hasStockNegativo(
																			idempresa,
																			conn)) {
														salida = "Existencia de articulo "
																+ articulo
																+ " insuficiente en deposito "
																+ origen + ".";
														break;
													}

													// CONTSTOCK INICIA
													// ==================
													if (!GeneralBean
															.isExisteCtaImputable(
																	cuencom_st,
																	ejercicioactivo,
																	idempresa,
																	conn)) {
														salida = "La cuenta comercial: "
																+ cuencom_st
																+ ", asociada al articulo: "
																+ articulo
																+ " no existe o no es imputable. ";
														break;
													}

													tipo_cs = "H";
													if (!listaSCS
															.containsKey(cuencom_st
																	+ tipo_cs)) {
														salida = stockContStockCreate(
																nrointerno_ms,
																cuencom_st,
																importe_cs,
																tipo_cs,
																sistema_cs,
																centr1_cs,
																centr2_cs,
																usuarioalt,
																idempresa, conn);
													} else {
														salida = stockContStockImporteUpdate(
																nrointerno_ms,
																cuencom_st,
																importe_cs,
																tipo_cs,
																idempresa, conn);
													}

													if (!salida
															.equalsIgnoreCase("OK"))
														break;
													listaSCS.put(cuencom_st
															+ tipo_cs, "");

													if (!GeneralBean
															.isExisteCtaImputable(
																	cuencos_st,
																	ejercicioactivo,
																	idempresa,
																	conn)) {
														salida = "La cuenta de costo:"
																+ cuencom_st
																+ ", asociada al articulo: "
																+ articulo
																+ " no existe o no es imputable.";
														break;
													}

													tipo_cs = "D";
													if (!listaSCS
															.containsKey(cuencos_st
																	+ tipo_cs)) {
														salida = stockContStockCreate(
																nrointerno_ms,
																cuencom_st,
																importe_cs,
																tipo_cs,
																sistema_cs,
																centr1_cs,
																centr2_cs,
																usuarioalt,
																idempresa, conn);
													} else {
														salida = stockContStockImporteUpdate(
																nrointerno_ms,
																cuencos_st,
																importe_cs,
																tipo_cs,
																idempresa, conn);
													}

													if (!salida
															.equalsIgnoreCase("OK"))
														break;
													listaSCS.put(cuencom_st
															+ tipo_cs, "");
													// CONTSTOCK FINALIZA
													// ==================

													// INICIA ACTUALIZACION DE
													// STOCK
													// =============================

													BigDecimal remito_ms = new BigDecimal(
															0);
													if (!listaMS
															.containsKey(articulo)) {
														salida = stockMovStockCreate(
																nrointerno_ms,
																sistema_ms,
																tipomov_ms,
																comprob_ms,
																fechamov,
																articulo,
																cantArtMov,
																new BigDecimal(
																		"1"),
																new Double("1"),
																new Double("0"),
																costo,
																sistema_cs,
																"",
																new Double("0"),
																remito_ms,
																new Double("0"),
																new Double("0"),
																new Double("0"),
																new Double("0"),
																new BigDecimal(
																		"0"),
																new Double("0"),
																new Double("0"),
																new BigDecimal(
																		"0"),
																observaciones,
																usuarioalt,
																idempresa, conn);
													} else {

														salida = stockMovStockCantidadUpdate(
																nrointerno_ms,
																articulo,
																cantArtMov,
																idempresa, conn);
													}

													if (!salida
															.equalsIgnoreCase("OK"))
														break;

													salida = stockStockBisUpdate(
															articulo,
															origen,
															cantArtMov.negate(),
															"",
															"",
															new BigDecimal("0"),
															usuarioalt,
															idempresa, conn);

													if (!salida
															.equalsIgnoreCase("OK"))
														break;

													salida = stockHisCreate(
															nrointerno_ms,
															articulo, origen,
															"", "", cantArtMov,
															"", "", "",
															usuarioalt,
															idempresa, conn);
													if (!salida
															.equalsIgnoreCase("OK"))
														break;

													listaMS.put(articulo,
															articulo);

												}// G

												listaMS.clear();
												listaSCS.clear();

											}// F

										}// E

									}// D

								}// C
								// FINALIZA ACTUALIZACION STOCK *SOLO!*
								// SALIDA
								// (clientestipocomp)
								// =============================================

								// INICIA COBRANZA
								// ==================

								// TODO: SI NO SE COBRA ??? ES REMITO
								// PENDIENTE.???
								// CONFIRMAR.

								if (salida.equalsIgnoreCase("OK")) { // 1

									log.info("Inicia COB:");
									if (htIdentificadoresIngresos != null
											&& !htIdentificadoresIngresos
													.isEmpty()) {// 2

										nrocobranza = GeneralBean.getContador(
												new BigDecimal(7), idempresa,
												conn);

										if (nrocobranza.longValue() > 0) {// 3

											nrointernomovclientecobranza = GeneralBean
													.getContador(
															new BigDecimal(8),
															idempresa, conn);

											if (nrointernomovclientecobranza
													.longValue() > 0) {// 4
												// TODO: Pendiente de calculo
												// !!!!!!!!!!!!
												BigDecimal totalCobranza = new BigDecimal(
														0);
												// TODO: Pendiente de recuperar
												// !!!!!!!!!!!!
												BigDecimal idcobrador = new BigDecimal(
														0);

												en = htIdentificadoresIngresos
														.keys();
												while (en.hasMoreElements()) {// 10

													String key = (String) en
															.nextElement();
													String[] datosIngresos = (String[]) htIdentificadoresIngresos
															.get(key);
													totalCobranza = totalCobranza
															.add(new BigDecimal(
																	datosIngresos[28]));
													// TODO: calcular fecha
													// clearing
													if (datosIngresos[6]
															.equalsIgnoreCase("C")) {
														nroint_mt = GeneralBean
																.getContador(
																		new BigDecimal(
																				6),
																		idempresa,
																		conn);
													} else {
														nroint_mt = new BigDecimal(
																0);
													}

													BigDecimal nrodoc_mt = datosIngresos[30]
															.trim().equals("") ? null
															: new BigDecimal(
																	datosIngresos[30]);
													log
															.info("Genera mov teso:");
													salida = cajaMovTesoCreate(
															datosIngresos[2],
															nrocobranza,
															new Timestamp(
																	fechamov
																			.getTime()),
															"COB",
															datosIngresos[6],
															nroint_mt,
															datosIngresos[29],
															nrodoc_mt,
															new Timestamp(
																	fechamov
																			.getTime()),
															new BigDecimal(
																	datosIngresos[32]),
															new Timestamp(
																	fechamov
																			.getTime()),
															new BigDecimal(
																	datosIngresos[28]),
															new BigDecimal(
																	datosIngresos[28]),
															null,
															new BigDecimal(
																	datosIngresos[5]),
															null,
															new BigDecimal(1),
															null,
															null,
															null,
															new BigDecimal(
																	datosIngresos[4]),
															idcliente,
															new BigDecimal(1),
															null,
															null,
															new BigDecimal(
																	datosIngresos[20]),
															new BigDecimal(
																	datosIngresos[21]),
															usuarioalt,
															idempresa, conn);

													if (!salida
															.equalsIgnoreCase("OK"))
														break;

													switch (datosIngresos[6]
															.trim().charAt(0)) {
													case 'E':
													case 'G':
														log
																.info("Actualiz saldo banco:");
														salida = cajaSaldoBcoCreateOrUpdate(
																datosIngresos[2],
																new Date(
																		fechamov
																				.getTime()),
																(new BigDecimal(
																		datosIngresos[28])),
																(new BigDecimal(
																		datosIngresos[28])),
																usuarioalt,
																idempresa, conn);

														break;
													default:
														break;
													}
													if (!salida
															.equalsIgnoreCase("OK"))
														break;
												}// 10

												if (salida
														.equalsIgnoreCase("OK")) {// 20
													log
															.info("Genera mov clie-anexo:");
													if (idcliente != null
															&& idcliente
																	.longValue() > 0) {// 20.1

														// CLIENTE

														salida = clientesMovCliCreate(
																idcliente,
																fechamov,
																new BigDecimal(
																		0),
																nrocobranza,
																null,
																new BigDecimal(
																		4),
																"COB",
																new BigDecimal(
																		0),
																totalCobranza,
																new BigDecimal(
																		1),
																new BigDecimal(
																		1),
																null,
																"|",
																null,
																nrointernomovclientecobranza,
																null,
																com_cobra,
																idcobrador,
																null,
																null,
																null,
																null,
																null,
																null,
																observaciones,
																// 20110621 -
																// EJV -
																// Factuaracion
																// FE-CF-MA -->
																condicionletra,
																// <--
																// 20121005 -
																// EJV - Mantis
																// 882 -->
																null,
																// <--
																usuarioalt,
																idempresa, conn);

														if (salida
																.equalsIgnoreCase("OK")) {// 20.2
															// UPD saldo mov :
															// FA -
															// NC -
															// ND
															log
																	.info("Actualiza saldo mov cli:");
															salida = clientesMovCliUpdateSaldo(
																	nrointernomovcliente,
																	totalCobranza
																			.negate(),
																	usuarioalt,
																	idempresa,
																	conn);
														}// 20.2

													}// 20.1
													else {

														// ANEXO

														salida = clientesAnexovCreate(
																cuit_an,
																razon_an,
																iva_an,
																sucucli,
																nrocobranza,
																null,
																postal,
																loca_an,
																pcia_an,
																tipomov,
																nrointernomovclientecobranza,
																new Double(
																		totalCobranza
																				.doubleValue()),
																fechamov,
																new Double(0),
																new Double(0),
																null,
																new BigDecimal(
																		1),
																new Double(1),
																"|",
																"COB",
																null,
																domici_an,
																null,
																// 20110621 -
																// EJV -
																// Factuaracion
																// FE-CF-MA -->
																condicionletra,
																// <--
																idempresa,
																usuarioalt,
																conn);

													}// 20.1

													if (salida
															.equalsIgnoreCase("OK")) {// 21

														// CUENTA CLIENTE -
														// DEUDORES
														// POR
														// VENTA...
														String[] datos = (String[]) htCuentasContCli
																.get("T");
														log
																.info("Genera mov teso II:");

														salida = cajaMovTesoCreate(
																"CLI",
																nrocobranza,
																fechamov,
																"COB",
																"O",
																new BigDecimal(
																		0),
																null,
																null,
																fechamov,
																null,
																fechamov,
																totalCobranza,
																totalCobranza,
																null,
																new BigDecimal(
																		1),
																null,
																new BigDecimal(
																		1),
																null,
																null,
																null,
																new BigDecimal(
																		datos[0]),
																idcliente,
																new BigDecimal(
																		2),
																null, null,
																null, null,
																usuarioalt,
																idempresa, conn);

														if (salida
																.equalsIgnoreCase("OK")) {// 22
															log
																	.info("Genera mov cancelacion:");
															salida = clientesCancClieCreate(
																	nrointernomovcliente,
																	nrointernomovclientecobranza,
																	totalCobranza,
																	fechamov,
																	usuarioalt,
																	idempresa,
																	conn);
															log
																	.info("Generacion exitosa :");

														}// 22

													}// 21

												}// 20

											}// 4
											else
												salida = "Imposible recuperar Nro. Movimiento Cliente [(cobranza)].";
										}// 3
										else
											salida = "Imposible recuperar Nro. Cobranza.";
									}// 2

								} // 1

								// FINALIZA COBRANZA
								// ==================

							}// B

						}// A
						else {
							salida = "Imposible recuperar Nro. Interno de Movimiento de Cliente.";
						}

					}// 0.2
					else {

						salida = "El comprobante "
								+ GeneralBean.strZero(sucursal.toString(), 4)
								+ " - "
								+ GeneralBean.strZero(comprob.toString(), 8)
								+ " ya fue emitido.";
					}

				}// 0.1
				else {
					salida = "No se recupero Nro. Comprobante para Sucursal "
							+ sucursal
							+ ", posiblemente no se haya definido contador.";
				}

			}// 0.0

			resultado[0] = salida;
			resultado[1] = resultado[1] != null ? resultado[1] + "-"
					+ nrointerno_ms.toString() : nrointerno_ms.toString();

		} catch (Exception e) {
			salida = "Imposible generar movimiento de cliente.";
			log.error("clientesMovimientoClienteCreate:" + e);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			conn.rollback();
		} else {
			conn.commit();
			salida = nrointernomovcliente.toString();
		}

		conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	// TODO: INFORMAR EN LOS BEANS QUE CORRESONDA, LOS METODOS QUE ESTAN
	// REPLICADOS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	/**
	 * TODO: clientesMovCliCreate - REPLICADO EN TesoreriaBean ..............
	 * EJV - 20070822 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	// 20110909 - EJV - Mantis 777 static
	public static String clientesMovCliCreate(BigDecimal cliente,
			Timestamp fechamov, BigDecimal sucursal, BigDecimal comprob,
			BigDecimal comprob_has, BigDecimal tipomov, String tipomovs,
			BigDecimal saldo, BigDecimal importe, BigDecimal cambio,
			BigDecimal moneda, String unamode, String tipocomp,
			BigDecimal condicion, BigDecimal nrointerno, BigDecimal com_venta,
			BigDecimal com_cobra, BigDecimal com_vende, String anulada,
			BigDecimal retoque, BigDecimal expreso, BigDecimal sucucli,
			BigDecimal remito, BigDecimal credito, String observaciones,
			// 20110621 - EJV - Factuaracion FE-CF-MA -->
			String condicionletra,
			// <--
			// 20121005 - EJV - Mantis 882 -->
			BigDecimal idmotivonc,
			// <--
			String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		// 2. sin nada desde la pagina

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESMOVCLI(cliente, fechamov, sucursal, comprob, comprob_has, tipomov, tipomovs, "
						+ "   saldo, importe, cambio, moneda, unamode, tipocomp, condicion, nrointerno, com_venta, "
						+ "   com_cobra, com_vende, anulada, retoque, expreso, sucucli, remito, credito, observaciones, letraiva, idmotivonc, usuarioalt, idempresa )"
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, cliente);
				insert.setTimestamp(2, fechamov);
				insert.setBigDecimal(3, sucursal);
				insert.setBigDecimal(4, comprob);
				insert.setBigDecimal(5, comprob_has);
				insert.setBigDecimal(6, tipomov);
				insert.setString(7, tipomovs);
				insert.setBigDecimal(8, saldo);
				insert.setBigDecimal(9, importe);
				insert.setBigDecimal(10, cambio);
				insert.setBigDecimal(11, moneda);
				insert.setString(12, unamode);
				insert.setString(13, tipocomp);
				insert.setBigDecimal(14, condicion);
				insert.setBigDecimal(15, nrointerno);
				insert.setBigDecimal(16, com_venta);
				insert.setBigDecimal(17, com_cobra);
				insert.setBigDecimal(18, com_vende);
				insert.setString(19, anulada);
				insert.setBigDecimal(20, retoque);
				insert.setBigDecimal(21, expreso);
				insert.setBigDecimal(22, sucucli);
				insert.setBigDecimal(23, remito);
				insert.setBigDecimal(24, credito);
				insert.setString(25, observaciones);
				insert.setString(26, condicionletra);
				// 20121005 - EJV - Mantis 882 -->
				insert.setBigDecimal(27, idmotivonc);
				// <--
				insert.setString(28, usuarioalt);
				insert.setBigDecimal(29, idempresa);
				int n = insert.executeUpdate();
				if (n != 1) {
					salida = "Imposible crear movimiento clientes. ";

				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesMovCliCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesMovCliCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: clientesCancClieCreate - REPLICADO EN TesoreriaBean ............
	 * EJV - 20070822 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String clientesCancClieCreate(BigDecimal comp_canc,
			BigDecimal comp_q_can, BigDecimal importe, Timestamp fecha,
			String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		// 2. sin nada desde la pagina

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESCANCCLIE(comp_canc, comp_q_can, importe, fecha, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, comp_canc);
				insert.setBigDecimal(2, comp_q_can);
				insert.setBigDecimal(3, importe);
				insert.setTimestamp(4, fecha);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n != 1) {
					salida = "Imposible crear cancelacion de comprobantes.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesCancClieCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesCancClieCreate(.....)"
							+ ex);
		}
		return salida;

	}

	/**
	 * TODO: clientesContCliCreate - REPLICADO EN TesoreriaBean .............
	 * EJV - 20070822 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	// 20110909 - EJV - Mantis 777 static
	public static String clientesContCliCreate(BigDecimal cuenta_con,
			BigDecimal impor_con, String nroiva_con, BigDecimal nroint_con,
			String centr1_con, String centr2_con, BigDecimal por_per,
			String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESCONTCLI(cuenta_con, impor_con, nroiva_con, nroint_con, centr1_con, centr2_con, por_per, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, cuenta_con);
				insert.setBigDecimal(2, impor_con);
				insert.setString(3, nroiva_con);
				insert.setBigDecimal(4, nroint_con);
				insert.setString(5, centr1_con);
				insert.setString(6, centr2_con);
				insert.setBigDecimal(7, por_per);
				insert.setString(8, usuarioalt);
				insert.setBigDecimal(9, idempresa);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar movimiento contable para cliente.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesContCliCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesContCliCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: stockContStockCreate - REPLICADO EN StockBean ..................
	 * EJV - 20070822 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockContStockCreate(BigDecimal nint_ms_cs,
			BigDecimal cuenta_cs, BigDecimal importe_cs, String tipo_cs,
			String sistema_cs, BigDecimal centr1_cs, BigDecimal centr2_cs,
			String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (cuenta_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuenta_cs ";
		if (importe_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: importe_cs ";
		if (tipo_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo_cs ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipo_cs.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo_cs ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO STOCKCONTSTOCK(nint_ms_cs, cuenta_cs, importe_cs, tipo_cs, sistema_cs, centr1_cs, centr2_cs, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:

				insert.setBigDecimal(1, nint_ms_cs);
				insert.setBigDecimal(2, cuenta_cs);
				insert.setBigDecimal(3, importe_cs);
				insert.setString(4, tipo_cs);
				insert.setString(5, sistema_cs);
				insert.setBigDecimal(6, centr1_cs);
				insert.setBigDecimal(7, centr2_cs);
				insert.setString(8, usuarioalt);
				insert.setBigDecimal(9, idempresa);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar datos contables.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String stockContStockCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String stockContStockCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * 20110921 - EJV - Mantis 776 - Replicado en Tesoreria - Desarrollar
	 * rapido. Luego ver de unificar
	 */

	public String cajaAplicaciCreate(String tipomov_ap, BigDecimal comprob_ap,
			BigDecimal nrointe_ap, String anexo_ap, BigDecimal sucursa_ap,
			String usuarioalt, BigDecimal idempresa, Connection conn)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		// 2. sin nada desde la pagina

		// fin validaciones
		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CAJAAPLICACI(tipomov_ap, comprob_ap, nrointe_ap, anexo_ap, sucursa_ap, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipomov_ap);
				insert.setBigDecimal(2, comprob_ap);
				insert.setBigDecimal(3, nrointe_ap);
				insert.setString(4, anexo_ap);
				insert.setBigDecimal(5, sucursa_ap);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible crear aplicaciones.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String cajaAplicaciCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String cajaAplicaciCreate(.....)"
					+ ex);
		}
		return salida;
	}

	/**
	 * TODO: cajaMovTesoCreate - REPLICADO EN TesoreriaBean .................
	 * EJV - 20070822 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String cajaMovTesoCreate(String cartera_mt, BigDecimal comprob_mt,
			Timestamp fechamo_mt, String tipomov_mt, String tipcart_mt,
			BigDecimal nroint_mt, String detalle_mt, BigDecimal nrodoc_mt,
			Timestamp fecha_mt, BigDecimal idclearing, Timestamp fclear_mt,
			BigDecimal impori_mt, BigDecimal importe_mt, String deposi_mt,
			BigDecimal idmoneda, String unamone_mt, BigDecimal cambio_mt,
			String movsal_mt, BigDecimal sucsal_mt, BigDecimal nrosal_mt,
			BigDecimal cuenta_mt, BigDecimal idcliente, BigDecimal tipo_mt,
			String usado_mt, String anulada_mt, BigDecimal idcencosto,
			BigDecimal idcencosto1, String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		try {
			// validaciones de datos:
			// 1. nulidad de campos
			if (cartera_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: cartera_mt ";
			if (comprob_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: comprob_mt ";
			if (fechamo_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: fechamo_mt ";
			if (tipomov_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: tipomov_mt ";
			if (tipcart_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: tipcart_mt ";
			if (nroint_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: nroint_mt ";
			if (fecha_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_mt ";
			if (fclear_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: fclear_mt ";
			if (impori_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: impori_mt ";
			if (importe_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: importe_mt ";
			if (idmoneda == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: idmoneda ";
			if (cuenta_mt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: cuenta_mt ";
			if (usuarioalt == null)
				salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
			// 2. sin nada desde la pagina
			if (cartera_mt.equalsIgnoreCase(""))
				salida = "Error: No se puede dejar vacio el campo: cartera_mt ";
			if (tipomov_mt.equalsIgnoreCase(""))
				salida = "Error: No se puede dejar vacio el campo: tipomov_mt ";
			if (tipcart_mt.equalsIgnoreCase(""))
				salida = "Error: No se puede dejar vacio el campo: tipcart_mt ";
			if (usuarioalt.equalsIgnoreCase(""))
				salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CAJAMOVTESO"
						+ "(cartera_mt, comprob_mt, fechamo_mt, tipomov_mt, tipcart_mt, nroint_mt, detalle_mt, "
						+ "  nrodoc_mt, fecha_mt, idclearing, fclear_mt, impori_mt, importe_mt, deposi_mt, idmoneda,"
						+ "   unamone_mt, cambio_mt, movsal_mt, sucsal_mt, nrosal_mt, cuenta_mt, idcliente, tipo_mt, "
						+ "  usado_mt, anulada_mt, idcencosto, idcencosto1, usuarioalt, idempresa ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, cartera_mt);
				insert.setBigDecimal(2, comprob_mt);
				insert.setTimestamp(3, fechamo_mt);
				insert.setString(4, tipomov_mt);
				insert.setString(5, tipcart_mt);
				insert.setBigDecimal(6, nroint_mt);
				insert.setString(7, detalle_mt);
				insert.setBigDecimal(8, nrodoc_mt);
				insert.setTimestamp(9, fecha_mt);
				insert.setBigDecimal(10, idclearing);
				insert.setTimestamp(11, fclear_mt);
				insert.setBigDecimal(12, impori_mt);
				insert.setBigDecimal(13, importe_mt);
				insert.setString(14, deposi_mt);
				insert.setBigDecimal(15, idmoneda);
				insert.setString(16, unamone_mt);
				insert.setBigDecimal(17, cambio_mt);
				insert.setString(18, movsal_mt);
				insert.setBigDecimal(19, sucsal_mt);
				insert.setBigDecimal(20, nrosal_mt);
				insert.setBigDecimal(21, cuenta_mt);
				insert.setBigDecimal(22, idcliente);
				insert.setBigDecimal(23, tipo_mt);
				insert.setString(24, usado_mt);
				insert.setString(25, anulada_mt);
				insert.setBigDecimal(26, idcencosto);
				insert.setBigDecimal(27, idcencosto1);
				insert.setString(28, usuarioalt);
				insert.setBigDecimal(29, idempresa);
				int n = insert.executeUpdate();
				if (n != 1) {
					salida = "Imposible crear movimiento de tesoreria.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String cajaMovTesoCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String cajaMovTesoCreate(.....)"
					+ ex);
		}
		return salida;
	}

	/**
	 * TODO: stockContStockImporteUpdate - REPLICADO EN StockBean ...........
	 * EJV - 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockContStockImporteUpdate(BigDecimal nint_ms_cs,
			BigDecimal cuenta_cs, BigDecimal importe_cs, String tipo_cs,
			BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nint_ms_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrointerno ";
		if (cuenta_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cuenta_cs ";
		if (importe_cs == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: importe_cs ";

		try {
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) { // si existe hago update
				sql = ""
						+ "UPDATE STOCKCONTSTOCK "
						+ "    SET  importe_cs = (importe_cs + ?)  "
						+ "  WHERE nint_ms_cs=? AND cuenta_cs=? AND tipo_cs=? AND idempresa=?;";
				insert = conn.prepareStatement(sql);

				insert.setBigDecimal(1, importe_cs);
				insert.setBigDecimal(2, nint_ms_cs);
				insert.setBigDecimal(3, cuenta_cs);
				insert.setString(4, tipo_cs);
				insert.setBigDecimal(5, idempresa);
			}
			int i = insert.executeUpdate();
			if (i != 1)
				salida = "Imposible actualizar el total cuenta.";
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String stockContStockImporteUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String stockContStockImporteUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: stockMovStockCreate - REPLICADO EN StockBean ...................
	 * EJV - 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockMovStockCreate(BigDecimal nrointerno_ms,
			String sistema_ms, String tipomov_ms, BigDecimal comprob_ms,
			Timestamp fechamov, String articu_ms, BigDecimal canti_ms,
			BigDecimal moneda_ms, Double cambio_ms, Double venta_ms,
			BigDecimal costo_ms, String tipoaux_ms, String destino_ms,
			Double comis_ms, BigDecimal remito_ms, Double impint_ms,
			Double impifl_ms, Double impica_ms, Double prelis_ms,
			BigDecimal unidad_ms, Double merma_ms, Double saldo_ms,
			BigDecimal medida_ms, String observaciones, String usuarioalt,
			BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (sistema_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sistema_ms ";
		if (tipomov_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipomov_ms ";
		if (canti_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canti_ms ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (sistema_ms.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: sistema_ms ";
		if (tipomov_ms.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipomov_ms ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String qDML = "";

				qDML = "INSERT INTO stockmovstock (nrointerno_ms,sistema_ms, tipomov_ms, comprob_ms, fecha_ms, articu_ms, canti_ms,";
				qDML += " moneda_ms,cambio_ms,venta_ms,costo_ms,tipoaux_ms,destino_ms,";
				qDML += " comis_ms,remito_ms,impint_ms,impifl_ms,impica_ms,prelis_ms,";
				qDML += " unidad_ms,merma_ms,saldo_ms,medida_ms,observaciones,usuarioalt,idempresa)";
				qDML += " VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";

				PreparedStatement statement = conn.prepareStatement(qDML);
				// seteo de campos:
				statement.setBigDecimal(1, nrointerno_ms);
				statement.setString(2, sistema_ms);
				// TODO: Discriminar si entra o sale.
				statement.setString(3, tipomov_ms);
				statement.setBigDecimal(4, comprob_ms);
				statement.setTimestamp(5, fechamov);
				statement.setString(6, articu_ms);
				statement.setBigDecimal(7, canti_ms);
				// HARCODE POR FUENTE
				statement.setInt(8, 1);
				statement.setInt(9, 1);
				statement.setBigDecimal(10, new BigDecimal(0));
				statement.setBigDecimal(11, costo_ms);
				statement.setString(12, tipoaux_ms);
				statement.setString(13, destino_ms);
				statement.setBigDecimal(14, new BigDecimal("0"));
				statement.setBigDecimal(15, new BigDecimal("0"));
				statement.setBigDecimal(16, new BigDecimal("0"));
				statement.setBigDecimal(17, new BigDecimal("0"));
				statement.setBigDecimal(18, new BigDecimal("0"));
				statement.setBigDecimal(19, new BigDecimal("0"));
				statement.setBigDecimal(20, new BigDecimal("0"));
				statement.setBigDecimal(21, new BigDecimal("0"));
				statement.setBigDecimal(22, new BigDecimal("0"));
				statement.setBigDecimal(23, new BigDecimal("0"));
				statement.setString(24, observaciones);
				statement.setString(25, usuarioalt);
				statement.setBigDecimal(26, idempresa);
				int n = statement.executeUpdate();
				if (n != 1)
					salida = "Imposible generar movimiento de stock.";
			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String stockMovStockCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String stockMovStockCreate(.....)"
							+ ex);
		}
		log.info("stockMovStockCreate: " + salida);
		return salida;
	}

	/**
	 * TODO: stockMovStockCantidadUpdate - REPLICADO EN StockBean ...........
	 * EJV - 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockMovStockCantidadUpdate(BigDecimal nrointerno_ms,
			String articu_ms, BigDecimal canti_ms, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrointerno_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrointerno_ms ";
		if (articu_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: articu_ms ";
		if (canti_ms == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canti_ms ";
		// fin validaciones

		try {
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE stockmovstock SET   canti_ms = canti_ms + (?) "
						+ " WHERE articu_ms=? AND  nrointerno_ms=?  AND  comprob_ms=? AND idempresa=?;";
				insert = conn.prepareStatement(sql);
				insert.setBigDecimal(1, canti_ms);
				insert.setString(2, articu_ms);
				insert.setBigDecimal(3, nrointerno_ms);
				insert.setBigDecimal(4, nrointerno_ms);
				insert.setBigDecimal(5, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar stock para articulo: "
							+ articu_ms;
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String stockMovStockUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String stockMovStockUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: stockStockBisUpdate - REPLICADO EN StockBean ........... EJV -
	 * 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockStockBisUpdate(String articu_sb, BigDecimal deposi_sb,
			BigDecimal canti_sb, String serie_sb, String despa_sb,
			BigDecimal pedid_sb, String usuarioact, BigDecimal idempresa,
			Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		String qDML = "";
		// validaciones de datos:
		// 1. nulidad de campos
		if (articu_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: articu_sb ";
		if (deposi_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: deposi_sb ";
		if (canti_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canti_sb ";

		// 2. sin nada desde la pagina
		if (articu_sb.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: articu_sb ";
		// fin validaciones

		try {

			PreparedStatement statement = null;
			if (salida.equalsIgnoreCase("OK")) {

				qDML = "UPDATE stockstockbis ";
				qDML += "   SET canti_sb=( canti_sb +( ? )),serie_sb=?,despa_sb=?,pedid_sb=pedid_sb+?,usuarioact=?,fechaact=?";
				qDML += " WHERE articu_sb=? AND deposi_sb=?  AND idempresa=?";
				statement = conn.prepareStatement(qDML);
				statement.clearParameters();

				statement.clearParameters();
				statement.setBigDecimal(1, canti_sb);
				statement.setString(2, null);
				statement.setString(3, null);
				statement.setBigDecimal(4, new BigDecimal("0"));
				statement.setString(5, usuarioact);
				statement.setTimestamp(6, fechaact);
				statement.setString(7, articu_sb);
				statement.setBigDecimal(8, deposi_sb);
				statement.setBigDecimal(9, idempresa);

				int i = statement.executeUpdate();
				if (i != 1) {
					salida = "Articulo (" + articu_sb
							+ ") inexistente en deposito (" + deposi_sb + ").";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String stockStockBisUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String stockStockBisUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: stockHisCreate - REPLICADO EN StockBean ........................
	 * EJV - 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockHisCreate(BigDecimal nromov_sh, String articu_sh,
			BigDecimal deposi_sh, String serie_sh, String despa_sh,
			BigDecimal canti_sh, String estamp1_sh, String estamp2_sh,
			String aduana_sh, String usuarioalt, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		String salida = "OK";
		String qDML = "";
		PreparedStatement statement;
		// validaciones de datos:
		// 1. nulidad de campos
		if (articu_sh == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: articu_sh ";
		if (deposi_sh == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: deposi_sh ";
		if (canti_sh == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canti_sh ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (articu_sh.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: articu_sh ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				// INSERTAR STOCKHIS
				qDML = "INSERT INTO stockhis (nromov_sh,articu_sh,deposi_sh,serie_sh,despa_sh, ";
				qDML += " canti_sh,estamp1_sh,estamp2_sh,aduana_sh,usuarioalt, idempresa) ";
				qDML += " VALUES (?,?,?,?,?,?,?,?,?,?,?)";

				statement = conn.prepareStatement(qDML);
				statement.clearParameters();
				statement.setBigDecimal(1, nromov_sh);
				statement.setString(2, articu_sh);
				statement.setBigDecimal(3, deposi_sh);
				statement.setString(4, null);
				statement.setString(5, null);
				statement.setBigDecimal(6, canti_sh);
				statement.setString(7, null);
				statement.setString(8, null);
				statement.setString(9, null);
				statement.setString(10, usuarioalt);
				statement.setBigDecimal(11, idempresa);
				int n = statement.executeUpdate();
				if (n != 1)
					salida = "Imposible generar histrico.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String stockHisCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String stockHisCreate(.....)"
					+ ex);
		}
		log.info("stockHisCreate:" + salida);
		return salida;
	}

	/**
	 * TODO: stockRemitosCreate - REPLICADO EN StockBean ....................
	 * EJV - 20070824 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String stockRemitosCreate(BigDecimal nint_ms_rm,
			BigDecimal remito_rm, Timestamp fecha_rm, String tipo_rm,
			String tipomov_rm, BigDecimal codigo_rm, String marcado_rm,
			BigDecimal sucurs_rm, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (remito_rm == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: remito_rm ";
		if (codigo_rm == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_rm ";
		if (sucurs_rm == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sucurs_rm ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO STOCKREMITOS(nint_ms_rm, remito_rm, fecha_rm, tipo_rm, tipomov_rm, codigo_rm, marcado_rm, sucurs_rm, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, nint_ms_rm);
				insert.setBigDecimal(2, remito_rm);
				insert.setTimestamp(3, fecha_rm);
				insert.setString(4, tipo_rm);
				insert.setString(5, tipomov_rm);
				insert.setBigDecimal(6, codigo_rm);
				insert.setString(7, marcado_rm);
				insert.setBigDecimal(8, sucurs_rm);
				insert.setString(9, usuarioalt);
				insert.setBigDecimal(10, idempresa);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar remitos.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String stockRemitosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String stockRemitosCreate(.....)"
					+ ex);
		}
		return salida;
	}

	/**
	 * TODO: cajaSaldoBcoCreateOrUpdate - REPLICADO EN TesoreriaBean ........
	 * EJV - 20070830 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria
	public String cajaSaldoBcoCreateOrUpdate(String banco, java.sql.Date fecha,
			BigDecimal saldo_cont, BigDecimal saldo_disp, String usuarioact,
			BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		BigDecimal saldoContAcumulado = new BigDecimal(0);
		BigDecimal saldoDispAcumulado = new BigDecimal(0);
		// validaciones de datos:
		// 1. nulidad de campos

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM cajaSaldoBco WHERE banco = ? AND fecha::date = ? AND idempresa=?";
			PreparedStatement statement = conn.prepareStatement(cQuery);
			statement.setString(1, banco);
			statement.setDate(2, fecha);
			statement.setBigDecimal(3, idempresa);
			rsSalida = statement.executeQuery();

			int total = 0;

			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update

					sql = "UPDATE CAJASALDOBCO SET  saldo_cont=saldo_cont + ?, saldo_disp=saldo_disp + ?, usuarioact=?, fechaact=? WHERE banco=? AND fecha::date = ? AND idempresa=?;";
					insert = conn.prepareStatement(sql);

					insert.setBigDecimal(1, saldo_cont);
					insert.setBigDecimal(2, saldo_disp);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setString(5, banco);
					insert.setDate(6, fecha);
					insert.setBigDecimal(7, idempresa);

				} else {

					cQuery = "SELECT saldo_cont, saldo_disp FROM cajaSaldoBco WHERE banco = ?  AND idempresa=?";
					statement = conn.prepareStatement(cQuery);
					statement.setString(1, banco);
					statement.setBigDecimal(2, idempresa);
					rsSalida = statement.executeQuery();

					if (rsSalida != null) {

						if (rsSalida.next()) {
							saldoContAcumulado = rsSalida.getBigDecimal(1);
							saldoDispAcumulado = rsSalida.getBigDecimal(2);

						}
					} else {
						throw new SQLException(
								"RSSALIDA:NULO - IMPOSIBLE RECUPERAR SALDOS.");
					}

					String ins = "INSERT INTO CAJASALDOBCO(banco, fecha, saldo_cont , saldo_disp, usuarioalt, idempresa ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = conn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, banco);
					insert.setDate(2, fecha);
					insert.setBigDecimal(3, saldo_cont.add(saldoContAcumulado));
					insert.setBigDecimal(4, saldo_disp.add(saldoDispAcumulado));
					insert.setString(5, usuarioalt);
					insert.setBigDecimal(6, idempresa);

				}
				int i = insert.executeUpdate();
				if (i <= 0)
					salida = "Imposible actualizar saldo para banco: " + banco;

			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro [saldo - " + banco
					+ "].";
			log
					.error("Error SQL public String cajaSaldoBcoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String cajaSaldoBcoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * TODO: clientesMovCliUpdateSaldo - REPLICADO EN TesoreriaBean ........ EJV
	 * - 20070830 - .....................................................
	 * COMENTARIOS: analizar la posibilidad de concentrar ...................
	 * metodo en una clase, recibiendo como nuevo parametro la coneccion, y .
	 * haciendo estatico al mismo. ..........................................
	 */

	public String clientesMovCliUpdateSaldo(BigDecimal nrointerno,
			BigDecimal saldo, String usuarioact, BigDecimal idempresa,
			// 20110617 - EJV - Factuaracion FE-CF-MA -->
			Connection conn
	// <--
	) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesMovCli WHERE nrointerno = "
					+ nrointerno.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";

			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update

					sql = "UPDATE CLIENTESMOVCLI SET saldo=saldo+(?), usuarioact=?, fechaact=? WHERE nrointerno=? AND idempresa=?  AND (  (saldo) +  (?) >= -0.01 );";
					insert = conn.prepareStatement(sql);

					// TODO: EJV 20090513
					// La condicion siguiente no tiene logica valida, reveer
					// porque
					// esta o que se pretendio hacer en el momento de crear el
					// metodo.
					// En el caso que se NC
					// 20120917 - EJV -->
					// if (saldo.signum() != -1)
					// saldo = saldo.negate();
					// <--
					insert.setBigDecimal(1, saldo);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, nrointerno);
					insert.setBigDecimal(5, idempresa);
					insert.setBigDecimal(6, saldo);

				}

				int i = insert.executeUpdate();
				if (i < 1) {
					salida = "Imposible actualizar saldo documento clientes.";
				}
			}

		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesMovCliUpdateSaldo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesMovCliUpdate(.....)"
							+ ex);
		}

		return salida;

	}

	/**
	 * =======================================================================
	 * =======================================================================
	 * FINAL ................................................................
	 * EJV ...................................................................
	 * 20070822 ..............................................................
	 * INGRESO DE MOVIMIENTOS DE CLIENTES VERSION PREELIMINAR ................
	 * =======================================================================
	 * =======================================================================
	 * =======================================================================
	 * =======================================================================
	 */

	/**
	 * Metodos para la entidad: globalTiposDocumentos Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Feb 14 09:17:32 ART 2008
	 * 
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getGlobalTiposDocumentosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM GLOBALTIPOSDOCUMENTOS WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTiposDocumentosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getGlobalTiposDocumentosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM GLOBALTIPOSDOCUMENTOS WHERE (UPPER(TIPODOCUMENTO) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTiposDocumentosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getGlobalTiposDocumentosPK(BigDecimal idtipodocumento,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipodocumento,tipodocumento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM GLOBALTIPOSDOCUMENTOS WHERE idtipodocumento="
				+ idtipodocumento.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getGlobalTiposDocumentosPK( BigDecimal idtipodocumento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String globalTiposDocumentosDelete(BigDecimal idtipodocumento)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM GLOBALTIPOSDOCUMENTOS WHERE idtipodocumento="
				+ idtipodocumento.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM GLOBALTIPOSDOCUMENTOS WHERE idtipodocumento="
						+ idtipodocumento.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : globalTiposDocumentosDelete( BigDecimal idtipodocumento ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: globalTiposDocumentosDelete( BigDecimal idtipodocumento )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String globalTiposDocumentosCreate(String tipodocumento,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodocumento ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO GLOBALTIPOSDOCUMENTOS(tipodocumento, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipodocumento);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalTiposDocumentosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalTiposDocumentosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String globalTiposDocumentosCreateOrUpdate(
			BigDecimal idtipodocumento, String tipodocumento,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodocumento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalTiposDocumentos WHERE idtipodocumento = "
					+ idtipodocumento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALTIPOSDOCUMENTOS SET tipodocumento=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodocumento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodocumento);
				} else {
					String ins = "INSERT INTO GLOBALTIPOSDOCUMENTOS(tipodocumento, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String globalTiposDocumentosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String globalTiposDocumentosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String globalTiposDocumentosUpdate(BigDecimal idtipodocumento,
			String tipodocumento, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodocumento ";
		if (tipodocumento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodocumento ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodocumento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodocumento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM globalTiposDocumentos WHERE idtipodocumento = "
					+ idtipodocumento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE GLOBALTIPOSDOCUMENTOS SET tipodocumento=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodocumento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodocumento);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodocumento);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String globalTiposDocumentosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String globalTiposDocumentosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesDomicilios Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Feb 14 15:31:28 ART 2008
	 * 
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesDomiciliosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente,d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,d.postal,d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona,"
				+ "       d.idexpreso,e.expreso,d.idcobrador,c.cobrador,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact"
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN clientesexpresos e ON d.idexpreso = e.idexpreso AND d.idempresa = e.idempresa "
				+ "        INNER JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ "        INNER JOIN clienteszonas z ON d.idzona = z.idzona AND d.idempresa = z.idempresa "
				+ " WHERE d.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// domicilio default para un cliente ()
	public List getClientesDomiciliosClienteDefault(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,COALESCE(l.cpostal, ''),d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,z.idzona,z.zona,"
				+ "       e.idexpreso,e.expreso,d.idcobrador,c.cobrador,d.idvendedor, v.vendedor, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact ,"
				+ "       date_part('day',  now() - COALESCE(d.fechaact, d.fechaalt) ) as diasauditados, "
				+ "       p.idprovincia, p.provincia, xl.idanexolocalidad, d.obsentrega, "
				+ "       COALESCE(bo.cartaoregalo, 'N') AS cartaoregalo, COALESCE(l.idtipoiva, -1) AS idtipoivaloca "
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN clientesclientes cl ON d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa "
				+ "        INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
				+ "  INNER JOIN clientesanexolocalidades xl ON d.idanexolocalidad = xl.idanexolocalidad AND d.idempresa = xl.idempresa"
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "

				+ "  INNER JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "  INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "  INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "

				+ "        LEFT JOIN clientesvendedor v ON d.idvendedor = v.idvendedor "
				+ "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				// ADD - 20091109 - EJV
				+ "        LEFT JOIN bacoobsequioslocalidad bo ON l.idlocalidad = bo.idlocalidad AND bo.idempresa = "
				+ idempresa.toPlainString()

				+ " WHERE d.idcliente = " + idcliente.toString()
				+ "   AND d.idempresa = " + idempresa.toString()
				+ "   AND UPPER(d.esdefault) = 'S' " + "  ;";
		log.info(cQuery);
		List vecSalida = new ArrayList();
		ResultSet rsSalida = null;
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}

			closeResultset(rsSalida);

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesDomiciliosClienteDefault() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosClienteDefault()  "
							+ ex);
		}
		return vecSalida;
	}

	// Todos los domicilios para un cliente (ordena por el segundo campo por
	// defecto)
	public List getClientesDomiciliosCliente(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		// EJV 20080822 CAMBIO POSICION-INDICE ENTRE
		// d.idvendedor, v.vendedor *** p.idprovincia, p.provincia
		/*
		 * String cQuery = "" + "SELECT d.iddomicilio,d.idcliente,
		 * t.idtipodomicilio, t.tipodomicilio,
		 * d.esdefault,d.calle,d.nro,d.piso,d
		 * .depto,d.idlocalidad,l.localidad," + "
		 * d.cpa,d.postal,d.contacto,d.cargocontacto
		 * ,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona," + "
		 * e.idexpreso,e.expreso,d.idcobrador,c.cobrador,d.idvendedor,
		 * v.vendedor, cl.idtipoiva, td.tipodocumento, cl.nrodocumento,
		 * cl.brutos," + "
		 * d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact ," + "
		 * date_part('day', now() - COALESCE(d.fechaact, d.fechaalt) ) as
		 * diasauditados, " + " p.idprovincia, p.provincia" + " FROM
		 * clientesdomicilios d " + " INNER JOIN clientesclientes cl ON
		 * d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa " + " INNER
		 * JOIN globaltiposdocumentos td ON cl.idtipodocumento =
		 * td.idtipodocumento and cl.idempresa = td.idempresa " + " INNER JOIN
		 * clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio
		 * AND d.idempresa = t.idempresa " + " INNER JOIN globallocalidades l ON
		 * d.idlocalidad = l.idlocalidad " + " INNER JOIN globalprovincias p ON
		 * l.idprovincia = p.idprovincia " + " LEFT JOIN clienteszonas z ON
		 * d.idzona = z.idzona AND d.idempresa = z.idempresa " + " LEFT JOIN
		 * clientesexpresoszonas ez ON z.idzona = ez.idzona AND z.idempresa =
		 * ez.idempresa " + " LEFT JOIN clientesexpresos e ON ez.idexpreso =
		 * e.idexpreso AND ez.idempresa = e.idempresa " + " LEFT JOIN
		 * clientesvendedor v ON d.idvendedor = v.idvendedor " + " LEFT JOIN
		 * clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa =
		 * c.idempresa " + " WHERE d.idcliente = " + idcliente.toString() + "
		 * AND d.idempresa = " + idempresa.toString() + " ORDER BY 2 LIMIT " +
		 * limit + " OFFSET " + offset + ";";
		 */

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,COALESCE(l.cpostal, ''),d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,z.idzona,z.zona,"
				+ "       e.idexpreso,e.expreso,d.idcobrador,c.cobrador,d.idvendedor, v.vendedor, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact ,"
				+ "       date_part('day',  now() - COALESCE(d.fechaact, d.fechaalt) ) as diasauditados, "
				+ "       p.idprovincia, p.provincia, xl.idanexolocalidad, d.obsentrega, COALESCE(ti.idtipoiva, -1) AS idtipoivaloca "
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN clientesclientes cl ON d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa "
				+ "        INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
				+ "  INNER JOIN clientesanexolocalidades xl ON d.idanexolocalidad = xl.idanexolocalidad AND d.idempresa = xl.idempresa"
				+ "         INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "         INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "
				+ " 		INNER JOIN clientestablaiva ti on ti.idtipoiva = cl.idtipoiva"
				+ "  INNER JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "  INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "  INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "

				+ "        LEFT JOIN clientesvendedor v ON d.idvendedor = v.idvendedor "
				+ "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ " WHERE d.idcliente = "
				+ idcliente.toString()
				+ "   AND d.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY p.provincia, l.localidad, d.calle, d.nro, d.contacto  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	// Todos los domicilios para un cliente (ordena por el segundo campo por
	// defecto)
	public List getClientesDomiciliosClienteOcu(long limit, long offset,
			BigDecimal idcliente, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		/*
		 * String cQuery = "" +
		 * "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
		 * +
		 * "       d.cpa,l.cpostal,d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona,"
		 * +
		 * "       d.idexpreso,e.expreso,d.idcobrador,c.cobrador,p.idprovincia, p.provincia, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
		 * +
		 * "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact "
		 * + "  FROM clientesdomicilios d " +
		 * "        INNER JOIN clientesclientes cl ON d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa "
		 * +
		 * "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
		 * +
		 * "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
		 * +
		 * "        INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "
		 * +
		 * "        LEFT JOIN clientesexpresos e ON d.idexpreso = e.idexpreso AND d.idempresa = e.idempresa "
		 * +
		 * "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
		 * +
		 * "        LEFT JOIN clienteszonas z ON d.idzona = z.idzona AND d.idempresa = z.idempresa "
		 * + " WHERE d.idcliente = " + idcliente.toString() +
		 * "   AND d.idempresa = " + idempresa.toString() +
		 * " AND UPPER(d.calle) LIKE '%" + ocurrencia.toUpperCase() + "%'" +
		 * "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		 */

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,COALESCE(l.cpostal, ''),d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,z.idzona,z.zona,"
				+ "       e.idexpreso,e.expreso,d.idcobrador,c.cobrador,d.idvendedor, v.vendedor, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact ,"
				+ "       date_part('day',  now() - COALESCE(d.fechaact, d.fechaalt) ) as diasauditados, "
				+ "       p.idprovincia, p.provincia, xl.idanexolocalidad, d.obsentrega, COALESCE(l.idtipoiva, -1) AS idtipoivaloca "
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN clientesclientes cl ON d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa "
				+ "        INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
				+ "  INNER JOIN clientesanexolocalidades xl ON d.idanexolocalidad = xl.idanexolocalidad AND d.idempresa = xl.idempresa"
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "

				+ "  INNER JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "  INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "  INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "

				+ "        LEFT JOIN clientesvendedor v ON d.idvendedor = v.idvendedor "
				+ "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ " WHERE d.idcliente = "
				+ idcliente.toString()
				+ "   AND d.idempresa = "
				+ idempresa.toString()
				+ " AND UPPER(d.calle) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%'"
				+ "  ORDER BY p.provincia, l.localidad, d.calle, d.nro, d.contacto  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosClienteOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesDomiciliosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente,d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,d.postal,d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona,"
				+ "       d.idexpreso,e.expreso,d.idcobrador,c.cobrador,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact"
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN clientesexpresos e ON d.idexpreso = e.idexpreso AND d.idempresa = e.idempresa "
				+ "        INNER JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ "        INNER JOIN clienteszonas z ON d.idzona = z.idzona AND d.idempresa = z.idempresa "
				+ "WHERE ((d.IDCLIENTE::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND d.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesDomiciliosPK(BigDecimal iddomicilio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente,d.esdefault,d.calle,d.nro,d.piso,d.depto,l.idlocalidad,l.localidad,"
				+ "       d.cpa,d.postal,d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,d.idzona,z.zona,"
				+ "       d.idexpreso,e.expreso,d.idcobrador,c.cobrador,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact"
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN clientesexpresos e ON d.idexpreso = e.idexpreso AND d.idempresa = e.idempresa "
				+ "        INNER JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ "        INNER JOIN clienteszonas z ON d.idzona = z.idzona AND d.idempresa = z.idempresa "
				+ " WHERE d.iddomicilio=" + iddomicilio.toString()
				+ " AND d.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosPK( BigDecimal iddomicilio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesDomiciliosDelete(BigDecimal iddomicilio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESDOMICILIOS WHERE iddomicilio="
				+ iddomicilio.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESDOMICILIOS WHERE iddomicilio="
						+ iddomicilio.toString() + " AND idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);

			} else {
				salida = "Error: Registro domicilio inesxistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Error SQL en el metodo : clientesDomiciliosDelete( BigDecimal iddomicilio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Salida por exception: en el metodo: clientesDomiciliosDelete( BigDecimal iddomicilio )  "
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "";
		String salida = "OK";
		try {

			Statement statement = dbconn.createStatement();

			cQuery = "DELETE FROM CLIENTESDOMICILIOS WHERE idcliente="
					+ idcliente.toString() + " AND idempresa = "
					+ idempresa.toString();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Error SQL en el metodo : clientesDomiciliosXClienteDelete( BigDecimal iddomicilio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar domicilio.";
			log
					.error("Salida por exception: en el metodo: clientesDomiciliosXClienteDelete( BigDecimal iddomicilio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesDomiciliosCreate(BigDecimal idcliente,
			BigDecimal idtipodomicilio, String esdefault, String calle,
			String nro, String piso, String depto, BigDecimal idlocalidad,
			String cpa, String postal, String contacto, String cargocontacto,
			String telefonos, String celular, String fax, String web,
			BigDecimal idanexolocalidad, BigDecimal idcobrador,
			BigDecimal idvendedor, String obsentrega, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (esdefault == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: esdefault ";
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (esdefault.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: esdefault ";
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (obsentrega == null)
			obsentrega = "";

		// fin validaciones

		try {

			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() == 1) {
				salida = clientesDomiciliosSetDefault(new BigDecimal(-1),
						idcliente, idempresa, usuarioalt);
			}
			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() != 1) {
				salida = "No es posible marcar como default un domicilio que no es de entrega.";
			} else if (idtipodomicilio.intValue() == 2
					|| idtipodomicilio.intValue() == 3) {
				clientesDomiciliosSetTipoAlternativo(new BigDecimal(-1),
						idcliente, idtipodomicilio, idempresa, usuarioalt);
			}

			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESDOMICILIOS(idcliente, idtipodomicilio, esdefault, calle, nro, piso, depto, idlocalidad, cpa, postal, contacto, cargocontacto, telefonos, celular, fax, web, idanexolocalidad, idcobrador, idvendedor, obsentrega, idempresa, usuarioalt ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:

				// for (int h = 0; h < obsentrega.length(); h++)
				// log.info("CHAR[" + h + "]:" + (int)obsentrega.charAt(h));

				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idtipodomicilio);
				insert.setString(3, esdefault);
				insert.setString(4, calle.trim().replaceAll("\n", ""));
				insert.setString(5, nro);
				insert.setString(6, piso);
				insert.setString(7, depto);
				insert.setBigDecimal(8, idlocalidad);
				insert.setString(9, cpa);
				insert.setString(10, postal);
				insert.setString(11, contacto.trim().replaceAll("\n", ""));
				insert.setString(12, cargocontacto);
				insert.setString(13, telefonos);
				insert.setString(14, celular);
				insert.setString(15, fax);
				insert.setString(16, web);
				insert.setBigDecimal(17, GeneralBean.setNull(idanexolocalidad,
						1));
				// insert.setBigDecimal(18, GeneralBean.setNull(idexpreso, 1));
				insert.setBigDecimal(18, GeneralBean.setNull(idcobrador, 0));
				insert.setBigDecimal(19, GeneralBean.setNull(idvendedor, 1));
				insert.setString(20, obsentrega.trim().replaceAll("\n", "")
						.replaceAll("\r", ""));
				insert.setBigDecimal(21, idempresa);
				insert.setString(22, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el domicilio.";
			log.error("Error SQL public String clientesDomiciliosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesDomiciliosCreateOrUpdate(BigDecimal iddomicilio,
			BigDecimal idcliente, String esdefault, String calle, String nro,
			String piso, String depto, BigDecimal idlocalidad, String cpa,
			String postal, String contacto, String cargocontacto,
			String telefonos, String celular, String fax, String web,
			BigDecimal idzona, BigDecimal idexpreso, BigDecimal idcobrador,
			BigDecimal idvendedor, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (esdefault == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: esdefault ";
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (esdefault.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: esdefault ";
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesDomicilios WHERE iddomicilio = "
					+ iddomicilio.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESDOMICILIOS SET idcliente=?, esdefault=?, calle=?, nro=?, piso=?, depto=?, idlocalidad=?, cpa=?, postal=?, contacto=?, cargocontacto=?, telefonos=?, celular=?, fax=?, web=?, idzona=?, idexpreso=?, idcobrador=?, idempresa=?, usuarioact=?, fechaact=? WHERE iddomicilio=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setString(2, esdefault);
					insert.setString(3, calle);
					insert.setString(4, nro);
					insert.setString(5, piso);
					insert.setString(6, depto);
					insert.setBigDecimal(7, idlocalidad);
					insert.setString(8, cpa);
					insert.setString(9, postal);
					insert.setString(10, contacto);
					insert.setString(11, cargocontacto);
					insert.setString(12, telefonos);
					insert.setString(13, celular);
					insert.setString(14, fax);
					insert.setString(15, web);
					insert.setBigDecimal(16, idzona);
					insert.setBigDecimal(17, idexpreso);
					insert.setBigDecimal(18, idcobrador);
					insert.setBigDecimal(19, idempresa);
					insert.setString(20, usuarioact);
					insert.setTimestamp(21, fechaact);
					insert.setBigDecimal(22, iddomicilio);
				} else {
					String ins = "INSERT INTO CLIENTESDOMICILIOS(idcliente, esdefault, calle, nro, piso, depto, idlocalidad, cpa, postal, contacto, cargocontacto, telefonos, celular, fax, web, idzona, idexpreso, idcobrador, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setString(2, esdefault);
					insert.setString(3, calle);
					insert.setString(4, nro);
					insert.setString(5, piso);
					insert.setString(6, depto);
					insert.setBigDecimal(7, idlocalidad);
					insert.setString(8, cpa);
					insert.setString(9, postal);
					insert.setString(10, contacto);
					insert.setString(11, cargocontacto);
					insert.setString(12, telefonos);
					insert.setString(13, celular);
					insert.setString(14, fax);
					insert.setString(15, web);
					insert.setBigDecimal(16, idzona);
					insert.setBigDecimal(17, idexpreso);
					insert.setBigDecimal(18, idcobrador);
					insert.setBigDecimal(19, idempresa);
					insert.setString(20, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesDomiciliosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesDomiciliosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosUpdate(BigDecimal iddomicilio,
			BigDecimal idcliente, BigDecimal idtipodomicilio, String esdefault,
			String calle, String nro, String piso, String depto,
			BigDecimal idlocalidad, String cpa, String postal, String contacto,
			String cargocontacto, String telefonos, String celular, String fax,
			String web, BigDecimal idanexolocalidad, BigDecimal idcobrador,
			BigDecimal idvendedor, String obsentrega, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (esdefault == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: esdefault ";
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (esdefault.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: esdefault ";
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesDomicilios WHERE iddomicilio = "
					+ iddomicilio.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";

			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() == 1) {
				salida = clientesDomiciliosSetDefault(new BigDecimal(-1),
						idcliente, idempresa, usuarioact);
			}
			if (esdefault.equalsIgnoreCase("S")
					&& idtipodomicilio.intValue() != 1) {
				salida = "No es posible marcar como default un domicilio que no es de entrega.";
			} else if (idtipodomicilio.intValue() == 2
					|| idtipodomicilio.intValue() == 3) {
				clientesDomiciliosSetTipoAlternativo(iddomicilio, idcliente,
						idtipodomicilio, idempresa, usuarioact);
			}

			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "    UPDATE CLIENTESDOMICILIOS "
							+ "   SET idcliente=?, idtipodomicilio=?, esdefault=?, calle=?, nro=?, piso=?, depto=?,"
							+ "       idlocalidad=?, cpa=?, postal=?, contacto=?, cargocontacto=?, telefonos=?, celular=?,"
							+ "       fax=?, web=?, idanexolocalidad=?, idcobrador=?, idvendedor=?, obsentrega=?, idempresa=?, usuarioact=?, fechaact=?"
							+ " WHERE iddomicilio=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idtipodomicilio);
					insert.setString(3, esdefault);
					insert.setString(4, calle);
					insert.setString(5, nro);
					insert.setString(6, piso);
					insert.setString(7, depto);
					insert.setBigDecimal(8, idlocalidad);
					insert.setString(9, cpa);
					insert.setString(10, postal);
					insert.setString(11, contacto);
					insert.setString(12, cargocontacto);
					insert.setString(13, telefonos);
					insert.setString(14, celular);
					insert.setString(15, fax);
					insert.setString(16, web);
					insert.setBigDecimal(17, GeneralBean.setNull(
							idanexolocalidad, 1));
					// insert.setBigDecimal(18, GeneralBean.setNull(idexpreso,
					// 1));
					insert
							.setBigDecimal(18, GeneralBean.setNull(idcobrador,
									0));
					insert
							.setBigDecimal(19, GeneralBean.setNull(idvendedor,
									1));
					insert.setString(20, obsentrega);
					insert.setBigDecimal(21, idempresa);
					insert.setString(22, usuarioact);
					insert.setTimestamp(23, fechaact);
					insert.setBigDecimal(24, iddomicilio);
					insert.setBigDecimal(25, idempresa);

					log.info("*** **** **** ***");
					log.info("idcliente:" + idcliente);
					log.info("idtipodomicilio:" + idtipodomicilio);
					log.info("esdefault:" + esdefault);
					log.info("calle:" + calle);
					log.info("nro:" + nro);
					log.info("piso:" + piso);
					log.info("depto:" + depto);
					log.info("idlocalidad:" + idlocalidad);
					log.info("cpa:" + cpa);
					log.info("postal:" + postal);
					log.info("contacto:" + contacto);
					log.info("cargocontacto:" + cargocontacto);
					log.info("telefonos:" + telefonos);
					log.info("celular:" + celular);
					log.info("fax:" + fax);
					log.info("web:" + web);
					log.info("idanexolocalidad:"
							+ GeneralBean.setNull(idanexolocalidad, 1));
					log
							.info("idcobrador:"
									+ GeneralBean.setNull(idcobrador, 0));
					log
							.info("idvendedor:"
									+ GeneralBean.setNull(idvendedor, 1));
					log.info("obsentrega:" + obsentrega);
					log.info("idempresa:" + idempresa);
					log.info("usuarioact:" + usuarioact);
					log.info("fechaact:" + fechaact);
					log.info("iddomicilio:" + iddomicilio);
					log.info("idempresa:" + idempresa);
					log.info("----------------------------------------");

				}

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar domicilio.";
			log.error("Error SQL public String clientesDomiciliosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// 20090717 - EJV

	public String clientesDomiciliosSetDefault(BigDecimal iddomicilio,
			BigDecimal idcliente, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "    UPDATE CLIENTESDOMICILIOS "
						+ "   SET esdefault=?, usuarioact=?, fechaact=?"
						+ " WHERE iddomicilio <> ? AND idcliente =? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setString(1, "N");
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, iddomicilio);
				insert.setBigDecimal(5, idcliente);
				insert.setBigDecimal(6, idempresa);

				int i = insert.executeUpdate();

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar domicilio default.";
			log
					.error("Error SQL public String clientesDomiciliosSetDefault(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar domicilio default.";
			log
					.error("Error excepcion public String clientesDomiciliosSetDefault(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesDomiciliosSetTipoAlternativo(BigDecimal iddomicilio,
			BigDecimal idcliente, BigDecimal idtipodomicilio,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "    UPDATE CLIENTESDOMICILIOS "
						+ "   SET idtipodomicilio=?, usuarioact=?, fechaact=?"
						+ " WHERE iddomicilio <> ? AND idcliente =? AND idtipodomicilio=? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setBigDecimal(1, new BigDecimal(4));
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, iddomicilio);
				insert.setBigDecimal(5, idcliente);
				insert.setBigDecimal(6, idtipodomicilio);
				insert.setBigDecimal(7, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Imposible actualizar tipos domicilio.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar tipos domicilio.";
			log
					.error("Error SQL public String clientesDomiciliosSetTipo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar tipos domicilio.";
			log
					.error("Error excepcion public String clientesDomiciliosSetTipo(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesEmail Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Fri Feb 15 12:39:01 ART 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesEmailAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT idemail,iddomicilio,idcliente,email,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESEMAILWHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEmailAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesEmailOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idemail,iddomicilio,idcliente,email,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESEMAIL WHERE ((IDDOMICILIO::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEmailOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesEmailPK(BigDecimal idemail, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT  idemail,iddomicilio,idcliente,email,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESEMAIL WHERE idemail="
				+ idemail.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEmailPK( BigDecimal idemail )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesEmailXCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idemail,iddomicilio,idcliente,email,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESEMAIL WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString() + " ORDER BY iddomicilio;";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesEmailXCliente( BigDecimal idemail )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesEmailDelete(BigDecimal idemail, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESEMAIL WHERE idemail="
				+ idemail.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESEMAIL WHERE idemail="
						+ idemail.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesEmailDelete( BigDecimal idemail ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesEmailDelete( BigDecimal idemail )  "
							+ ex);
		}
		return salida;
	}

	// Elimina e-emails por domicilio

	public String clientesEmailXDomicilioDelete(BigDecimal iddomicilio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "DELETE FROM CLIENTESEMAIL WHERE iddomicilio="
				+ iddomicilio.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el e-mails domicilio - cliente("
					+ iddomicilio + ").";
			log
					.error("Error SQL en el metodo : clientesEmailXDomicilioDelete( ..) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el e-mails cliente(" + iddomicilio
					+ ").";
			log
					.error("Salida por exception: en el metodo: clientesEmailXDomicilioDelete( .. )  "
							+ ex);
		}
		return salida;
	}

	// Elimina e-emails por cliente

	public String clientesEmailXClienteDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "DELETE FROM CLIENTESEMAIL WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			statement.execute(cQuery);

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el e-mails domicilio - cliente("
					+ idcliente + ").";
			log
					.error("Error SQL en el metodo : clientesEmailXClienteDelete( ..) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el e-mails cliente(" + idcliente
					+ ").";
			log
					.error("Salida por exception: en el metodo: clientesEmailXClienteDelete( .. )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesEmailCreate(BigDecimal iddomicilio,
			BigDecimal idcliente, String email, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESEMAIL(iddomicilio, idcliente, email, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, iddomicilio);
				insert.setBigDecimal(2, idcliente);
				insert.setString(3, email);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar e-mail cliente.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesEmailCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesEmailCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesEmailCreateOrUpdate(BigDecimal idemail,
			BigDecimal iddomicilio, BigDecimal idcliente, String email,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idemail == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idemail ";
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesEmail WHERE idemail = "
					+ idemail.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESEMAIL SET iddomicilio=?, idcliente=?, email=?, idempresa=?, usuarioact=?, fechaact=? WHERE idemail=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, iddomicilio);
					insert.setBigDecimal(2, idcliente);
					insert.setString(3, email);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idemail);
				} else {
					String ins = "INSERT INTO CLIENTESEMAIL(iddomicilio, idcliente, email, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, iddomicilio);
					insert.setBigDecimal(2, idcliente);
					insert.setString(3, email);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesEmailCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesEmailCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesEmailUpdate(BigDecimal idemail,
			BigDecimal iddomicilio, BigDecimal idcliente, String email,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idemail == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idemail ";
		if (iddomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddomicilio ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (email == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: email ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (email.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: email ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesEmail WHERE idemail = "
					+ idemail.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESEMAIL SET iddomicilio=?, idcliente=?, email=?, idempresa=?, usuarioact=?, fechaact=? WHERE idemail=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, iddomicilio);
					insert.setBigDecimal(2, idcliente);
					insert.setString(3, email);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idemail);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesEmailUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesEmailUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesTiposDomicilios Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Feb 27 14:41:00 ART 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesTiposDomiciliosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipodomicilio,tipodomicilio,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESTIPOSDOMICILIOS WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTiposDomiciliosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesTiposDomiciliosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipodomicilio,tipodomicilio,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTIPOSDOMICILIOS WHERE (UPPER(TIPODOMICILIO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTiposDomiciliosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesTiposDomiciliosPK(BigDecimal idtipodomicilio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT  idtipodomicilio,tipodomicilio,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM CLIENTESTIPOSDOMICILIOS WHERE idtipodomicilio="
				+ idtipodomicilio.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTiposDomiciliosPK( BigDecimal idtipodomicilio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesTiposDomiciliosDelete(BigDecimal idtipodomicilio)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTIPOSDOMICILIOS WHERE idtipodomicilio="
				+ idtipodomicilio.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTIPOSDOMICILIOS WHERE idtipodomicilio="
						+ idtipodomicilio.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesTiposDomiciliosDelete( BigDecimal idtipodomicilio ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesTiposDomiciliosDelete( BigDecimal idtipodomicilio )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesTiposDomiciliosCreate(String tipodomicilio,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipodomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodomicilio ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipodomicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodomicilio ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESTIPOSDOMICILIOS(tipodomicilio, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipodomicilio);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesTiposDomiciliosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesTiposDomiciliosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesTiposDomiciliosCreateOrUpdate(
			BigDecimal idtipodomicilio, String tipodomicilio,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodomicilio ";
		if (tipodomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodomicilio ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodomicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodomicilio ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesTiposDomicilios WHERE idtipodomicilio = "
					+ idtipodomicilio.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOSDOMICILIOS SET tipodomicilio=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodomicilio=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodomicilio);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodomicilio);
				} else {
					String ins = "INSERT INTO CLIENTESTIPOSDOMICILIOS(tipodomicilio, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipodomicilio);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesTiposDomiciliosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesTiposDomiciliosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesTiposDomiciliosUpdate(BigDecimal idtipodomicilio,
			String tipodomicilio, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipodomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipodomicilio ";
		if (tipodomicilio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipodomicilio ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipodomicilio.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipodomicilio ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesTiposDomicilios WHERE idtipodomicilio = "
					+ idtipodomicilio.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTIPOSDOMICILIOS SET tipodomicilio=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipodomicilio=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipodomicilio);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipodomicilio);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesTiposDomiciliosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesTiposDomiciliosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// Listados Precios
	// para todo (ordena por el segundo campo por defecto)
	public List getClienteslistasdepreciosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = " "
				+ "SELECT lp.idlista, cl.descri_lis, lp.codigo_st, st.descrip_st, lp.precio,"
				+ "       lp.idempresa, lp.usuarioalt, lp.usuarioact, lp.fechaalt, lp.fechaact"
				+ "  FROM clienteslistasdeprecios lp "
				+ "       INNER JOIN stockstock st ON st.codigo_st = lp.codigo_st AND  st.idempresa= lp.idempresa"
				+ "       INNER JOIN clienteslistas cl ON cl.idlista = lp.idlista AND cl.idempresa = lp.idempresa "
				+ " WHERE lp.idempresa = " + idempresa.toString()
				+ " ORDER BY 2, 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistasdepreciosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClienteslistasdepreciosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = "  "
				+ "SELECT lp.idlista, cl.descri_lis, lp.codigo_st, st.descrip_st, lp.precio,"
				+ "       lp.idempresa, lp.usuarioalt, lp.usuarioact, lp.fechaalt, lp.fechaact"
				+ "  FROM clienteslistasdeprecios lp "
				+ "       INNER JOIN stockstock st ON st.codigo_st = lp.codigo_st AND  st.idempresa= lp.idempresa"
				+ "       INNER JOIN clienteslistas cl ON cl.idlista = lp.idlista AND cl.idempresa = lp.idempresa "
				+ " WHERE lp.idempresa = " + idempresa.toString()
				+ "   AND ( UPPER(cl.descri_lis) LIKE '%"
				+ ocurrencia.toUpperCase() + "%' OR "
				+ " UPPER(st.codigo_st) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') " + " ORDER BY 2, 3  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistasdepreciosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClienteslistasdepreciosPK(BigDecimal idlista,
			String codigo_st, BigDecimal idempresa) throws EJBException {

		String cQuery = " SELECT "
				+ "CLIENTESLISTASDEPRECIOS.idlista,"
				+ "clienteslistas.descri_lis,"
				+ "CLIENTESLISTASDEPRECIOS.codigo_st,"
				+ "stockstock.descrip_st,"
				+ "CLIENTESLISTASDEPRECIOS.precio,"
				+ "CLIENTESLISTASDEPRECIOS.idempresa,"
				+ "CLIENTESLISTASDEPRECIOS.usuarioalt,"
				+ "CLIENTESLISTASDEPRECIOS.usuarioact,"
				+ "CLIENTESLISTASDEPRECIOS.fechaalt, "
				+ "CLIENTESLISTASDEPRECIOS.fechaact "
				+ "FROM "
				+ "CLIENTESLISTASDEPRECIOS, "
				+ "stockstock ,"
				+ "clienteslistas "
				+ "WHERE "
				+ "stockstock.codigo_st = CLIENTESLISTASDEPRECIOS.codigo_st "
				+ "and stockstock.idempresa= CLIENTESLISTASDEPRECIOS.idempresa "
				+ "and clienteslistas.idlista = CLIENTESLISTASDEPRECIOS.idlista "
				+ "and clienteslistas.idempresa = CLIENTESLISTASDEPRECIOS.idempresa "
				+ " and CLIENTESLISTASDEPRECIOS.idlista=" + idlista.toString()
				+ " and CLIENTESLISTASDEPRECIOS.codigo_st='" + codigo_st + "'"
				+ " AND CLIENTESLISTASDEPRECIOS.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteslistasdepreciosPK( BigDecimal idlista )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clienteslistasdepreciosDelete(BigDecimal idlista,
			String codigo_st, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESLISTASDEPRECIOS "
				+ " WHERE idlista=" + idlista.toString() + " AND codigo_st = '"
				+ codigo_st + "' and idempresa=" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESLISTASDEPRECIOS "
						+ " WHERE idlista=" + idlista.toString()
						+ " AND codigo_st = '" + codigo_st + "' and idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clienteslistasdepreciosDelete( BigDecimal idlista ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clienteslistasdepreciosDelete( BigDecimal idlista )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clienteslistasdepreciosCreate(BigDecimal idlista,
			String codigo_st, Double precio, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESLISTASDEPRECIOS(idlista, codigo_st, precio, idempresa, usuarioalt ) VALUES (?,?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idlista);
				insert.setString(2, codigo_st);
				insert.setDouble(3, precio.doubleValue());
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clienteslistasdepreciosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteslistasdepreciosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clienteslistasdepreciosCreateOrUpdate(BigDecimal idlista,
			String codigo_st, Double precio, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteslistasdeprecios WHERE idlista = "
					+ idlista.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESLISTASDEPRECIOS SET codigo_st=?, precio=?, idempresa=?, usuarioact=?, fechaact=? WHERE idlista=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, codigo_st);
					insert.setDouble(2, precio.doubleValue());
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idlista);
				} else {
					String ins = "INSERT INTO CLIENTESLISTASDEPRECIOS(codigo_st, precio, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, codigo_st);
					insert.setDouble(2, precio.doubleValue());
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clienteslistasdepreciosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clienteslistasdepreciosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clienteslistasdepreciosUpdate(BigDecimal idlista,
			String codigo_st, Double precio, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteslistasdeprecios "
					+ " WHERE idlista = " + idlista.toString()
					+ " and idempresa = " + idempresa.toString()
					+ " and codigo_st = '" + codigo_st.toString() + "'";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESLISTASDEPRECIOS SET  precio=?, usuarioact=?, fechaact=? WHERE idlista=? and codigo_st=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setDouble(1, precio.doubleValue());
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idlista);
					insert.setString(5, codigo_st);
					insert.setBigDecimal(6, idempresa);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clienteslistasdepreciosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clienteslistasdepreciosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// Update Listados
	public String clientesListadosUpdate(BigDecimal idlista, Double precio,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteslistasdeprecios "
					+ " WHERE idlista = " + idlista.toString()
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESLISTASDEPRECIOS SET  precio=?, usuarioact=?, fechaact=? WHERE idlista=? and idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setDouble(1, precio.doubleValue());
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idlista);
					insert.setBigDecimal(5, idempresa);
				}
				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesListadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesListadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// clientes tarjetas calendarios presentacion
	// para todo (ordena por el segundo campo por defecto)
	public List getClientestarjetascalendariopresentacionAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CLIENTESTARJETASCALENDARIOPRESENTACION.codigo,clientetarjetascreditomarcas.tarjetacredito,CLIENTESTARJETASCALENDARIOPRESENTACION.anio,globalmeses.mes,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentaciondesde,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentacionhasta,CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioalt,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioact,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaalt,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaact FROM CLIENTESTARJETASCALENDARIOPRESENTACION,clientetarjetascreditomarcas,globalmeses WHERE clientetarjetascreditomarcas.idtarjetacredito = CLIENTESTARJETASCALENDARIOPRESENTACION.idtarjetacredito  and clientetarjetascreditomarcas.idempresa = CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa and globalmeses.idmes  = CLIENTESTARJETASCALENDARIOPRESENTACION.mes and CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestarjetascalendariopresentacionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientestarjetascalendariopresentacionOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "SELECT CLIENTESTARJETASCALENDARIOPRESENTACION.codigo,clientetarjetascreditomarcas.tarjetacredito,CLIENTESTARJETASCALENDARIOPRESENTACION.anio,globalmeses.mes,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentaciondesde,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentacionhasta,CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioalt,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioact,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaalt,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaact FROM CLIENTESTARJETASCALENDARIOPRESENTACION,clientetarjetascreditomarcas,globalmeses WHERE clientetarjetascreditomarcas.idtarjetacredito = CLIENTESTARJETASCALENDARIOPRESENTACION.idtarjetacredito  and clientetarjetascreditomarcas.idempresa = CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa and globalmeses.idmes  = CLIENTESTARJETASCALENDARIOPRESENTACION.mes "
				+ " and CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa= "
				+ idempresa.toString()
				+ " and (CLIENTESTARJETASCALENDARIOPRESENTACION.codigo::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " clientetarjetascreditomarcas.tarjetacredito LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " CLIENTESTARJETASCALENDARIOPRESENTACION.anio::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(globalmeses.mes) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestarjetascalendariopresentacionOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientestarjetascalendariopresentacionPK(BigDecimal codigo,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "SELECT CLIENTESTARJETASCALENDARIOPRESENTACION.codigo,clientetarjetascreditomarcas.idtarjetacredito,clientetarjetascreditomarcas.tarjetacredito,CLIENTESTARJETASCALENDARIOPRESENTACION.anio,globalmeses.idmes,globalmeses.mes,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentaciondesde,CLIENTESTARJETASCALENDARIOPRESENTACION.fpresentacionhasta,CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioalt,CLIENTESTARJETASCALENDARIOPRESENTACION.usuarioact,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaalt,CLIENTESTARJETASCALENDARIOPRESENTACION.fechaact FROM CLIENTESTARJETASCALENDARIOPRESENTACION,clientetarjetascreditomarcas,globalmeses WHERE clientetarjetascreditomarcas.idtarjetacredito = CLIENTESTARJETASCALENDARIOPRESENTACION.idtarjetacredito  and clientetarjetascreditomarcas.idempresa = CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa and globalmeses.idmes  = CLIENTESTARJETASCALENDARIOPRESENTACION.mes "
				+ " and CLIENTESTARJETASCALENDARIOPRESENTACION.codigo="
				+ codigo.toString()
				+ " AND CLIENTESTARJETASCALENDARIOPRESENTACION.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientestarjetascalendariopresentacionPK( BigDecimal codigo )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientestarjetascalendariopresentacionDelete(
			BigDecimal codigo, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESTARJETASCALENDARIOPRESENTACION "
				+ " WHERE codigo = " + codigo.toString() + " and idempresa = "
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESTARJETASCALENDARIOPRESENTACION "
						+ " WHERE codigo=" + codigo.toString()
						+ " and idempresa = " + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientestarjetascalendariopresentacionDelete( BigDecimal codigo ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientestarjetascalendariopresentacionDelete( BigDecimal codigo )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientestarjetascalendariopresentacionCreate(
			BigDecimal idtarjetacredito, BigDecimal anio, BigDecimal mes,
			Timestamp fpresentaciondesde, Timestamp fpresentacionhasta,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESTARJETASCALENDARIOPRESENTACION(idtarjetacredito, anio, mes, fpresentaciondesde, fpresentacionhasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idtarjetacredito);
				insert.setBigDecimal(2, anio);
				insert.setBigDecimal(3, mes);
				insert.setTimestamp(4, fpresentaciondesde);
				insert.setTimestamp(5, fpresentacionhasta);
				insert.setBigDecimal(6, idempresa);
				insert.setString(7, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestarjetascalendariopresentacionCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestarjetascalendariopresentacionCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientestarjetascalendariopresentacionCreateOrUpdate(
			BigDecimal codigo, BigDecimal idtarjetacredito, BigDecimal anio,
			BigDecimal mes, Timestamp fpresentaciondesde,
			Timestamp fpresentacionhasta, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestarjetascalendariopresentacion WHERE codigo = "
					+ codigo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTARJETASCALENDARIOPRESENTACION SET idtarjetacredito=?, anio=?, mes=?, fpresentaciondesde=?, fpresentacionhasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE codigo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, anio);
					insert.setBigDecimal(3, mes);
					insert.setTimestamp(4, fpresentaciondesde);
					insert.setTimestamp(5, fpresentacionhasta);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, codigo);
				} else {
					String ins = "INSERT INTO CLIENTESTARJETASCALENDARIOPRESENTACION(idtarjetacredito, anio, mes, fpresentaciondesde, fpresentacionhasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, anio);
					insert.setBigDecimal(3, mes);
					insert.setTimestamp(4, fpresentaciondesde);
					insert.setTimestamp(5, fpresentacionhasta);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientestarjetascalendariopresentacionCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientestarjetascalendariopresentacionCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientestarjetascalendariopresentacionUpdate(
			BigDecimal codigo, BigDecimal idtarjetacredito, BigDecimal anio,
			BigDecimal mes, Timestamp fpresentaciondesde,
			Timestamp fpresentacionhasta, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientestarjetascalendariopresentacion WHERE codigo = "
					+ codigo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESTARJETASCALENDARIOPRESENTACION SET idtarjetacredito=?, anio=?, mes=?, fpresentaciondesde=?, fpresentacionhasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE codigo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idtarjetacredito);
					insert.setBigDecimal(2, anio);
					insert.setBigDecimal(3, mes);
					insert.setTimestamp(4, fpresentaciondesde);
					insert.setTimestamp(5, fpresentacionhasta);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, codigo);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientestarjetascalendariopresentacionUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientestarjetascalendariopresentacionUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesPeriodicidadEntrega Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Jul 31 12:17:08 GMT-03:00 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesPeriodicidadEntregaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,idmes,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESPERIODICIDADENTREGA WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPeriodicidadEntregaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesPeriodicidadEntregaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,idmes,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM CLIENTESPERIODICIDADENTREGA"
				+ " WHERE ((IDMES::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPeriodicidadEntregaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesPeriodicidadEntregaOne(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT m.idmes, m.mes, "
				+ "       CASE WHEN pc.idmes IS NULL THEN 0 ELSE 1 END AS entregar "
				+ "  FROM globalmeses m "
				+ "       LEFT JOIN"
				+ "		( "
				+ "		SELECT cpe.idmes "
				+ "       FROM clientesperiodicidadentrega cpe "
				+ "		       INNER JOIN clientesclientes cc ON cpe.idcliente = cc.idcliente "
				+ "                   AND cpe.idempresa = cc.idempresa "
				+ "                 WHERE cc.idcliente = "
				+ idcliente.toString() + " AND cc.idempresa ="
				+ idempresa.toString() + "  ) pc ON m.idmes = pc.idmes; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPeriodicidadEntregaOne( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesPeriodicidadEntregaPK(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,idmes,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESPERIODICIDADENTREGA WHERE idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPeriodicidadEntregaPK( BigDecimal idcliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesPeriodicidadEntregaDelete(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESPERIODICIDADENTREGA WHERE idcliente="
				+ idcliente.toString()
				+ " AND idempresa = "
				+ idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESPERIODICIDADENTREGA WHERE idcliente="
						+ idcliente.toString()
						+ " AND idempresa = "
						+ idempresa.toString();
				statement.execute(cQuery);

			}

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesPeriodicidadEntregaDelete( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesPeriodicidadEntregaDelete( BigDecimal idcliente )  "
							+ ex);
		}
		return salida;
	}

	// Generacion de periricidad de entrga para clientes.
	// Borrar siempre e insertar.

	public String clientesPeriodicidadEntregaGenerar(BigDecimal idcliente,
			String[] idmes, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idmes == null || idmes.length == 0)
			salida = "Error: Por favor seleccione la Periodicidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPeriodicidadEntrega WHERE idcliente = "
					+ idcliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			// String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update

					salida = clientesPeriodicidadEntregaDelete(idcliente,
							idempresa);

				}

				for (int r = 0; r < idmes.length
						&& salida.equalsIgnoreCase("OK"); r++) {
					int i = 0;
					String ins = "INSERT INTO CLIENTESPERIODICIDADENTREGA(idcliente,idmes, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, new BigDecimal(idmes[r]));
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
					i = insert.executeUpdate();

					if (i != 1) {
						salida = "Error al insertar el mes:" + idmes[r];
					}

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesPeriodicidadEntregaGenerar(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesPeriodicidadEntregaGenerar(.....)"
							+ ex);
		}

		return salida;
	}

	/**
	 * Metodos para la entidad: bacoTmLlamados Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Mar 12 08:58:18 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoTmLlamadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idllamado,idcliente,idcampacabe,sociotelefono,idpedidoasoc,idresultado,idmotivo,"
				+ "       observaciones,fecharellamada,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM BACOTMLLAMADOS WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmLlamadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoTmLlamadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idllamado,idcliente,idcampacabe,sociotelefono,idpedidoasoc,idresultado,idmotivo,"
				+ "       observaciones,fecharellamada,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM BACOTMLLAMADOS WHERE (UPPER(IDCLIENTE) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmLlamadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoTmLlamadosPK(BigDecimal idllamado, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idllamado,idcliente,idcampacabe,sociotelefono,idpedidoasoc,idresultado,idmotivo,"
				+ "       observaciones,fecharellamada,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM BACOTMLLAMADOS WHERE idllamado="
				+ idllamado.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmLlamadosPK( BigDecimal idllamado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoTmLlamadosDelete(BigDecimal idllamado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOTMLLAMADOS WHERE idllamado="
				+ idllamado.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOTMLLAMADOS WHERE idllamado="
						+ idllamado.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoTmLlamadosDelete( BigDecimal idllamado, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoTmLlamadosDelete( BigDecimal idllamado, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoTmLlamadosCreate(BigDecimal idcliente,
			BigDecimal idcampacabe, String sociotelefono,
			BigDecimal idpedidoasoc, BigDecimal idresultado,
			BigDecimal idmotivo, String observaciones,
			java.sql.Timestamp fecharellamada, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOTMLLAMADOS(idcliente, idcampacabe, sociotelefono, idpedidoasoc, idresultado, idmotivo, observaciones, fecharellamada, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idcampacabe);
				insert.setString(3, sociotelefono);
				insert.setBigDecimal(4, idpedidoasoc);
				insert.setBigDecimal(5, idresultado);
				insert.setBigDecimal(6, idmotivo);
				insert.setString(7, observaciones);
				insert.setTimestamp(8, fecharellamada);
				insert.setBigDecimal(9, idempresa);
				insert.setString(10, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoTmLlamadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmLlamadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoTmLlamadosCreateOrUpdate(BigDecimal idllamado,
			BigDecimal idcliente, BigDecimal idcampacabe, String sociotelefono,
			BigDecimal idpedidoasoc, BigDecimal idresultado,
			BigDecimal idmotivo, String observaciones,
			java.sql.Date fecharellamada, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idllamado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idllamado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmLlamados WHERE idllamado = "
					+ idllamado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMLLAMADOS SET idcliente=?, idcampacabe=?, sociotelefono=?, idpedidoasoc=?, idresultado=?, idmotivo=?, observaciones=?, fecharellamada=?, idempresa=?, usuarioact=?, fechaact=? WHERE idllamado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcampacabe);
					insert.setString(3, sociotelefono);
					insert.setBigDecimal(4, idpedidoasoc);
					insert.setBigDecimal(5, idresultado);
					insert.setBigDecimal(6, idmotivo);
					insert.setString(7, observaciones);
					insert.setDate(8, fecharellamada);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idllamado);
				} else {
					String ins = "INSERT INTO BACOTMLLAMADOS(idcliente, idcampacabe, sociotelefono, idpedidoasoc, idresultado, idmotivo, observaciones, fecharellamada, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcampacabe);
					insert.setString(3, sociotelefono);
					insert.setBigDecimal(4, idpedidoasoc);
					insert.setBigDecimal(5, idresultado);
					insert.setBigDecimal(6, idmotivo);
					insert.setString(7, observaciones);
					insert.setDate(8, fecharellamada);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoTmLlamadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoTmLlamadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoTmLlamadosUpdate(BigDecimal idllamado,
			BigDecimal idcliente, BigDecimal idcampacabe, String sociotelefono,
			BigDecimal idpedidoasoc, BigDecimal idresultado,
			BigDecimal idmotivo, String observaciones,
			java.sql.Date fecharellamada, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idllamado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idllamado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (idresultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoTmLlamados WHERE idllamado = "
					+ idllamado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOTMLLAMADOS SET idcliente=?, idcampacabe=?, sociotelefono=?, idpedidoasoc=?, idresultado=?, idmotivo=?, observaciones=?, fecharellamada=?, idempresa=?, usuarioact=?, fechaact=? WHERE idllamado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idcampacabe);
					insert.setString(3, sociotelefono);
					insert.setBigDecimal(4, idpedidoasoc);
					insert.setBigDecimal(5, idresultado);
					insert.setBigDecimal(6, idmotivo);
					insert.setString(7, observaciones);
					insert.setDate(8, fecharellamada);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idllamado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoTmLlamadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoTmLlamadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * END - Llamados Telemarketing
	 */

	public List getCampaniaLovAll(long limit, long offset) throws EJBException {

		String cQuery = "SELECT idcampacabe,campacabe FROM bacotmcampacabe ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCampaniaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getCampaniaLovOcu(long limit, long offset, String ocurrencia)
			throws EJBException {

		String cQuery = "SELECT idcampacabe,campacabe FROM bacotmcampacabe "
				+ " where (idcampacabe::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(campacabe) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') " + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCampaniaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getCosnultaCumpleanioProspecto(long limit, long offset,
			String fdesde, String fhasta, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select idprecarga,razon,fechadenacimiento from clientesprecargaclientes"
				+ " where fechadenacimiento between '"
				+ fdesde.toString()
				+ "' and '"
				+ fhasta.toString()
				+ "' and idempresa ="
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCampaniaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// consulta de fecha de ingreso de Prospecto
	public List getCosnultaIngresoProspecto(long limit, long offset,
			String fdesde, BigDecimal idempresa) throws EJBException {

		String cQuery = "select idprecarga,razon from clientesprecargaclientes"
				+ " where fechadeingreso between '" + fdesde.toString()
				+ "' and '" + fdesde.toString() + "' and idempresa ="
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaCumpleanioProspecto()  "
							+ ex);
		}
		return vecSalida;
	}

	// consulta socio prospecto
	public List getCosnultaSocioProspecto(long limit, long offset,
			String sdesde, String shasta, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select idprecarga,razon from clientesprecargaclientes"
				+ " where idprecarga between '" + sdesde.toString() + "' and '"
				+ shasta.toString() + "' and idempresa ="
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaSocioProspecto()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: stockstock - clienteslistasdeprecios desde
	 * lovArticulosListaPreciosPedidos.jsp Copyrigth(r) utilizada para registrar
	 * captura de documentos sysWarp S.R.L. Fecha de creacion: Wed Aug 27
	 * 11:20:13 GMT-03:00 2008
	 */

	public List getArtListaPreciosPedidosAll(long limit, long offset,
			BigDecimal idlista, BigDecimal idzona, String conExistencia,
			String soloCampania, BigDecimal idcampacabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, lp.precio, lp.precio, "
				// +
				// "       st.ultcomp_st, st.cuencom_st, st.serializable, st.numeroserie, "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '' AS posicionDisponibleExNroSerie, "
				+ "       de.codigo_dt, de.descrip_dt, "
				+ "       COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, COALESCE(sb.pedid_sb::numeric(18), 0)AS reserva,  "
				+ "       st.oid AS tupla, "
				// 20120314- EJV - Mantis 702 -->
				+ "       COALESCE(brc.puntaje, 0) refpuntaje, COALESCE(brc.comprometido, 0) refcomprometido, COALESCE(brc.utilizado, 0) refutilizado, "
				// <--
				+ "       st.idempresa "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "       INNER JOIN stockdepositos de ON de.idempresa = "
				+ idempresa.toString()
				+ "       INNER JOIN clienteszonasdepositos dz ON de.codigo_dt = dz.codigo_dt AND  de.idempresa = dz.idempresa "
				+ "              AND dz.idzona = "
				+ idzona.toString()
				// -->
				+ (soloCampania.equalsIgnoreCase("S") ? "       INNER JOIN bacotmcampadeta cd ON st.codigo_st = cd.codigo_st AND st.idempresa = cd.idempresa AND cd.idcampacabe = "
						+ idcampacabe.toString()
						: "")
				// <--
				+ "        LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb "
				+ "              AND st.idempresa = sb.idempresa "
				// 20120314- EJV - Mantis 702 -->
				+ "        LEFT JOIN bacorefcatalogo brc ON st.codigo_st = brc.codigo_st AND st.idempresa = brc.idempresa "
				+ "                AND current_date BETWEEN fechadesde AND fechahasta AND brc.fechabaja IS NULL "
				// <--
				+ "  WHERE st.idempresa = "
				+ idempresa.toString()
				+ "    AND lp.idlista = "
				+ idlista.toString()
				+ (conExistencia.equals("S") ? " AND  sb.canti_sb IS NOT NULL AND sb.canti_sb > 0 "
						: "")
				+ " AND de.codigo_dt NOT IN (SELECT codigo_dt FROM stockdepositoslockregalos WHERE current_date BETWEEN fechadesde AND fechahasta  AND fechabaja IS NULL  AND idempresa = "
				+ idempresa + ") ORDER BY 2  LIMIT " + limit + " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosPedidosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getArtListaPreciosPedidosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idlista, BigDecimal idzona,
			String conExistencia, String soloCampania, BigDecimal idcampacabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, lp.precio, lp.precio, "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '', "
				+ "       de.codigo_dt, de.descrip_dt, "
				+ "       COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, COALESCE(sb.pedid_sb::numeric(18), 0) AS reserva, "
				+ "       st.oid AS tupla,  "
				// + "       st.oid AS tupla, "
				// 20120314- EJV - Mantis 702 -->
				+ "       COALESCE(brc.puntaje, 0) refpuntaje, COALESCE(brc.comprometido, 0) refcomprometido, COALESCE(brc.utilizado, 0) refutilizado, "
				// <--
				+ "       st.idempresa "

				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "       INNER JOIN stockdepositos de ON de.idempresa =  "
				+ idempresa.toString()
				+ "       INNER JOIN clienteszonasdepositos dz ON de.codigo_dt = dz.codigo_dt AND  de.idempresa = dz.idempresa "
				+ "              AND dz.idzona = "
				+ idzona.toString()
				// -->
				+ (soloCampania.equalsIgnoreCase("S") ? "       INNER JOIN bacotmcampadeta cd ON st.codigo_st = cd.codigo_st AND st.idempresa = cd.idempresa AND cd.idcampacabe = "
						+ idcampacabe.toString()
						: "")
				// <--
				// 20120314- EJV - Mantis 702 -->
				+ "        LEFT JOIN bacorefcatalogo brc ON st.codigo_st = brc.codigo_st AND st.idempresa = brc.idempresa "
				+ "                AND current_date BETWEEN fechadesde AND fechahasta AND brc.fechabaja IS NULL "
				// <--
				+ "        LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb "
				+ "              AND st.idempresa = sb.idempresa "
				+ " WHERE (UPPER(st.codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'"
				+ "    OR UPPER(st.descrip_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND st.idempresa = "
				+ idempresa.toString()
				+ " AND lp.idlista = "
				+ idlista.toString()
				+ (conExistencia.equals("S") ? " AND  sb.canti_sb IS NOT NULL AND sb.canti_sb > 0 "
						: "")
				+ " AND de.codigo_dt NOT IN (SELECT codigo_dt FROM stockdepositoslockregalos WHERE current_date BETWEEN fechadesde AND fechahasta  AND fechabaja IS NULL  AND idempresa = "
				+ idempresa
				+ ") ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosPedidosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// 20101124 - EJV - Mantis 602 -->

	public List getArtListaPreciosPedidosRegalosAll(long limit, long offset,
			BigDecimal idlista, BigDecimal idzona, String conExistencia,
			String soloCampania, BigDecimal idcampacabe, boolean exsiteLock,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, lp.precio, lp.precio, "
				// +
				// "       st.ultcomp_st, st.cuencom_st, st.serializable, st.numeroserie, "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '' AS posicionDisponibleExNroSerie, "
				+ "       de.codigo_dt, de.descrip_dt, "
				+ "       COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, COALESCE(sb.pedid_sb::numeric(18), 0)AS reserva,  "
				+ "       st.oid AS tupla, st.idempresa "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "       INNER JOIN stockdepositos de ON de.idempresa = "
				+ idempresa.toString()
				+ "       INNER JOIN clienteszonasdepositos dz ON de.codigo_dt = dz.codigo_dt AND  de.idempresa = dz.idempresa "
				+ "              AND dz.idzona = "
				+ idzona.toString()
				// -->
				+ (soloCampania.equalsIgnoreCase("S") ? "       INNER JOIN bacotmcampadeta cd ON st.codigo_st = cd.codigo_st AND st.idempresa = cd.idempresa AND cd.idcampacabe = "
						+ idcampacabe.toString()
						: "")
				// <--
				+ "        LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb "
				+ "              AND st.idempresa = sb.idempresa "
				+ "  WHERE st.idempresa = "
				+ idempresa.toString()
				+ "    AND lp.idlista = "
				+ idlista.toString()
				+ (conExistencia.equals("S") ? " AND  sb.canti_sb IS NOT NULL AND sb.canti_sb > 0 "
						: "")
				+ (exsiteLock ? " AND de.codigo_dt  IN (SELECT codigo_dt FROM stockdepositoslockregalos WHERE current_date BETWEEN fechadesde AND fechahasta  AND fechabaja IS NULL  AND idempresa = "
						+ idempresa + ")  "
						: "") + "    ORDER BY 2  LIMIT " + limit + " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosPedidosRegalosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getArtListaPreciosPedidosRegalosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idlista, BigDecimal idzona,
			String conExistencia, String soloCampania, BigDecimal idcampacabe,
			boolean exsiteLock, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, lp.precio, lp.precio, "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '', "
				+ "       de.codigo_dt, de.descrip_dt, "
				+ "       COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, COALESCE(sb.pedid_sb::numeric(18), 0) AS reserva, "
				+ "       st.oid AS tupla, st.idempresa "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "       INNER JOIN stockdepositos de ON de.idempresa =  "
				+ idempresa.toString()
				+ "       INNER JOIN clienteszonasdepositos dz ON de.codigo_dt = dz.codigo_dt AND  de.idempresa = dz.idempresa "
				+ "              AND dz.idzona = "
				+ idzona.toString()
				// -->
				+ (soloCampania.equalsIgnoreCase("S") ? "       INNER JOIN bacotmcampadeta cd ON st.codigo_st = cd.codigo_st AND st.idempresa = cd.idempresa AND cd.idcampacabe = "
						+ idcampacabe.toString()
						: "")
				// <--
				+ "        LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb "
				+ "              AND st.idempresa = sb.idempresa "
				+ " WHERE (UPPER(st.codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'"
				+ "    OR UPPER(st.descrip_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND st.idempresa = "
				+ idempresa.toString()
				+ " AND lp.idlista = "
				+ idlista.toString()
				+ (conExistencia.equals("S") ? " AND  sb.canti_sb IS NOT NULL AND sb.canti_sb > 0 "
						: "")
				+ (exsiteLock ? " AND de.codigo_dt  IN (SELECT codigo_dt FROM stockdepositoslockregalos WHERE current_date BETWEEN fechadesde AND fechahasta  AND fechabaja IS NULL  AND idempresa = "
						+ idempresa + ")  "
						: "")
				+ "    ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosPedidosRegalosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotaLockRegalos(BigDecimal idempresa) throws EJBException {

		long total = -1l;
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM  stockdepositoslockregalos  WHERE current_date BETWEEN fechadesde AND fechahasta AND fechabaja IS NULL AND idempresa="
				+ idempresa.toString();
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidad()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			total = -2;
			log.error("getTotaLockRegalos()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			total = -3;
			log.error("getTotaLockRegalos()- Salida por exception: " + ex);
		}
		return total;
	}

	// <--

	// por primary key (primer campo por defecto)

	public List getArtListaPreciosPedidosPK(String codigo_st,
			BigDecimal idlista, BigDecimal codigo_dt, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st,  "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, lp.precio, "
				+ "       COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, "
				+ "       COALESCE(pedid_sb::numeric(18), 0) AS reserva , "
				+ "       de.codigo_dt as deposito, 1 as cantidad, 0 as total, "
				+ "       st.cuencom_st, st.unimed_st,  "
				+ "       st.cuenven_st, st.cuenve2_st, st.cuencos_st,  "
				+ "       0 AS iddescuento_suge,0 AS iddescuento_apli,0 AS porcdesc_suge,"
				+ "       0 AS porcdesc_apli, 0 AS idmotivodescuento, de.descrip_dt,  "
				+ "       COALESCE(si.idstockiva, -1) AS idstockiva, COALESCE(si.porcentaje,0.00) AS porcentaje, "
				+ "       COALESCE(si.tipoexen_grav, 'G'), 0.00 AS porciva_st, 0.00 AS totaliva_st, "
				+ "       COALESCE(sb.canti_sb::NUMERIC(18, 2), 0.00) AS canti_sb, COALESCE(sb.pedid_sb::NUMERIC(18, 2), 0.00) AS pedid_sb,"
				+ "       st.inventa_st, COALESCE(fm.codigo_fm, -1) AS codigo_fm, COALESCE(fm.descrip_fm, '') AS descrip_fm, 'true' AS flagLoad  "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "       INNER JOIN stockdepositos de ON de.idempresa = "
				+ idempresa.toString()
				+ "        LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb "
				+ "              AND st.idempresa = sb.idempresa "
				+ "        LEFT JOIN stockiva si ON st.tipoiva_st = si.idstockiva AND st.idempresa = si.idempresa"
				+ "        LEFT JOIN stockgrupos gr ON st.grupo_st = gr.codigo_gr AND st.idempresa = gr.idempresa"
				+ "        LEFT JOIN stockfamilias fm ON gr.codigo_fm = fm.codigo_fm AND gr.idempresa = fm.idempresa"
				+ " WHERE st.codigo_st='" + codigo_st + "'"
				+ "   AND lp.idlista = " + idlista.toString()
				+ "   AND de.codigo_dt = " + codigo_dt.toString()
				+ "   AND st.idempresa = " + idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosPedidosPK( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getArtListaPreciosAll(long limit, long offset,
			BigDecimal idlista, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio, "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '', "
				+ "       st.idempresa "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "  WHERE st.idempresa = " + idempresa.toString()
				+ "    AND lp.idlista = " + idlista.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getArtListaPreciosOcu(long limit, long offset,
			BigDecimal idlista, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st, st.alias_st, st.descrip_st, st.descri2_st, "
				+ "       COALESCE(st.bonific_st, 0)AS porcdesc, lp.precio,  "
				+ "       st.ultcomp_st, st.cuencom_st, st.id_indi_st AS serializable, '', "
				+ "       st.idempresa "
				+ "  FROM stockstock st "
				+ "       INNER JOIN clienteslistasdeprecios lp ON st.codigo_st = lp.codigo_st  AND st.idempresa = lp.idempresa "
				+ "  WHERE st.idempresa = " + idempresa.toString()
				+ "    AND lp.idlista = " + idlista.toString()
				+ " AND ( UPPER(st.codigo_st)LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%' OR UPPER(st.descrip_st)LIKE '%"
				+ ocurrencia.toUpperCase() + "%'   )" + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getArtListaPreciosOcu()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesDescuentosAll(BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT iddescuento,por_desc,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM clientesdescuentos WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2;";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDescuentosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * TODO: stockStockBisCantidadPedidosUpdate .............................
	 * EJV - 20080828 - .....................................................
	 * COMENTARIOS: Invocado en la generacion de pedidos. ...................
	 * Finalidad, dejar reflejado el compromiso de mercaderia en el campo: ..
	 * PEDID_SB. ............................................................
	 * 
	 */

	/*
	 * TODO: 20091001 - EJV REPLICADO EN INTERFACES :
	 * BCBean.stockStockBisCantPediCreateUpdate
	 */

	public String[] stockStockBisCantPediCreateUpdate(String articu_sb,
			BigDecimal deposi_sb, BigDecimal pedid_sb, String usuarioact,
			BigDecimal idempresa, Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String[] resultado = new String[] { "", "" };
		String salida = "OK";
		String alerta = "";
		String qDML = "";
		BigDecimal totalExistencia = new BigDecimal(0);
		BigDecimal totalRemananente = new BigDecimal(0);
		List listDep = new ArrayList();
		String[] datosDep = new String[] { "", "", "", "" };
		// validaciones de datos:
		// 1. nulidad de campos
		if (articu_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: articu_sb ";
		if (deposi_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: deposi_sb ";
		if (pedid_sb == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: pedid_sb ";

		// 2. sin nada desde la pagina
		if (articu_sb.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: articu_sb ";
		// fin validaciones

		try {

			PreparedStatement statement = null;
			listDep = getStockDepositosPk(deposi_sb, idempresa);
			if (!listDep.isEmpty())
				datosDep = (String[]) listDep.get(0);

			totalExistencia = GeneralBean.getCantidadArticuloDeposito(
					articu_sb, deposi_sb, idempresa, conn);
			totalRemananente = totalExistencia.subtract(pedid_sb);

			if (!GeneralBean.hasStockNegativo(idempresa, dbconn)
			// && totalRemananente.longValue() >= 0)!!!! WHAT IT THIS???
					&& totalRemananente.longValue() < 0)
				salida = "Cantidad disponible existente insuficiente: "
						+ totalExistencia + " para art." + articu_sb
						+ " en dep. " + datosDep[1];

			if (salida.equalsIgnoreCase("OK")) {

				if (!GeneralBean.getExisteArticuloDeposito(articu_sb,
						deposi_sb, idempresa, conn)) {

					qDML = "INSERT INTO stockstockbis (articu_sb,deposi_sb,canti_sb,serie_sb,despa_sb,pedid_sb,usuarioalt, idempresa)";
					qDML += " VALUES (?,?,?,?,?,?,?,?)";
					statement = dbconn.prepareStatement(qDML);
					statement.clearParameters();
					statement.setString(1, articu_sb);
					statement.setBigDecimal(2, deposi_sb);
					statement.setBigDecimal(3, pedid_sb.negate());
					statement.setString(4, null);
					statement.setString(5, null);
					statement.setBigDecimal(6, pedid_sb);
					statement.setString(7, usuarioact);
					statement.setBigDecimal(8, idempresa);

					alerta = "#[Articulo:(" + articu_sb + ") - Deposito:("
							+ deposi_sb + "-" + datosDep[1] + ")].";

				} else {

					if (totalRemananente.compareTo(new BigDecimal(0)) < 0) {
						alerta = "#[Articulo:(" + articu_sb + ")-Deposito:("
								+ deposi_sb + "-" + datosDep[1] + ")].";
					}

					qDML = " UPDATE stockstockbis ";
					qDML += "   SET canti_sb=(canti_sb+?),pedid_sb=(pedid_sb+?),usuarioact=?,fechaact=?";
					qDML += " WHERE articu_sb=? AND deposi_sb=?  AND idempresa=?";
					statement = conn.prepareStatement(qDML);
					statement.clearParameters();

					statement.clearParameters();
					statement.setBigDecimal(1, pedid_sb.negate());
					statement.setBigDecimal(2, pedid_sb);
					statement.setString(3, usuarioact);
					statement.setTimestamp(4, fechaact);
					statement.setString(5, articu_sb);
					statement.setBigDecimal(6, deposi_sb);
					statement.setBigDecimal(7, idempresa);

				}

				int i = statement.executeUpdate();

				if (i != 1) {
					salida = "Fallo Actutualizacion para Articulo ("
							+ articu_sb + "), en deposito (" + deposi_sb + "-"
							+ datosDep[1] + ").";
				}
			}

		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String stockStockBisCantPediCreateUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String stockStockBisCantPediCreateUpdate(.....)"
							+ ex);
		}

		resultado = new String[] { salida, alerta };
		return resultado;
	}

	/**
	 * Metodos para la entidad: stockStockBis Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Aug 28 17:41:57 GMT-03:00 2008
	 * 
	 */

	public List getStockDepositoArticulo(String articu_sb,
			BigDecimal deposi_sb, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				// + "SELECT canti_sb, pedid_sb, canti_sb-pedid_sb AS remanente"
				+ "SELECT canti_sb, pedid_sb, canti_sb AS remanente"
				+ "  FROM STOCKSTOCKBIS WHERE articu_sb='"
				+ articu_sb.toString() + "'  AND deposi_sb="
				+ deposi_sb.toString() + "   AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getStockDepositoArticulo( ... )  "
							+ ex);
		}

		return vecSalida;
	}

	// PEDIDOS MOTIVOS DESCUENTOS
	public List getPedidosMotivosDescuentosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idmotivodescuento,motivodescuento,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM pedidosmotivosdescuento WHERE idempresa= "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosMotivosDescuentosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesZonasDepositos Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Sep 02 17:40:20 GMT-03:00 2008
	 */

	public String clientesZonasDepositosGenerar(BigDecimal idzona,
			String[] codigo_dt, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idzona ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clienteszonasdepositos WHERE idzona = "
					+ idzona.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update

					salida = clientesZonasDepositosDelete(idzona, idempresa);

				}

				for (int r = 0; codigo_dt != null && r < codigo_dt.length
						&& salida.equalsIgnoreCase("OK"); r++) {
					int i = 0;
					String ins = "INSERT INTO clienteszonasdepositos(idzona, codigo_dt, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idzona);
					insert.setBigDecimal(2, new BigDecimal(codigo_dt[r]));
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
					i = insert.executeUpdate();

					if (i != 1) {
						salida = "Error al insertar el deposito:"
								+ codigo_dt[r];
					}

				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesZonasDepositosGenerar(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesZonasDepositosGenerar(.....)"
							+ ex);
		}

		return salida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesZonasDepositosOne(BigDecimal idzona,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT dt.codigo_dt, dt.descrip_dt, CASE WHEN dz.codigo_dt IS NULL THEN 0 ELSE 1 END AS asociado, dt.idempresa "
				+ "  FROM stockdepositos dt "
				+ "       LEFT JOIN ( "
				+ "                  SELECT z.idzona, z.zona, zd.codigo_dt, z.idempresa "
				+ "                    FROM clienteszonas z  "
				+ "                         INNER JOIN clienteszonasdepositos zd "
				+ "                                 ON z.idzona = zd.idzona "
				+ "                                AND z.idempresa = zd.idempresa AND  z.idzona =  "
				+ idzona.toString()
				+ "                 ) dz ON dt.codigo_dt = dz.codigo_dt "
				+ "                     AND dt.idempresa = dz.idempresa WHERE dt.idempresa =  "
				+ idempresa.toString() + "ORDER BY 2; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesZonasDepositosOne(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesZonasDepositosDelete(BigDecimal idzona,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESZONASDEPOSITOS WHERE idzona="
				+ idzona.toString() + " AND idempresa=" + idempresa.toString();
		String salida = "OK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESZONASDEPOSITOS WHERE idzona="
						+ idzona.toString() + " AND idempresa="
						+ idempresa.toString();

				statement.execute(cQuery);

			}

		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesZonasDepositosDelete( ... ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesZonasDepositosDelete( ... )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesZonasDepositosCreate(BigDecimal codigo_dt,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESZONASDEPOSITOS(codigo_dt, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, codigo_dt);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesZonasDepositosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesZonasDepositosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * TODO: 20091001 - EJV REPLICADO EN BCBean :
	 * ClientesBean.getStockDepositosPk
	 */

	public List getStockDepositosPk(BigDecimal codigo_dt, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT dt.codigo_dt,dt.descrip_dt,dt.direc_dt,dt.factura_dt "
				+ "  FROM stockdepositos dt " + " WHERE dt.idempresa = "
				+ idempresa.toString() + "   AND dt.codigo_dt = "
				+ codigo_dt.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getStockDepositosPk(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getStockDepositosXZona(BigDecimal idzona, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ " SELECT dt.codigo_dt,dt.descrip_dt,dt.direc_dt,dt.factura_dt,dt.usuarioalt,dt.usuarioact,dt.fechaalt,dt.fechaact "
				+ "  FROM stockdepositos dt "
				+ "       INNER JOIN clienteszonasdepositos zd  ON dt.codigo_dt = zd.codigo_dt AND dt.idempresa = zd.idempresa "
				+ " WHERE zd.idempresa = " + idempresa.toString()
				+ "   AND zd.idzona = " + idzona.toString() + " ORDER BY 2;";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getStockDepositosXZona(...)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: pedidosCuotas Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Wed Sep 03 17:38:57 GMT-03:00 2008
	 * 
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosCuotasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcuota,nrocuotas,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM PEDIDOSCUOTAS WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosCuotasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosCuotasOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcuota,nrocuotas,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM pedidoscuotas WHERE ((NROCUOTAS::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosCuotasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosCuotasPK(BigDecimal idcuota, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idcuota,nrocuotas,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM PEDIDOSCUOTAS WHERE idcuota=" + idcuota.toString()
				+ " AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosCuotasPK( BigDecimal idcuota )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosCuotasDelete(BigDecimal idcuota, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSCUOTAS WHERE idcuota="
				+ idcuota.toString() + " AND idempresa=" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSCUOTAS WHERE idcuota="
						+ idcuota.toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosCuotasDelete( BigDecimal idcuota ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosCuotasDelete( BigDecimal idcuota )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosCuotasCreate(BigDecimal nrocuotas,
			String observaciones, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrocuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocuotas ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina

		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSCUOTAS(nrocuotas, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, nrocuotas);
				insert.setString(2, observaciones);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String pedidosCuotasCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosCuotasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosCuotasCreateOrUpdate(BigDecimal idcuota,
			BigDecimal nrocuotas, String observaciones, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcuota == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcuota ";
		if (nrocuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocuotas ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosCuotas WHERE idcuota = "
					+ idcuota.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSCUOTAS SET nrocuotas=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcuota=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, nrocuotas);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcuota);
				} else {
					String ins = "INSERT INTO PEDIDOSCUOTAS(nrocuotas, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, nrocuotas);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosCuotasCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosCuotasCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosCuotasUpdate(BigDecimal idcuota, BigDecimal nrocuotas,
			String observaciones, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcuota == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcuota ";
		if (nrocuotas == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrocuotas ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosCuotas WHERE idcuota = "
					+ idcuota.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSCUOTAS SET nrocuotas=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcuota=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, nrocuotas);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcuota);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String pedidosCuotasUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosCuotasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizo la tabla de precarga le ingreso el numero de socio
	public String ClientesActualizar(BigDecimal prospecto,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campo
		boolean bError = true;
		if (salida.equalsIgnoreCase("OK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPrecargaclientes WHERE idprecarga = "
					+ prospecto.toString()
					+ " and idcliente is null"
					+ " and idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE clientesPrecargaclientes SET idcliente=? WHERE idprecarga=? and idempresa =?;";

					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, prospecto);
					insert.setBigDecimal(3, idempresa);
				}

				int i = insert.executeUpdate();
				// if (i == 0)
				// salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String ClientesActualizar(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String ClientesActualizar(.....)"
					+ ex);
		}
		return salida;
	}

	public List getClientesestadosclientesXClienteAll(BigDecimal idcliente,
			long limit, long offset, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,CEC.fechahasta,"
				+ "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,"
				+ "       CEC.fbaja,CEC.observaciones,CEC.usuarioalt,CEC.usuarioact,CEC.fechaalt,CEC.fechaact"
				+ "  FROM CLIENTESESTADOSCLIENTES CEC "
				+ "       INNER JOIN clientesclientes CLI  ON (CEC.idcliente = CLI.idcliente and CEC.idempresa   = CLI.idempresa ) "
				+ "       INNER JOIN clientesestados CE ON (CEC.idestado  = CE.idestado and CEC.idempresa    = CE.idempresa)"
				+ "       INNER JOIN clientesmotivos CM ON (CEC.idmotivo  = CM.idmotivo and CEC.idempresa   = CM.idempresa )"
				+ " WHERE CEC.idempresa= " + idempresa.toString()
				+ " and CEC.idcliente = " + idcliente.toString()
				+ "ORDER BY CEC.fechadesde DESC, CEC.fechaact ASC  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosclientesXClienteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/*
	 * 
	 * public long getTotalEntidadXCliente(BigDecimal idcliente, String entidad,
	 * BigDecimal idempresa) throws EJBException {
	 * 
	 * /** Entidad: Total Registros de Una Entidad en Particular
	 * 
	 * @ejb.interface-method view-type = "remote"
	 * 
	 * @throws SQLException Thrown if method fails due to system-level error.
	 * Utilidad : recuperar total de registros. / long total = 0l; ResultSet
	 * rsSalida = null; String cQuery = "SELECT count(1)AS total FROM " +
	 * entidad + " WHERE idempresa=" + idempresa.toString() + " and idcliente ="
	 * + idcliente.toString(); try { Statement statement =
	 * dbconn.createStatement(); rsSalida = statement.executeQuery(cQuery); if
	 * (rsSalida.next()) { total = rsSalida.getLong("total"); } else { log
	 * .warn("getTotalEntidadXCliente()- Error al recuperar total: " + entidad);
	 * } } catch (SQLException sqlException) {
	 * log.error("getTotalEntidadXCliente()- Error SQL: " + sqlException); }
	 * catch (Exception ex) {
	 * log.error("getTotalEntidadXCliente()- Salida por exception: " + ex); }
	 * return total; }
	 */

	public List getClientesestadosclientesXClienteOcu(BigDecimal idcliente,
			long limit, long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = " "
				// 20090722 EJV - Normalizar Estados como VB6BACO
				// +
				// "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,CEC.fechahasta,"
				+ "SELECT CEC.idestadocliente,CLI.idcliente,CLI.razon,CE.estado,CM.motivo,CEC.fechadesde,"
				+ "       CEC.fbaja,CEC.observaciones,CEC.usuarioalt,CEC.usuarioact,CEC.fechaalt,CEC.fechaact"
				+ "  FROM CLIENTESESTADOSCLIENTES CEC "
				+ "       INNER JOIN clientesclientes CLI  ON (CEC.idcliente = CLI.idcliente and CEC.idempresa   = CLI.idempresa ) "
				+ "       INNER JOIN clientesestados CE ON (CEC.idestado  = CE.idestado and CEC.idempresa    = CE.idempresa)"
				+ "       INNER JOIN clientesmotivos CM ON (CEC.idmotivo  = CM.idmotivo and CEC.idempresa   = CM.idempresa )"
				+ " WHERE CEC.idempresa= " + idempresa.toString()
				+ " and CEC.idcliente = " + idcliente.toString()
				+ "   AND (CEC.idcliente::VARCHAR LIKE '%" + ocurrencia
				+ "%' OR " + " UPPER(CLI.razon) LIKE '%"
				+ ocurrencia.toUpperCase() + "%') "
				+ " ORDER BY CEC.fechadesde DESC, CEC.fechaact ASC    LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesestadosclientesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public String ClientesInsertoEstadoInicial(BigDecimal idcliente,
			BigDecimal idestado, BigDecimal idmotivo, String observaciones,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "OK";
		Calendar hoy = new GregorianCalendar();
		java.sql.Date fechadesde = new java.sql.Date(hoy.getTime().getTime());
		boolean bError = true;
		try {
			if (bError) {
				String ins = "INSERT INTO CLIENTESESTADOSCLIENTES(idcliente, idestado, idmotivo, fechadesde, observaciones, usuarioalt,idempresa ) VALUES (?,?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idestado);
				insert.setBigDecimal(3, idmotivo);
				insert.setDate(4, fechadesde);
				insert.setString(5, observaciones);
				insert.setString(6, usuarioalt);
				insert.setBigDecimal(7, idempresa);
				int n = insert.executeUpdate();
				log
						.info("actualizando estado inicial del cliente a: " + n
								+ "");
				salida = setClientesEstadosHoyCliente(idcliente, idempresa,
						dbconn);
			}

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar estado inicial.";
			log
					.error("Error SQL public String clientesestadosclientesCreate(.....)"
							+ sqlException);
			// salida = "NOOK";
		} catch (Exception ex) {
			// salida = "NOOK";
			salida = "(EX)Imposible generar estado inicial.";
			log
					.error("Error excepcion public String clientesestadosclientesCreate(.....)"
							+ ex);
			// salida = "NOOK";
		}
		return salida;
	}

	public List getClientesCampaiaLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		Calendar hoy = new GregorianCalendar();
		java.sql.Date fecha = new java.sql.Date(hoy.getTime().getTime());
		String cQuery = "SELECT idcampacabe,campacabe,fDesde,fHasta FROM bacotmcampacabe "
				+ " where fHasta::date >= "
				+ "'"
				+ fecha
				+ "'"
				+ " and idempresa = "
				+ idempresa
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCampaiaLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesCampaniaLovOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		Calendar hoy = new GregorianCalendar();
		Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = "SELECT idcampacabe,campacabe,fDesde,fHasta FROM bacotmcampacabe "
				+ " where fHasta >= "
				+ "'"
				+ fecha
				+ "'"
				+ " and idempresa = "
				+ idempresa
				+ " and (idcampacabe::VARCHAR LIKE '%"
				+ ocurrencia
				+ "%' OR "
				+ " UPPER(campacabe) LIKE '%"
				+ ocurrencia.toUpperCase()
				+ "%') "
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCampanaLovOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// distinto de resultado <> 4 resultado is not null
	public List getClientesTMllamados1(long limit, long offset,
			BigDecimal idempresa, BigDecimal idresultado,
			BigDecimal idcampania, long idusuario, String usuarioalt)
			throws EJBException {

		// Calendar hoy = new GregorianCalendar();
		// Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = " select "
				+ " LL.idLlamado,"
				+ " LL.idcliente,"
				+ " SO.razon  as nombre,"
				+ " LL.socioTelefono,"
				+ " LL.fechaInicio,"
				+ " LL.fechaFin,"
				+ " LL.fechaRellamada,"
				+ " SEH.estado as estado,"
				+ " SEH.motivo as motivo,"
				+ " LL.usuarioalt,"
				+ " LL.usuarioact,"
				+ " LL.fechaalt,"
				+ " LL.fechaact,"
				+ " LL.observaciones"
				+ " FROM "
				+ " bacotmllamados LL, "
				+ " clientesclientes SO,"
				+ " vclientesestadoshoy SEH "
				+ " WHERE "
				+ " LL.idcliente = so.idcliente "
				+ " and LL.idcliente = SEH.idcliente "
				+ " and LL.idResultado = "
				+ idresultado.toString()
				+ " and LL.idCampaCabe = "
				+ idcampania.toString()
				+ " and LL.usuarioalt = "
				+ idusuario
				+ " and LL.idLlamado = (SELECT MAX(idLlamado) FROM bacotmllamados WHERE idcliente = LL.idcliente and idCampaCabe = "
				+ idcampania + " and usuarioalt = " + "'" + usuarioalt + "')"
				+ " and LL.idempresa = " + idempresa + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTMllamados1()  "
							+ ex);
		}
		return vecSalida;
	}

	public long getusuarioxdescripcion(BigDecimal idempresa, String usuario)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 01;
		ResultSet rsSalida = null;
		String cQuery = " SELECT idusuario as total  FROM globalusuarios "
				+ " WHERE idempresa=" + idempresa.toString() + " and usuario ="
				+ "'" + usuario.toString() + "'";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log
						.warn("getusuarioxdescripcion()- Error al recuperar total: ");
			}
		} catch (SQLException sqlException) {
			log.error("getusuarioxdescripcion()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getusuarioxdescripcion()- Salida por exception: " + ex);
		}
		return total;
	}

	// distinto de resultado <> 4 resultado is null
	public List getClientesTMllamados2(long limit, long offset,
			BigDecimal idempresa, BigDecimal idcampania, long idusuario,
			String usuarioalt) throws EJBException {

		// Calendar hoy = new GregorianCalendar();
		// Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = " select "
				+ " LL.idLlamado,"
				+ " LL.idcliente,"
				+ " SO.razon  as nombre,"
				+ " LL.socioTelefono,"
				+ " LL.fechaInicio,"
				+ " LL.fechaFin,"
				+ " LL.fechaRellamada,"
				+ " SEH.estado as estado,"
				+ " SEH.motivo as motivo,"
				+ " LL.usuarioalt,"
				+ " LL.usuarioact,"
				+ " LL.fechaalt,"
				+ " LL.fechaact,"
				+ " LL.observaciones"
				+ " FROM "
				+ " bacotmllamados LL, "
				+ " clientesclientes SO,"
				+ " vclientesestadoshoy SEH "
				+ " WHERE "
				+ " LL.idcliente = so.idcliente "
				+ " and LL.idcliente = SEH.idcliente "
				+ " and LL.idCampaCabe = "
				+ idcampania.toString()
				+ " and LL.usuarioalt = "
				+ idusuario
				+ " and LL.idLlamado = (SELECT MAX(idLlamado) FROM bacotmllamados WHERE idcliente = LL.idcliente and idCampaCabe = "
				+ idcampania + " and usuarioalt = " + "'" + usuarioalt + "')"
				+ " and LL.idempresa = " + idempresa + " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTMllamados1()  "
							+ ex);
		}
		return vecSalida;
	}

	// resultado == 4
	public List getClientesTMllamados3(long limit, long offset,
			BigDecimal idempresa, BigDecimal idresultado,
			BigDecimal idcampania, long idusuario, String usuarioalt)
			throws EJBException {

		Calendar hoy = new GregorianCalendar();
		Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = " select " + " LL.idLlamado," + " LL.idcliente,"
				+ " SO.razon  as nombre," + " LL.socioTelefono,"
				+ " LL.fechaInicio," + " LL.fechaFin," + " LL.fechaRellamada,"
				+ " SEH.estado as estado," + " SEH.motivo as motivo,"
				+ " LL.usuarioalt," + " LL.usuarioact," + " LL.fechaalt,"
				+ " LL.fechaact," + " LL.observaciones" + " FROM "
				+ " bacotmllamados LL, " + " clientesclientes SO,"
				+ " vclientesestadoshoy SEH " + " WHERE "
				+ " LL.idcliente = so.idcliente "
				+ " and LL.idcliente = SEH.idcliente "
				+ " and LL.idResultado = "
				+ idresultado.toString()
				+ " and LL.idCampaCabe = "
				+ idcampania.toString()
				+ " and LL.usuarioalt = "
				+ idusuario
				+ " and  LL.fechaRellamada <= "
				+ "'"
				+ fecha
				+ "'"
				+ " and LL.idLlamado = (SELECT MAX(idLlamado) FROM bacotmllamados WHERE idcliente = LL.idcliente and idCampaCabe = "
				+ idcampania
				+ " and usuarioalt = "
				+ "'"
				+ usuarioalt
				+ "')"
				+ " and LL.idempresa = "
				+ idempresa
				+ " ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTMllamados1()  "
							+ ex);
		}
		return vecSalida;
	}

	public long getTotalEntidadXFecha(String entidad, BigDecimal idempresa)
			throws EJBException {

		/**
		 * Entidad: Total Registros de Una Entidad en Particular
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : recuperar total de registros.
		 */
		long total = 0l;
		ResultSet rsSalida = null;
		Calendar hoy = new GregorianCalendar();
		Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = "SELECT count(1)AS total FROM " + entidad
				+ " WHERE idempresa=" + idempresa.toString()
				+ " and  fHasta >= " + "'" + fecha + "'";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadXFecha()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadXFecha()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadXFecha()- Salida por exception: " + ex);
		}
		return total;
	}

	public long getTotalEntidadXFechaOcu(String entidad, String[] campos,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		/**
		 * Entidad: ??????
		 * 
		 * @ejb.interface-method view-type = "remote"
		 * @throws SQLException
		 *             Thrown if method fails due to system-level error.
		 *             Utilidad : traer cantidad por ocurrencia-criterio.
		 */
		long total = 0l;
		Calendar hoy = new GregorianCalendar();
		Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		ResultSet rsSalida = null;
		String cQuery = "SELECT count(1)AS total FROM " + entidad + " WHERE ";
		String like = "";
		int len = campos.length;

		try {
			for (int i = 0; i < len; i++) {
				like += "UPPER(" + campos[i] + "::VARCHAR) LIKE '%"
						+ ocurrencia.toUpperCase() + "%' ";
				if (i + 1 < len)
					like += " OR ";
			}
			cQuery += "(" + like + ") AND idempresa = " + idempresa.toString()
					+ " and fHasta >= " + "'" + fecha + "'";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				total = rsSalida.getLong("total");
			} else {
				log.warn("getTotalEntidadOcu()- Error al recuperar total: "
						+ entidad);
			}
		} catch (SQLException sqlException) {
			log.error("getTotalEntidadOcu()- Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTotalEntidadOcu()- Salida por exception: " + ex);
		}
		return total;
	}

	/*
	 * EJV - 20090330
	 * 
	 * public List getClientesTMllamadosXSocio(long limit, long offset,
	 * BigDecimal idempresa, BigDecimal idcampania, long idusuario, BigDecimal
	 * idcliente) throws EJBException { ResultSet rsSalida = null; Calendar hoy
	 * = new GregorianCalendar(); Timestamp fecha = new
	 * Timestamp(hoy.getTime().getTime()); String cQuery = "SELECT" + "
	 * SO.idcliente as Numero," + " SO.razon as socio," + " ES.estado as Estado
	 * " + " FROM " + " clientesclientes SO," + " vclientesestadoshoy ES " + "
	 * WHERE " + " SO.idcliente = ES.idcliente " + " and SO.idcliente IN (SELECT
	 * idcliente from bacotmseleccionsocio where idtelemark = " + idusuario + "
	 * and idcampacabe = " + idcampania + ")" + " and SO.idcliente = " +
	 * idcliente // or so.xnombre like '%'+@dato+'%' // or so.xapellido like
	 * '%'+@dato+'%' // or ES.estado_desc like '%'+@dato+'%' ) +
	 * " and SO.idempresa = " + idempresa + " ORDER BY 2 LIMIT " + limit +
	 * " OFFSET " + offset + ";"; List vecSalida = new ArrayList(); try {
	 * Statement statement = dbconn.createStatement(); rsSalida =
	 * statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) {
	 * log.error("Error SQL en el metodo : getClientesTMllamadosXSocio() " +
	 * sqlException); } catch (Exception ex) { log .error("Salida por exception:
	 * en el metodo: getClientesTMllamadosXSocio() " + ex); } return vecSalida;
	 * }
	 */

	/*
	 * EJV - 20090330
	 * 
	 * public List getClientesTMllamadosAgendadelDia(long limit, long offset,
	 * BigDecimal idempresa, BigDecimal idcampania, long idusuario) throws
	 * EJBException { ResultSet rsSalida = null; Calendar hoy = new
	 * GregorianCalendar(); Timestamp fecha = new
	 * Timestamp(hoy.getTime().getTime()); String cQuery = "SELECT" + "
	 * SEL.idcliente as socio," + " SO.razon as nombre," + " SEH.estado as
	 * estado," + " SEH.motivo as motivo," + " SEL.usuarioalt," + "
	 * SEL.usuarioact," + " SEL.fechaalt," + " SEL.fechaact" + " FROM" + "
	 * bacotmseleccionsocio SEL, " + " clientesclientes SO, " + "
	 * vclientesestadoshoy SEH " + " WHERE " + " SEL.idcliente = SO.idcliente
	 * " + " and SEL.idcliente = SEH.idcliente " + " and SEL.idCampaCabe =" +
	 * idcampania + " and SEL.idcliente NOT IN (SELECT idcliente FROM
	 * bacotmllamados where idcampacabe =" + idcampania + ")" + " and
	 * SEL.idtelemark =" + idusuario + " and SO.idempresa = " + idempresa + "
	 * ORDER BY 2 LIMIT " + limit + " OFFSET " + offset + ";"; List vecSalida =
	 * new ArrayList(); try { Statement statement = dbconn.createStatement();
	 * rsSalida = statement.executeQuery(cQuery); ResultSetMetaData md =
	 * rsSalida.getMetaData(); while (rsSalida.next()) { int totCampos =
	 * md.getColumnCount() - 1; String[] sSalida = new String[totCampos + 1];
	 * int i = 0; while (i <= totCampos) { sSalida[i] = rsSalida.getString(++i);
	 * } vecSalida.add(sSalida); } } catch (SQLException sqlException) { log
	 * .error("Error SQL en el metodo : getClientesTMllamadosAgendadelDia() " +
	 * sqlException); } catch (Exception ex) { log .error("Salida por exception:
	 * en el metodo: getClientesTMllamadosAgendadelDia() " + ex); } return
	 * vecSalida; }
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoTmAsignacionTelemarketAll(long limit, long offset,
			BigDecimal idtelemark, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT tms.idcampacabe, bc.campacabe, tms.idcliente, cl.razon, "
				+ "       cl.idestado,cl.estado, cl.idmotivo, cl.motivo,bcata.categoriasocio, tms.idempresa"
				+ "  FROM bacotmseleccionsocio tms "
				+ "       INNER JOIN vclientesestadoshoy cl ON tms.idcliente = cl.idcliente AND tms.idempresa = cl.idempresa "
				+ "       INNER JOIN bacotmcampacabe bc ON tms.idcampacabe = bc.idcampacabe AND tms.idempresa = bc.idempresa "
				+ "       left JOIN bacotmcategorizaciones bcat ON tms.idcliente = bcat.idcliente AND tms.idempresa = bcat.idempresa "
				+ "       left JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio AND tms.idempresa = bcata.idempresa "
				+ " WHERE tms.idtelemark = "
				+ idtelemark.toString()
				+ "   AND tms.idcliente "
				+ "   NOT IN("
				+ "         SELECT idcliente "
				+ "           FROM bacotmllamados "
				+ "          WHERE idcampacabe = tms.idcampacabe "
				+ "            AND idempresa = tms.idempresa AND fecharellamada IS NULL) "
				+ "   AND tms.idempresa = " + idempresa.toString()
				+ " ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmAsignacionTelemarketAll(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoTmAsignacionTelemarketOcu(long limit, long offset,
			BigDecimal idtelemark, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT tms.idcampacabe, bc.campacabe, tms.idcliente, cl.razon, "
				+ "       cl.idestado,cl.estado, cl.idmotivo, cl.motivo,bcata.categoriasocio, tms.idempresa"
				+ "  FROM bacotmseleccionsocio tms "
				+ "       INNER JOIN vclientesestadoshoy cl ON tms.idcliente = cl.idcliente AND tms.idempresa = cl.idempresa "
				+ "       INNER JOIN bacotmcampacabe bc ON tms.idcampacabe = bc.idcampacabe AND tms.idempresa = bc.idempresa "
				+ "       left JOIN bacotmcategorizaciones bcat ON tms.idcliente = bcat.idcliente AND tms.idempresa = bcat.idempresa "
				+ "       left JOIN bacotmcategoriassocios bcata ON bcat.idcategoria = bcata.idcategoriasocio AND tms.idempresa = bcata.idempresa "
				+ " WHERE  (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')AND tms.idtelemark = "
				+ idtelemark.toString()
				+ "   AND tms.idcliente "
				+ "   NOT IN ("
				+ "        SELECT idcliente "
				+ "          FROM bacotmllamados "
				+ "         WHERE idcampacabe = tms.idcampacabe "
				+ "           AND idempresa = tms.idempresa AND fecharellamada IS NULL)"
				+ "   AND tms.idempresa = " + idempresa.toString()
				+ "  ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmAsignacionTelemarketOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * @COMENTARIO: 20090508 - EJV - Reemplazo de los metodos por los existentes
	 *              en GeneralBean. TODO: Ver la posibilidad de unificar ya que
	 *              se encuentran en AMBOS beans. public String
	 *              getValidacionTarjetaDeCredito(BigDecimal idempresa, String
	 *              nrotarjeta, BigDecimal idmarcatarjeta) throws EJBException {
	 * 
	 *              String salida = ""; long longitudTarjetaMarca = 0; long
	 *              longitudTarjeta = 0; ResultSet rsSalida = null; String
	 *              cQuery = "" + "SELECT LENGTH(TRIM(REPLACE(formato,' ','')))
	 *              AS total " + " FROM clientetarjetascreditomarcas " + " WHERE
	 *              idempresa = " + idempresa.toString() +
	 *              " AND idtarjetacredito = " + idmarcatarjeta.toString(); try
	 *              { Statement statement = dbconn.createStatement(); rsSalida =
	 *              statement.executeQuery(cQuery); if (rsSalida.next()) {
	 *              longitudTarjetaMarca = rsSalida.getLong("total"); }
	 *              longitudTarjeta = nrotarjeta.length(); if (longitudTarjeta
	 *              != longitudTarjetaMarca) salida =
	 *              "La longitud de la tarjeta es incorrecta"; } catch
	 *              (SQLException sqlException) {
	 *              log.error("getValidacionTarjetaDeCredito()- Error SQL: " +
	 *              sqlException); } catch (Exception ex) {
	 *              log.error("getValidacionTarjetaDeCredito()- Salida por
	 *              exception: " + ex); } return salida; }
	 * 
	 *              public String getValidacionTarjetaDeCreditoExistenciaaAlta(
	 *              BigDecimal idempresa, String nrotarjeta, BigDecimal
	 *              idmarcatarjeta) throws EJBException {
	 * 
	 *              String salida = ""; long total = 0; ResultSet rsSalida =
	 *              null; String cQuery = "" +
	 *              "SELECT COUNT(1) AS total FROM clientetarjetascredito " + "
	 *              WHERE idempresa = " + idempresa.toString() + " AND
	 *              idtarjetacredito = " + idmarcatarjeta.toString() +
	 *              " AND nrotarjeta = '" + nrotarjeta.toString() + "'"; try {
	 *              Statement statement = dbconn.createStatement(); rsSalida =
	 *              statement.executeQuery(cQuery); if (rsSalida.next()) { total
	 *              = rsSalida.getLong("total"); } if (total != 0) salida = "La
	 *              tarjeta ya existe!"; } catch (SQLException sqlException) {
	 *              log
	 *              .error("getValidacionTarjetaDeCreditoExistenciaaAlta()- Error SQL: "
	 *              + sqlException); } catch (Exception ex) { log
	 *              .error("getValidacionTarjetaDeCreditoExistenciaaAlta()-
	 *              Salida por exception: " + ex); } return salida; }
	 * 
	 *              public String
	 *              getValidacionTarjetaDeCreditoExistenciaaModificacion(
	 *              BigDecimal idempresa, String nrotarjeta, BigDecimal
	 *              idmarcatarjeta, BigDecimal idtarjeta) throws EJBException {
	 * 
	 *              String salida = ""; long total = 0; ResultSet rsSalida =
	 *              null; String cQuery = "" +
	 *              "SELECT COUNT(1) AS total FROM clientetarjetascredito " + "
	 *              WHERE idempresa = " + idempresa.toString() + " AND
	 *              idtarjetacredito = " + idmarcatarjeta.toString() +
	 *              " AND nrotarjeta = '" + nrotarjeta.toString() + "'" +
	 *              " AND idtarjeta <> " + idtarjeta.toString();
	 * 
	 *              try { Statement statement = dbconn.createStatement();
	 *              rsSalida = statement.executeQuery(cQuery); if
	 *              (rsSalida.next()) { total = rsSalida.getLong("total"); } if
	 *              (total != 0) salida = "La tarjeta ya existe!"; } catch
	 *              (SQLException sqlException) { log
	 *              .error("getValidacionTarjetaDeCreditoExistenciaaModificacion
	 *              ( ) - Error SQL: " + sqlException); } catch (Exception ex) {
	 *              log .error
	 *              ("getValidacionTarjetaDeCreditoExistenciaaModificacion()-
	 *              Salida por exception: " + ex); } return salida; }
	 * 
	 *              public String validarTarjetaDeCredito(String nrotarjeta) {
	 *              String salida = "NOOK"; String letra = ""; String tar = "";
	 *              int i = 0; try { while (i < nrotarjeta.length()) { letra =
	 *              nrotarjeta.substring(i, ++i); if (i % 2 == 0) tar += letra;
	 *              else { int num = Integer.parseInt(letra); num = num * 2; if
	 *              (num < 9) { tar += num; } else { num = num - 9; tar += num;
	 *              } } } // -- fin de descomposicion del numero // -- ahora
	 *              viene la suma algebraica. i = 0; int total = 0; while (i <
	 *              tar.length()) { letra = tar.substring(i, ++i); int num =
	 *              Integer.parseInt(letra); total += num; } // fin de suma
	 *              algebraica. if (total < 150 && total % 10 == 0) salida = "";
	 *              } catch (Exception ex) {
	 *              System.out.println("Error validarTarjetaDeCredito " + ex); }
	 * 
	 *              return salida; }
	 * 
	 */

	/**
	 * Metodos para la entidad: clientesAnexoLocalidades Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Dec 23 14:59:21 GMT-03:00 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesAnexoLocalidadesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT al.idanexolocalidad,al.idexpresozona, e.expreso, z.zona,al.idlocalidad, l.cpostal, l.localidad, al.codtfbasica, al.codtfctdo,"
				+ "       al.tarand1bulto,al.tarandexc,al.tarsoc1bulto,al.tarsocexc,al.cabeoinflu,al.norteosur,"
				+ "       al.idempresa,al.usuarioalt,al.usuarioact,al.fechaalt,al.fechaact,gp.provincia "
				+ "  FROM clientesanexolocalidades al"
				+ "       INNER JOIN clientesexpresoszonas ez ON al.idexpresozona = ez.codigo AND al.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "       INNER JOIN globallocalidades l ON al.idlocalidad = l.idlocalidad "
				+ "       INNER JOIN globalprovincias gp on l.idprovincia = gp.idprovincia "
				+ " WHERE al.idempresa = " + idempresa.toString()
				+ " ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexoLocalidadesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesAnexoLocalidadesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT al.idanexolocalidad,al.idexpresozona, e.expreso, z.zona,al.idlocalidad, l.cpostal, l.localidad, al.codtfbasica, al.codtfctdo,"
				+ "       al.tarand1bulto,al.tarandexc,al.tarsoc1bulto,al.tarsocexc,al.cabeoinflu,al.norteosur,"
				+ "       al.idempresa,al.usuarioalt,al.usuarioact,al.fechaalt,al.fechaact,gp.provincia"
				+ "  FROM clientesanexolocalidades al"
				+ "       INNER JOIN clientesexpresoszonas ez ON al.idexpresozona = ez.codigo AND al.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "       INNER JOIN globallocalidades l ON al.idlocalidad = l.idlocalidad "
				+ "       INNER JOIN globalprovincias gp on l.idprovincia = gp.idprovincia "
				+ " WHERE (UPPER(e.expreso) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(z.zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(l.cpostal) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(l.localidad) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND al.idempresa = "
				+ idempresa.toString() + " ORDER BY 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexoLocalidadesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// --

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesAnexoLocalidadesXLocaAll(long limit, long offset,
			BigDecimal idlocalidad, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT al.idanexolocalidad,al.idexpresozona, e.idexpreso, e.expreso, z.idzona, z.zona,al.idlocalidad, l.localidad, al.codtfbasica, al.codtfctdo,"
				+ "       al.tarand1bulto,al.tarandexc,al.tarsoc1bulto,al.tarsocexc,al.cabeoinflu,al.norteosur,"
				+ "       al.idempresa,al.usuarioalt,al.usuarioact,al.fechaalt,al.fechaact"
				+ "  FROM clientesanexolocalidades al"
				+ "       INNER JOIN clientesexpresoszonas ez ON al.idexpresozona = ez.codigo AND al.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "       INNER JOIN globallocalidades l ON al.idlocalidad = l.idlocalidad "
				+ " WHERE al.idlocalidad = " + idlocalidad
				+ " AND al.idempresa = " + idempresa.toString()
				+ " ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexoLocalidadesAll(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesAnexoLocalidadesXLocaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idlocalidad, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT al.idanexolocalidad,al.idexpresozona, e.idexpreso, e.expreso, z.idzona, z.zona,al.idlocalidad, l.localidad, al.codtfbasica, al.codtfctdo,"
				+ "       al.tarand1bulto,al.tarandexc,al.tarsoc1bulto,al.tarsocexc,al.cabeoinflu,al.norteosur,"
				+ "       al.idempresa,al.usuarioalt,al.usuarioact,al.fechaalt,al.fechaact"
				+ "  FROM clientesanexolocalidades al"
				+ "       INNER JOIN clientesexpresoszonas ez ON al.idexpresozona = ez.codigo AND al.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "       INNER JOIN globallocalidades l ON al.idlocalidad = l.idlocalidad "
				+ " WHERE al.idlocalidad = " + idlocalidad
				+ " AND (UPPER(e.expreso) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(z.zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(l.localidad) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND al.idempresa = "
				+ idempresa.toString() + " ORDER BY 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexoLocalidadesXLocaOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// --

	// por primary key (primer campo por defecto)

	public List getClientesAnexoLocalidadesPK(BigDecimal idanexolocalidad,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT al.idanexolocalidad,al.idexpresozona, e.expreso, z.zona,al.idlocalidad, TRIM(l.localidad) || ' - CP: ' || cpostal AS localidad, al.codtfbasica, al.codtfctdo,"
				+ "       al.tarand1bulto,al.tarandexc,al.tarsoc1bulto,al.tarsocexc,al.cabeoinflu,al.norteosur,"
				+ "       al.idexpresobaco,al.iddistribuidorbaco,"
				+ "       al.idempresa,al.usuarioalt,al.usuarioact,al.fechaalt,al.fechaact"
				+ "  FROM clientesanexolocalidades al"
				+ "       INNER JOIN clientesexpresoszonas ez ON al.idexpresozona = ez.codigo AND al.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "       INNER JOIN globallocalidades l ON al.idlocalidad = l.idlocalidad "
				+ " WHERE al.idanexolocalidad=" + idanexolocalidad.toString()
				+ "   AND al.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesAnexoLocalidadesPK( BigDecimal idanexolocalidad )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesAnexoLocalidadesDelete(BigDecimal idanexolocalidad,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESANEXOLOCALIDADES WHERE idanexolocalidad="
				+ idanexolocalidad.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESANEXOLOCALIDADES WHERE idanexolocalidad="
						+ idanexolocalidad.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesAnexoLocalidadesDelete( BigDecimal idanexolocalidad, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesAnexoLocalidadesDelete( BigDecimal idanexolocalidad, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesAnexoLocalidadesCreate(BigDecimal idexpresozona,
			BigDecimal idlocalidad, Double codtfbasica, String codtfctdo,
			Double tarand1bulto, Double tarandexc, Double tarsoc1bulto,
			Double tarsocexc, String cabeoinflu, String norteosur,
			BigDecimal idexpresobaco, BigDecimal iddistribuidorbaco,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idexpresozona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpresozona ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		// if (codtfbasica == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfbasica ";
		// if (codtfctdo == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfctdo ";
		if (tarand1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarand1bulto ";
		if (tarandexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarandexc ";
		if (tarsoc1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsoc1bulto ";
		if (tarsocexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsocexc ";
		if (cabeoinflu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cabeoinflu ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		// if (codtfctdo.equalsIgnoreCase(""))
		// salida = "Error: No se puede dejar vacio el campo: codtfctdo ";
		if (cabeoinflu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cabeoinflu ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO CLIENTESANEXOLOCALIDADES "
						+ " (idexpresozona, idlocalidad, codtfbasica, codtfctdo, tarand1bulto, tarandexc, tarsoc1bulto, "
						+ "  tarsocexc, cabeoinflu, norteosur, idexpresobaco, iddistribuidorbaco,idempresa, usuarioalt ) "
						+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idexpresozona);
				insert.setBigDecimal(2, idlocalidad);
				insert.setDouble(3, codtfbasica.doubleValue());
				insert.setString(4, codtfctdo);
				insert.setDouble(5, tarand1bulto.doubleValue());
				insert.setDouble(6, tarandexc.doubleValue());
				insert.setDouble(7, tarsoc1bulto.doubleValue());
				insert.setDouble(8, tarsocexc.doubleValue());
				insert.setString(9, cabeoinflu);
				insert.setString(10, norteosur);
				insert.setBigDecimal(11, idexpresobaco);
				insert.setBigDecimal(12, iddistribuidorbaco);
				insert.setBigDecimal(13, idempresa);
				insert.setString(14, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesAnexoLocalidadesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesAnexoLocalidadesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesAnexoLocalidadesCreateOrUpdate(
			BigDecimal idanexolocalidad, BigDecimal idexpresozona,
			BigDecimal idlocalidad, Double codtfbasica, String codtfctdo,
			Double tarand1bulto, Double tarandexc, Double tarsoc1bulto,
			Double tarsocexc, String cabeoinflu, String norteosur,
			BigDecimal idexpresobaco, BigDecimal iddistribuidorbaco,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idanexolocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idanexolocalidad ";
		if (idexpresozona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpresozona ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		// if (codtfbasica == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfbasica ";
		// if (codtfctdo == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfctdo ";
		if (tarand1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarand1bulto ";
		if (tarandexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarandexc ";
		if (tarsoc1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsoc1bulto ";
		if (tarsocexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsocexc ";
		if (cabeoinflu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cabeoinflu ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// if (codtfctdo.equalsIgnoreCase(""))
		// salida = "Error: No se puede dejar vacio el campo: codtfctdo ";
		if (cabeoinflu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cabeoinflu ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesAnexoLocalidades WHERE idanexolocalidad = "
					+ idanexolocalidad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE CLIENTESANEXOLOCALIDADES "
							+ "SET idexpresozona=?, idlocalidad=?, codtfbasica=?, codtfctdo=?, tarand1bulto=?, "
							+ "    tarandexc=?, tarsoc1bulto=?, tarsocexc=?, cabeoinflu=?, norteosur=?, "
							+ "    idexpresobaco=?, iddistribuidorbaco=?, idempresa=?, usuarioact=?, fechaact=?"
							+ " WHERE idanexolocalidad=?;";

					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpresozona);
					insert.setBigDecimal(2, idlocalidad);
					insert.setDouble(3, codtfbasica.doubleValue());
					insert.setString(4, codtfctdo);
					insert.setDouble(5, tarand1bulto.doubleValue());
					insert.setDouble(6, tarandexc.doubleValue());
					insert.setDouble(7, tarsoc1bulto.doubleValue());
					insert.setDouble(8, tarsocexc.doubleValue());
					insert.setString(9, cabeoinflu);
					insert.setString(10, norteosur);
					insert.setBigDecimal(11, idexpresobaco);
					insert.setBigDecimal(12, iddistribuidorbaco);
					insert.setBigDecimal(13, idempresa);
					insert.setString(14, usuarioact);
					insert.setTimestamp(15, fechaact);
					insert.setBigDecimal(16, idanexolocalidad);

				} else {
					String ins = ""
							+ "INSERT INTO CLIENTESANEXOLOCALIDADES "
							+ " (idexpresozona, idlocalidad, codtfbasica, codtfctdo, tarand1bulto, tarandexc, tarsoc1bulto, "
							+ "  tarsocexc, cabeoinflu, norteosur, idexpresobaco, iddistribuidorbaco,idempresa, usuarioalt ) "
							+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, idexpresozona);
					insert.setBigDecimal(2, idlocalidad);
					insert.setDouble(3, codtfbasica.doubleValue());
					insert.setString(4, codtfctdo);
					insert.setDouble(5, tarand1bulto.doubleValue());
					insert.setDouble(6, tarandexc.doubleValue());
					insert.setDouble(7, tarsoc1bulto.doubleValue());
					insert.setDouble(8, tarsocexc.doubleValue());
					insert.setString(9, cabeoinflu);
					insert.setString(10, norteosur);
					insert.setBigDecimal(11, idexpresobaco);
					insert.setBigDecimal(12, iddistribuidorbaco);
					insert.setBigDecimal(13, idempresa);
					insert.setString(14, usuarioact);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesAnexoLocalidadesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesAnexoLocalidadesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesAnexoLocalidadesUpdate(BigDecimal idanexolocalidad,
			BigDecimal idexpresozona, BigDecimal idlocalidad,
			Double codtfbasica, String codtfctdo, Double tarand1bulto,
			Double tarandexc, Double tarsoc1bulto, Double tarsocexc,
			String cabeoinflu, String norteosur, BigDecimal idexpresobaco,
			BigDecimal iddistribuidorbaco, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idanexolocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idanexolocalidad ";
		if (idexpresozona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idexpresozona ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		// if (codtfbasica == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfbasica ";
		// if (codtfctdo == null)
		// salida =
		// "Error: No se puede dejar sin datos (nulo) el campo: codtfctdo ";
		if (tarand1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarand1bulto ";
		if (tarandexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarandexc ";
		if (tarsoc1bulto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsoc1bulto ";
		if (tarsocexc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tarsocexc ";
		if (cabeoinflu == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cabeoinflu ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// if (codtfctdo.equalsIgnoreCase(""))
		// salida = "Error: No se puede dejar vacio el campo: codtfctdo ";
		if (cabeoinflu.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cabeoinflu ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesAnexoLocalidades WHERE idanexolocalidad = "
					+ idanexolocalidad.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update

					sql = ""
							+ "UPDATE CLIENTESANEXOLOCALIDADES "
							+ "SET idexpresozona=?, idlocalidad=?, codtfbasica=?, codtfctdo=?, tarand1bulto=?, "
							+ "    tarandexc=?, tarsoc1bulto=?, tarsocexc=?, cabeoinflu=?, norteosur=?, "
							+ "    idexpresobaco=?, iddistribuidorbaco=?, idempresa=?, usuarioact=?, fechaact=?"
							+ " WHERE idanexolocalidad=?;";

					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpresozona);
					insert.setBigDecimal(2, idlocalidad);
					insert.setDouble(3, codtfbasica.doubleValue());
					insert.setString(4, codtfctdo);
					insert.setDouble(5, tarand1bulto.doubleValue());
					insert.setDouble(6, tarandexc.doubleValue());
					insert.setDouble(7, tarsoc1bulto.doubleValue());
					insert.setDouble(8, tarsocexc.doubleValue());
					insert.setString(9, cabeoinflu);
					insert.setString(10, norteosur);
					insert.setBigDecimal(11, idexpresobaco);
					insert.setBigDecimal(12, iddistribuidorbaco);
					insert.setBigDecimal(13, idempresa);
					insert.setString(14, usuarioact);
					insert.setTimestamp(15, fechaact);
					insert.setBigDecimal(16, idanexolocalidad);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesAnexoLocalidadesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesAnexoLocalidadesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos Lov Expresos / Zonas: Copyrigth(r) sysWarp S.R.L. Fecha de
	 * creacion: Tue Dec 29 17:22:21 GMT-03:00 2008
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesExpresosZonasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ez.codigo AS idexpresozona, ez.idexpreso, e.expreso, ez.idzona, z.zona"
				+ "  FROM clientesexpresoszonas ez "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND  ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND  ez.idempresa = z.idempresa "
				+ " WHERE ez.idempresa = " + idempresa.toString()
				+ "  ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesExpresosZonasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesExpresosZonasOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ez.codigo AS idexpresozona, ez.idexpreso, e.expreso, ez.idzona, z.zona"
				+ "  FROM clientesexpresoszonas ez "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND  ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND  ez.idempresa = z.idempresa "
				+ " WHERE ez.idempresa = " + idempresa.toString()
				+ " AND ( UPPER(e.expreso) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(z.zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')   ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesExpresosZonasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesExpresosZonasXZona(long limit, long offset,
			BigDecimal idzona, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ez.codigo AS idexpresozona, ez.idexpreso, e.expreso, ez.idzona, z.zona"
				+ "  FROM clientesexpresoszonas ez "
				+ "       INNER JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND  ez.idempresa = e.idempresa "
				+ "       INNER JOIN clienteszonas z ON ez.idzona = z.idzona AND  ez.idempresa = z.idempresa "
				+ " WHERE ez.idzona = " + idzona + " AND ez.idempresa = "
				+ idempresa.toString() + "  ORDER BY 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesExpresosZonasXZona()  "
							+ ex);
		}
		return vecSalida;
	}

	public String getGoogleMapTitulo(BigDecimal idempresa,
			BigDecimal idDomicilio) throws EJBException {
		String salida = "nook";
		ResultSet rsSalida = null;
		String cQuery = "select   '('||  cli.idcliente::varchar  ||') '||cli.razon || ' ('|| tipo.tipodomicilio||')' as titulo "
				+ " from "
				+ " clientesdomicilios dom "
				+ " join clientesclientes cli on (dom.idcliente = cli.idcliente and dom.idempresa = cli.idempresa ) "
				+ " join clientestiposdomicilios tipo on(dom.idtipodomicilio = tipo.idtipodomicilio and dom.idempresa = tipo.idempresa) "
				+ " where dom.iddomicilio = "
				+ idDomicilio.toString()
				+ " and dom.idempresa = " + idempresa.toString() + "; " + "";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = rsSalida.getString("titulo");
			} else {
				log
						.warn("getGoogleMapTitulo(BigDecimal idempresa, BigDecimal idDomicilio)- Error  ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getGoogleMapTitulo(BigDecimal idempresa, BigDecimal idDomicilio)- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getGoogleMapTitulo(BigDecimal idempresa, BigDecimal idDomicilio)- Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String getGoogleMapDomicilio(BigDecimal idempresa,
			BigDecimal idDomicilio) throws EJBException {
		String salida = "nook";
		ResultSet rsSalida = null;
		// ||', '|| trim(pro.provincia) // LA SAQUE DE ENTRE LOCALIDAD Y PAIS
		String cQuery = "select dom.nro::varchar ||' '|| trim(dom.calle) ||', '|| trim(loc.localidad) ||', '|| trim(pais.pais)  as direccion  "
				+ " from "
				+ " clientesdomicilios dom "
				+ " join globallocalidades loc on( dom.idlocalidad = loc.idlocalidad ) "
				+ " join globalprovincias pro on ( loc.idprovincia = pro.idprovincia ) "
				+ " join globalpaises pais on (pro.idpais = pais.idpais) "
				+ " where iddomicilio = "
				+ idDomicilio.toString()
				+ " and idempresa =" + idempresa.toString() + ";";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = rsSalida.getString("direccion");
			} else {
				log
						.warn("getGoogleMapDomicilio(BigDecimal idempresa, BigDecimal idDomicilio)- Error  ");
			}
		} catch (SQLException sqlException) {
			log
					.error("getGoogleMapDomicilio(BigDecimal idempresa, BigDecimal idDomicilio)- Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getGoogleMapDomicilio(BigDecimal idempresa, BigDecimal idDomicilio)- Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String getGmapKeyID() throws EJBException {
		return mapKey;
	}

	/**
	 * Metodos para la entidad: stockstock - esquemascabe / deta desde
	 * lovPedidosEsquemasContieneArt.jsp Copyrigth(r) utilizada para consultar
	 * esquemas que contienen articulos sin stock, para desarme, para poder
	 * cumplir pedidos sysWarp S.R.L. Fecha de creacion: Wed Jan 22 12:06:13
	 * GMT-03:00 2009
	 */

	public List getEsquemasContienenArticulo(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ "SELECT idesquema, cstock, esquema, replace(replace(observaciones, chr(13), ''), chr(10), ''), "
				+ "       codigo_st, descrip_st, cantidad::numeric(18), canti_sb::numeric(18, 0), pedid_sb, deposi_sb, descrip_dt, idempresa "
				+ "  FROM varticulosesquemadesarme"
				+ " WHERE (UPPER(codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%'"
				+ "    OR UPPER(descrip_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND idempresa =   "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		// +
		// "SELECT ec.idesquema, es.cstock, ec.esquema, replace(replace(ec.observaciones, chr(13), ''), chr(10), ''), "
		// +
		// "       st.codigo_st, st.descrip_st, ed.cantidad::numeric(18) AS cantidad, es.canti_sb, es.pedid_sb, es.deposi_sb, es.descrip_dt "
		// + "  FROM produccionesquemas_cabe ec "
		// + "       INNER JOIN ( "
		// +
		// "                   SELECT ca.idesquema, de.codigo_st AS cstock, ss.descrip_st, "
		// +
		// "                          sb.deposi_sb, dt.descrip_dt, sb.canti_sb, sb.pedid_sb, ss.idempresa "
		// + "                     FROM produccionesquemas_cabe ca "
		// +
		// "                          INNER JOIN  produccionesquemas_deta de ON ca.idesquema = de.idesquema AND ca.idempresa = de.idempresa "
		// +
		// "                          INNER JOIN stockstock ss ON de.codigo_st = ss.codigo_st AND de.idempresa = ss.idempresa "
		//
		// +
		// "                          INNER JOIN stockstockbis sb ON de.codigo_st = sb.articu_sb AND de.idempresa = sb.idempresa "
		// +
		// "                          INNER JOIN stockdepositos dt ON sb.deposi_sb = dt.codigo_dt AND dt.idempresa = sb.idempresa "
		//
		// + "                    WHERE de.entsal = 'P' "
		// + "                      AND sb.canti_sb > 0"
		//
		// +
		// "                  )es ON ec.idesquema = es.idesquema AND ec.idempresa = es.idempresa "
		// +
		// "       INNER JOIN  produccionesquemas_deta ed ON ec.idesquema = ed.idesquema AND ec.idempresa = ed.idempresa "
		// +
		// "       INNER JOIN stockstock st ON ed.codigo_st = st.codigo_st AND ed.idempresa = st.idempresa "
		// + " WHERE (UPPER(st.codigo_st) LIKE '%"
		// + ocurrencia.toUpperCase().trim() + "%'"
		// + "    OR UPPER(st.descrip_st) LIKE '%"
		// + ocurrencia.toUpperCase().trim() + "%') AND ec.idempresa =   "
		// + idempresa.toString() + "   AND ed.entsal = 'C' "
		// + "   AND ed.reutiliza = 'S' " + " ORDER BY 2  LIMIT " + limit
		// + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getEsquemasContienenArticulo(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: pedidos_cabe - clientesdomicilios -
	 * clientesclientes - pedidosestados - clientesanexolocalidades -
	 * globallocalidades - clientesexpresoszonas - clienteszonas -
	 * clientesexpresos Copyrigth(r) sysWarp S.R.L. Fecha de creacion: Thu Feb
	 * 12 08:43:04 GYT 2009
	 * 
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosPendientesAll(long limit, long offset,
			BigDecimal idestado, String tipopedido, String orden,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe, idestado, estado,idcliente, razon, fechapedido, idprioridad, prioridad,"
				+ "            zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, cotizacion, ctacteok, club, logo, idempresa"
				+ "  FROM vpedidospendientes WHERE idestado = " + idestado
				+ "     AND noinventariable IS NULL  AND tipo = '" + tipopedido
				+ "'  AND idempresa = " + idempresa.toString() + "  ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";

		// 

		// if (tipopedido.equalsIgnoreCase("N")) {
		//
		//		
		// cQuery = "SELECT idpedido_cabe, idestado, estado, "
		// + "       idcliente, razon, fechapedido, idprioridad, prioridad,"
		// +
		// "       zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa"
		// + "  FROM ("
		// + "       SELECT pc.idpedido_cabe, es.idestado, es.estado,  "
		// +
		// "              cl.idcliente, cl.razon, pc.fechapedido, pr.idprioridad, pr.prioridad,"
		// +
		// "              zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa "
		// + "         FROM pedidos_cabe pc "
		// +
		// "              INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa "
		// +
		// "              INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
		// +
		// "              INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa "
		// // 20100804 - EJV - Reasignacion -->
		// // +
		// //
		// "              INNER JOIN clientesanexolocalidades an ON cd.idanexolocalidad = an.idanexolocalidad  AND  cd.idempresa = an.idempresa "
		// +
		// "              INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa "
		// // +
		// //
		// "              INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad  "
		// // <--
		//
		// +
		// "              INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa "
		// +
		// "              INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa "
		// +
		// "              INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa "
		//
		// // 20100804 - EJV - Reasignacion -->
		// +
		// "              INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad  AND  cd.idempresa = anlo.idempresa "
		// +
		// "              INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad "
		// // <--
		//
		// +
		// "              INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad "
		// + "        ) pedido_pendientes WHERE idestado = "
		// + idestado + " AND idempresa = " + idempresa.toString()
		// + "  ORDER BY " + orden + "  LIMIT " + limit + " OFFSET  "
		// + offset + ";";
		// } else {
		// cQuery = "SELECT idpedido_regalos_entrega_cabe, idestado, estado,  "
		// + "       idcliente, razon, fechapedido, idprioridad, prioridad, "
		// +
		// "       zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa "
		// + "  FROM ( "
		// +
		// "       SELECT pc.idpedido_regalos_entrega_cabe, es.idestado, es.estado,   "
		// +
		// "              cl.idcliente, cl.razon || ' - ' || cd.contacto AS razon , pc.fechapedido, pr.idprioridad, pr.prioridad, "
		// +
		// "              zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa "
		// + "         FROM pedidos_regalos_entregas_cabe pc  "
		// +
		// "              INNER JOIN pedidosdomiciliosentrega cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa "
		// +
		// "              INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
		// +
		// "              INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa  "
		// // 20100804 - EJV - Reasignacion -->
		// +
		// "              INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa "
		// // +
		// //
		// "              INNER JOIN clientesanexolocalidades an ON cd.idanexolocalidad = an.idanexolocalidad  AND  cd.idempresa = an.idempresa "
		// // +
		// //
		// "              INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad   "
		// // <--
		// +
		// "              INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa "
		// +
		// "              INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa  "
		// +
		// "              INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa "
		// // 20100804 - EJV - Reasignacion -->
		// +
		// "              INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad  AND  cd.idempresa = anlo.idempresa "
		// +
		// "              INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad  "
		// // <--
		// +
		// "              INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad "
		// + "        ) pedido_pendientes WHERE idestado = "
		// + idestado
		// + " AND idempresa = "
		// + idempresa.toString()
		// + "  ORDER BY "
		// + orden
		// + "  LIMIT "
		// + limit
		// + " OFFSET  "
		// + offset + ";";
		// }

		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosPendientesOcu(long limit, long offset,
			BigDecimal idestado, String tipopedido, String filtro,
			String orden, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe, idestado, estado,idcliente, razon, fechapedido, idprioridad, prioridad,"
				+ "            zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, cotizacion, ctacteok, club, logo, idempresa"
				+ "  FROM vpedidospendientes  " + filtro
				+ "   AND idempresa = " + idempresa.toString() + "  ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";

		//		
		// if (tipopedido.equalsIgnoreCase("N")) {
		//
		// cQuery = "SELECT idpedido_cabe, idestado, estado, "
		// + "       idcliente, razon, fechapedido, idprioridad, prioridad,"
		// +
		// "       zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa"
		// + "  FROM ("
		// + "       SELECT pc.idpedido_cabe, es.idestado, es.estado,  "
		// +
		// "              cl.idcliente, cl.razon, pc.fechapedido, pr.idprioridad, pr.prioridad,"
		// +
		// "              zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa "
		// + "         FROM pedidos_cabe pc "
		// +
		// "              INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa "
		// +
		// "              INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
		// +
		// "              INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa "
		//
		// // 20100804 - EJV - Reasignacion -->
		// // +
		// //
		// "              INNER JOIN clientesanexolocalidades an ON cd.idanexolocalidad = an.idanexolocalidad  AND  cd.idempresa = an.idempresa "
		// +
		// "              INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa "
		// // +
		// //
		// "              INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad  "
		// // <--
		//
		// +
		// "              INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa "
		// +
		// "              INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa "
		// +
		// "              INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa "
		//
		// // 20100804 - EJV - Reasignacion -->
		// +
		// "              INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad  AND  cd.idempresa = anlo.idempresa "
		// +
		// "              INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad "
		// // <--
		//
		// +
		// "              INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad"
		// + "        ) pedidos_pendientes   " + filtro
		// + " AND idempresa = " + idempresa.toString() + " ORDER BY "
		// + orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		// } else {
		//
		// cQuery = "SELECT idpedido_cabe, idestado, estado, "
		// + "       idcliente, razon, fechapedido, idprioridad, prioridad,"
		// +
		// "       zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa"
		// + "  FROM ("
		// +
		// "       SELECT pc.idpedido_regalos_entrega_cabe AS idpedido_cabe, es.idestado, es.estado,   "
		// +
		// "              cl.idcliente, cl.razon || ' - ' || cd.contacto AS razon , pc.fechapedido, pr.idprioridad, pr.prioridad, "
		// +
		// "              zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa "
		// + "         FROM pedidos_regalos_entregas_cabe pc  "
		// +
		// "              INNER JOIN pedidosdomiciliosentrega cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa "
		// +
		// "              INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
		// +
		// "              INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa  "
		//
		// // 20100804 - EJV - Reasignacion -->
		// // +
		// //
		// "              INNER JOIN clientesanexolocalidades an ON cd.idanexolocalidad = an.idanexolocalidad  AND  cd.idempresa = an.idempresa "
		// +
		// "              INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa "
		// // +
		// //
		// "              INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad  "
		// // <--
		//
		// +
		// "              INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa "
		// +
		// "              INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa  "
		// +
		// "              INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa "
		//
		// // 20100804 - EJV - Reasignacion -->
		// +
		// "              INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad  AND  cd.idempresa = anlo.idempresa "
		// +
		// "              INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad "
		// // <--
		//
		// +
		// "              INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad "
		// + "        ) pedidos_pendientes   " + filtro
		// + " AND idempresa = " + idempresa.toString() + " ORDER BY "
		// + orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		//
		// }

		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosProgramadosAll(long limit, long offset,
			BigDecimal idprioridad, String tipopedido, String orden,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N")) {

			cQuery = ""
					+ " SELECT idpedido_cabe, idremitocliente, nrosucursal, nroremitocliente, idestadopedido,  estadopedido, idestadoremito, COALESCE(estadoremito, 'SIN REMITO'), "
					+ "        idcliente, razon, fechapedido, idprioridad, prioridad, "
					+ "        zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa "
					+ "   FROM ( "
					+ "        SELECT pc.idpedido_cabe, cre.idremitocliente, cre.nrosucursal, cre.nroremitocliente, "
					+ "                    es.idestado AS idestadopedido, es.estado AS estadopedido, cre.idestadoremito, cre.estadoremito,  "
					+ "                    cl.idcliente, cl.razon, pc.fechapedido, pr.idprioridad, pr.prioridad, "
					+ "                    zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa  "
					+ "          FROM pedidos_cabe pc  "
					+ "               INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa  "
					+ "               INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "               INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa  "
					+ "               INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa  "
					+ "               INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa  "
					+ "               INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa  "
					+ "               INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa  "
					// 20100804 - EJV - Reasignacion -->
					// +
					+ "               INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad AND cd.idempresa = anlo.idempresa "
					+ "               INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad   "
					// <--
					+ "               INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad "
					+ "               INNER JOIN ( "
					+ "                           SELECT rpc.idpedido_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, "
					+ "                                       res.idestado AS idestadoremito, res.estado AS estadoremito, rpc.idempresa "
					+ "                             FROM pedidos_cabe rpc "
					+ "                                  INNER JOIN pedidos_deta rpd ON rpc.idpedido_cabe = rpd.idpedido_cabe AND rpc.idempresa = rpd.idempresa "
					+ "                                   LEFT JOIN clientesremitos cr ON rpd.idremitocliente = cr.idremitocliente AND rpd.idempresa = cr.idempresa "
					+ "                                   LEFT JOIN clientesremitosestados res ON cr.idestado = res.idestado AND cr.idempresa = res.idempresa "
					+ "                            WHERE rpc.idprioridad =  "
					+ idprioridad.toString()
					+ "                              AND (cr.idestado IS NULL OR cr.idestado = 1 ) "
					+ "                              AND rpc.idempresa =  "
					+ idempresa.toString()
					+ "                            GROUP BY rpc.idpedido_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, res.idestado, res.estado, rpc.idempresa "
					+ "                          ) cre ON pc.idpedido_cabe = cre.idpedido_cabe AND pc.idempresa = cre.idempresa "
					+ "         ) pedidos_pendientes  "
					+ "  WHERE idempresa =  " + idempresa.toString()
					+ "      AND idestadopedido IN (1,2,3)  ORDER BY " + orden
					+ "  LIMIT " + limit + " OFFSET  " + offset + ";";

		} else {

			cQuery = ""
					+ " SELECT idpedido_cabe, idremitocliente, nrosucursal, nroremitocliente, idestadopedido,  estadopedido, idestadoremito, COALESCE(estadoremito, 'SIN REMITO'), "
					+ "        idcliente, razon, fechapedido, idprioridad, prioridad, "
					+ "        zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa "
					+ "   FROM ( "
					+ "        SELECT pc.idpedido_regalos_entrega_cabe AS idpedido_cabe, cre.idremitocliente, cre.nrosucursal, cre.nroremitocliente, "
					+ "                    es.idestado AS idestadopedido, es.estado AS estadopedido, cre.idestadoremito, cre.estadoremito,  "
					+ "                    cl.idcliente, cl.razon, pc.fechapedido, pr.idprioridad, pr.prioridad, "
					+ "                    zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa  "
					+ "          FROM pedidos_regalos_entregas_cabe pc   "
					+ "                   INNER JOIN pedidosdomiciliosentrega cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa  "
					+ "                   INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "                   INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa   "
					+ "                   INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa  "
					// +
					// "                   INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad    "
					+ "                   INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa  "
					+ "                   INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa   "
					+ "                   INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa  "
					// 20100804 - EJV - Reasignacion -->
					// +
					+ "               INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad AND cd.idempresa = anlo.idempresa "
					+ "               INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad   "
					// <--
					+ "                   INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad  "
					+ "                   INNER JOIN (  "
					+ "                            SELECT rpc.idpedido_regalos_entrega_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, "
					+ "                                        res.idestado AS idestadoremito, res.estado AS estadoremito, rpc.idempresa  "
					+ "                              FROM pedidos_regalos_entregas_cabe rpc  "
					+ "                                        INNER JOIN pedidos_regalos_entregas_deta rpd ON rpc.idpedido_regalos_entrega_cabe = rpd.idpedido_regalos_entrega_cabe AND rpc.idempresa = rpd.idempresa  "
					+ "                                          LEFT JOIN clientesremitos cr ON rpd.idremitocliente = cr.idremitocliente AND rpd.idempresa = cr.idempresa  "
					+ "                                          LEFT JOIN clientesremitosestados res ON cr.idestado = res.idestado AND cr.idempresa = res.idempresa  "
					+ "                             WHERE rpc.idprioridad =   "
					+ idprioridad.toString()
					+ "                               AND (cr.idestado IS NULL OR cr.idestado = 1 )  "
					+ "                               AND rpc.idempresa = "
					+ idempresa.toString()
					+ "                             GROUP BY rpc.idpedido_regalos_entrega_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, res.idestado, res.estado, rpc.idempresa  "
					+ "                           ) cre ON pc.idpedido_regalos_entrega_cabe = cre.idpedido_regalos_entrega_cabe AND pc.idempresa = cre.idempresa  "
					+ "         ) pedidos_pendientes      "
					+ " WHERE idempresa =   " + idempresa.toString()
					+ "     AND idestadopedido IN (1,2,3) " + " ORDER BY "
					+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";

		}

		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	public List getPedidosProgramadosOcu(long limit, long offset,
			BigDecimal idprioridad, String tipopedido, String filtro,
			String orden, BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N")) {

			cQuery = ""
					+ " SELECT idpedido_cabe, idremitocliente, nrosucursal, nroremitocliente, "
					+ "             idestadopedido,  estadopedido, idestadoremito, COALESCE(estadoremito, 'SIN REMITO'), "
					+ "             idcliente, razon, fechapedido, idprioridad, prioridad, "
					+ "             zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa "
					+ "   FROM ( "
					+ "        SELECT pc.idpedido_cabe, cre.idremitocliente, cre.nrosucursal, cre.nroremitocliente, "
					+ "                    es.idestado AS idestadopedido, es.estado AS estadopedido, cre.idestadoremito, cre.estadoremito,  "
					+ "                    cl.idcliente, cl.razon, pc.fechapedido, pr.idprioridad, pr.prioridad, "
					+ "                    zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa  "
					+ "          FROM pedidos_cabe pc  "
					+ "                   INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa  "
					+ "                   INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "                   INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa  "
					+ "                   INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa  "
					// +
					// "                   INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad   "
					+ "                   INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa  "
					+ "                   INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa  "
					+ "                   INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa  "
					+ "                   INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad "
					// 20100804 - EJV - Reasignacion -->
					// +
					+ "               INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad AND cd.idempresa = anlo.idempresa "
					+ "               INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad   "
					// <--

					+ "                   INNER JOIN ( "
					+ "                           SELECT rpc.idpedido_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente,"
					+ "                                        res.idestado AS idestadoremito, res.estado AS estadoremito, rpc.idempresa "
					+ "                              FROM pedidos_cabe rpc "
					+ "                                       INNER JOIN pedidos_deta rpd ON rpc.idpedido_cabe = rpd.idpedido_cabe AND rpc.idempresa = rpd.idempresa "
					+ "                                         LEFT JOIN clientesremitos cr ON rpd.idremitocliente = cr.idremitocliente AND rpd.idempresa = cr.idempresa "
					+ "                                         LEFT JOIN clientesremitosestados res ON cr.idestado = res.idestado AND cr.idempresa = res.idempresa "
					+ "                            WHERE rpc.idprioridad =  "
					+ idprioridad.toString()
					+ "                              AND (cr.idestado IS NULL OR cr.idestado = 1 ) "
					+ "                              AND rpc.idempresa =  "
					+ idempresa.toString()
					+ "                            GROUP BY rpc.idpedido_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, res.idestado, res.estado, rpc.idempresa "
					+ "                          ) cre ON pc.idpedido_cabe = cre.idpedido_cabe AND pc.idempresa = cre.idempresa "
					+ "         ) pedidos_pendientes  " + filtro
					+ "    AND idempresa =  " + idempresa.toString()
					+ "    AND idestadopedido IN (1,2,3)  ORDER BY " + orden
					+ "  LIMIT " + limit + " OFFSET  " + offset + ";";

		} else {

			cQuery = ""
					+ "SELECT idpedido_cabe, idremitocliente, nrosucursal, nroremitocliente,  idestado, estado, "
					+ "             idcliente, razon, fechapedido, idprioridad, prioridad, "
					+ "              zona, localidad, expreso, idzona, idexpreso, iddomicilio, idexpresozona, idempresa "
					+ "   FROM ( "
					+ "        SELECT pc.idpedido_regalos_entrega_cabe AS idpedido_cabe, cre.idremitocliente, cre.nrosucursal, cre.nroremitocliente, es.idestado, es.estado,    "
					+ "               cl.idcliente, cl.razon || ' - ' || cd.contacto AS razon , pc.fechapedido, pr.idprioridad, pr.prioridad,  "
					+ "               zo.idzona, zo.zona, lo.localidad, ex.idexpreso, ex.expreso, cd.iddomicilio, an.idexpresozona, pc.idempresa  "
					+ "          FROM pedidos_regalos_entregas_cabe pc   "
					+ "               INNER JOIN pedidosdomiciliosentrega cd ON pc.idsucuclie = cd.iddomicilio AND  pc.idempresa = cd.idempresa  "
					+ "               INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "               INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa   "
					+ "               INNER JOIN clientesanexolocalidades an ON pc.idanexolocalidad = an.idanexolocalidad  AND  pc.idempresa = an.idempresa  "
					// +
					// "               INNER JOIN globallocalidades lo ON an.idlocalidad = lo.idlocalidad    "
					+ "               INNER JOIN clientesexpresoszonas ez ON  an.idexpresozona = ez.codigo AND an.idempresa = ez.idempresa  "
					+ "               INNER JOIN clienteszonas zo ON ez.idzona = zo.idzona AND ez.idempresa = zo.idempresa   "
					+ "               INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso  AND ez.idempresa = ex.idempresa  "
					// 20100804 - EJV - Reasignacion -->
					// +
					+ "               INNER JOIN clientesanexolocalidades anlo ON cd.idanexolocalidad = anlo.idanexolocalidad AND cd.idempresa = anlo.idempresa "
					+ "               INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad   "
					// <--

					+ "               INNER JOIN pedidosprioridades pr ON pc.idprioridad = pr.idprioridad  "
					+ "               INNER JOIN (  "
					+ "                            SELECT rpc.idpedido_regalos_entrega_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, "
					+ "                                        res.idestado AS idestadoremito, res.estado AS estadoremito, rpc.idempresa  "
					+ "                              FROM pedidos_regalos_entregas_cabe rpc  "
					+ "                                       INNER JOIN pedidos_regalos_entregas_deta rpd ON rpc.idpedido_regalos_entrega_cabe = rpd.idpedido_regalos_entrega_cabe AND rpc.idempresa = rpd.idempresa  "
					+ "                                         LEFT JOIN clientesremitos cr ON rpd.idremitocliente = cr.idremitocliente AND rpd.idempresa = cr.idempresa  "
					+ "                                         LEFT JOIN clientesremitosestados res ON cr.idestado = res.idestado AND cr.idempresa = res.idempresa  "
					+ "                             WHERE rpc.idprioridad =   "
					+ idprioridad.toString()
					+ "                               AND (cr.idestado IS NULL OR cr.idestado = 1 )  "
					+ "                               AND rpc.idempresa = "
					+ idempresa.toString()
					+ "                             GROUP BY rpc.idpedido_regalos_entrega_cabe, cr.idremitocliente, cr.nrosucursal, cr.nroremitocliente, res.idestado, res.estado, rpc.idempresa  "
					+ "                           ) cre ON pc.idpedido_regalos_entrega_cabe = cre.idpedido_regalos_entrega_cabe AND pc.idempresa = cre.idempresa  "
					+ "         ) pedidos_pendientes      " + filtro
					+ "    AND idempresa =   " + idempresa.toString()
					+ " ORDER BY " + orden + "  LIMIT " + limit + " OFFSET  "
					+ offset + ";";

		}

		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	/**
	 * ========================================================================
	 * ===== BEGIN - CONSOLIDACION DE PEDIDOS
	 * 
	 */

	/**
	 * Metodos para la entidad: clientesRemitos Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Feb 17 14:10:19 GYT 2009
	 */

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String clientesRemitosCreate(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal idcliente,
			BigDecimal bultos, BigDecimal valorflete,
			BigDecimal valordeclaradoflete, BigDecimal seguro,
			BigDecimal impresion, BigDecimal idestado, String observaciones,
			java.sql.Date fecha, BigDecimal idprefactura, String tipopedido,
			String ctactezona, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrosucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrosucursal ";
		if (nroremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nroremitocliente ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (bultos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: bultos ";
		if (valorflete == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: flete ";
		if (seguro == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: seguro ";
		if (impresion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: impresion ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESREMITOS"
						+ "       (nrosucursal, nroremitocliente, idcliente, bultos, valorflete, valordeclaradoflete, seguro, impresion, idestado, observaciones, fecharemito, idprefactura, idctrlremito, tipopedido, nroctacte, idempresa, usuarioalt )"
						+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,  UPPER(SUBSTR(MD5(SUBSTR(RANDOM()::VARCHAR, 3, 8) ),0, 16 - (LENGTH(? || ?) + 1) )  ) || 'R' || ? || 'D' || ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, nrosucursal);
				insert.setBigDecimal(2, nroremitocliente);
				insert.setBigDecimal(3, idcliente);
				insert.setBigDecimal(4, bultos);
				insert.setBigDecimal(5, valorflete);
				insert.setBigDecimal(6, valordeclaradoflete);
				insert.setBigDecimal(7, seguro);
				insert.setBigDecimal(8, impresion);
				insert.setBigDecimal(9, idestado);
				insert.setString(10, observaciones);
				insert.setDate(11, fecha);
				insert.setBigDecimal(12, idprefactura);
				insert.setString(13, nrosucursal.toString());
				insert.setString(14, nroremitocliente.toString());
				insert.setString(15, nrosucursal.toString());
				insert.setString(16, nroremitocliente.toString());
				insert.setString(17, tipopedido);
				insert.setString(18, ctactezona);
				insert.setBigDecimal(19, idempresa);
				insert.setString(20, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar remito cliente.";

			}
		} catch (SQLException sqlException) {
			salida = "Imposible generar remito cliente (1).";
			log.error("Error SQL public String clientesRemitosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible generar remito cliente (2).";
			log
					.error("Error excepcion public String clientesRemitosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesRemitosUpdateGrupoArmado(BigDecimal idremitocliente,
			String grupoarmado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE idremitocliente = "
					+ idremitocliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESREMITOS SET grupoarmado=?, usuarioact=?, fechaact=?"
							+ " WHERE idremitocliente=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, grupoarmado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idremitocliente);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No se pudo actualizar grupo armado id-remito:  "
								+ idremitocliente;
				}

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar grupo armado id-remito:  "
					+ idremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateGrupoArmado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar grupo armado id-remito:  "
					+ idremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateGrupoArmado(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesRemitosUpdateBultos(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, int bultos, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrosucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE nrosucursal = "
					+ nrosucursal.toString()
					+ " AND nroremitocliente = "
					+ nroremitocliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESREMITOS SET bultos=?, usuarioact=?, fechaact=?"
							+ " WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setInt(1, bultos);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, nrosucursal);
					insert.setBigDecimal(5, nroremitocliente);
					insert.setBigDecimal(6, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No se pudo actualizar total Bultos remito:  "
								+ nroremitocliente;
				}

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateBultos(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateBultos(.....)"
							+ ex);
		}
		return salida;
	}

	// 20110811 - EJV -Mantis 764 -->
	public String clientesRemitosUpdateBultosFlete(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, int bultos, BigDecimal totalFlete,
			BigDecimal totalIvaFlete, BigDecimal porcIvaFlete,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrosucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE nrosucursal = "
					+ nrosucursal.toString()
					+ " AND nroremitocliente = "
					+ nroremitocliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESREMITOS SET bultos=?, valorflete=?, valordeclaradoflete=?, valorivaflete=?, porcivaflete=?, usuarioact=?, fechaact=?"
							+ " WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setInt(1, bultos);
					insert.setBigDecimal(2, totalFlete);
					insert.setBigDecimal(3, totalFlete);

					insert.setBigDecimal(4, totalIvaFlete);
					insert.setBigDecimal(5, porcIvaFlete);

					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, nrosucursal);
					insert.setBigDecimal(9, nroremitocliente);
					insert.setBigDecimal(10, idempresa);

					int i = insert.executeUpdate();

					if (i != 1)
						salida = "No se pudo actualizar total Bultos-Flete remito:  "
								+ nroremitocliente;
				}

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar total Bultos-Flete remito:  "
					+ nroremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateBultosFlete(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar total Bultos-Flete remito:  "
					+ nroremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateBultosFlete(.....)"
							+ ex);
		}
		return salida;
	}

	// <--

	// EJV - 20100804 -->
	// Se invoca desde regalos.

	public String clientesRemitosUpdateBultosCtaCte(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, int bultos, String ctactezona,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrosucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sucursal ";

		if (nroremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: remito ";

		if (ctactezona == null || ctactezona.trim().equals(""))
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ctactezona ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE nrosucursal = "
					+ nrosucursal.toString()
					+ " AND nroremitocliente = "
					+ nroremitocliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESREMITOS SET bultos=?, nroctacte=?, usuarioact=?, fechaact=?"
							+ " WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setInt(1, bultos);
					insert.setString(2, ctactezona);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, nrosucursal);
					insert.setBigDecimal(6, nroremitocliente);
					insert.setBigDecimal(7, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No se pudo actualizar total Bultos remito:  "
								+ nroremitocliente;
				}

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateBultosCtaCte(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateBultosCtaCte(.....)"
							+ ex);
		}
		return salida;
	}

	// <--

	// EJV - 20101216 - Mantis 642 -->

	public String clientesRemitosUpdateCtaCte(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, String ctactezona,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrosucursal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: sucursal ";

		if (nroremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: remito ";

		if (ctactezona == null || ctactezona.trim().equals(""))
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ctactezona ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE nrosucursal = "
					+ nrosucursal.toString()
					+ " AND nroremitocliente = "
					+ nroremitocliente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE clientesremitos SET  nroctacte=?, usuarioact=?, fechaact=?"
							+ " WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, ctactezona);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, nrosucursal);
					insert.setBigDecimal(5, nroremitocliente);
					insert.setBigDecimal(6, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No se pudo actualizar total Bultos remito:  "
								+ nroremitocliente;
				}

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateBultosCtaCte(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar total Bultos remito:  "
					+ nroremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateBultosCtaCte(.....)"
							+ ex);
		}
		return salida;
	}

	// <--

	// 20120627 - EJV - Mantis 840 -->

	public String getNroRemitoCliente(BigDecimal idremitocliente,
			BigDecimal idempresa) throws EJBException {

		String nroremitocliente = "";
		String cQuery = ""
				+ "SELECT LPAD(nrosucursal::VARCHAR, 4, '0')  || '-' || LPAD(nroremitocliente::VARCHAR, 8, '0') FROM clientesremitos "
				+ " WHERE idremitocliente = " + idremitocliente
				+ "     AND idempresa = " + idempresa;

		try {

			List listNro = getLista(cQuery);
			if (!listNro.isEmpty()) {

				nroremitocliente = ((String[]) listNro.get(0))[0];

			}

		} catch (Exception e) {
			log.error("getNroRemitoCliente(): " + e);
		}

		return nroremitocliente;
	}

	// <--

	//
	public String clientesRemitosUpdateHojaArmado(BigDecimal idremitocliente,
			BigDecimal nrohojaarmado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		String nroremitocliente = "";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (nrohojaarmado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojaarmado ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {

			nroremitocliente = getNroRemitoCliente(idremitocliente, idempresa);

			if (!nroremitocliente.equals("")) {

				ResultSet rsSalida = null;
				String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE idremitocliente = "
						+ idremitocliente.toString()
						+ " AND idempresa = "
						+ idempresa.toString() + " AND nrohojaarmado IS NULL";
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
				int total = 0;
				if (rsSalida != null && rsSalida.next())
					total = rsSalida.getInt(1);
				PreparedStatement insert = null;
				String sql = "";
				if (salida.equalsIgnoreCase("OK")) {

					if (total > 0) { // si existe hago update
						sql = "UPDATE CLIENTESREMITOS SET nrohojaarmado=?, fechahojaarmado=?, usuarioact=?, fechaact=?"
								+ " WHERE idremitocliente=? AND idempresa=?;";
						insert = dbconn.prepareStatement(sql);

						insert.setBigDecimal(1, nrohojaarmado);
						insert.setDate(2, new java.sql.Date(hoy
								.getTimeInMillis()));
						insert.setString(3, usuarioact);
						insert.setTimestamp(4, fechaact);
						insert.setBigDecimal(5, idremitocliente);
						insert.setBigDecimal(6, idempresa);

						int i = insert.executeUpdate();
						if (i != 1)
							salida = "No se pudo actualizar hoja armado  para remito  "
									+ nroremitocliente
									+ "  id-remito:  "
									+ idremitocliente;
					} else
						salida = "Remito   "
								+ nroremitocliente
								+ " id("
								+ idremitocliente
								+ ") posiblemente asignado a hoja de armado desde otra sesion.";

				} else
					salida += ". Remito " + nroremitocliente;

			} else {

				salida = "No fue posible recuperar nroremito para id-remito: "
						+ idremitocliente;

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar grupo hoja para remito  "
					+ nroremitocliente + " id-remito:  " + idremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateHojaArmado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar grupo hoja para remito  "
					+ nroremitocliente + " id-remito:   " + idremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateHojaArmado(.....)"
							+ ex);
		}

		return salida;

	}

	public String clientesRemitosUpdateDesvincularHojaArmado(
			BigDecimal nrohojaarmado, BigDecimal sucursal,
			BigDecimal comprobante, String idctrlremito, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (nrohojaarmado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojaarmado ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE idctrlremito = '"
					+ idctrlremito.toString()
					+ "'  AND idestado=1  AND nrohojaarmado="
					+ nrohojaarmado
					+ " AND nrosucursal="
					+ sucursal
					+ " AND nroremitocliente="
					+ comprobante + "  AND idempresa = " + idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = ""
							+ " UPDATE CLIENTESREMITOS SET nrohojaarmado=NULL, fechahojaarmado=NULL, usuarioact=?, fechaact=?"
							+ "  WHERE idctrlremito=?  AND nrohojaarmado=? AND nrosucursal=? AND nroremitocliente=? AND idempresa=? AND nrohojarutafinal IS NULL AND idestado=1;";
					insert = dbconn.prepareStatement(sql);

					insert.setString(1, usuarioact);
					insert.setTimestamp(2, fechaact);
					insert.setString(3, idctrlremito);
					insert.setBigDecimal(4, nrohojaarmado);
					insert.setBigDecimal(5, sucursal);
					insert.setBigDecimal(6, comprobante);
					insert.setBigDecimal(7, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No se pudo desvincular hoja armado para id-remito:  "
								+ idctrlremito;
				} else
					salida = "Remito id("
							+ idctrlremito
							+ ") posiblemente modificado desde otra sesion o estado no es pendiente.";

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar grupo hoja id-remito:  "
					+ idctrlremito;
			log
					.error("Error SQL public String clientesRemitosUpdateDesvincularHojaArmado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar hoja armado id-remito:  "
					+ idctrlremito;
			log
					.error("Error excepcion public String clientesRemitosUpdateDesvincularHojaArmado(.....)"
							+ ex);
		}

		return salida;

	}

	//
	public String clientesRemitosUpdateHojaRutaFinal(String nrohojaarmadoIN,
			BigDecimal nrohojarutafinal, String impactastock,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrohojaarmadoIN == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (nrohojarutafinal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojaarmado ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitos WHERE nrohojaarmado IN ( "
					+ nrohojaarmadoIN
					+ ") AND idempresa = "
					+ idempresa.toString() + " AND nrohojarutafinal IS  NULL";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESREMITOS SET nrohojarutafinal=?, fechahojarutafinal=?, impactostock=?, usuarioact=?, fechaact=?"
							+ " WHERE nrohojaarmado IN ( "
							+ nrohojaarmadoIN
							+ ") AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setBigDecimal(1, nrohojarutafinal);
					insert.setDate(2, new java.sql.Date(hoy.getTimeInMillis()));
					insert.setString(3, impactastock);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idempresa);

					int i = insert.executeUpdate();
					if (i == 0)
						salida = "No se pudo actualizar hoja ruta final:  "
								+ nrohojaarmadoIN;
				} else
					salida = "Nro. Hoja Armado("
							+ nrohojaarmadoIN
							+ ") posiblemente asignado a hoja de armado desde otra sesion.";

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar  hoja ruta final - Nro. Hoja Armado:  "
					+ nrohojaarmadoIN;
			log
					.error("Error SQL public String clientesRemitosUpdateHojaRutaFinal(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar hoja ruta final - Nro. Hoja Armado:  "
					+ nrohojaarmadoIN;
			log
					.error("Error excepcion public String clientesRemitosUpdateHojaRutaFinal(.....)"
							+ ex);
		}

		return salida;

	}

	public List getClientesRemitosCabecera(BigDecimal idremitocliente,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))

			cQuery = "SELECT cl.idcliente, cl.razon, td.tipodocumento, cl.nrodocumento, "
					+ "       cd.calle, cd.nro, cd.piso, cd.depto, lo.cpostal, lo.localidad, pr.provincia, cd.telefonos, cd.contacto, "
					+ "       cr.fecharemito,  cr.bultos, "
					+ "       LPAD(cr.nrosucursal::varchar, 4, '0') AS nrosucursal, "
					+ "       LPAD(cr.nroremitocliente::varchar, 8, '0') AS nroremitocliente "
					+ "  FROM pedidos_cabe pc "
					+ "       INNER JOIN pedidos_deta pd ON pc.idpedido_cabe = pd.idpedido_cabe AND pc.idempresa = pd.idempresa "
					+ "       INNER JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa "
					+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND pd.idempresa = st.idempresa  "
					+ "       INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
					+ "       INNER JOIN clientesclientes cl ON cd.idcliente = cl.idcliente AND cd.idempresa = cl.idempresa  "
					+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento AND cl.idempresa = td.idempresa  "
					+ "       INNER JOIN globallocalidades lo ON cd.idlocalidad =  lo.idlocalidad "
					+ "       INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia   "
					+ " WHERE pd.idremitocliente ="
					+ idremitocliente.toString()
					+ "   AND pd.idempresa = "
					+ idempresa.toString() + " LIMIT 1  ;";
		else

			cQuery = "SELECT cl.idcliente, cl.razon, td.tipodocumento, cl.nrodocumento, "
					+ "       cd.calle, cd.nro, cd.piso, cd.depto, lo.cpostal, lo.localidad, pr.provincia, cd.telefonos, cd.contacto, "
					+ "       cr.fecharemito,  cr.bultos,  "
					+ "       LPAD(cr.nrosucursal::varchar, 4, '0') AS nrosucursal, "
					+ "       LPAD(cr.nroremitocliente::varchar, 8, '0') AS nroremitocliente "
					+ "  FROM pedidos_regalos_entregas_cabe pc  "
					+ "       INNER JOIN pedidos_regalos_entregas_deta pd ON pc.idpedido_regalos_entrega_cabe = pd.idpedido_regalos_entrega_cabe AND pc.idempresa = pd.idempresa "
					+ "       INNER JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa  "
					+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st  AND pd.idempresa = st.idempresa   "
					+ "       INNER JOIN pedidosdomiciliosentrega cd ON pc.idcliente = cd.idcliente AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
					+ "       INNER JOIN clientesclientes cl ON cd.idcliente = cl.idcliente AND cd.idempresa = cl.idempresa   "
					+ "       INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento AND cl.idempresa = td.idempresa "
					+ "       INNER JOIN clientesanexolocalidades ax ON cd.idanexolocalidad = ax.idanexolocalidad AND cd.idempresa = ax.idempresa "
					+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad =  lo.idlocalidad  "
					+ "       INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia    "
					+ " WHERE pd.idremitocliente =  "
					+ idremitocliente.toString()
					+ "   AND pd.idempresa =   "
					+ idempresa.toString() + " LIMIT 1  ;  ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosCabecera( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesRemitosDetalle(BigDecimal idremitocliente,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))

			cQuery = "SELECT pd.idpedido_cabe, pd.codigo_st, st.descrip_st, pd.precio, pd.cantidad, pd.codigo_md, pd.codigo_dt "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidos_deta pd ON cr.idremitocliente = pd.idremitocliente AND pd.idempresa = cr.idempresa "
					+ "       INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
					+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st AND pd.idempresa = st.idempresa  "
					+ " WHERE cr.idremitocliente ="
					+ idremitocliente.toString()
					+ "   AND cr.idempresa = "
					+ idempresa.toString() + " ORDER BY pd.idpedido_cabe  ;";

		else

			cQuery = "SELECT pc.idpedido_regalos_entrega_cabe, pd.codigo_st, st.descrip_st, rd.precio, pd.cantidad, rd.codigo_md, rd.codigo_dt  "
					+ "  FROM clientesremitos cr  "
					+ "       INNER JOIN pedidos_regalos_entregas_deta pd ON cr.idremitocliente = pd.idremitocliente AND pd.idempresa = cr.idempresa "
					+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
					+ "       INNER JOIN pedidos_regalos_deta rd ON pc.idpedido_regalos_cabe = rd.idpedido_regalos_cabe AND pc.idempresa = rd.idempresa "
					+ "                 AND pd.codigo_st = rd.codigo_st AND pd.idempresa = rd.idempresa AND pd.codigo_dt = rd.codigo_dt "
					+ "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st AND pd.idempresa = st.idempresa "
					+ " WHERE cr.idremitocliente = "
					+ idremitocliente.toString()
					+ "   AND cr.idempresa = "
					+ idempresa.toString()
					+ " ORDER BY pd.idpedido_regalos_entrega_cabe ; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosDetalle( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRemitosXPedidos(BigDecimal idpedido,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))
			cQuery = ""
					+ "SELECT DISTINCT r.idremitocliente, d.idpedido_cabe, r.nrosucursal, r.nroremitocliente, l.idcliente, l.razon, "
					+ "             ea.estado AS estadoactual, cs.estado AS estadoconformacion, "
					+ "             r.idempresa,r.usuarioalt,r.usuarioact,r.fechaalt,r.fechaact, "
					+ "             cs.usuarioalt AS ualtconf, cs.usuarioact AS uactconf, cs.fechaalt AS faltconf, cs.fechaact AS factconf "
					+ "  FROM pedidos_deta d "
					+ "            INNER JOIN pedidos_cabe c ON d.idpedido_cabe = c.idpedido_cabe AND d.idempresa = c.idempresa "
					+ "            INNER JOIN clientesclientes l ON c.idcliente = l.idcliente AND c.idempresa = l.idempresa "
					+ "            INNER JOIN clientesremitos r ON d.idremitocliente = r.idremitocliente AND d.idempresa = r.idempresa "
					+ "            INNER JOIN clientesremitosestados ea ON r.idestado = ea.idestado AND r.idempresa = ea.idempresa "
					+ "              LEFT JOIN vclientesremitosconformacionstatus cs ON d.idremitocliente = cs.idremitocliente AND d.idempresa = cs.idempresa "
					+ "WHERE d.idpedido_cabe = " + idpedido.toString()
					+ "     AND d.idempresa = " + idempresa.toString() + ""
					+ " ORDER BY 1;";
		else
			cQuery = ""
					+ " SELECT DISTINCT r.idremitocliente, d.idpedido_regalos_entrega_cabe, r.nrosucursal, r.nroremitocliente, l.idcliente, l.razon || ' - ' || de.contacto AS razon,  "
					+ "              ea.estado AS estadoactual, cs.estado AS estadoconformacion,  "
					+ "              r.idempresa,r.usuarioalt,r.usuarioact,r.fechaalt,r.fechaact, cs.usuarioalt AS ualtconf, cs.usuarioact AS uactconf, cs.fechaalt AS faltconf, cs.fechaact AS factconf  "
					+ "   FROM pedidos_regalos_entregas_deta d  "
					+ "        INNER JOIN pedidos_regalos_entregas_cabe c ON d.idpedido_regalos_entrega_cabe = c.idpedido_regalos_entrega_cabe AND d.idempresa = c.idempresa  "
					+ "        INNER JOIN pedidosdomiciliosentrega de ON c.idsucuclie = de.iddomicilio AND c.idempresa = c.idempresa "
					+ "        INNER JOIN clientesclientes l ON c.idcliente = l.idcliente AND c.idempresa = l.idempresa  "
					+ "        INNER JOIN clientesremitos r ON d.idremitocliente = r.idremitocliente AND d.idempresa = r.idempresa  "
					+ "        INNER JOIN clientesremitosestados ea ON r.idestado = ea.idestado AND r.idempresa = ea.idempresa  "
					+ "         LEFT JOIN vclientesremitosconformacionstatus cs ON d.idremitocliente = cs.idremitocliente AND d.idempresa = cs.idempresa  "
					+ "  WHERE c.idpedido_regalos_cabe =  "
					+ idpedido.toString() + "    AND c.idempresa =    "
					+ idempresa.toString() + "" + " ORDER BY 1;";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Error SQL en el metodo : getPedidosRemitosXPedidos( BigDecimal idpedido ) "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * 20100217 - EJV ANULACION DE REMITOS - MANTIS 483
	 * 
	 * BEGIN --->
	 */

	public String clientesRemitosUpdEstado(BigDecimal idremitocliente,
			BigDecimal nuevoidestado, BigDecimal idempresa, String usuarioact,
			Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		int idestadoActual = -1000;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		// 20120510 -- EJV -->

		idestadoActual = getClientesRemitoEstadoActual(idremitocliente,
				idempresa, conn);

		if (idestadoActual < 0 && idestadoActual != -100)
			salida = "UPD - Error: No fue posible verificar estado actual - [ "
					+ idestadoActual + " ]";

		if (idestadoActual == nuevoidestado.intValue() && idestadoActual != 4)
			salida = "UPD - Error: Inconsistencia al actualizar nuevo estado, estado actual debe ser distinto del nuevo["
					+ idestadoActual + " - " + nuevoidestado + " ]";

		// <--

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "UPDATE clientesremitos SET idestado=?, usuarioact=?, fechaact=?"
						+ " WHERE idremitocliente=?  AND idempresa=? ;";
				insert = conn.prepareStatement(sql);
				insert.setBigDecimal(1, nuevoidestado);
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, idremitocliente);
				insert.setBigDecimal(5, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "UPD-Imposible actualizar estado de pedido Nro.: "
							+ idremitocliente;

			}

		} catch (SQLException sqlException) {
			salida = "SQLE - Imposible actualizar estado de pedido Nro.: "
					+ idremitocliente;
			log.error("Error SQL public String clientesRemitosUpdEstado(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "EX - Imposible actualizar estado de pedido Nro.: "
					+ idremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdEstado(.....)"
							+ ex);
		}
		return salida;
	}

	/*
	 * Recuperar remitos y pedidos asociados y encadenados a un nro de control
	 * de remito.
	 */

	public List getRemitoClienteAnularRecursivo(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, String idctrlremito,
			String tipopedido, int nivel, Hashtable htPedidoRemito,
			BigDecimal idempresa) throws EJBException {

		List vecSalida = new ArrayList();
		List vecAux = new ArrayList();
		Iterator iter;

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))

			cQuery = " SELECT DISTINCT pd.idpedido_cabe, pd.idremitocliente, cr.nrosucursal, "
					+ "       cr.nroremitocliente, cr.idctrlremito, pc.idcliente, cl.razon, pc.idsucuclie,"
					+ "       cr.nrohojaarmado, nrohojarutafinal "
					+ "  FROM pedidos_deta pd "
					+ "       INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE cr.nrosucursal = "
					+ nrosucursal.toString()
					+ "   AND cr.nroremitocliente = "
					+ nroremitocliente.toString()
					+ "   AND cr.idctrlremito = '"
					+ idctrlremito.toString()
					+ "' "
					+ "   AND cr.tipopedido = '"
					+ tipopedido.toUpperCase()
					+ "'"
					+ "   AND pd.idempresa =  "
					+ idempresa.toString()
					+ " ORDER BY 1 ASC, 2 ";
		else

			cQuery = " SELECT DISTINCT pd.idpedido_regalos_entrega_cabe, pd.idremitocliente, cr.nrosucursal, "
					+ "       cr.nroremitocliente, cr.idctrlremito, pc.idcliente, cl.razon, pc.idsucuclie, "
					+ "       cr.nrohojaarmado, nrohojarutafinal "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidos_regalos_entregas_deta pd ON cr.idremitocliente = pd.idremitocliente AND cr.idempresa = pd.idempresa "
					+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "       INNER JOIN pedidosdomiciliosentrega de ON pc.idsucuclie = de.iddomicilio AND pc.idempresa = de.idempresa  "
					+ " WHERE cr.nrosucursal = "
					+ nrosucursal.toString()
					+ "   AND cr.nroremitocliente = "
					+ nroremitocliente.toString()
					+ "   AND cr.idctrlremito = '"
					+ idctrlremito.toString()
					+ "'"
					+ "   AND cr.tipopedido = '"
					+ tipopedido.toUpperCase()
					+ "'"
					+ "   AND pd.idempresa =  "
					+ idempresa.toString()
					+ " ORDER BY 1 ASC, 2 ";

		vecAux = getLista(cQuery);
		iter = vecAux.iterator();

		try {

			if (nivel > 300)
				throw new Exception("ERROR RECURSIVIDAD:" + nivel);

			log.debug("nivel: " + nivel++);

			while (iter.hasNext()) {

				String[] datos = (String[]) iter.next();

				Iterator iterXpedido = getRemitoClienteAnularXPedido(
						new BigDecimal(datos[0]), idctrlremito, tipopedido,
						idempresa).iterator();

				if (htPedidoRemito.containsKey(datos[0] + "-" + datos[1]))
					continue;

				while (iterXpedido.hasNext()) {

					String[] datosXpedido = (String[]) iterXpedido.next();
					if (htPedidoRemito.containsKey(datosXpedido[0] + "-"
							+ datosXpedido[1]))
						continue;

					vecSalida.add(datosXpedido);
					htPedidoRemito.put(datosXpedido[0] + "-" + datosXpedido[1],
							"");

					Iterator i = getRemitoClienteAnularRecursivo(
							new BigDecimal(datosXpedido[2]),
							new BigDecimal(datosXpedido[3]), datosXpedido[4],
							tipopedido, nivel, htPedidoRemito, idempresa)
							.iterator();

					while (i.hasNext()) {

						String[] datosAux = (String[]) i.next();
						vecSalida.add(datosAux);
						htPedidoRemito.put(datosAux[0] + "-" + datosAux[1], "");

					}

				}

				if (htPedidoRemito.containsKey(datos[0] + "-" + datos[1]))
					continue;

				vecSalida.add(datos);
				htPedidoRemito.put(datos[0] + "-" + datos[1], "");

			}

		} catch (Exception e) {
			log.error("getRemitoClienteAnularRecursivo(): " + e);
		}

		return vecSalida;

	}

	/*
	 * Recuperar remitos asociados a un remito.
	 */

	public List getRemitoClienteAnularXPedido(BigDecimal idpedido_cabe,
			String idctrlremito, String tipopedido, BigDecimal idempresa)
			throws EJBException {

		List vecSalida = new ArrayList();

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))

			cQuery = "SELECT DISTINCT pd.idpedido_cabe, pd.idremitocliente, cr.nrosucursal, "
					+ "      cr.nroremitocliente, cr.idctrlremito, pc.idcliente, cl.razon, pc.idsucuclie, "
					+ "      cr.nrohojaarmado, nrohojarutafinal "
					+ " FROM pedidos_deta pd "
					+ "      INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
					+ "      INNER JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa "
					+ "      INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ "WHERE pd.idpedido_cabe = "
					+ idpedido_cabe.toString()
					+ "   AND cr.idctrlremito <> '"
					+ idctrlremito.toString()
					+ "'"
					+ "   AND cr.tipopedido = '"
					+ tipopedido.toUpperCase()
					+ "'"
					+ "   AND pd.idempresa =  "
					+ idempresa.toString()
					+ " ORDER BY 1 ASC, 2 ";
		else
			cQuery = "SELECT DISTINCT pd.idpedido_regalos_entrega_cabe, pd.idremitocliente, cr.nrosucursal, "
					+ "      cr.nroremitocliente, cr.idctrlremito, pc.idcliente, cl.razon, pc.idsucuclie, "
					+ "      cr.nrohojaarmado, nrohojarutafinal "
					+ " FROM clientesremitos cr "
					+ "      INNER JOIN pedidos_regalos_entregas_deta pd ON cr.idremitocliente = pd.idremitocliente AND cr.idempresa = pd.idempresa "
					+ "      INNER JOIN pedidos_regalos_entregas_cabe pc ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
					+ "      INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
					+ "      INNER JOIN pedidosdomiciliosentrega de ON pc.idsucuclie = de.iddomicilio AND pc.idempresa = de.idempresa  "
					+ "WHERE pd.idpedido_regalos_entrega_cabe = "
					+ idpedido_cabe.toString()
					+ "   AND cr.idctrlremito <> '"
					+ idctrlremito.toString()
					+ "'"
					+ "   AND cr.tipopedido = '"
					+ tipopedido.toUpperCase()
					+ "'"
					+ "   AND pd.idempresa =  "
					+ idempresa.toString()
					+ " ORDER BY 1 ASC, 2 ";

		vecSalida = getLista(cQuery);

		return vecSalida;

	}

	/*
	 * Anular / desvincular remitos correspondientes a pedidos de clientes.
	 */

	public String clientesRemitosNormalesAnular(Iterator iter,
			Hashtable htPedidos, Hashtable htCtrlRemitos,
			String[] vecIdctrlremito, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		String usuarioact = usuarioalt;
		BigDecimal idpedido_cabe = new BigDecimal(-1);
		// EJV - 20110202 - Idestado 2 corresponde a Rechazado. El correcto es 7
		// Anulado.

		// BigDecimal nuevoidestadoremito = new BigDecimal(2);
		BigDecimal nuevoidestadoremito = new BigDecimal(7);
		BigDecimal nuevoidestadopedido = new BigDecimal(1);
		Enumeration enPedidos;
		dbconn.setAutoCommit(false);

		String tipopedido = "N";

		try {

			if (vecIdctrlremito == null || vecIdctrlremito.length == 0) {

				salida = "No existen Nros. de Ctrl de Remitos a Desvincular.";

			} else if (htCtrlRemitos.size() != vecIdctrlremito.length) {

				salida = "No concuerda el valor de tabla de control con el valor de remitos a desvincular.";

			}

			if (salida.equalsIgnoreCase("OK")) {

				for (int r = 0; vecIdctrlremito != null
						&& r < vecIdctrlremito.length; r++) {

					if (htCtrlRemitos.containsKey(vecIdctrlremito[r])) {
						BigDecimal idremitocliente = new BigDecimal(
								htCtrlRemitos.get(vecIdctrlremito[r])
										.toString());
						salida = clientesRemitosUpdEstado(idremitocliente,
								nuevoidestadoremito, idempresa, usuarioact,
								dbconn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

						log.info("Actualizando estado remito: "
								+ htCtrlRemitos.get(vecIdctrlremito[r]));
						log.info("Actualizando estado remito: "
								+ vecIdctrlremito[r]);

					} else {
						salida = "Incongruencia en validacin de remitos a desvincular, uno de los nros de ctrl parece no corresponder al grupo: "
								+ vecIdctrlremito[r];
						break;
					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					BigDecimal idtransaccion = GeneralBean
							.getNextValorSequencia(
									"seq_pedidosanulacionremitoslog", dbconn);

					if (idtransaccion.longValue() > 0) {

						while (iter.hasNext() && salida.equalsIgnoreCase("OK")) {

							String[] datos = (String[]) iter.next();
							BigDecimal idremitocliente = new BigDecimal(
									datos[1]);
							BigDecimal idpedido = new BigDecimal(datos[0]);

							log.info("ANULAR pedido " + idpedido
									+ " / idremitocliente " + idremitocliente);

							salida = pedidosAnulacionRemitosLogCreate(
									idtransaccion, idremitocliente, idpedido,
									tipopedido, idempresa, usuarioalt);

							if (!salida.equalsIgnoreCase("OK"))
								break;

							log.info("DESASOCIAR pedido " + idpedido
									+ " / idremitocliente " + idremitocliente);
							salida = pedidosDetaUpdDesAsociarRemito(idpedido,
									idremitocliente, idempresa, usuarioact);

						}

					} else {

						salida = "No fue posible capturar Nro. Transaccin.";

					}

					if (salida.equalsIgnoreCase("OK")) {

						enPedidos = htPedidos.keys();
						while (enPedidos.hasMoreElements()) {

							idpedido_cabe = new BigDecimal(enPedidos
									.nextElement().toString());

							log.info("Actualizar estado pedido: "
									+ idpedido_cabe);

							salida = pedidosCabeUpdEstado(idpedido_cabe,
									nuevoidestadopedido, idempresa, usuarioact);
							if (!salida.equalsIgnoreCase("OK"))
								break;

						}

					}
				}
			}

		} catch (Exception e) {
			salida = "" + e;
			log.error("clientesRemitosNormalesAnular(): " + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else
			dbconn.rollback();

		dbconn.setAutoCommit(false);
		return salida;

	}

	/*
	 * Anular / desvincular remitos correspondientes a entregas de regalos
	 * empresarios.
	 */

	public String clientesRemitosRegalosAnular(Iterator iter,
			Hashtable htPedidos, Hashtable htCtrlRemitos,
			String[] vecIdctrlremito, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		String usuarioact = usuarioalt;
		BigDecimal idpedido_cabe = new BigDecimal(-1);
		BigDecimal nuevoidestadoremito = new BigDecimal(2);
		BigDecimal nuevoidestadopedido = new BigDecimal(1);
		Enumeration enPedidos;
		dbconn.setAutoCommit(false);

		String tipopedido = "R";

		try {

			if (vecIdctrlremito == null || vecIdctrlremito.length == 0) {

				salida = "No existen Nros. de Ctrl de Remitos a Desvincular.";

			} else if (htCtrlRemitos.size() != vecIdctrlremito.length) {

				salida = "No concuerda el valor de tabla de control con el valor de remitos a desvincular.";

			}

			if (salida.equalsIgnoreCase("OK")) {

				for (int r = 0; vecIdctrlremito != null
						&& r < vecIdctrlremito.length; r++) {

					if (htCtrlRemitos.containsKey(vecIdctrlremito[r])) {
						BigDecimal idremitocliente = new BigDecimal(
								htCtrlRemitos.get(vecIdctrlremito[r])
										.toString());
						salida = clientesRemitosUpdEstado(idremitocliente,
								nuevoidestadoremito, idempresa, usuarioact,
								dbconn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

						log.info("Actualizando estado remito: "
								+ htCtrlRemitos.get(vecIdctrlremito[r]));
						log.info("Actualizando estado remito: "
								+ vecIdctrlremito[r]);

					} else {
						salida = "Incongruencia en validacin de remitos a desvincular, uno de los nros de ctrl parece no corresponder al grupo: "
								+ vecIdctrlremito[r];
						break;
					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					BigDecimal idtransaccion = GeneralBean
							.getNextValorSequencia(
									"seq_pedidosanulacionremitoslog", dbconn);

					if (idtransaccion.longValue() > 0) {

						while (iter.hasNext() && salida.equalsIgnoreCase("OK")) {

							String[] datos = (String[]) iter.next();
							BigDecimal idremitocliente = new BigDecimal(
									datos[1]);
							BigDecimal idpedido = new BigDecimal(datos[0]);

							log.info("ANULAR pedido " + idpedido
									+ " / idremitocliente " + idremitocliente);

							salida = pedidosAnulacionRemitosLogCreate(
									idtransaccion, idremitocliente, idpedido,
									tipopedido, idempresa, usuarioalt);

							if (!salida.equalsIgnoreCase("OK"))
								break;

							log.info("DESASOCIAR pedido " + idpedido
									+ " / idremitocliente " + idremitocliente);
							salida = pedidosRegalosEntregasDetaUpdDesAsociarRemito(
									idpedido, idremitocliente, idempresa,
									usuarioact);

						}

					} else {

						salida = "No fue posible capturar Nro. Transaccin.";

					}

					if (salida.equalsIgnoreCase("OK")) {

						enPedidos = htPedidos.keys();
						while (enPedidos.hasMoreElements()) {

							idpedido_cabe = new BigDecimal(enPedidos
									.nextElement().toString());

							log.info("Actualizar estado pedido: "
									+ idpedido_cabe);

							salida = pedidosRegalosEntregasCabeUpdEstado(
									idpedido_cabe, nuevoidestadopedido,
									idempresa, usuarioact);
							if (!salida.equalsIgnoreCase("OK"))
								break;

						}

					}
				}
			}

		} catch (Exception e) {
			salida = "" + e;
			log.error("clientesRemitosRegalosAnular(): " + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else
			dbconn.rollback();

		dbconn.setAutoCommit(false);
		return salida;

	}

	/*
	 * Generar log de remitos desvinculados / anulados
	 */
	public String pedidosAnulacionRemitosLogCreate(BigDecimal idtransaccion,
			BigDecimal idremitocliente, BigDecimal idpedido, String tipopedido,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtransaccion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtransaccion ";
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";
		if (idpedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido ";
		if (tipopedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipopedido ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipopedido.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipopedido ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO pedidosanulacionremitoslog"
						+ "            (idtransaccion, idremitocliente, idpedido, tipopedido, idempresa, usuarioalt )"
						+ "     VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idtransaccion);
				insert.setBigDecimal(2, idremitocliente);
				insert.setBigDecimal(3, idpedido);
				insert.setString(4, tipopedido);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar log [" + idremitocliente
							+ " / " + idpedido + "].";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible generar log [" + idremitocliente
					+ " / " + idpedido + "].";
			log
					.error("Error SQL public String pedidosAnulacionRemitosLogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX) No fue posible generar log [" + idremitocliente
					+ " / " + idpedido + "].";
			log
					.error("Error excepcion public String pedidosAnulacionRemitosLogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * 20100217 - EJV ANULACION DE REMITOS - MANTIS 483
	 * 
	 * END <---
	 */

	/**
	 * 20100902 - EJV MANTIS - 481 Desvincular remitos de hojas de armado BEGIN
	 * -->
	 */

	public String clientesRemitosDesvincularHA(BigDecimal nrohojaarmado,
			String idctrlremito, BigDecimal sucursal, BigDecimal comprobante,
			String tipopedido, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		String usuarioact = usuarioalt;
		BigDecimal nuevoidestadoremito = new BigDecimal(2);

		dbconn.setAutoCommit(false);

		try {

			List list = getLista("SELECT idremitocliente FROM clientesremitos WHERE idctrlremito = '"
					+ idctrlremito + "' AND idempresa =  " + idempresa);

			if (!list.isEmpty() && list.size() > 0) {

				BigDecimal idremitocliente = new BigDecimal(((String[]) list
						.get(0))[0]);

				// log.info("idremitocliente: " + idremitocliente);

				salida = clientesRemitosUpdateDesvincularHojaArmado(
						nrohojaarmado, sucursal, comprobante, idctrlremito,
						idempresa, usuarioact);

				if (salida.equalsIgnoreCase("OK")) {

					salida = clientesRemitosDesvincularHojaArmadoLogCreate(
							idremitocliente, nrohojaarmado, tipopedido,
							idempresa, usuarioalt);

				}

			}

		} catch (Exception e) {
			salida = "" + e;
			log.error("clientesRemitosDesvincularHA(): " + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else
			dbconn.rollback();

		dbconn.setAutoCommit(false);
		return salida;

	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesRemitosDesvincularHojaArmadoLogCreate(
			BigDecimal idremitocliente, BigDecimal nrohojaarmado,
			String tipopedido, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";
		if (nrohojaarmado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojaarmado ";
		if (tipopedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipopedido ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipopedido.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipopedido ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESREMITOSDESVINCULARHOJAARMADOLOG(idremitocliente, nrohojaarmado, tipopedido, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idremitocliente);
				insert.setBigDecimal(2, nrohojaarmado);
				insert.setString(3, tipopedido);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No se fu posible generar log para desvincular remito [id: "
							+ idremitocliente
							+ "] de hoja de armado: "
							+ nrohojaarmado;
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)No se fu posible generar log para desvincular remito [id: "
					+ idremitocliente + "] de hoja de armado: " + nrohojaarmado;
			log
					.error("Error SQL public String clientesRemitosDesvincularHojaArmadoLogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(E)No se fu posible generar log para desvincular remito [id: "
					+ idremitocliente + "] de hoja de armado: " + nrohojaarmado;
			log
					.error("Error excepcion public String clientesRemitosDesvincularHojaArmadoLogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * END <--
	 * */

	// + "  WHERE pc.idempresa = ? "
	// + "    AND pc.idpedido_cabe IN ( " + pedidosIN
	// + ")";
	//
	// String ins = ""
	// + "INSERT INTO pedidosanulacionremitoslog"
	// +
	// "            (idtransaccion, idremitocliente, idpedido, tipopedido, idempresa, usuarioalt ) "
	// + subQuery;
	//
	// PreparedStatement insert = dbconn.prepareStatement(ins);
	//
	// insert.setBigDecimal(1, idtransaccion);
	// insert.setString(2, tipopedido);
	// insert.setBigDecimal(3, idempresa);
	// insert.setString(4, usuarioalt);
	// insert.setBigDecimal(5, idempresa);
	//
	// int n = insert.executeUpdate();
	// if (n > 1)
	// salida = "No se generaron registros en log.";
	// } else
	// salida = "No fue posible capturar Nro. Transaccin.";
	// }
	// } catch (SQLException sqlException) {
	// salida = "(SQLE) No fue posible generar log.";
	// log
	// .error("Error SQL public String pedidosAnulacionRemitosLogCreate(.....)"
	// + sqlException);
	// } catch (Exception ex) {
	// salida = "(EX) No fue posible generar log.";
	// log
	// .error("Error excepcion public String pedidosAnulacionRemitosLogCreate(.....)"
	// + ex);
	// }
	// return salida;
	// }
	//
	//	
	//	
	/**
	 * Recuperar detalle de pedidos para mismo cliente, mismo domicilio, misma
	 * fecha, mismo deposito origen, para agrupar en un solo remito.
	 * 
	 */

	public List getPedidosAConsolidar(String idpedidoIN, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_cabe, pc.idcliente, pc.idsucuclie, pc.fechapedido::date AS fechapedido,  "
				+ "       pd.idpedido_deta, pd.codigo_st, pd.cantidad, pd.codigo_dt, "
				+ "       (pc.idcliente::VARCHAR || '-' || pc.idsucuclie::VARCHAR || '-'"
				// 20110706 - EJV - Factuaracion FE-CF-MA -->
				+ "       || TO_CHAR(pc.fechapedido,'yyyymm')|| '-' ||  pc.idcondicion || '-'  "
				+ "       || CASE WHEN pc.idtarjeta IS NULL  OR  pc.idtarjeta < 1 THEN 'ST' ELSE pc.idtarjeta::VARCHAR END || '-' "
				+ "       || ex.idzona::VARCHAR)::VARCHAR AS flagNuevoRemito, zcc.ctacte_normal  "
				// <--
				// +
				// "       || TO_CHAR(pc.fechapedido,'yyyymm')|| '-' ||  pc.idcondicion || '-' ||  ex.idzona::VARCHAR)::VARCHAR AS flagNuevoRemito, zcc.ctacte_normal  "

				// EJV - 20100802 Mantis 554 -
				// +
				// "       || TO_CHAR(pc.fechapedido,'yyyymmdd')|| '-' || ex.idzona::VARCHAR)::VARCHAR AS flagNuevoRemito "
				+ "  FROM pedidos_cabe pc"
				+ "       INNER JOIN pedidos_deta pd ON pc.idpedido_cabe = pd.idpedido_cabe AND pc.idempresa = pd.idempresa "
				+ "       INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND pc.idempresa = pd.idempresa "
				// 20100804 - EJV - Reasignacion -->
				// +
				// "       INNER JOIN clientesanexolocalidades xl ON cd.idanexolocalidad = xl.idanexolocalidad AND cd.idempresa = xl.idempresa "
				+ "       INNER JOIN clientesanexolocalidades xl ON pc.idanexolocalidad = xl.idanexolocalidad AND pc.idempresa = xl.idempresa "
				// <--

				+ "       INNER JOIN clientesexpresoszonas ex ON xl.idexpresozona = ex.codigo AND xl.idempresa = ex.idempresa "
				// 20100803 - CuentaCorriente - EJV
				+ "         LEFT JOIN clienteszonasctacte zcc ON ex.idzona = zcc.idzona AND ex.idempresa = zcc.idempresa "

				+ " WHERE pc.idpedido_cabe IN " + idpedidoIN
				+ "   AND pd.idremitocliente IS NULL  "
				+ "   AND pc.idempresa = " + idempresa.toString()
				// 20110216 - Mantis 679 - EJV
				// +
				// " ORDER BY pc.idcliente, pc.idsucuclie, pc.fechapedido, pd.codigo_dt,  pc.idcondicion; ";
				// +
				// " ORDER BY pc.idcliente, pc.idsucuclie, pc.fechapedido::date, pd.codigo_dt,  pc.idcondicion; ";
				// 20110728 - EJV - Incidencia Baco (posible error en
				// ordenamiento?)
				+ " ORDER BY pc.idcliente, pc.idsucuclie, pc.fechapedido::date, pd.codigo_dt,  pc.idcondicion, pc.idtarjeta; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosAConsolidar(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosAConsolidar(String idpedidoIN,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_regalos_entrega_cabe, pc.idcliente, pc.idsucuclie, pc.fechapedido::date AS fechapedido,  "
				+ "       pd.idpedido_regalos_entrega_deta, pd.codigo_st, pd.cantidad, rd.codigo_dt, "
				+ "       (pc.idcliente::VARCHAR || '-' || pc.idsucuclie::VARCHAR || '-'"
				+ "       || TO_CHAR(pc.fechapedido,'yyyymm')|| '-' || ex.idzona::VARCHAR)::VARCHAR AS flagNuevoRemito, zcc.ctacte_regalos, zcc.ctacte_regalos_alto "
				// EJV - 20100802 Mantis 554 -
				// +
				// "       || TO_CHAR(pc.fechapedido,'yyyymmdd')|| '-' || ex.idzona::VARCHAR)::VARCHAR AS flagNuevoRemito "
				// + "  FROM pedidos_regalos_entregas_cabe pc"
				+ "  FROM pedidos_regalos_deta rd "
				+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON rd.idpedido_regalos_cabe = pc.idpedido_regalos_cabe AND  rd.idempresa = pc.idempresa "
				+ "       INNER JOIN pedidos_regalos_entregas_deta pd ON pc.idpedido_regalos_entrega_cabe = pd.idpedido_regalos_entrega_cabe AND pc.idempresa = pd.idempresa "
				+ "                  AND rd.codigo_st = pd.codigo_st   AND rd.idempresa = pd.idempresa AND rd.codigo_dt = pd.codigo_dt"
				+ "       INNER JOIN pedidosdomiciliosentrega cd ON pc.idsucuclie = cd.iddomicilio AND pc.idempresa = pd.idempresa "
				// 20100804 - EJV - Reasignacion -->
				// +
				// "       INNER JOIN clientesanexolocalidades xl ON cd.idanexolocalidad = xl.idanexolocalidad AND cd.idempresa = xl.idempresa "
				+ "       INNER JOIN clientesanexolocalidades xl ON pc.idanexolocalidad = xl.idanexolocalidad AND pc.idempresa = xl.idempresa "
				// <--
				+ "       INNER JOIN clientesexpresoszonas ex ON xl.idexpresozona = ex.codigo AND xl.idempresa = ex.idempresa "
				// 20100803 - CuentaCorriente - EJV
				+ "         LEFT JOIN clienteszonasctacte zcc ON ex.idzona = zcc.idzona AND ex.idempresa = zcc.idempresa "
				+ " WHERE pc.idpedido_regalos_entrega_cabe IN "
				+ idpedidoIN
				+ "   AND pd.idremitocliente IS NULL  "
				+ "   AND pc.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY pc.idcliente, pc.idsucuclie, pc.fechapedido::date, rd.codigo_dt; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosAConsolidar(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Actualizar detalle pedido, asociar remito.
	 */

	public String pedidosDetaUpdAsociarRemito(BigDecimal idpedido_deta,
			BigDecimal idremitocliente, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_deta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_deta ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_deta WHERE idpedido_deta = "
					+ idpedido_deta.toString()
					+ " AND idempresa = "
					+ idempresa.toString() + " AND idremitocliente IS NULL";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_DETA SET idremitocliente=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_deta=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idremitocliente);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_deta);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible actualizar el detalle pedido (iddetalle="
								+ idpedido_deta + ").";

				} else
					salida = "Detalle de pedido(iddetalle=" + idpedido_deta
							+ ") posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE-Imposible actualizar el detalle pedido (iddetalle="
					+ idpedido_deta + ").";
			log
					.error("Error SQL public String pedidosDetaUpdAsociarRemito(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "E-Imposible actualizar el detalle pedido (iddetalle="
					+ idpedido_deta + ").";
			log
					.error("Error excepcion public String pedidosDetaUpdAsociarRemito(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosDetaUpdDesAsociarRemito(BigDecimal idpedido_cabe,
			BigDecimal idremitocliente, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_deta WHERE idpedido_cabe = "
					+ idpedido_cabe.toString()
					+ " AND idempresa = "
					+ idempresa.toString()
					+ " AND idremitocliente = "
					+ idremitocliente;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update

					sql = "     UPDATE pedidos_deta "
							+ "    SET idremitocliente = NULL, "
							+ "        usuarioact = ?, "
							+ "        fechaact = ? "
							+ "  WHERE idpedido_cabe = ? "
							+ "    AND idremitocliente = ? "
							+ "    AND idempresa = ? ";

					insert = dbconn.prepareStatement(sql);
					insert.setString(1, usuarioact);
					insert.setTimestamp(2, fechaact);
					insert.setBigDecimal(3, idpedido_cabe);
					insert.setBigDecimal(4, idremitocliente);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i < 1)
						salida = "UPD-Imposible actualizar el detalle pedido (idpedido="
								+ idpedido_cabe
								+ " / idremito="
								+ idremitocliente + ").";

				} else
					salida = "Detalle de pedido(idpedido=" + idpedido_cabe
							+ ") posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE-Imposible actualizar el detalle pedido (idpedido="
					+ idpedido_cabe + ").";
			log
					.error("Error SQL public String pedidosDetaUpdDesAsociarRemito(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "E-Imposible actualizar el detalle pedido (idpedido="
					+ idpedido_cabe + ").";
			log
					.error("Error excepcion public String pedidosDetaUpdDesAsociarRemito(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Actualizar detalle pedido, asociar remito.
	 */

	public String pedidosRegalosEntregasDetaUpdAsociarRemito(
			BigDecimal idpedido_deta, BigDecimal idremitocliente,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_deta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_deta ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_regalos_entregas_deta WHERE idpedido_regalos_entrega_deta = "
					+ idpedido_deta.toString()
					+ " AND idempresa = "
					+ idempresa.toString() + " AND idremitocliente IS NULL";

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE pedidos_regalos_entregas_deta SET idremitocliente=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_regalos_entrega_deta=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idremitocliente);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_deta);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible actualizar el detalle entrega (iddetalle="
								+ idpedido_deta + ").";

				} else
					salida = "Detalle de entrega(iddetalle=" + idpedido_deta
							+ ") posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE-Imposible actualizar el detalle entrega (iddetalle="
					+ idpedido_deta + ").";
			log
					.error("Error SQL public String pedidosRegalosEntregasDetaUpdAsociarRemito(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "E-Imposible actualizar el detalle entrega (iddetalle="
					+ idpedido_deta + ").";
			log
					.error("Error excepcion public String pedidosRegalosEntregasDetaUpdAsociarRemito(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosRegalosEntregasDetaUpdDesAsociarRemito(
			BigDecimal idpedido_regalos_entrega_cabe,
			BigDecimal idremitocliente, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_regalos_entrega_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_regalos_entrega_cabe ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_regalos_entregas_deta WHERE idpedido_regalos_entrega_cabe = "
					+ idpedido_regalos_entrega_cabe.toString()
					+ " AND idempresa = "
					+ idempresa.toString()
					+ " AND idremitocliente = " + idremitocliente;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update

					sql = "     UPDATE pedidos_regalos_entregas_deta "
							+ "    SET idremitocliente = NULL, "
							+ "        usuarioact = ?, "
							+ "        fechaact = ? "
							+ "  WHERE idpedido_regalos_entrega_cabe = ? "
							+ "    AND idremitocliente = ? "
							+ "    AND idempresa = ? ";

					insert = dbconn.prepareStatement(sql);
					insert.setString(1, usuarioact);
					insert.setTimestamp(2, fechaact);
					insert.setBigDecimal(3, idpedido_regalos_entrega_cabe);
					insert.setBigDecimal(4, idremitocliente);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i < 1)
						salida = "UPD-Imposible actualizar el detalle pedido (idpedido="
								+ idpedido_regalos_entrega_cabe
								+ " / idremito=" + idremitocliente + ").";

				} else
					salida = "Detalle de pedido(idpedido="
							+ idpedido_regalos_entrega_cabe
							+ ") posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE-Imposible actualizar el detalle pedido (idpedido="
					+ idpedido_regalos_entrega_cabe + ").";
			log
					.error("Error SQL public String pedidosRegalosEntregasDetaUpdDesAsociarRemito(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "E-Imposible actualizar el detalle pedido (idpedido="
					+ idpedido_regalos_entrega_cabe + ").";
			log
					.error("Error excepcion public String pedidosRegalosEntregasDetaUpdDesAsociarRemito(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Actualizar cabecera pedido - cambiar estado.
	 */

	public String pedidosCabeUpdEstado(BigDecimal idpedido_cabe,
			BigDecimal nuevoidestado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_cabe WHERE idpedido_cabe = "
					+ idpedido_cabe.toString() + " AND idempresa =" + idempresa;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_CABE SET idestado=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_cabe=?  AND idempresa=? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, nuevoidestado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_cabe);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible actualizar estado de pedido Nro.: "
								+ idpedido_cabe;

				} else
					salida = "Pedido Nro.:(" + idpedido_cabe
							+ "), posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log.error("Error SQL public String pedidosCabeUpdEstado(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "EX - Imposible actualizar estado de pedido Nro.: "
					+ idpedido_cabe;
			log
					.error("Error excepcion public String pedidosCabeUpdEstado(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Actualizar cabecera pedido (entrega) - cambiar estado.
	 */

	public String pedidosRegalosEntregasCabeUpdEstado(BigDecimal idpedido_cabe,
			BigDecimal nuevoidestado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";

		// fin validaciones

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_regalos_entregas_cabe WHERE idpedido_regalos_entrega_cabe = "
					+ idpedido_cabe.toString() + " AND idempresa =" + idempresa;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE pedidos_regalos_entregas_cabe SET idestado=?, usuarioact=?, fechaact=?"
							+ " WHERE idpedido_regalos_entrega_cabe=?  AND idempresa=? ;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, nuevoidestado);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_cabe);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "UPD-Imposible actualizar estado de entrega Nro.: "
								+ idpedido_cabe;

				} else
					salida = "Pedido Nro.:(" + idpedido_cabe
							+ "), posiblemente actualizado desde otra sesion.";

			}
		} catch (SQLException sqlException) {
			salida = "SQLE - Imposible actualizar estado de Entrega Nro.: "
					+ idpedido_cabe;
			log
					.error("Error SQL public String pedidosRegalosEntregasCabeUpdEstado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX - Imposible actualizar estado de Entrega Nro.: "
					+ idpedido_cabe;
			log
					.error("Error excepcion public String pedidosRegalosEntregasCabeUpdEstado(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidosMotivosDescuento Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Mar 11 08:31:00 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosMotivosDescuentoAll(long limit, long offset,
			BigDecimal ejercicio, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pm.idmotivodescuento,pm.motivodescuento,pm.idcuenta,ip.cuenta,pm.idempresa,"
				+ "       pm.usuarioalt,pm.usuarioact,pm.fechaalt,pm.fechaact"
				+ "  FROM pedidosmotivosdescuento pm"
				+ "        INNER JOIN contableinfiplan ip  ON pm.idcuenta = ip.idcuenta AND pm.idempresa = ip.idempresa "
				+ " WHERE ip.ejercicio = " + ejercicio + " AND pm.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosMotivosDescuentoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosMotivosDescuentoOcu(long limit, long offset,
			String ocurrencia, BigDecimal ejercicio, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pm.idmotivodescuento,pm.motivodescuento,pm.idcuenta,ip.cuenta,pm.idempresa,"
				+ "       pm.usuarioalt,pm.usuarioact,pm.fechaalt,pm.fechaact"
				+ "  FROM pedidosmotivosdescuento pm"
				+ "        INNER JOIN contableinfiplan ip  ON pm.idcuenta = ip.idcuenta AND pm.idempresa = ip.idempresa "
				+ " WHERE (UPPER(pm.motivodescuento) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND ip.ejercicio = "
				+ ejercicio + " AND pm.idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosMotivosDescuentoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosMotivosDescuentoPK(BigDecimal idmotivodescuento,
			BigDecimal ejercicio, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pm.idmotivodescuento,pm.motivodescuento,pm.idcuenta,ip.cuenta,pm.idempresa,"
				+ "       pm.usuarioalt,pm.usuarioact,pm.fechaalt,pm.fechaact"
				+ "  FROM pedidosmotivosdescuento pm"
				+ "        INNER JOIN contableinfiplan ip  ON pm.idcuenta = ip.idcuenta AND pm.idempresa = ip.idempresa "
				+ " WHERE pm.idmotivodescuento=" + idmotivodescuento.toString()
				+ "   AND ip.ejercicio = " + ejercicio + " AND pm.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosMotivosDescuentoPK( BigDecimal idmotivodescuento )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosMotivosDescuentoDelete(BigDecimal idmotivodescuento,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSMOTIVOSDESCUENTO WHERE idmotivodescuento="
				+ idmotivodescuento.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSMOTIVOSDESCUENTO WHERE idmotivodescuento="
						+ idmotivodescuento.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosMotivosDescuentoDelete( BigDecimal idmotivodescuento, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosMotivosDescuentoDelete( BigDecimal idmotivodescuento, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosMotivosDescuentoCreate(String motivodescuento,
			BigDecimal idcuenta, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (motivodescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivodescuento ";
		if (idcuenta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcuenta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (motivodescuento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivodescuento ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSMOTIVOSDESCUENTO(motivodescuento, idcuenta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, motivodescuento);
				insert.setBigDecimal(2, idcuenta);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosMotivosDescuentoCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosMotivosDescuentoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosMotivosDescuentoCreateOrUpdate(
			BigDecimal idmotivodescuento, String motivodescuento,
			BigDecimal idcuenta, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivodescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivodescuento ";
		if (motivodescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivodescuento ";
		if (idcuenta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcuenta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (motivodescuento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivodescuento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosMotivosDescuento WHERE idmotivodescuento = "
					+ idmotivodescuento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSMOTIVOSDESCUENTO SET motivodescuento=?, idcuenta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idmotivodescuento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivodescuento);
					insert.setBigDecimal(2, idcuenta);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivodescuento);
				} else {
					String ins = "INSERT INTO PEDIDOSMOTIVOSDESCUENTO(motivodescuento, idcuenta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, motivodescuento);
					insert.setBigDecimal(2, idcuenta);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosMotivosDescuentoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosMotivosDescuentoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosMotivosDescuentoUpdate(BigDecimal idmotivodescuento,
			String motivodescuento, BigDecimal idcuenta, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivodescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivodescuento ";
		if (motivodescuento == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivodescuento ";
		if (idcuenta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcuenta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (motivodescuento.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivodescuento ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosMotivosDescuento WHERE idmotivodescuento = "
					+ idmotivodescuento.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSMOTIVOSDESCUENTO SET motivodescuento=?, idcuenta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idmotivodescuento=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivodescuento);
					insert.setBigDecimal(2, idcuenta);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivodescuento);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosMotivosDescuentoUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosMotivosDescuentoUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Generar consolidacion de pedidos normales
	 */

	public String[] pedidosNormalesConsolidarRemitos(BigDecimal idpuesto,
			BigDecimal idcontadorcomprobante, String[] idpedido_cabe,
			java.sql.Date fecharemito, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		String[] resultado = new String[] {};
		String idpedidoIN = "";
		String muevestock = "";
		String flagCambiaRemito = "";
		String grupoArmado = "";
		int maxLineasXremito = 0;
		int auxLineas = 0;

		BigDecimal minidremito = new BigDecimal(-1);
		BigDecimal maxidremito = new BigDecimal(0);

		BigDecimal nrosucursal = new BigDecimal(-1);
		BigDecimal nroremitocliente = new BigDecimal(-1);
		BigDecimal idremitocliente = new BigDecimal(-1);
		List listPedidosConsolidar;
		Iterator iter;
		Enumeration enume;
		Hashtable hashRemitos = new Hashtable();

		Hashtable hashGrupoArmado = new Hashtable();
		Hashtable hashAuxGrupoArmado = new Hashtable();
		// EJV - 20110113 - Mantis 659 -->
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM");
		int anoMesRemito = Integer.parseInt(sdf.format(fecharemito));
		// <--
		dbconn.setAutoCommit(false);

		try {

			if (idcontadorcomprobante != null
					&& idcontadorcomprobante.longValue() > 0) {

				nrosucursal = GeneralBean.getSucursalComprobante(
						idcontadorcomprobante, idempresa, dbconn);

				if (nrosucursal == null || nrosucursal.longValue() < 0) {
					salida = "Verificar sucursal definida para el contador de remitos del puesto.";
				}

				if (salida.equalsIgnoreCase("OK")) {
					// TODO: se esta llamando a la misma configuracion de
					// remitos
					// internos, quizas sea necesario generar una nueva.
					try {
						maxLineasXremito = Integer.parseInt(GeneralBean
								.getValorSetupVariables("maxLineasXremito",
										idempresa, this.dbconn));
					} catch (Exception e) {
						salida = "Imposible recuperar lineas detalle remito.";
						log.error("maxLineasXremito: " + e);
					}

					if (salida.equalsIgnoreCase("OK")) {

						// Determinar si se invoca a los metodos de movimientos
						// de
						// stock
						muevestock = GeneralBean.getValorSetupVariables(
								"pedidosConsolidarRemitoMueveStock", idempresa,
								this.dbconn);

						for (int m = 0; m < idpedido_cabe.length; m++)
							idpedidoIN += idpedido_cabe[m] + ",";

						idpedidoIN = " ( "
								+ idpedidoIN.substring(0, idpedidoIN
										.lastIndexOf(',')) + " ) ";

						listPedidosConsolidar = getPedidosAConsolidar(
								idpedidoIN, idempresa);

						if (listPedidosConsolidar != null
								&& !listPedidosConsolidar.isEmpty()) {

							iter = listPedidosConsolidar.iterator();

							while (iter.hasNext()) {

								String[] datos = (String[]) iter.next();
								BigDecimal idpedidocabe = new BigDecimal(
										datos[0]);

								// EJV - 20110113 - Mantis 659 -->

								int anoMesPedido = Integer
										.parseInt(sdf.format(java.sql.Date
												.valueOf(datos[3])));
								log.info("anoMesPedido: " + anoMesPedido);
								log.info("anoMesRemito: " + anoMesRemito);

								// <--

								BigDecimal idpedido_deta = new BigDecimal(
										datos[4]);
								String codigo_st = datos[5];
								// EJV - 20100803
								String ctactezona = datos[9];

								// for (int r = 0; r < datos.length;
								// r++)log.warn("datos[" +
								// r +
								// "]: " + datos[r]);

								// EJV - 20110113 - Mantis 659 -->
								if (anoMesRemito != anoMesPedido) {

									sdf = new SimpleDateFormat("dd/MM/yyyy");
									salida = "Mes y ano de fecha de entrega "
											+ sdf.format(java.sql.Date
													.valueOf(datos[3]))
											+ " del pedido "
											+ idpedidocabe
											+ " deben corresponderse con mes y ano de fecha de remito "
											+ sdf.format(fecharemito) + ".";
									break;
								}
								// <--

								if (!flagCambiaRemito.equals(datos[8])
										|| auxLineas >= maxLineasXremito) {

									log.debug("------- " + datos[0]
											+ " -------- ");

									if (idremitocliente.longValue() > 0) {

										// Encapsular -->
										enume = GeneralBean
												.getSetSorted(hashAuxGrupoArmado
														.keySet());
										while (enume.hasMoreElements())
											grupoArmado += enume.nextElement()
													.toString()
													+ ";";

										hashGrupoArmado.put(idremitocliente
												.toString(), grupoArmado);
										// Encapsular <--

										hashAuxGrupoArmado = new Hashtable();
										grupoArmado = "";

									}

									/*
									 * 
									 * "pc.idpedido_cabe, pc.idcliente,
									 * pc.idsucuclie, pc.fechapedido, "
									 * "pd.idpedido_deta, pd.codigo_st,
									 * pd.cantidad, pd.codigo_dt,
									 * " "(pc.idcliente::VARCHAR || '-' ||
									 * pc.idsucuclie::VARCHAR || '-'" "||
									 * TO_CHAR(pc.fechapedido,'yyyymmdd')|| '-'
									 * || pd.codigo_dt::VARCHAR)::VARCHAR AS
									 * flagNuevoRemito"
									 */

									BigDecimal idcliente = new BigDecimal(
											datos[1]);
									BigDecimal bultos = new BigDecimal(0);
									BigDecimal valorflete = new BigDecimal(0);
									BigDecimal valordeclaradoflete = new BigDecimal(
											0);
									BigDecimal seguro = new BigDecimal(0);
									// 20110203 - EJV - Mantis 668 -->
									seguro = new BigDecimal(100);
									// <--

									BigDecimal impresion = new BigDecimal(0);
									BigDecimal idestadoremito = new BigDecimal(
											1);
									String observaciones = "";
									// EJV - Mantis 540 - 20100626
									// java.sql.Date fecha =
									// java.sql.Date.valueOf(datos[3]);
									BigDecimal idprefactura = null;

									nroremitocliente = GeneralBean.getContador(
											idcontadorcomprobante, idempresa,
											this.dbconn);
									flagCambiaRemito = datos[8];
									auxLineas = 0;

									log.warn("REMITO:  " + nroremitocliente
											+ " * ");

									hashRemitos.put(nroremitocliente,
											nroremitocliente);

									salida = clientesRemitosCreate(nrosucursal,
											nroremitocliente, idcliente,
											bultos, valorflete,
											valordeclaradoflete, seguro,
											impresion, idestadoremito,
											observaciones, fecharemito,
											idprefactura, "N", ctactezona,
											idempresa, usuarioalt);

									if (!salida.equalsIgnoreCase("OK"))
										break;

									idremitocliente = GeneralBean
											.getValorSequencia(
													"seq_idremitocliente",
													dbconn);

									if (idremitocliente == null) {
										salida = "Error al recuperar id. interno de remito cliente.";
										break;
									}

									// 20109007 - EJV Mantis 565 - Generar
									// estado inicial de preconformacion - ->
									salida = clientesRemitosConformacionCreate(
											idremitocliente, new BigDecimal(1),
											"N", idempresa, usuarioalt, dbconn);

									if (!salida.equalsIgnoreCase("OK"))
										break;
									// <--

									if (minidremito.longValue() < 0)
										minidremito = idremitocliente;
									maxidremito = idremitocliente;

								}

								// 

								salida = pedidosCabeUpdEstado(idpedidocabe,
										new BigDecimal(2), idempresa,
										usuarioalt);

								if (salida.equalsIgnoreCase("OK")) {
									salida = pedidosDetaUpdAsociarRemito(
											idpedido_deta, idremitocliente,
											idempresa, usuarioalt);

									hashAuxGrupoArmado
											.put(codigo_st, codigo_st);

								}

								if (!salida.equalsIgnoreCase("OK"))
									break;

								auxLineas++;

							}//

							// EJV - 20110113 - Mantis 659 -->
							if (salida.equalsIgnoreCase("OK")) {
								// <--
								// Encapsular -->
								enume = GeneralBean
										.getSetSorted(hashAuxGrupoArmado
												.keySet());
								while (enume.hasMoreElements())
									grupoArmado += enume.nextElement()
											.toString()
											+ ";";

								hashGrupoArmado.put(idremitocliente.toString(),
										grupoArmado);
								// Encapsular <--

								if (salida.equalsIgnoreCase("OK")) {
									enume = hashGrupoArmado.keys();
									while (enume.hasMoreElements()) {
										grupoArmado = enume.nextElement() + "";
										salida = clientesRemitosUpdateGrupoArmado(
												new BigDecimal(grupoArmado),
												hashGrupoArmado
														.get(grupoArmado)
														+ "", idempresa,
												usuarioalt);
										if (!salida.equalsIgnoreCase("OK"))
											break;
									}

									if (salida.equalsIgnoreCase("OK")) {
										enume = hashRemitos.keys();
										while (enume.hasMoreElements()) {
											int bultos = 0;

											BigDecimal[] totalesFlete = new BigDecimal[] {
													new BigDecimal(0),
													new BigDecimal(0),
													new BigDecimal(0) };
											BigDecimal totalFlete = new BigDecimal(
													0);
											BigDecimal totalIvaFlete = new BigDecimal(
													0);
											BigDecimal porcIvaFlete = new BigDecimal(
													0);

											nroremitocliente = new BigDecimal(
													enume.nextElement()
															.toString());

											bultos = getCalculoBulto(
													nrosucursal,
													nroremitocliente, idempresa);

											log.info("BULTOS: " + bultos);

											// 20110811 - EJV - Matis 764 -->
											totalesFlete = getCalculoFlete(
													nrosucursal,
													nroremitocliente, bultos,
													idempresa, null);

											totalFlete = totalesFlete[0];
											totalIvaFlete = totalesFlete[1];
											porcIvaFlete = totalesFlete[2];

											if (totalFlete.signum() == -1) {

												salida = "No fue posible calcular flete para remito: "
														+ nroremitocliente;
												break;

											}

											// salida =
											// clientesRemitosUpdateBultos(
											// nrosucursal,
											// nroremitocliente, bultos,
											// idempresa, usuarioalt);

											salida = clientesRemitosUpdateBultosFlete(
													nrosucursal,
													nroremitocliente, bultos,
													totalFlete, totalIvaFlete,
													porcIvaFlete, idempresa,
													usuarioalt);
											// <--

											if (!salida.equalsIgnoreCase("OK"))
												break;

										}

									}

								}

							}//

						} else
							salida = "Los pedidos seleccionados posiblemente hayan sido consolidados desde otra sesion.";
					}

				}

			} else {

				salida = "No hay contador asociado, no se pudo recuperar o el mismo esta mal definido.";

			}

		} catch (Exception e) {
			log.error("pedidosNormalesConsolidarRemitos():" + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else {
			dbconn.rollback();
		}

		log.warn("SALIDA: " + salida);

		resultado = new String[] { salida, minidremito.toString(),
				maxidremito.toString() };

		this.dbconn.setAutoCommit(true);
		return resultado;

	}

	/**
	 * Generar consolidacion de pedidos (entregas) regalos empresarios
	 */

	public String[] pedidosRegalosConsolidarRemitos(BigDecimal idpuesto,
			BigDecimal idcontadorcomprobante, String[] idpedido_cabe,
			java.sql.Date fecharemito, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		String[] resultado = new String[] {};
		String idpedidoIN = "";
		String muevestock = "";
		String flagCambiaRemito = "";
		String grupoArmado = "";
		int maxLineasXremito = 0;
		int auxLineas = 0;

		BigDecimal minidremito = new BigDecimal(-1);
		BigDecimal maxidremito = new BigDecimal(0);

		BigDecimal nrosucursal = new BigDecimal(-1);
		BigDecimal nroremitocliente = new BigDecimal(-1);
		BigDecimal idremitocliente = new BigDecimal(-1);
		List listPedidosConsolidar;
		Iterator iter;
		Enumeration enume;
		Hashtable hashRemitos = new Hashtable();

		Hashtable hashGrupoArmado = new Hashtable();
		Hashtable hashAuxGrupoArmado = new Hashtable();

		// EJV - 20100803 -->
		String ctactezona = "";
		String ctacte_regalos = "";
		String ctactezona_regalos_alto = "";
		// <--

		// EJV - 20110113 - Mantis 659 -->
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM");
		int anoMesRemito = Integer.parseInt(sdf.format(fecharemito));
		// <--

		dbconn.setAutoCommit(false);

		try {

			nrosucursal = GeneralBean.getSucursalComprobante(
					idcontadorcomprobante, idempresa, dbconn);

			if (nrosucursal == null || nrosucursal.longValue() < 0) {
				salida = "Verificar sucursal definida para el contador de remitos del puesto.";
			}

			if (salida.equalsIgnoreCase("OK")) {
				// TODO: se esta llamando a la misma configuracion de remitos
				// internos, quizas sea necesario generar una nueva.
				try {
					maxLineasXremito = Integer.parseInt(GeneralBean
							.getValorSetupVariables("maxLineasXremito",
									idempresa, this.dbconn));
				} catch (Exception e) {
					salida = "Imposible recuperar lineas detalle remito.";
					log.error("maxLineasXremito: " + e);
				}

				if (salida.equalsIgnoreCase("OK")) {

					// Determinar si se invoca a los metodos de movimientos de
					// stock
					muevestock = GeneralBean.getValorSetupVariables(
							"pedidosConsolidarRemitoMueveStock", idempresa,
							this.dbconn);

					for (int m = 0; m < idpedido_cabe.length; m++)
						idpedidoIN += idpedido_cabe[m] + ",";

					idpedidoIN = " ( "
							+ idpedidoIN.substring(0, idpedidoIN
									.lastIndexOf(',')) + " ) ";

					listPedidosConsolidar = getPedidosRegalosAConsolidar(
							idpedidoIN, idempresa);

					if (listPedidosConsolidar != null
							&& !listPedidosConsolidar.isEmpty()) {

						iter = listPedidosConsolidar.iterator();

						while (iter.hasNext()) {

							String[] datos = (String[]) iter.next();
							BigDecimal idpedidocabe = new BigDecimal(datos[0]);
							BigDecimal idpedido_deta = new BigDecimal(datos[4]);
							String codigo_st = datos[5];
							// EJV - 20100803 -->
							ctacte_regalos = datos[9];
							ctactezona_regalos_alto = datos[10];
							// <--

							// for (int r = 0; r < datos.length;
							// r++)log.warn("datos[" +
							// r +
							// "]: " + datos[r]);

							// EJV - 20110113 - Mantis 659 -->

							int anoMesPedido = Integer.parseInt(sdf
									.format(java.sql.Date.valueOf(datos[3])));
							log.info("anoMesPedido: " + anoMesPedido);
							log.info("anoMesRemito: " + anoMesRemito);

							// <--

							// EJV - 20110113 - Mantis 659 -->
							if (anoMesRemito != anoMesPedido) {

								sdf = new SimpleDateFormat("dd/MM/yyyy");
								salida = "Mes y ano de fecha de entrega "
										+ sdf.format(java.sql.Date
												.valueOf(datos[3]))
										+ " del pedido "
										+ idpedidocabe
										+ " deben corresponderse con mes y ano de fecha de remito "
										+ sdf.format(fecharemito) + ".";
								break;
							}
							// <--

							if (!flagCambiaRemito.equals(datos[8])
									|| auxLineas >= maxLineasXremito) {

								log.debug("------- " + datos[0] + " -------- ");

								if (idremitocliente.longValue() > 0) {

									// Encapsular -->
									enume = GeneralBean
											.getSetSorted(hashAuxGrupoArmado
													.keySet());
									while (enume.hasMoreElements())
										grupoArmado += enume.nextElement()
												.toString()
												+ ";";

									hashGrupoArmado.put(idremitocliente
											.toString(), grupoArmado);
									// Encapsular <--

									hashAuxGrupoArmado = new Hashtable();
									grupoArmado = "";

								}

								/*
								 * 
								 * "pc.idpedido_cabe, pc.idcliente,
								 * pc.idsucuclie, pc.fechapedido, "
								 * "pd.idpedido_deta, pd.codigo_st, pd.cantidad,
								 * pd.codigo_dt, " "(pc.idcliente::VARCHAR ||
								 * '-' || pc.idsucuclie::VARCHAR || '-'" "||
								 * TO_CHAR(pc.fechapedido,'yyyymmdd')|| '-' ||
								 * pd.codigo_dt::VARCHAR)::VARCHAR AS
								 * flagNuevoRemito"
								 */

								BigDecimal idcliente = new BigDecimal(datos[1]);
								BigDecimal bultos = new BigDecimal(0);
								BigDecimal valorflete = new BigDecimal(0);
								BigDecimal valordeclaradoflete = new BigDecimal(
										0);
								BigDecimal seguro = new BigDecimal(0);
								// 20110203 - EJV - Mantis 668 -->
								seguro = new BigDecimal(100);
								// <--
								BigDecimal impresion = new BigDecimal(0);
								BigDecimal idestadoremito = new BigDecimal(1);
								String observaciones = "";
								// EJV - Mantis 540 - 20100626
								// java.sql.Date fecha =
								// java.sql.Date.valueOf(datos[3]);
								BigDecimal idprefactura = null;

								nroremitocliente = GeneralBean.getContador(
										idcontadorcomprobante, idempresa,
										this.dbconn);
								flagCambiaRemito = datos[8];
								auxLineas = 0;

								log
										.warn("REMITO:  " + nroremitocliente
												+ " * ");

								hashRemitos.put(nroremitocliente,
										nroremitocliente);

								salida = clientesRemitosCreate(nrosucursal,
										nroremitocliente, idcliente, bultos,
										valorflete, valordeclaradoflete,
										seguro, impresion, idestadoremito,
										observaciones, fecharemito,
										idprefactura, "R", ctactezona,
										idempresa, usuarioalt);

								if (!salida.equalsIgnoreCase("OK"))
									break;

								idremitocliente = GeneralBean
										.getValorSequencia(
												"seq_idremitocliente", dbconn);

								// 20109007 - EJV Mantis 565 - Generar
								// estado inicial de preconformacion - ->
								salida = clientesRemitosConformacionCreate(
										idremitocliente, new BigDecimal(1),
										"N", idempresa, usuarioalt, dbconn);

								if (!salida.equalsIgnoreCase("OK"))
									break;
								// <--

								if (idremitocliente == null) {
									salida = "Error al recuperar id. interno de remito cliente.";
									break;
								}

								if (minidremito.longValue() < 0)
									minidremito = idremitocliente;
								maxidremito = idremitocliente;

							}

							// 

							salida = pedidosRegalosEntregasCabeUpdEstado(
									idpedidocabe, new BigDecimal(2), idempresa,
									usuarioalt);

							if (salida.equalsIgnoreCase("OK")) {

								salida = pedidosRegalosEntregasDetaUpdAsociarRemito(
										idpedido_deta, idremitocliente,
										idempresa, usuarioalt);

								hashAuxGrupoArmado.put(codigo_st, codigo_st);

							}

							if (!salida.equalsIgnoreCase("OK"))
								break;

							auxLineas++;

						}//

						// EJV - 20110113 - Mantis 659 -->
						if (salida.equalsIgnoreCase("OK")) {
							// <--
							// Encapsular -->
							enume = GeneralBean.getSetSorted(hashAuxGrupoArmado
									.keySet());
							while (enume.hasMoreElements())
								grupoArmado += enume.nextElement().toString()
										+ ";";

							hashGrupoArmado.put(idremitocliente.toString(),
									grupoArmado);
							// Encapsular <--

							if (salida.equalsIgnoreCase("OK")) {
								enume = hashGrupoArmado.keys();
								while (enume.hasMoreElements()) {
									grupoArmado = enume.nextElement() + "";
									salida = clientesRemitosUpdateGrupoArmado(
											new BigDecimal(grupoArmado),
											hashGrupoArmado.get(grupoArmado)
													+ "", idempresa, usuarioalt);
									if (!salida.equalsIgnoreCase("OK"))
										break;
								}

								if (salida.equalsIgnoreCase("OK")) {
									enume = hashRemitos.keys();
									while (enume.hasMoreElements()) {
										int bultos = 0;
										nroremitocliente = new BigDecimal(enume
												.nextElement().toString());

										bultos = getCalculoBulto(nrosucursal,
												nroremitocliente, idempresa);

										log.info("REMITO: " + nroremitocliente);
										log.info("BULTOS: " + bultos);

										// EJV - 20100804 -->
										ctactezona = bultos < 25 ? ctacte_regalos
												: ctactezona_regalos_alto;
										// <--
										salida = clientesRemitosUpdateBultosCtaCte(
												nrosucursal, nroremitocliente,
												bultos, ctactezona, idempresa,
												usuarioalt);

										if (!salida.equalsIgnoreCase("OK"))
											break;

									}

								}

							}

						}//

					} else
						salida = "Los pedidos seleccionados posiblemente hayan sido consolidados desde otra sesion.";
				}

			}

		} catch (Exception e) {
			log.error("pedidosNormalesConsolidarRemitos():" + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();

		} else {
			dbconn.rollback();
		}

		log.warn("SALIDA: " + salida);

		resultado = new String[] { salida, minidremito.toString(),
				maxidremito.toString() };

		this.dbconn.setAutoCommit(true);
		return resultado;

	}

	/**
	 * Recuperar rango de remitos de clientes generados .
	 * 
	 */

	public List getPedidosRemitosGenerados(BigDecimal idremitoclientedesde,
			BigDecimal idremitoclientehasta, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT LPAD(nrosucursal::varchar, 4, '0') || '-' || LPAD(MIN(nroremitocliente)::varchar, 8, '0') AS minimo,"
				+ "       LPAD(nrosucursal::varchar, 4, '0') || '-' || LPAD(MAX(nroremitocliente)::varchar, 8, '0') AS maximo "
				+ "  FROM clientesremitos  WHERE idremitocliente BETWEEN "
				+ idremitoclientedesde.toString() + " AND "
				+ idremitoclientehasta.toString() + " AND idempresa = "
				+ idempresa.toString() + " GROUP BY nrosucursal; ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRemitosGenerados(...)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * 
	 * END - CONSOLIDACION DE PEDIDOS
	 * 
	 */

	/**
	 * BEGIN - HOJA ARMADO
	 */

	public String[] setHojaArmadoRemitosClientes(String[] idremitocliente,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		String[] resultado = new String[] { "", "" };
		BigDecimal nrohojaarmado = new BigDecimal(-1);
		BigDecimal idremito = new BigDecimal(-1);

		dbconn.setAutoCommit(false);

		try {

			nrohojaarmado = GeneralBean.getNextValorSequencia(
					"seq_nrohojaarmado", dbconn);

			if (nrohojaarmado == null || nrohojaarmado.longValue() < 0)
				salida = "Imposible recuperar nro. de hoja de armado.";

			if (salida.equalsIgnoreCase("OK")) {
				for (int h = 0; h < idremitocliente.length; h++) {

					idremito = new BigDecimal(idremitocliente[h]);
					salida = clientesRemitosUpdateHojaArmado(idremito,
							nrohojaarmado, idempresa, usuarioalt);

					if (!salida.equalsIgnoreCase("OK"))
						break;

				}
			}

		} catch (Exception e) {

			salida = "EX: Error al generar Hoja de Armado";
			log.error("setHojaArmadoRemitosClientes(...)");

		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
			resultado[0] = salida;
			resultado[1] = nrohojaarmado.toString();
		} else {
			resultado[0] = salida;
			resultado[1] = salida;
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);

		return resultado;

	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRemitosPendientesHAAll(long limit, long offset,
			BigDecimal idestado, String tipopedido, String orden,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fecharemito, sucursal, remitocliente, "
				+ "       idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "       zona, idexpreso, expreso, idlocalidad, localidad, "
				+ "       idprovincia, provincia, descrip_dt, nroctacte, "
				+ "       nrosucursal, nroremitocliente, grupoarmado, idexpresozona, "
				// EJV - Mantis 735 - 20110721 -->
				+ "       idclub, club, logo, "
				+ "idempresa "
				// <--
				+ "  FROM vclientesremitoshojaarmado" + " WHERE idempresa = "
				+ idempresa.toString() + " AND tipopedido = '" + tipopedido
				+ "'  ORDER BY " + orden + "  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosPendientesHAAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesRemitosPendientesHAXZonaAll(long limit, long offset,
			BigDecimal idzona, BigDecimal idestado, String tipopedido,
			String orden, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fecharemito, sucursal, remitocliente, "
				+ "       idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "       zona, idexpreso, expreso, idlocalidad, localidad, "
				+ "       idprovincia, provincia, descrip_dt, nroctacte, "
				+ "       nrosucursal, nroremitocliente, grupoarmado, idexpresozona, idempresa "
				+ "  FROM vclientesremitoshojaarmado" + " WHERE idempresa = "
				+ idempresa.toString() + " AND idzona = " + idzona
				+ " AND tipopedido = '" + tipopedido + "'  ORDER BY " + orden
				+ "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosPendientesHAXZonaAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRemitosPendientesHAOcu(long limit, long offset,
			BigDecimal idestado, String tipopedido, String filtro,
			String orden, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fecharemito, sucursal, remitocliente, "
				+ "       idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "       zona, idexpreso, expreso, idlocalidad, localidad, "
				+ "       idprovincia, provincia, descrip_dt, nroctacte, "
				+ "       nrosucursal, nroremitocliente, grupoarmado, idexpresozona, "

				// EJV - Mantis 735 - 20110721 -->
				+ "       idclub, club, logo, "
				// <--

				+ "idempresa " + "  FROM vclientesremitoshojaarmado " + filtro
				+ " AND idempresa = " + idempresa.toString()
				+ " AND tipopedido = '" + tipopedido + "' ORDER BY " + orden
				+ "  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosPendientesHAOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRemitosHAAll(long limit, long offset,
			BigDecimal nrohojaarmado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fecharemito, sucursal, remitocliente, idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "       zona, idexpreso, expreso, idlocalidad, localidad, idprovincia, provincia, descrip_dt, nroctacte, nrosucursal, nroremitocliente, grupoarmado, idempresa"
				+ "  FROM vclienteshojaarmadoconsulta"
				+ " WHERE nrohojaarmado = " + nrohojaarmado.toString()
				+ "   AND idempresa = " + idempresa.toString()
				+ "  ORDER BY 3, 4 LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosHAAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesRemitosHAOcu(long limit, long offset,
			String ocurrencia, BigDecimal nrohojaarmado, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fecharemito, sucursal, remitocliente, idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "       zona, idexpreso, expreso, idlocalidad, localidad, idprovincia, provincia, descrip_dt, nroctacte, nrosucursal, nroremitocliente, grupoarmado, idempresa"
				+ "  FROM vclienteshojaarmadoconsulta"
				+ " WHERE nrohojaarmado = " + nrohojaarmado.toString()
				+ "   AND remitocliente LIKE '%" + ocurrencia + "%'"
				+ "   AND idempresa = " + idempresa.toString()
				+ "  ORDER BY 3, 4 LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosHAOcu(..)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * END - HOJA ARMADO
	 */

	/**
	 * BEGIN - HOJA RUTA FINAL
	 */

	/**
	 * Metodos para la entidad: pedidosHojaRutaFinal Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Mar 17 08:12:59 GYT 2009
	 */

	public List getVClientesRemitosHojaRutaFinalPreconfAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal, nropallets, fechahojarutafinal, idzona, zona, idexpreso, expreso, fechapreconf, fechabaja, "
				+ "            idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
				+ "   FROM vclientesremitoshojarutafinalpreconf "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalPreconfAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesRemitosHojaRutaFinalPreconfOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal, nropallets, fechahojarutafinal, idzona, zona, idexpreso, expreso, fechapreconf, fechabaja, "
				+ "             idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
				+ "   FROM vclientesremitoshojarutafinalpreconf"
				+ " WHERE (UPPER(nrohojarutafinal::varchar) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 1  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalPreconfOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String pedidosHojaRutaFinalCreate(BigDecimal nrohojarutafinal,
			BigDecimal nropallets, String filename, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nropallets == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nropallets ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("OK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO PEDIDOSHOJARUTAFINAL(  nrohojarutafinal, nropallets, filename, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, nrohojarutafinal);
				insert.setBigDecimal(2, nropallets);
				insert.setString(3, filename);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);

				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No se pudo generar hoja de ruta final.";
			}
		} catch (SQLException sqlException) {
			salida = "SQL: Imposible dar de alta hoja de ruta final.";
			log
					.error("Error SQL public String pedidosHojaRutaFinalCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: Imposible dar de alta hoja de ruta final.";
			log
					.error("Error excepcion public String pedidosHojaRutaFinalCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosHojaRutaFinalFPreconfUpdate(
			BigDecimal nrohojarutafinal, Date fechapreconf,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrohojarutafinal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojarutafinal ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "" + "UPDATE pedidoshojarutafinal "
						+ "      SET fechapreconf=?, usuarioact=?, fechaact=? "
						+ "WHERE nrohojarutafinal=? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setDate(1, fechapreconf);
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, nrohojarutafinal);
				insert.setBigDecimal(5, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Error al actualizar fecha de preconformacion para HRF: "
							+ nrohojarutafinal;

			}
		} catch (SQLException sqlException) {
			salida = "(SQL)Error al actualizar fecha de preconformacion para HRF: "
					+ nrohojarutafinal;
			log
					.error("Error SQL public String pedidosHojaRutaFinalFPreconfUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Error al actualizar fecha de preconformacion para HRF: "
					+ nrohojarutafinal;
			log
					.error("Error excepcion public String pedidosHojaRutaFinalFPreconfUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosHojaRutaFinalFileAndreaniUpdate(
			BigDecimal nrohojarutafinal, String fileandreani,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nrohojarutafinal == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrohojarutafinal ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "" + "UPDATE pedidoshojarutafinal "
						+ "      SET fileandreani=?, usuarioact=?, fechaact=? "
						+ "WHERE nrohojarutafinal=? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);

				insert.setString(1, fileandreani);
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, nrohojarutafinal);
				insert.setBigDecimal(5, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "Error al actualizar archivo Andreani para HRF: "
							+ nrohojarutafinal;

			}
		} catch (SQLException sqlException) {
			salida = "(SQL)Error al actualizar archivo Andreani para HRF: "
					+ nrohojarutafinal;
			log
					.error("Error SQL public String pedidosHojaRutaFinalFileAndreaniUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Error al actualizar archivo Andreani para HRF: "
					+ nrohojarutafinal;
			log
					.error("Error excepcion public String pedidosHojaRutaFinalFileAndreaniUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRemitosHRFinalAll(long limit, long offset,
			String orden, String tipopedido, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT nrohojaarmado, idexpreso, expreso, codigo_dt, descrip_dt, total_bultos, "
				// EJV - Mantis 736 - 20110721 -->
				+ "            idclub, club, logo, "
				// <--
				+ "idempresa " + "  FROM vclientesremitoshojarutafinal "
				+ " WHERE tipo = '" + tipopedido.toUpperCase()
				+ "' AND idempresa = " + idempresa.toString() + "  ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosHRFinalAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRemitosHRFinalOcu(long limit, long offset,
			String filtro, String orden, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT nrohojaarmado, idexpreso, expreso, codigo_dt, descrip_dt, total_bultos, "

				// EJV - Mantis 736 - 20110721 -->
				+ "            idclub, club, logo, "
				// <--
				+ "            idempresa "
				+ "  FROM vclientesremitoshojarutafinal " + filtro
				+ "    AND idempresa = " + idempresa.toString() + " ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosHRFinalOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getStockTransferirHRFinal(String nrohojaarmadoIN,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " SELECT idexpreso, codigo_st,  SUM(total), deposito_origen,  deposito_destino, 0 AS cost_uc_st"
				+ "    FROM vclientesremitoshojarutatransferir "
				+ "  WHERE nrohojaarmado IN ("
				+ nrohojaarmadoIN
				+ ") "
				+ "      AND idempresa = "
				+ idempresa.toString()
				// -- 201004 EJV Se agrego agrupamiento, y sumarizacion
				+ " GROUP BY idexpreso, codigo_st,  deposito_origen,  deposito_destino  "
				+ " ORDER BY deposito_origen ;";

		//		
		// cQuery = ""
		// + "SELECT pc.idexpreso, pd.codigo_st, SUM(pd.cantidad) as total,"
		// +
		// "       pd.codigo_dt AS deposito_origen, ex.codigo_dt AS deposito_destino, st.cost_uc_st"
		// + "  FROM clientesremitos cr "
		// +
		// "       INNER JOIN pedidos_deta pd ON cr.idremitocliente = pd.idremitocliente AND  cr.idempresa = pd.idempresa "
		// +
		// "       INNER JOIN pedidos_cabe pc ON pc.idpedido_cabe = pd.idpedido_cabe AND  pd.idempresa = pc.idempresa "
		// +
		// "       INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND  pc.idempresa = ex.idempresa  "
		// +
		// "       INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st AND  pd.idempresa = st.idempresa"
		// + " WHERE cr.nrohojaarmado IN ("
		// + nrohojaarmadoIN
		// + ")"
		// + "   AND cr.nrohojarutafinal IS NULL  AND cr.idempresa = "
		// + idempresa.toString()
		// +
		// "  GROUP BY pc.idexpreso, pd.codigo_st, pd.codigo_dt,  ex.codigo_dt, st.cost_uc_st"
		// + " ORDER BY pd.codigo_dt ;";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getStockTransferirHRFinal(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public String[] generarHojaRutaFinal(Timestamp fechamov, String tipomov,
			BigDecimal num_cnt, BigDecimal sucursal, String tipo,
			String observaciones, BigDecimal idcontadorcomprobante,
			String[] nrohojaarmado, BigDecimal nropallets, String tipopedido,
			String nameFile, BigDecimal idexpreso, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {

		BigDecimal nrohojarutafinal = new BigDecimal(-1);
		String salida = "OK";
		String[] resultado = new String[] { "", "", "" };
		Hashtable htArticulos = new Hashtable();
		List listArticulos = new ArrayList();
		Iterator iter;
		String[] datosArticulo = new String[] {};
		String nrohojaarmadoIN = "";
		String ctrlExpreso = "";
		boolean statusgeneracion = false;
		String generaAndreani = "NO";
		String archivoAndreani = "";
		String archivoAndreaniZip = "";

		dbconn.setAutoCommit(false);

		try {

			/*
			 * pc.idexpreso, pd.codigo_st, SUM(pd.cantidad) as total,
			 * pd.codigo_dt AS deposito_origen, ex.codigo_dt AS
			 * deposito_destino, st.cost_uc_st
			 */

			nrohojarutafinal = GeneralBean.getContador("nrohojarutafinal",
					idempresa, dbconn);

			if (nrohojarutafinal != null && nrohojarutafinal.longValue() > 0) {

				nameFile = nameFile.replace("###", nrohojarutafinal.toString());

				salida = pedidosHojaRutaFinalCreate(nrohojarutafinal,
						nropallets, nameFile, idempresa, usuarioalt);

				if (salida.equalsIgnoreCase("OK")) {

					for (int f = 0; f < nrohojaarmado.length; f++) {
						nrohojaarmadoIN += f == 0 ? nrohojaarmado[f] : ", "
								+ nrohojaarmado[f];
					}

					listArticulos = getStockTransferirHRFinal(nrohojaarmadoIN,
							idempresa);

					salida = clientesRemitosUpdateHojaRutaFinal(
							nrohojaarmadoIN, nrohojarutafinal, "S", idempresa,
							usuarioalt);

					if (salida.equalsIgnoreCase("OK")) {

						if (listArticulos != null && !listArticulos.isEmpty()) {

							iter = listArticulos.iterator();

							while (iter.hasNext()) {

								/*
								 * codigo_st,alias_st,descrip_st,descri2_st, 0
								 * as cantidad, -1 as origen, -1 as destino,
								 * cost_uc_st
								 */

								String[] datos = (String[]) iter.next();

								String expreso = datos[0];
								String codigo_st = datos[1];
								String cantidadTransferir = datos[2];
								String depositoOrigen = datos[3];
								String depositoDestino = datos[4];
								String costo_st = datos[5];

								if (ctrlExpreso.equals(""))
									ctrlExpreso = expreso;

								datosArticulo = new String[] { codigo_st,
										codigo_st, codigo_st, codigo_st,
										cantidadTransferir, depositoOrigen,
										depositoDestino, costo_st };

								// control para que no seleccione mas de un
								// expreso;

								if (!ctrlExpreso.equals(expreso)) {
									salida = "Se detecto mas de un expreso al realizar HRF: ["
											+ expreso
											+ " - "
											+ ctrlExpreso
											+ "]";
									log.info(salida);
									htArticulos = new Hashtable();
									break;
								}

								if (depositoOrigen.equals(depositoDestino)) {
									log
											.info("Mismo origen / destino, no transfiere stock.");
									continue;
								}

								// 20101004 - EJV agregar en KEY deposito origen
								// y destino
								htArticulos.put(codigo_st + "-"
										+ depositoOrigen + "-"
										+ depositoDestino, datosArticulo);
							}

							// Realizar movimiento de Stock solo si existen
							// articulos a transferir.

							if (salida.equalsIgnoreCase("OK")
									&& !htArticulos.isEmpty()) {

								observaciones = "[HRF(" + nrohojarutafinal
										+ ")] - " + "[HA(" + nrohojaarmadoIN
										+ ")] - Mov. interno por pedidos."
										+ observaciones;

								resultado = stockMovInternoPedidosCreate(
										fechamov, tipomov, num_cnt, sucursal,
										tipo, observaciones, htArticulos,
										idcontadorcomprobante, tipopedido,
										dbconn, usuarioalt, idempresa);
								salida = resultado[0];

							}

						} else
							salida = "Hoja de ruta inexistente o actualizada desde otra sesion.";

					}

				}

			} else
				salida = "No se puedo recuperar Nro. Hoja de Ruta Final.";

		} catch (Exception e) {
			salida = "E: Error al generar Hoja de Ruta Final.";
			log.error("generarHojaRutaFinal()" + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			// TEST

			// if (isExpresoAndreani(idexpreso, idempresa)) {
			//
			// try {
			//
			// generaAndreani = "SI";
			// SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
			// String fname = sdf.format(Calendar.getInstance().getTime());
			//
			// String source = getArchivoAndreani(nrohojarutafinal,
			// nrohojarutafinal, idempresa);
			// // String path = "/home/ejv/Escritorio/";
			// String archivoZip = fname + "-bclavehr-" + nrohojarutafinal
			// + ".zip";
			//
			// // 20101013-EJV-Pedido-de-AMELIA-Mantis 480-Nota-901
			// //
			// Eliminando-esta-linea-el-archivo-tendra-el-nombre-con-formato-YYYYDDMM-andreani-hrf-NROHRF.txt
			// String archivo = "bclavehr.txt";
			//
			// statusgeneracion = GeneralBean.generaArchivo(source,
			// archivo, pathAndreani);
			//
			// File file = new File(pathAndreani + archivo);
			//
			// GeneralBean.zipFile(file, file.getAbsolutePath().replace(
			// archivo, archivoZip));
			//
			// if (statusgeneracion) {
			// archivoAndreani = ".."
			// + pathAndreani.substring(pathAndreani
			// .toLowerCase().indexOf(".war") + 4)
			// + archivo;
			// archivoAndreaniZip = ".."
			// + pathAndreani.substring(pathAndreani
			// .toLowerCase().indexOf(".war") + 4)
			// + archivoZip;
			//
			// }
			//
			// log.info("archivoAndreani: " + archivoAndreani);
			//
			// } catch (Exception e) {
			//
			// log.error("ERROR EN TEST DE GENERACION DE ANDREANI: " + e);
			//
			// }
			//
			// }

			dbconn.commit();

		} else {

			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);

		resultado = new String[] { salida, resultado[1], nrohojarutafinal + "",
				generaAndreani, archivoAndreani, archivoAndreaniZip };

		return resultado;

	}

	public static String[] stockMovInternoPedidosCreate(Timestamp fechamov,
			String tipomov, BigDecimal num_cnt, BigDecimal sucursal,
			String tipo, String observaciones, Hashtable htArticulos,
			BigDecimal idcontadorcomprobante, String tipopedido,
			Connection conn, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {
		/*
		 * Observaciones : CEP 25/01/2007 cambios para poder pasar stock en
		 * negativo. Solicitud oscura.
		 */

		String salida = "OK";
		BigDecimal comprob_ms = BigDecimal.valueOf(-1);
		BigDecimal nrointerno_ms = BigDecimal.valueOf(-1);
		Enumeration en;
		String tipomov_ms = ""; // TODO
		String sistema_ms = "S"; // TODO
		java.util.Date date = new java.util.Date();
		BigDecimal cantArtDep;
		BigDecimal remito_ms = new BigDecimal(0);
		boolean isFirst;
		/*
		 * 20070604 EJV Lineas detalle por Remito.
		 */
		int maxLineasXremito = 0;
		int indice = 0;
		Hashtable htArticulosImagen = new Hashtable(htArticulos);
		Hashtable htArticulosPaginados = null;
		String[] resultado = new String[] { "", "" };

		/*
		 * 20071203 EJV Comprobantes internos - sucursal
		 */

		BigDecimal remito_interno_ms = new BigDecimal(-1);
		BigDecimal sucu_ms = new BigDecimal(-1);

		// EJV 20090316
		BigDecimal canti_sb = new BigDecimal(0);
		BigDecimal pedid_sb = new BigDecimal(0);

		// log.info("htArticulos" + htArticulos);
		// log.info("htArticulosImagen" + htArticulosImagen);

		try {
			// TODO: REALIZAR TODAS LAS VALIDACIONES
			// Pasos del movimiento ...
			// 1.0 - Generar movimiento salida .... stockmovstock
			// 1.1 - Generar movimiento entrada .... stockmovstock
			// 2.0 - Generar movimiento entrada .... stockbis
			// 2.1 - Generar movimiento salida .... stockbis
			// 3.0 - Generar movimiento historico .... stockhis
			// 3.1 - Generar movimiento historico .... stockhis

			// EJV - 20090316
			// dbconn.setAutoCommit(fa lse);

			if (htArticulos != null && !htArticulos.isEmpty()) {

				/*
				 * 20070604 EJV Lineas detalle por Remito.
				 */
				try {
					maxLineasXremito = Integer.parseInt(GeneralBean
							.getValorSetupVariables("maxLineasXremito",
									idempresa, conn));
				} catch (Exception e) {
					salida = "Imposible recuperar lineas detalle remito.";
					log.error("maxLineasXremito: " + e);
				}
				/*
				 * */

				log.info("idcontadorcomprobante: " + idcontadorcomprobante);

				if (tipopedido != null
						&& tipopedido.equalsIgnoreCase("NORMAL-NO SE USA")) {

					sucu_ms = new BigDecimal(1);

				} else if (tipopedido != null
						&& tipopedido.equalsIgnoreCase("REGALOS-NO SE USA")) {

					sucu_ms = new BigDecimal(3);

				} else {

					sucu_ms = GeneralBean.getSucursalComprobante(
							idcontadorcomprobante, idempresa, conn);
				}

				if (sucu_ms == null || sucu_ms.longValue() < 0) {
					salida = "Verificar sucursal definida para el contador de remitos del puesto.";
				}

				/*
				 * 20070604 EJV Lineas detalle por Remito.
				 */
				while (salida.equalsIgnoreCase("OK")) {
					indice = 0;
					htArticulosPaginados = new Hashtable();
					Enumeration enu = htArticulosImagen.keys();
					while (enu.hasMoreElements() && indice < maxLineasXremito) {
						Object elemento = enu.nextElement();
						htArticulosPaginados.put(elemento, htArticulosImagen
								.get(elemento));
						htArticulosImagen.remove(elemento);
						indice++;
					}

					if (htArticulosPaginados.isEmpty())
						break;
					en = htArticulosPaginados.keys();

					/*
					 * */

					comprob_ms = new BigDecimal(-1);
					nrointerno_ms = new BigDecimal(-1);
					tipomov_ms = ""; // TODO
					isFirst = true;
					remito_ms = new BigDecimal(0);

					/*
					 * TODO:
					 * .......................................................
					 * Previsto para recuperar contador de comprobante ...
					 * (REMITOS ). momentaneamente validar contra tipomov (RO:
					 * Remito Oficial), es necesario analizar.
					 */

					if (tipomov != null && tipomov.equalsIgnoreCase("RO"))
						remito_ms = GeneralBean.getContadorComprobante(num_cnt,
								sucursal, tipo, idempresa, conn);

					if (remito_ms.compareTo(new BigDecimal(-1)) > 0) {

						while (en.hasMoreElements()) {

							if (isFirst) {

								comprob_ms = GeneralBean.getContador(
										new BigDecimal(4), idempresa, conn);

								remito_interno_ms = GeneralBean.getContador(
										idcontadorcomprobante, idempresa, conn);

							}
							isFirst = false;
							String key = (String) en.nextElement();
							String[] datosArticulo = (String[]) htArticulosPaginados
									.get(key);
							String articulo = datosArticulo[0];
							BigDecimal cantArtMov = new BigDecimal(
									datosArticulo[4]);
							BigDecimal origen = new BigDecimal(datosArticulo[5]);
							BigDecimal destino = new BigDecimal(
									datosArticulo[6]);
							BigDecimal costo = new BigDecimal(datosArticulo[7]);

							pedid_sb = cantArtMov;

							log.info("pedid_sb: " + pedid_sb);

							/*
							 * 0 codigo_st: 1 alias_st: 2 descrip_st: 3
							 * descri2_st: 4 cantidad: 5 origen: 6 destino: 7
							 * cost_uc_st:
							 */

							// RECUPERAR DATOS ARTICULO
							// List listaArticulo = getStockstockPK(articulo);
							// String[] das = (String[]) listaArticulo
							// .get(0);
							/*
							 * MODIFICA ORIGEN
							 */

							if (GeneralBean.getExisteArticuloDeposito(articulo,
									origen, idempresa, conn)) {
								tipomov_ms = "S";
								cantArtDep = GeneralBean
										.getCantidadReservaArticuloDeposito(
												articulo, origen, idempresa,
												conn);
								// CEP: 25/01/2007 : primer arreglo
								if ((cantArtDep.doubleValue() >= cantArtMov
										.doubleValue())) {

									// EJV - 20090318, no valida contra reserva.
									// || GeneralBean.hasStockNegativo(
									// idempresa, conn)

									/*
									 * nrointerno_ms : sistema_ms : tipomov_ms :
									 * comprob_ms : fecha_ms : articu_ms :
									 * canti_ms : moneda_ms : cambio_ms :
									 * venta_ms : costo_ms : tipoaux_ms :
									 * destino_ms : comis_ms : remito_ms :
									 * impint_ms : impifl_ms : impica_ms :
									 * prelis_ms : unidad_ms : merma_ms :
									 * saldo_ms : medida_ms : observaciones :
									 * usuarioalt : usuarioact : fechaalt :
									 * fechaact :
									 */

									// nrointerno_ms =
									// getValorSequencia("seq_stockmovstock");
									// 20061101 - nrointerno_ms permite
									// duplicados
									nrointerno_ms = GeneralBean.getContador(
											new BigDecimal(5), idempresa, conn);
									salida = StockBean.stockMovStockCreate(
											nrointerno_ms, sistema_ms,
											tipomov_ms, comprob_ms, fechamov,
											articulo, cantArtMov,
											new BigDecimal("1"),
											new Double("1"), new Double("0"),
											costo, "C", "", new Double("0"),
											remito_ms, new Double("0"),
											new Double("0"), new Double("0"),
											new Double("0"),
											new BigDecimal("0"),
											new Double("0"), new Double("0"),
											new BigDecimal("0"), observaciones,
											remito_interno_ms, sucu_ms, conn,
											usuarioalt, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;

									// nrointerno_ms =
									// getValorSequencia("seq_stockmovstock");
									// 20061101 - nrointerno_ms permite
									// duplicados

									// 20090317 - EJV - ?? no incide en nada
									// cantArtDep = GeneralBean
									// .getCantidadArticuloDeposito(
									// articulo, origen,
									// idempresa, conn);

									// Actualiza stockbis
									// Descuenta del origen

									/*
									 * articu_sb : deposi_sb : canti_sb :
									 * serie_sb : despa_sb : pedid_sb :
									 * usuarioalt : usuarioact : fechaalt :
									 * fechaact :
									 */

									salida = StockBean.stockStockBisUpdate(
											articulo, origen, canti_sb, "", "",
											pedid_sb.negate(), conn,
											usuarioalt, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;
									//

									/*
									 * nromov_sh : articu_sh : deposi_sh :
									 * serie_sh : despa_sh : canti_sh :
									 * estamp1_sh : estamp2_sh : aduana_sh :
									 * usuarioalt : usuarioact : fechaalt :
									 * fechaact :
									 */

									salida = StockBean.stockHisCreate(
											nrointerno_ms, articulo, origen,
											"", "", cantArtMov, "", "", "",
											conn, usuarioalt, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;
									/*
									 * ==========================================
									 * ============= MODIFICA DESTINO
									 * ============
									 * ==============================
									 * =============
									 */

									tipomov_ms = "E";

									/*
									 * nrointerno_ms : sistema_ms : tipomov_ms :
									 * comprob_ms : fecha_ms : articu_ms :
									 * canti_ms : moneda_ms : cambio_ms :
									 * venta_ms : costo_ms : tipoaux_ms :
									 * destino_ms : comis_ms : remito_ms :
									 * impint_ms : impifl_ms : impica_ms :
									 * prelis_ms : unidad_ms : merma_ms :
									 * saldo_ms : medida_ms : observaciones :
									 * usuarioalt : usuarioact : fechaalt :
									 * fechaact :
									 */

									// nrointerno_ms =
									// getValorSequencia("seq_stockmovstock");
									// 20061101 - nrointerno_ms permite
									// duplicados
									nrointerno_ms = GeneralBean.getContador(
											new BigDecimal(5), idempresa, conn);

									salida = StockBean.stockMovStockCreate(
											nrointerno_ms, sistema_ms,
											tipomov_ms, comprob_ms, fechamov,
											articulo, cantArtMov,
											new BigDecimal("1"),
											new Double("1"), new Double("0"),
											costo, "C", "", new Double("0"),
											remito_ms, new Double("0"),
											new Double("0"), new Double("0"),
											new Double("0"),
											new BigDecimal("0"),
											new Double("0"), new Double("0"),
											new BigDecimal("0"), observaciones,
											remito_interno_ms, sucu_ms, conn,
											usuarioalt, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;

									// nrointerno_ms =
									// getValorSequencia("seq_stockmovstock");
									// 20061101 - nrointerno_ms permite
									// duplicados
									// Actualiza el destino ... o lo crea

									if (GeneralBean.getExisteArticuloDeposito(
											articulo, destino, idempresa, conn))

										/*
										 * ACTUALIZA ... articu_sb : deposi_sb :
										 * canti_sb : serie_sb : despa_sb :
										 * pedid_sb : usuarioalt : usuarioact :
										 * fechaalt : fechaact :
										 */
										salida = StockBean.stockStockBisUpdate(
												articulo, destino, canti_sb,
												"", "", pedid_sb, conn,
												usuarioalt, idempresa);
									else

										// CREA ...
										salida = StockBean.stockStockBisCreate(
												articulo, destino, canti_sb,
												"", "", pedid_sb, conn,
												usuarioalt, idempresa);

									if (!salida.equalsIgnoreCase("OK"))
										break;
									/*
									 * nromov_sh : articu_sh : deposi_sh :
									 * serie_sh : despa_sh : canti_sh :
									 * estamp1_sh : estamp2_sh : aduana_sh :
									 * usuarioalt : usuarioact : fechaalt :
									 * fechaact :
									 */

									salida = StockBean.stockHisCreate(
											nrointerno_ms, articulo, destino,
											"", "", cantArtMov, "", "", "",
											conn, usuarioalt, idempresa);
									if (!salida.equalsIgnoreCase("OK"))
										break;

								} else {
									salida = "Cantidad en reserva insuficiente para articulo "
											+ articulo
											+ " en deposito origen ( "
											+ origen
											+ " ).";
									break;
								}

							} else {
								salida = "No existe stock en deposito ( "
										+ origen + " ) para articulo: "
										+ articulo;
								break;
							}
						}
					} else {
						salida = "Error al recuperar Nro. comprobante.";
					}

					resultado[1] = resultado[1] != null ? resultado[1] + "-"
							+ comprob_ms.toString() : comprob_ms.toString();
				}//
			} else
				salida = "No existen articulos a transferir.";

		} catch (Exception e) {
			// TODO: handle exception
			salida = "E-1000: Ocurrio Excepcion Mientras Se Actualizaba Stock.";
			log.error("stockMovInternoPedidosCreate(): " + e);
		}
		if (!salida.equalsIgnoreCase("OK")) {

		} else {
			htArticulos = null;
		}

		resultado[0] = salida;
		htArticulosImagen = null;

		return resultado;
	}

	// -- EJV 20100929 -->

	// generacion de archivo para ANDREANI
	public String getArchivoAndreani(String[] nrohojarutafinal,
			BigDecimal idempresa) throws EJBException {

		// Reemplaza todo lo que no este dentro de los rango A-Z, az, 0-9 y sea
		// diferente de salto de carro
		Pattern patron = Pattern.compile("[^A-Za-z0-9\r\n# ]");
		Matcher compara;

		String inNrohojarutafinal = " ( ";

		String tabla = ("tmp_" + (Math.random() + 100d)).replaceAll("-", "")
				.replace('.', 'x');
		log.info("tabla: " + tabla);
		String fsalida = "";

		try {

			if (nrohojarutafinal != null && nrohojarutafinal.length > 0) {

				// 20101213 - EJV - Mantis 637 -->
				// 20131108 - CEP - Mantis 925 -->

				for (int z = 0; z < nrohojarutafinal.length; z++) {
					inNrohojarutafinal += nrohojarutafinal[z] + ", ";
				}

				inNrohojarutafinal = inNrohojarutafinal.substring(0,
						inNrohojarutafinal.lastIndexOf(','));
				inNrohojarutafinal += " ) ";

				// <--

				String cQuery = "" + "CREATE TEMPORARY TABLE "
						+ tabla
						+ " AS SELECT "
						+ " rm.nrosucursal as campo1,"
						+ " rm.nroremitocliente as campo2, "
						+ " 'R' as campo3, "
						+ " '      ' as campo4, "
						+ " '   '::varchar(10) as campo5, "
						+ " date_part('year', now()) as campo6, "
						+ " case when date_part('month', now()) < 10 then '0'||date_part('month', now())::text else date_part('month', now())::text end as campo7, "

						+ " case when date_part('day', now()) < 10 then '0'||date_part('day', now())::text else date_part('day', now())::text end  as campo8, "

						+ " upper(loca.localidad) ||'                              ' as campo9, "
						+ " '0' as campo10, "
						+ " loca.cpostal as campo11, "
						+ " '50' as campo12, "
						+ " '                              ' as campo13, "
						+ " '                              ' as campo14, "
						+ " '000000000000000000000000000' as campo15, "
						+ " rm.valordeclaradoflete as campo16, "
						+ " rm.bultos as campo17, "
						+ " '        ' as campo18, "
						+ " cl.razon ||'                              ' as campo19, "
						// +
						// 20110311 - EJV - Mantis 691 -->
						// " cd.calle ||' '|| cd.nro ||' '|| cd.piso ||' '|| cd.depto||'                                                  ' as campo20, "
						+ " COALESCE(cd.calle, 'S/C') ||' '|| COALESCE(cd.nro,'') ||' '|| COALESCE(cd.piso, '') ||' '|| COALESCE(cd.depto, '')||'                                                  ' as campo20, "
						+ " '         ' as campo21, "
						// <--
						+ "( "
						+ " SELECT sum(kilaje::numeric(18,2)) as total "
						+ "    FROM pedidos_deta de "
						+ "             INNER JOIN stockstock st ON( de.codigo_st = st.codigo_st and de.idempresa = st.idempresa ) "
						+ "    WHERE de.idremitocliente =   pd.idremitocliente "
						+ "      AND de.idempresa=  pd.idempresa "
						+ "  )  as campo22, "

						// + " '       ' as campo22, "

						+ "( "
						+ " SELECT sum(kilaje::numeric(18,2)) as total "
						+ "    FROM pedidos_deta de "
						+ "             INNER JOIN stockstock st ON( de.codigo_st = st.codigo_st and de.idempresa = st.idempresa ) "
						+ "    WHERE de.idremitocliente =   pd.idremitocliente "
						+ "      AND de.idempresa=  pd.idempresa "
						+ "  )  as campo23, "

						// + " '       ' as campo23, "
						+ " coalesce(rm.nroctacte,'NOTIEN')||'     ' as campo24, "
						+ " '                                     ' as campo25,"
						+ " rm.nrosucursal::varchar(10) as campo26,"
						+ " rm.nroremitocliente::varchar(15) as campo27, "
						+ " '   ' as campo28, "
						+ " '         ' as campo29, "
						+ " '1' as campo30, "
						+ " 'AVELLANEDA B             ' as campo31 , rm.idremitocliente, cl.idcliente, cd.iddomicilio "
						+ " FROM pedidoshojarutafinal hr "
						+ "  INNER JOIN clientesremitos rm ON ( hr.nrohojarutafinal = rm.nrohojarutafinal and hr.idempresa = rm.idempresa ) "
						+ "  INNER JOIN pedidos_deta pd ON ( rm.idremitocliente = pd.idremitocliente and rm.idempresa = pd.idempresa     "
						+ "     AND  pd.idpedido_deta = (SELECT MAX(idpedido_deta) FROM pedidos_deta WHERE pedidos_deta.idremitocliente = rm.idremitocliente and pedidos_deta.idempresa = rm.idempresa   ) ) "
						+ "  INNER JOIN pedidos_cabe pc on (pd.idpedido_cabe = pc.idpedido_cabe and pd.idempresa = pc.idempresa ) "
						+ "  INNER JOIN clientesanexolocalidades anex on ( pc.idanexolocalidad = anex.idanexolocalidad and pc.idempresa = anex.idempresa )"
						+ "  INNER JOIN globallocalidades loca ON ( anex.idlocalidad = loca.idlocalidad ) "
						+ "  INNER JOIN clientesclientes cl ON (pc.idcliente = cl.idcliente and pc.idempresa = cl.idempresa) "
						+ "  INNER JOIN clientesdomicilios cd ON (pc.idsucuclie = cd.iddomicilio and pc.idempresa = cd.idempresa ) "

						// 20101213 - EJV - Mantis 637 -->
						// + " WHERE (hr.nrohojarutafinal between " + idHRdesde
						// + " and " + idHRhasta + " )"
						+ " WHERE hr.nrohojarutafinal IN  "
						+ inNrohojarutafinal
						// <--
						+ " and hr.idempresa = "
						+ idempresa

						/**/
						// 20101220 - EJV - Mantis 647 -->
						// 20131108 - CEP - Mantis 925 -->
						+ "                                                                 UNION  "
						+ " SELECT "
						+ " rm.nrosucursal as campo1,"
						+ " rm.nroremitocliente as campo2, "
						+ " 'R' as campo3, "
						+ " '      ' as campo4, "
						+ " '   '::varchar(10) as campo5, "
						+ " date_part('year', now()) as campo6, "
						+ " case when date_part('month', now()) < 10 then '0'||date_part('month', now())::text else date_part('month', now())::text end as campo7, "

						+ " case when date_part('day', now()) < 10 then '0'||date_part('day', now())::text else date_part('day', now())::text end  as campo8, "

						+ " upper(loca.localidad) ||'                              ' as campo9, "
						+ " '0' as campo10, "
						+ " loca.cpostal as campo11, "
						+ " '50' as campo12, "
						+ " '                              ' as campo13, "
						+ " '                              ' as campo14, "
						+ " '000000000000000000000000000' as campo15, "
						// 20131108 - CEP - Mantis 925 -->
						+ "((pd.cantidad * ppd.precio) / 2 )::numeric(18,2) as campo16, "
						// + " rm.valordeclaradoflete as campo16, "
						+ " rm.bultos as campo17, "
						+ " '        ' as campo18, "
						+ " cl.razon ||'                              ' as campo19, "
						// 20110311 - EJV - Mantis 691 -->
						// " cd.calle ||' '|| cd.nro ||' '|| cd.piso ||' '|| cd.depto||'                                                  ' as campo20, "
						+ " COALESCE(cd.calle, 'S/C') ||' '|| COALESCE(cd.nro,'') ||' '|| COALESCE(cd.piso, '') ||' '|| COALESCE(cd.depto, '')||'                                                  ' as campo20, "
						// <--
						+ " '         ' as campo21, "

						+ "( "
						+ " SELECT sum(kilaje::numeric(18,2)) as total "
						+ "    FROM pedidos_regalos_entregas_deta de "
						+ "             INNER JOIN stockstock st ON( de.codigo_st = st.codigo_st and de.idempresa = st.idempresa ) "
						+ "    WHERE de.idremitocliente =   pd.idremitocliente "
						+ "      AND de.idempresa=  pd.idempresa "
						+ "  )  as campo22, "

						// + " '       ' as campo22, "

						+ "( "
						+ " SELECT sum(kilaje::numeric(18,2)) as total "
						+ "    FROM pedidos_regalos_entregas_deta de "
						+ "             INNER JOIN stockstock st ON( de.codigo_st = st.codigo_st and de.idempresa = st.idempresa ) "
						+ "    WHERE de.idremitocliente =   pd.idremitocliente "
						+ "      AND de.idempresa=  pd.idempresa "
						+ "  )  as campo23, "

						// + " '       ' as campo23, "
						+ " coalesce(rm.nroctacte,'NOTIEN')||'     ' as campo24, "
						+ " '                                     ' as campo25,"
						+ " rm.nrosucursal::varchar(10) as campo26,"
						+ " rm.nroremitocliente::varchar(15) as campo27, "
						+ " '   ' as campo28, "
						+ " '         ' as campo29, "
						+ " '1' as campo30, "
						+ " 'AVELLANEDA B             ' as campo31 , rm.idremitocliente, cl.idcliente, cd.iddomicilio "
						+ " FROM pedidoshojarutafinal hr "
						+ "  INNER JOIN clientesremitos rm ON ( hr.nrohojarutafinal = rm.nrohojarutafinal and hr.idempresa = rm.idempresa ) "

						+ "  INNER JOIN pedidos_regalos_entregas_deta pd ON ( rm.idremitocliente = pd.idremitocliente and rm.idempresa = pd.idempresa         "
						+ "             AND  pd.idpedido_regalos_entrega_deta = (SELECT MAX(idpedido_regalos_entrega_deta) FROM pedidos_regalos_entregas_deta WHERE pedidos_regalos_entregas_deta.idremitocliente = rm.idremitocliente and pedidos_regalos_entregas_deta.idempresa = rm.idempresa   ) ) "
						+ "  INNER JOIN pedidos_regalos_entregas_cabe pc on (pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe and pd.idempresa = pc.idempresa )  "
						+ "  INNER JOIN clientesanexolocalidades anex on ( pc.idanexolocalidad = anex.idanexolocalidad and pc.idempresa = anex.idempresa )"
						+ "  INNER JOIN globallocalidades loca ON ( anex.idlocalidad = loca.idlocalidad ) "
						+ "  INNER JOIN clientesclientes cl ON (pc.idcliente = cl.idcliente and pc.idempresa = cl.idempresa) "
						+ "  INNER JOIN pedidosdomiciliosentrega cd ON (pc.idsucuclie = cd.iddomicilio and pc.idempresa = cd.idempresa ) "
						// 20131108 - CEP - Mantis 925 -->
						+ "  INNER JOIN pedidos_regalos_cabe ppc ON ( pc.idpedido_regalos_cabe = ppc.idpedido_regalos_cabe AND pc.idempresa =  ppc.idempresa ) "
						+ "  INNER JOIN pedidos_regalos_deta ppd ON ( ppc.idpedido_regalos_cabe = ppd.idpedido_regalos_cabe AND ppc.idempresa =  ppd.idempresa and pd.codigo_st = ppd.codigo_st  ) "
						// ------> fin
						+ " WHERE hr.nrohojarutafinal IN  "
						+ inNrohojarutafinal + " and hr.idempresa = "
						+ idempresa

				// 20101220 - EJV - Mantis 647
				/**/
				;

				Statement statement = dbconn.createStatement();

				statement.execute(cQuery);

				statement.execute("ALTER TABLE " + tabla
						+ " ADD COLUMN id BIGSERIAL NOT NULL; ");

				cQuery = ""
						+ "SELECT campo1, campo2, campo3, campo4, campo5, campo6, campo7, campo8, campo9, campo10, "
						+ "             campo11, campo12, campo13, campo14, campo15, campo16, campo17, campo18, campo19, campo20, "
						+ "             campo21, campo22, campo23, campo24, campo25, campo26, campo27, campo28, campo29, campo30, campo31, idremitocliente, iddomicilio, idcliente,  id "
						+ "  FROM " + tabla + " ORDER BY campo19, campo20, id";

				Statement st = dbconn.createStatement();
				ResultSet rsSalida = st.executeQuery(cQuery);
				String auxSocio = "";
				String auxDomi = "";

				if (rsSalida.next()) {

					do {

						log.info("id: " + rsSalida.getString("id"));

						if (auxSocio.equalsIgnoreCase(rsSalida
								.getString("idcliente"))
								&& auxDomi.equalsIgnoreCase(rsSalida
										.getString("iddomicilio"))) {

							log.info("Mismo Socio: " + auxSocio
									+ " - Mismo Domicilio: " + auxDomi);

							// 1.Recuperar-el-id-minimo-para-el-grupo-de-cliente-domicilio.

							ResultSet rsAux = statement
									.executeQuery("SELECT MIN(id) AS id FROM  "
											+ tabla + " WHERE idcliente = "
											+ auxSocio + " AND iddomicilio = "
											+ auxDomi);

							if (rsAux != null && rsAux.next()) {

								long minId = rsAux.getLong("id");

								ResultSet rsTotal = statement
										.executeQuery("SELECT COUNT(1) AS total FROM  "
												+ tabla
												+ " WHERE idcliente = "
												+ auxSocio
												+ " AND iddomicilio = "
												+ auxDomi);

								if (rsTotal != null && rsTotal.next()) {

									int r = 0;
									String total = rsTotal.getString("total");

									// 2.Para-ese-minimo-id-setear-campo5-con-count()-para-el-grupo-cliente-domicilio.

									r = statement.executeUpdate("UPDATE  "
											+ tabla + " SET campo5 = LPAD('"
											+ total + "', 3, '0') WHERE id = "
											+ minId);

									// 3.Para-los-distintos-del-minimo-id-setear-campo5-con-000-para-el-grupo-cliente-domicilio
									r = statement
											.executeUpdate("UPDATE  "
													+ tabla
													+ " SET campo5 = '000' WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi + " AND  id <>  "
													+ minId);

									// --->
									// 4.Para-ese-minimo-id-setear-campo22-con-totaldekilos-para-el-grupo-cliente-domicilio
									// 5.Para-ese-minimo-id-setear-campo23-con-totaldekilos-para-el-grupo-cliente-domicilio
									// 6.Para-ese-minimo-id-setear-campo17-con-totalbultos-para-el-grupo-cliente-domicilio
									// 7.Para-ese-minimo-id-setear-campo16-con-valordeclarado-para-el-grupo-cliente-domicilio

									r = statement
											.executeUpdate("UPDATE  "
													+ tabla
													+ " SET campo22 = (SELECT SUM(campo22) FROM "
													+ tabla
													+ " WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi
													+ "),  campo23 = (SELECT SUM(campo23) FROM "
													+ tabla
													+ " WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi
													+ "),  campo16 = (SELECT SUM(campo16) FROM "
													+ tabla
													+ " WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi
													+ "),  campo17 = (SELECT SUM(campo17) FROM "
													+ tabla
													+ " WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi
													+ ") WHERE  id =  " + minId);

									// <---

									// 8.Para-los-distintos-del-minimo-id-setear-campo26-campo27-con-este-remito-comopadre-para-el-grupo-cliente-domicilio

									r = statement
											.executeUpdate("UPDATE  "
													+ tabla
													+ " SET campo26 = (SELECT LPAD(campo26, 4, '0') FROM "
													+ tabla
													+ "  WHERE id = "
													+ minId
													+ "), campo27 = (SELECT LPAD(campo27, 8, '0') FROM "
													+ tabla + "  WHERE id = "
													+ minId
													+ ")  WHERE idcliente = "
													+ auxSocio
													+ " AND iddomicilio = "
													+ auxDomi + " AND  id <>  "
													+ minId);

								}

							}

						}

						auxSocio = rsSalida.getString("idcliente");
						auxDomi = rsSalida.getString("iddomicilio");

					} while (rsSalida.next());

				}

				rsSalida = statement.executeQuery(cQuery);
				while (rsSalida.next()) {

					BigDecimal idRemito = rsSalida
							.getBigDecimal("idremitocliente");
					BigDecimal kilaje = getKilos4Remito(idRemito, idempresa);

					String salida = "";
					salida += GeneralBean.strZero(rsSalida.getString("campo1"),
							4);
					salida += GeneralBean.strZero(rsSalida.getString("campo2"),
							8);
					salida += rsSalida.getString("campo3");
					salida += rsSalida.getString("campo4");
					// salida += GeneralBean.strZero(total, 3);
					salida += rsSalida.getString("campo5");
					// revisar si esta bien que sea el total de remitos!!
					salida += rsSalida.getString("campo6");
					salida += rsSalida.getString("campo7");
					salida += rsSalida.getString("campo8");
					salida += rsSalida.getString("campo9").substring(0, 25);
					salida += rsSalida.getString("campo10");
					salida += rsSalida.getString("campo11").substring(0, 4);
					salida += rsSalida.getString("campo12");
					salida += rsSalida.getString("campo13");
					salida += rsSalida.getString("campo14");
					salida += rsSalida.getString("campo15");
					salida += GeneralBean.strZero(rsSalida.getString("campo16")
							.trim().replace('.', '#').replace("#", ""), 11);
					salida += GeneralBean.strZero(rsSalida.getString("campo17")
							.trim().replace('.', '#').replace("#", ""), 7);
					salida += rsSalida.getString("campo18");
					salida += rsSalida.getString("campo19").substring(0, 30);
					salida += rsSalida.getString("campo20").substring(0, 30);
					salida += rsSalida.getString("campo21");

					salida += GeneralBean.strZero(rsSalida.getString("campo22")
							.replace('.', '#').replace("#", ""), 7);

					salida += GeneralBean.strZero(rsSalida.getString("campo23")
							.replace('.', '#').replace("#", ""), 7); // aca
					// van
					// kilos
					salida += rsSalida.getString("campo24").substring(0, 5); // cuenta
					// corriente
					salida += rsSalida.getString("campo25");
					salida += GeneralBean.strZero(
							rsSalida.getString("campo26"), 4);
					salida += GeneralBean.strZero(
							rsSalida.getString("campo27"), 8);
					salida += rsSalida.getString("campo28");
					salida += rsSalida.getString("campo29");
					salida += rsSalida.getString("campo30");
					salida += rsSalida.getString("campo31");
					// 20101207 - EJV - Mantis 632 - Se heredo de proceso
					// BACO.-->
					// salida += "\r";
					// 20101210 -->
					// salida += "\n";
					salida += "\r\n";
					// <--
					// <--

					compara = patron.matcher(salida);
					salida = compara.replaceAll("?");

					fsalida += salida;

				}

			}

		} catch (SQLException sqlException) {
			log.error("getArchivoAndreani()  Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getArchivoAndreani()  Salida por exception: " + ex);
		}
		return fsalida;
	}

	// 

	// EJV - 20101213 - Mantis 637-->
	// CEP - 20131108 - Mantis 925 -->
	public String[] generaArchivoAndreani(String[] nrohojarutafinal,
			String usuarioact, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "";
		String[] resultado = new String[] { "", "" };
		boolean statusgeneracion = false;
		String archivoAndreani = "";
		String archivoAndreaniZip = "";
		// if (isExpresoAndreani(idexpreso, idempresa)) {

		dbconn.setAutoCommit(false);
		try {

			SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
			String fname = sdf.format(Calendar.getInstance().getTime());

			String source = getArchivoAndreani(nrohojarutafinal, idempresa);
			// String path = "/home/ejv/Escritorio/";
			String archivoZip = fname + "-bclavehr-" + usuarioact + ".zip";

			// 20101013-EJV-Pedido-de-AMELIA-Mantis 480-Nota-901
			// Eliminando-esta-linea-el-archivo-tendra-el-nombre-con-formato-YYYYDDMM-andreani-hrf-NROHRF.txt
			String archivo = "bclavehr.txt";

			statusgeneracion = GeneralBean.generaArchivo(source, archivo,
					pathAndreani);

			if (statusgeneracion) {

				File file = new File(pathAndreani + archivo);

				statusgeneracion = GeneralBean.zipFile(file, file
						.getAbsolutePath().replace(archivo, archivoZip));

				if (statusgeneracion) {
					archivoAndreani = ".."
							+ pathAndreani.substring(pathAndreani.toLowerCase()
									.indexOf(".war") + 4) + archivo;
					archivoAndreaniZip = ".."
							+ pathAndreani.substring(pathAndreani.toLowerCase()
									.indexOf(".war") + 4) + archivoZip;

					for (int m = 0; m < nrohojarutafinal.length; m++) {
						salida = pedidosHojaRutaFinalFileAndreaniUpdate(
								new BigDecimal(nrohojarutafinal[m]),
								archivoAndreaniZip, idempresa, usuarioact);
						if (!salida.equalsIgnoreCase("OK"))
							break;

					}

				} else {

					salida = "No fue posible comprimir archivo de texto plano Andreani.";

				}
			} else {

				salida = "No fue posible generar archivo de texto plano Andreani.";

			}

			log.info("archivoAndreani: " + archivoAndreani);

		} catch (Exception e) {

			salida = "Se produjo un error al generar archivo Andreani.";
			log.error("ERROR EN TEST DE GENERACION DE ANDREANI: " + e);

		}

		// }

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else {
			archivoAndreaniZip = "";
			dbconn.rollback();
		}

		resultado = new String[] { salida, archivoAndreaniZip };
		dbconn.setAutoCommit(false);
		return resultado;
	}

	// <--

	// 
	// -------------------------------------------------

	public BigDecimal getKilos4Remito(BigDecimal idremitocliente,
			BigDecimal idempresa) throws EJBException {
		BigDecimal salida = new BigDecimal(0);
		String cQuery = ""
				+ "SELECT sum(kilaje::numeric(18,2)) as total "
				+ "   FROM pedidos_deta pd"
				+ "            INNER JOIN stockstock st ON( pd.codigo_st = st.codigo_st and pd.idempresa = st.idempresa ) "
				+ "WHERE pd.idremitocliente = " + idremitocliente
				+ "     AND pd.idempresa=" + idempresa
				+ "     AND st.idempresa =" + idempresa;
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal("total");
			}
		} catch (SQLException sqlException) {
			log.error("getKilos4Remito Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error(" getKilos4Remito Salida por exception: " + ex);
		}
		return salida;
	}

	// -- EJV 20100929 <---

	public boolean isExpresoAndreani(BigDecimal idexpreso, BigDecimal idempresa) {
		boolean isandreani = false;
		try {

			String query = ""
					+ "SELECT 1 FROM clientesexpresoszonas WHERE idzona = 28 AND idempresa = "
					+ idempresa + " AND idexpreso = " + idexpreso;

			List listExpreso = getLista(query);

			if (listExpreso != null && !listExpreso.isEmpty()) {
				isandreani = true;
			}

		} catch (Exception e) {
			log.error("isExpresoAndreani: " + e);
		}

		return isandreani;
	}

	/**
	 * END - HOJA RUTA FINAL
	 */

	/**
	 * BEGIN - CALCULO DE BULTOS
	 * 
	 */

	// -- Metodos a testear
	// isKit: determina si un producto forma parte de un grupo de tipo KIT
	// public boolean isKit(String codigo_st, BigDecimal idempresa)
	// throws EJBException { //
	// boolean salida = false;
	// String cQuery = ""
	// + " SELECT COUNT(*) as total "
	// + "   FROM stockstock st"
	// +
	// "        INNER JOIN stockgrupos gr ON (st.grupo_st=gr.codigo_gr AND st.idempresa = gr.idempresa) "
	// + "  WHERE UPPER(gr.descrip_gr) LIKE '%KITS%' "
	// + "    AND st.codigo_st='" + codigo_st + "'"
	// + "    AND st.idempresa =" + idempresa;
	// try {
	//
	// Statement statement = dbconn.createStatement();
	// ResultSet rsSalida = statement.executeQuery(cQuery);
	// int total = 0;
	// while (rsSalida.next()) {
	// total = rsSalida.getInt("total");
	// }
	// if (total > 0)
	// salida = true;
	// } catch (SQLException sqlException) {
	// System.out.println("Error SQL: " + sqlException);
	// } catch (Exception ex) {
	// System.out.println("Salida por exception: " + ex);
	// }
	// return salida;
	// }
	// isCaja: determina si un producto es una CAJA (si viene en una unidad de
	// medida mayor a 1
	// public boolean isCaja(String codigo_st, BigDecimal idempresa)
	// throws EJBException { //
	// boolean salida = false;
	// String cQuery = ""
	// + " select gr.cantidad_md::numeric(18) as cantidad "
	// +
	// " from stockstock st join stockmedidas gr on (st.unimed_st=gr.codigo_md and st.idempresa = gr.idempresa) "
	// + " where " + " st.codigo_st='" + codigo_st + "'"
	// + " and st.idempresa =" + idempresa;
	// try {
	//
	// Statement statement = dbconn.createStatement();
	// ResultSet rsSalida = statement.executeQuery(cQuery);
	// int total = 0;
	// while (rsSalida.next()) {
	// total = rsSalida.getInt("cantidad");
	// }
	// if (total > 1)
	// salida = true;
	// } catch (SQLException sqlException) {
	// System.out.println("Error SQL: " + sqlException);
	// } catch (Exception ex) {
	// System.out.println("Salida por exception: " + ex);
	// }
	// return salida;
	// }
	// trae del expreso el factor de la medida de su bulto mmmmmmmmmmmmmm!!
	// public BigDecimal getMedida4Bulto(BigDecimal idExpreso, BigDecimal
	// idempresa)
	// throws EJBException { // throws
	// // EJBException
	// BigDecimal salida = new BigDecimal(1); // inicializa en 1 por si no
	// // encuentra nada.
	// String cQuery = ""
	// + " SELECT med.cantidad_md::numeric(18) AS cantidad  "
	// + "   FROM clientesexpresos ex "
	// +
	// "       INNER JOIN stockmedidas med ON( ex.idmedidabulto = med.codigo_md AND ex.idempresa= med.idempresa) "
	// + "  WHERE ex.idexpreso = " + idExpreso + " AND ex.idempresa ="
	// + idempresa;
	// try {
	//
	// Statement statement = dbconn.createStatement();
	// ResultSet rsSalida = statement.executeQuery(cQuery);
	//
	// while (rsSalida.next()) {
	// salida = rsSalida.getBigDecimal("cantidad");
	// }
	//
	// } catch (SQLException sqlException) {
	// System.out.println("Error SQL: " + sqlException);
	// } catch (Exception ex) {
	// System.out.println("Salida por exception: " + ex);
	// }
	// return salida;
	// }
	// traer la cantidad de una unidad de medida que proviene de un producto
	// public BigDecimal getMedidaFactor(String codigo_st, BigDecimal idempresa)
	// throws EJBException {
	// BigDecimal salida = new BigDecimal(1);
	// // inicializa en 1 por si no encuentra nada.
	// String cQuery = ""
	// + " SELECT gr.cantidad_md::numeric(18) as cantidad  "
	// + "   FROM stockstock st "
	// +
	// "        INNER JOIN stockmedidas gr ON (st.unimed_st=gr.codigo_md AND st.idempresa = gr.idempresa) "
	// + "  WHERE st.codigo_st='" + codigo_st + "' "
	// + "    AND st.idempresa =" + idempresa;
	// try {
	//
	// Statement statement = dbconn.createStatement();
	// ResultSet rsSalida = statement.executeQuery(cQuery);
	//
	// while (rsSalida.next()) {
	// salida = rsSalida.getBigDecimal("cantidad");
	// }
	//
	// } catch (SQLException sqlException) {
	// System.out.println("Error SQL: " + sqlException);
	// } catch (Exception ex) {
	// System.out.println("Salida por exception: " + ex);
	// }
	// return salida;
	// }
	//
	// CALCULO DEL BULTO!!
	// public int getCalculoBulto(BigDecimal nrosucursal, BigDecimal nroremito,
	// BigDecimal idempresa) throws EJBException { // throws
	// // EJBException
	// int salida = 0;
	// BigDecimal totalU = new BigDecimal(0);
	// BigDecimal totalC = new BigDecimal(0);
	// BigDecimal disponible = new BigDecimal(0);
	// BigDecimal cajas = new BigDecimal(0);
	// BigDecimal disponibilidadBulto = new BigDecimal(1); // cantidad que
	// // caben en una caja
	// // de bulto (8)
	// String cQuery = ""
	// +
	// " SELECT ped.codigo_st, ped.cantidad, ped.bonific, ped.precio, pedc.idexpreso "
	// + "   FROM clientesremitos rem  "
	// +
	// "        INNER JOIN pedidos_deta ped ON ( rem.idremitocliente = ped.idremitocliente AND rem.idempresa = ped.idempresa ) "
	// +
	// "        INNER JOIN pedidos_cabe pedc ON( ped.idpedido_cabe = pedc.idpedido_cabe AND ped.idempresa = pedc.idempresa ) "
	// + "  WHERE rem.nrosucursal = " + nrosucursal
	// + "    AND rem.nroremitocliente = " + nroremito
	// + "    AND rem.idempresa =" + idempresa;
	// try {
	//
	// Statement statement = dbconn.createStatement();
	// ResultSet rsSalida = statement.executeQuery(cQuery);
	// while (rsSalida.next()) {
	// disponibilidadBulto = getMedida4Bulto(rsSalida
	// .getBigDecimal("idexpreso"), idempresa);
	// if (isKit(rsSalida.getString("codigo_st"), idempresa)) {
	// totalU = totalU.add(new BigDecimal(0)); // no sumo unidades
	// // (queda asi por si
	// // cambia)
	// } else {
	//
	// if (isCaja(rsSalida.getString("codigo_st"), idempresa)) {
	// cajas = cajas.add(rsSalida.getBigDecimal("cantidad"));
	// BigDecimal factor = getMedidaFactor(rsSalida
	// .getString("codigo_st"), idempresa);
	// totalC = totalC.add((rsSalida.getBigDecimal("cantidad")
	// .multiply(factor)));
	// } else {
	// BigDecimal factor = getMedidaFactor(rsSalida
	// .getString("codigo_st"), idempresa);
	// totalU = totalU.add((rsSalida.getBigDecimal("cantidad")
	// .multiply(factor)));
	//
	// }
	// }
	//
	// }
	//
	// if (cajas.compareTo(new BigDecimal(0)) > 0) {
	// disponible = new BigDecimal(
	// (disponibilidadBulto.intValue() * cajas.intValue())
	// - totalC.intValue());
	// totalU = totalU.add(new BigDecimal(totalU.intValue()
	// - disponible.intValue()));
	//
	// }
	// if (totalU.compareTo(new BigDecimal(0)) > 0) { // quedaron cajas
	// // fuera
	// if ((totalU.intValue() % disponibilidadBulto.intValue()) == 0) {
	// salida = cajas.intValue()
	// + (totalU.intValue() / disponibilidadBulto
	// .intValue());
	// } else {
	// salida = cajas.intValue()
	// + (totalU.intValue() / disponibilidadBulto
	// .intValue()) + 1;
	// }
	// } else {
	// salida = cajas.intValue();
	// }
	//
	// } catch (SQLException sqlException) {
	// System.out.println("Error SQL: " + sqlException);
	// } catch (Exception ex) {
	// System.out.println("Salida por exception: " + ex);
	// }
	// return salida;
	// }
	// ------------------------------------------------------------------------------------------------
	// 20100803 - CEP - CALCULO DE BULTO RELEASE
	public BigDecimal getMedidaFactor(String codigo_st,
			BigDecimal tipoDistribucion, BigDecimal idempresa)
			throws EJBException {
		BigDecimal salida = new BigDecimal(1);
		String cQuery = "";
		// validacion por las dudas: como es una cocinada lo dejamos hardcode
		// para que no pinche el programa
		if (tipoDistribucion.compareTo(new BigDecimal(1)) != 0
				&& tipoDistribucion.compareTo(new BigDecimal(2)) != 0)

			tipoDistribucion = new BigDecimal(2);

		if (tipoDistribucion.compareTo(new BigDecimal(1)) == 0) {
			// si es andreani va la unidad alternativa 1 sino va la 2

			cQuery = ""
					+ " SELECT gr.cantidad_md::numeric(18) as cantidad  "
					+ "   FROM stockstock st "
					+ "        INNER JOIN stockmedidas gr ON (st.unialt1_st=gr.codigo_md AND st.idempresa = gr.idempresa) "

					+ "  WHERE st.codigo_st='" + codigo_st + "' "
					+ "    AND st.idempresa =" + idempresa;
		} else {
			cQuery = ""
					+ " SELECT gr.cantidad_md::numeric(18) as cantidad  "
					+ "   FROM stockstock st "
					+ "        INNER JOIN stockmedidas gr ON (st.unialt2_st=gr.codigo_md AND st.idempresa = gr.idempresa) "

					+ "  WHERE st.codigo_st='" + codigo_st + "' "
					+ "    AND st.idempresa =" + idempresa;

		}

		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);

			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal("cantidad");
			}

		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		log.debug("cantidad para la medida " + salida);
		return salida;
	}

	public boolean isCaja(String codigo_st, BigDecimal idempresa)
			throws EJBException {
		boolean salida = false;
		String cQuery = ""
				+ " select gr.cantidad_md::numeric(18) as cantidad "
				+ " from stockstock st join stockmedidas gr on (st.unimed_st=gr.codigo_md and st.idempresa = gr.idempresa) "

				+ " where " + " st.codigo_st='" + codigo_st + "'"
				+ " and st.idempresa =" + idempresa;
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			while (rsSalida.next()) {
				total = rsSalida.getInt("cantidad");
			}
			if (total > 1)
				salida = true;
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return salida;
	}

	public boolean isKit(String codigo_st, BigDecimal idempresa)
			throws EJBException {
		boolean salida = false;
		String cQuery = ""
				+ " SELECT COUNT(*) as total "
				+ "   FROM stockstock st"
				+ "        INNER JOIN stockgrupos gr ON (st.grupo_st=gr.codigo_gr AND st.idempresa = gr.idempresa) "

				+ "  WHERE UPPER(gr.descrip_gr) LIKE '%KITS%' "
				+ "    AND st.codigo_st='" + codigo_st + "'"
				+ "    AND st.idempresa =" + idempresa;
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			while (rsSalida.next()) {
				total = rsSalida.getInt("total");
			}
			if (total > 0)
				salida = true;
		} catch (SQLException sqlException) {
			log.error("isKit() - Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("isKit () - Salida por exception: " + ex);
		}
		return salida;
	}

	// funcion nueva.
	public BigDecimal getTipoDistribucion(BigDecimal idExpreso,
			BigDecimal idempresa) throws EJBException {
		BigDecimal salida = new BigDecimal(1); // inicializa en 1 por si no
		// encuentra nada.
		String cQuery = ""
				+ " SELECT ex.idmedidabulto::numeric(18) AS cantidad  "
				+ "   FROM clientesexpresos ex " + "  WHERE ex.idexpreso = "
				+ idExpreso + " AND ex.idempresa =" + idempresa;
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);

			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal("cantidad");
			}

		} catch (SQLException sqlException) {
			log.error("getTipoDistribucion() - Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getTipoDistribucion() - Salida por exception: " + ex);
		}
		return salida;
	}

	public BigDecimal getMedida4Bulto(BigDecimal idExpreso, BigDecimal idempresa)
			throws EJBException {

		BigDecimal salida = new BigDecimal(1); // inicializa en 1 por si no
		// encuentra nada.
		String cQuery = ""
				+ " SELECT med.cantidad_md::numeric(18) AS cantidad  "
				+ "   FROM clientesexpresos ex "
				+ "       INNER JOIN stockmedidas med ON( ex.idmedidabulto = med.codigo_md AND ex.idempresa= med.idempresa) "

				+ "  WHERE ex.idexpreso = " + idExpreso + " AND ex.idempresa ="
				+ idempresa;
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);

			while (rsSalida.next()) {
				salida = rsSalida.getBigDecimal("cantidad");
			}

		} catch (SQLException sqlException) {
			log.error("getMedida4Bulto() - Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getMedida4Bulto() - Salida por exception: " + ex);
		}
		return salida;
	}

	// -------------------------------
	// CALCULO DEL BULTO!!
	public int getCalculoBulto(BigDecimal nrosucursal, BigDecimal nroremito,
			BigDecimal idempresa) throws EJBException {
		/*
		 * Modificaciones: 03/08/2010 1. disponibilidadBulto : si es 1 es
		 * andreani y debe usar unidad alternativa 1, sino unidad alternativa 2.
		 */

		int salida = 0;
		BigDecimal totalU = new BigDecimal(0);
		BigDecimal totalC = new BigDecimal(0);
		BigDecimal disponible = new BigDecimal(0);
		BigDecimal cajas = new BigDecimal(0);
		BigDecimal disponibilidadBulto = new BigDecimal(1);
		BigDecimal tipoDistribucion = new BigDecimal(0);

		// caben en una caja
		// de bulto (8)
		String cQuery = ""
				+ " SELECT ped.codigo_st, ped.cantidad, ped.bonific, ped.precio, pedc.idexpreso "
				+ "   FROM clientesremitos rem  "
				+ "        INNER JOIN pedidos_deta ped ON ( rem.idremitocliente = ped.idremitocliente AND rem.idempresa = ped.idempresa ) "
				+ "        INNER JOIN pedidos_cabe pedc ON( ped.idpedido_cabe = pedc.idpedido_cabe AND ped.idempresa = pedc.idempresa ) "
				+ "  WHERE rem.nrosucursal = "
				+ nrosucursal
				+ "    AND rem.nroremitocliente = "
				+ nroremito
				+ "    AND rem.idempresa ="
				+ idempresa
				// 20100901 - EJV - Mantis 569 -->
				// 
				+ " UNION ALL "
				+ "  SELECT ped.codigo_st, ped.cantidad, 0 AS bonific, 0 AS precio, pedc.idexpreso  "
				+ "    FROM clientesremitos rem   "
				+ "         INNER JOIN pedidos_regalos_entregas_deta ped ON ( rem.idremitocliente = ped.idremitocliente AND rem.idempresa = ped.idempresa ) "
				+ "         INNER JOIN pedidos_regalos_entregas_cabe pedc ON( ped.idpedido_regalos_entrega_cabe = pedc.idpedido_regalos_entrega_cabe AND ped.idempresa = pedc.idempresa ) "
				+ "  WHERE rem.nrosucursal = " + nrosucursal
				+ "    AND rem.nroremitocliente = " + nroremito
				+ "    AND rem.idempresa =" + idempresa;
		// <--

		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			while (rsSalida.next()) {
				disponibilidadBulto = getMedida4Bulto(rsSalida
						.getBigDecimal("idexpreso"), idempresa);

				tipoDistribucion = getTipoDistribucion(rsSalida
						.getBigDecimal("idexpreso"), idempresa);

				// if (isKit(rsSalida.getString("codigo_st"), idempresa)) {
				// totalU = totalU.add(new BigDecimal(0)); // no sumo unidades
				// (queda asi por si
				// cambia)
				// } else {
				BigDecimal factor = getMedidaFactor(rsSalida
						.getString("codigo_st"), tipoDistribucion, idempresa);
				totalU = totalU.add((rsSalida.getBigDecimal("cantidad")
						.multiply(factor)));

				/*
				 * if (isCaja(rsSalida.getString("codigo_st"), idempresa)) {
				 * cajas = cajas.add(rsSalida.getBigDecimal("cantidad"));
				 * BigDecimal factor = getMedidaFactor(rsSalida
				 * .getString("codigo_st"),tipoDistribucion, idempresa); totalC
				 * = totalC.add((rsSalida.getBigDecimal("cantidad")
				 * .multiply(factor))); } else { BigDecimal factor =
				 * getMedidaFactor(rsSalida
				 * .getString("codigo_st"),tipoDistribucion, idempresa); totalU
				 * = totalU.add((rsSalida.getBigDecimal("cantidad")
				 * .multiply(factor)));
				 * 
				 * }
				 */

				// }
			}

			if (cajas.compareTo(new BigDecimal(0)) > 0) {
				disponible = new BigDecimal(
						(disponibilidadBulto.intValue() * cajas.intValue())
								- totalC.intValue());
				totalU = totalU.add(new BigDecimal(totalU.intValue()
						- disponible.intValue()));

			}
			if (totalU.compareTo(new BigDecimal(0)) > 0) { // quedaron cajas
				// fuera
				if ((totalU.intValue() % disponibilidadBulto.intValue()) == 0) {
					salida = cajas.intValue()
							+ (totalU.intValue() / disponibilidadBulto
									.intValue());
				} else {
					salida = cajas.intValue()
							+ (totalU.intValue() / disponibilidadBulto
									.intValue()) + 1;
				}
			} else {
				salida = cajas.intValue();
			}

		} catch (SQLException sqlException) {
			log.error("getCalculoBulto() - Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getCalculoBulto() - Salida por exception: " + ex);
		}
		return salida;
	}

	// ------------------------------ fin

	/**
	 * END - CALCULO DE BULTOS
	 */

	// 20120615 - EJV - Mantis 810 -->
	private int esFacturaExportacion(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) {

		int facturaExportacion = -10;
		String cQuery = ""
				+ "SELECT iva.letra "
				+ "  FROM clientesclientes cl "
				+ "            INNER JOIN clientestablaiva iva ON cl.idtipoiva = iva.idtipoiva AND cl.idempresa = iva.idempresa "
				+ " WHERE cl.idcliente = " + idcliente + " AND cl.idempresa = "
				+ idempresa;

		List listEsExportacion;
		String[] datos;

		try {

			listEsExportacion = getLista(cQuery, conn);

			if (listEsExportacion != null && !listEsExportacion.isEmpty()) {

				datos = (String[]) listEsExportacion.get(0);

				if (datos[0].equalsIgnoreCase("E")) {
					facturaExportacion = 1;
				} else {
					facturaExportacion = 0;
				}

			} else {

				facturaExportacion = -9;
				log
						.warn("esFacturaExportacion(E-9)No fue posible verificar si es Exportacion.");
			}

		} catch (Exception e) {
			log.error("esFacturaExportacion():" + e);
		}

		return facturaExportacion;

	}

	// <--

	// 20110811 - EJV - Mantis 764 - Calculo de FLETE -->
	public BigDecimal[] getCalculoFlete(BigDecimal nrosucursal,
			BigDecimal nroremito, int cantidadBultos, BigDecimal idempresa,
			Connection conn) throws EJBException {

		BigDecimal totalFlete = new BigDecimal(0);

		BigDecimal totalIvalFlete = new BigDecimal(0);
		BigDecimal porcIvaFlete = new BigDecimal(21);
		BigDecimal totalesFlete[] = new BigDecimal[] { new BigDecimal(0.000),
				new BigDecimal(0.0000), new BigDecimal(0.00) };

		try {

			if (conn == null)
				conn = dbconn;

			Statement statement = conn.createStatement();
			String cQuery = ""
					// 20120614 - EJV - Mantis 810 -->
					// +
					// "SELECT DISTINCT anx.idanexolocalidad, anx.tarsoc1bulto tarifa_bulto_unico, anx.tarsocexc tarifa_bulto_excedente "
					+ "SELECT DISTINCT pc.idcliente, anx.idanexolocalidad, anx.tarsoc1bulto tarifa_bulto_unico, anx.tarsocexc tarifa_bulto_excedente "
					// <--
					+ "   FROM pedidos_cabe pc "
					+ "             INNER JOIN pedidos_deta pd ON pc.idpedido_cabe = pd.idpedido_cabe AND pc.idempresa = pd.idempresa "
					+ "             INNER JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa  "
					+ "             INNER JOIN clientesanexolocalidades anx ON pc.idanexolocalidad = anx.idanexolocalidad AND pc.idempresa = anx.idempresa "
					+ " WHERE cr.nrosucursal  = " + nrosucursal
					+ "     AND cr.nroremitocliente = " + nroremito
					+ "     AND cr.idempresa = " + idempresa;

			ResultSet rsSalida = statement.executeQuery(cQuery);
			boolean esPrimero = true;
			BigDecimal idcliente = new BigDecimal(-1);
			int facturaExportacion = -100;

			if (rsSalida != null) {

				if (rsSalida.next()) {

					for (int i = 0; i < cantidadBultos; i++) {

						if (esPrimero) {
							// 20120615 - EJV - Mantis 810 -->
							idcliente = rsSalida.getBigDecimal("idcliente");
							facturaExportacion = esFacturaExportacion(
									idcliente, idempresa, conn);

							if (facturaExportacion == 1) {

								// No corresponde iva cuando es exportacion.
								porcIvaFlete = new BigDecimal(0);

							} else if (facturaExportacion == 0) {

								// Por definicion es iva 21 para todos los que
								// no son exportacion.
								porcIvaFlete = new BigDecimal(21);

							} else {

								totalFlete = new BigDecimal(-5);
								log
										.error("getCalculoFlete(): No fue posible verificar si es expotacion: "
												+ nrosucursal
												+ " - "
												+ nroremito);
								break;
							}

							// <--

							totalFlete = totalFlete.add(rsSalida
									.getBigDecimal("tarifa_bulto_unico"));
							esPrimero = false;

						} else {

							totalFlete = totalFlete.add(rsSalida
									.getBigDecimal("tarifa_bulto_excedente"));

						}

						totalIvalFlete = (totalFlete.multiply(porcIvaFlete))
								.divide(new BigDecimal(100));

					}

				} else {
					totalFlete = new BigDecimal(-2);
					log
							.error("getCalculoFlete(): No existen registros para remito: "
									+ nrosucursal + " - " + nroremito);
				}

			} else {
				totalFlete = new BigDecimal(-3);
				log
						.error("getCalculoFlete():{RS Vacio} No existen registros para remito: "
								+ nrosucursal + " - " + nroremito);
			}

		} catch (Exception e) {
			totalFlete = new BigDecimal(-4);
			log.error("getCalculoFlete(): " + e);
		}

		totalesFlete[0] = totalFlete;
		totalesFlete[1] = totalIvalFlete;
		totalesFlete[2] = porcIvaFlete;

		return totalesFlete;

	}

	// <--

	/**
	 * Metodos para la entidad: vclientesCtaCtes Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Wed Mar 25 08:50:25 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVclientesCtaCtesAll(long limit, long offset,
			BigDecimal idcliente, String historico, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,razon,fecha,tipomov,idtipomov,comprobante,debe,haber,saldo_movimiento,"
				+ "       fecha_vencimiento,nrointerno,idempresa "
				+ "  FROM VCLIENTESCTACTES WHERE idempresa = "
				+ idempresa.toString() + " AND idcliente = " + idcliente
				+ (historico.equals("P") ? " AND saldo_movimiento <> 0" : "")
				+ " ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesCtaCtesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVclientesCtaCtesOcu(long limit, long offset,
			BigDecimal idcliente, String historico, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,razon,fecha,tipomov,idtipomov,comprobante,debe,haber,saldo_movimiento,"
				+ "       fecha_vencimiento,nrointerno,idempresa"
				+ "  FROM VCLIENTESCTACTES" + " WHERE ( (comprobante) LIKE '"
				+ ocurrencia.toUpperCase().trim() + "%') AND idcliente ="
				+ idcliente + "  AND idempresa = " + idempresa.toString()
				+ (historico.equals("P") ? " AND saldo_movimiento <> 0" : "")
				+ " ORDER BY 3 LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesCtaCtesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getVclientesCtaCtesSaldo(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT COALESCE(SUM(saldo_movimiento), 0) AS total_saldo "
				+ "  FROM VCLIENTESCTACTES "
				+ " WHERE saldo_movimiento <> 0 AND  idcliente="
				+ idcliente.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";

		BigDecimal saldo = new BigDecimal(0);
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null && rsSalida.next()) {
				saldo = rsSalida.getBigDecimal(1);
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getVclientesCtaCtesSaldo( BigDecimal idcliente ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesCtaCtesSaldo( BigDecimal idcliente )  "
							+ ex);
		}
		return saldo;
	}

	// 20120607 - EJV -->

	public List getVclientesCtaCtesGeneral(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idcliente,razon,fecha,tipomov,idtipomov,comprobante,debe,haber,saldo_movimiento,"
				+ "       fecha_vencimiento,nrointerno, idtipoclie, tipoclie, idcondicion, condicion, idempresa "
				+ "  FROM vclientesctactes WHERE idempresa = "
				+ idempresa.toString() + filtro + " ORDER BY 2, 3  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesCtaCtesGeneral()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	/**
	 * Metodos para la entidad: vclientesAsientos Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Wed Mar 25 10:59:30 GYT 2009
	 * 
	 */

	// por primary key (primer campo por defecto)
	public List getVclientesAsientosPK(BigDecimal nrointerno,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT nrointerno,idcuenta,cuenta,tip,tipdh,importe,debe,haber,tipomov,idempresa"
				+ "  FROM VCLIENTESASIENTOS WHERE nrointerno="
				+ nrointerno.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesAsientosPK( BigDecimal nrointerno )  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: bacoErEsquema Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Wed Mar 25 14:12:47 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoErEsquemaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT be.idesquema, be.anio, be.idmes, be.idpreferencia, cp.preferencia, be.codigo_st, st.descrip_st, "
				+ "       cantidad, be.codigo_dt, dt.descrip_dt,  be.iddescuento, be.idmotivodescuento, "
				+ "       be.idlista, COALESCE(cd.por_desc, 0.00) AS descuento, "
				+ "       be.idempresa, be.usuarioalt, be.usuarioact, be.fechaalt, be.fechaact "
				+ "  FROM bacoeresquema be  "
				+ "       INNER JOIN stockstock st ON be.codigo_st = st.codigo_st AND be.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON be.codigo_dt = dt.codigo_dt AND be.idempresa = dt.idempresa "
				+ "       INNER JOIN clientespreferencias cp ON be.idpreferencia = cp.idpreferencia AND be.idempresa = cp.idempresa "
				+ "        LEFT JOIN clientesdescuentos cd ON be.iddescuento = cd.iddescuento AND be.idempresa = cd.idempresa "
				+ " WHERE be.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2 DESC, 3 DESC LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoErEsquemaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoErEsquemaOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT be.idesquema, be.anio, be.idmes, be.idpreferencia, cp.preferencia, be.codigo_st, st.descrip_st, "
				+ "       cantidad, be.codigo_dt, dt.descrip_dt,  be.iddescuento, be.idmotivodescuento, "
				+ "       be.idlista, COALESCE(cd.por_desc, 0.00) AS descuento,"
				+ "       be.idempresa, be.usuarioalt, be.usuarioact, be.fechaalt, be.fechaact "
				+ "  FROM bacoeresquema be  "
				+ "       INNER JOIN stockstock st ON be.codigo_st = st.codigo_st AND be.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON be.codigo_dt = dt.codigo_dt AND be.idempresa = dt.idempresa "
				+ "       INNER JOIN clientespreferencias cp ON be.idpreferencia = cp.idpreferencia AND be.idempresa = cp.idempresa "
				+ "        LEFT JOIN clientesdescuentos cd ON be.iddescuento = cd.iddescuento AND be.idempresa = cd.idempresa "
				+ " WHERE ( (be.ANIO::varchar || '/' || be.idmes::varchar) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND be.idempresa = "
				+ idempresa.toString() + " ORDER BY 2 DESC, 3 DESC LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoErEsquemaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoErEsquemaPK(BigDecimal idesquema, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT be.idesquema, be.anio, be.idmes, be.idpreferencia, be.codigo_st, st.descrip_st, "
				+ "       cantidad, be.codigo_dt, dt.descrip_dt,  be.iddescuento, be.idmotivodescuento, "
				+ "       be.idlista, cl.descri_lis, be.idempresa, be.usuarioalt, be.usuarioact, be.fechaalt, be.fechaact "
				+ "  FROM bacoeresquema be  "
				+ "       INNER JOIN stockstock st ON be.codigo_st = st.codigo_st AND be.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON be.codigo_dt = dt.codigo_dt AND be.idempresa = dt.idempresa "
				+ "       INNER JOIN clienteslistas cl ON be.idlista = cl.idlista AND be.idempresa = cl.idempresa "
				+ " WHERE be.idesquema=" + idesquema.toString()
				+ "   AND be.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoErEsquemaPK( BigDecimal idesquema )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoErEsquemaDelete(BigDecimal idesquema, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOERESQUEMA WHERE idesquema="
				+ idesquema.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOERESQUEMA WHERE idesquema="
						+ idesquema.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoErEsquemaDelete( BigDecimal idesquema, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoErEsquemaDelete( BigDecimal idesquema, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoErEsquemaCreate(BigDecimal anio, BigDecimal idmes,
			BigDecimal idpreferencia, String codigo_st, BigDecimal cantidad,
			BigDecimal codigo_dt, BigDecimal iddescuento,
			BigDecimal idmotivodescuento, BigDecimal idlista,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idpreferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreferencia ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOERESQUEMA(anio, idmes, idpreferencia, codigo_st, cantidad, codigo_dt, iddescuento, idmotivodescuento, idlista, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, anio);
				insert.setBigDecimal(2, idmes);
				insert.setBigDecimal(3, idpreferencia);
				insert.setString(4, codigo_st);
				insert.setBigDecimal(5, cantidad);
				insert.setBigDecimal(6, codigo_dt);
				insert.setBigDecimal(7, iddescuento);
				insert.setBigDecimal(8, idmotivodescuento);
				insert.setBigDecimal(9, idlista);
				insert.setBigDecimal(10, idempresa);
				insert.setString(11, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoErEsquemaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoErEsquemaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoErEsquemaCreateOrUpdate(BigDecimal idesquema,
			BigDecimal anio, BigDecimal idmes, BigDecimal idpreferencia,
			String codigo_st, BigDecimal cantidad, BigDecimal codigo_dt,
			BigDecimal iddescuento, BigDecimal idmotivodescuento,
			BigDecimal idlista, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idesquema == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idesquema ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idpreferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreferencia ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoErEsquema WHERE idesquema = "
					+ idesquema.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOERESQUEMA SET anio=?, idmes=?, idpreferencia=?, codigo_st=?, cantidad=?, codigo_dt=?, iddescuento=?, idmotivodescuento=?, idlista=?, idempresa=?, usuarioact=?, fechaact=? WHERE idesquema=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idpreferencia);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, cantidad);
					insert.setBigDecimal(6, codigo_dt);
					insert.setBigDecimal(7, iddescuento);
					insert.setBigDecimal(8, idmotivodescuento);
					insert.setBigDecimal(9, idlista);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idesquema);
				} else {
					String ins = "INSERT INTO BACOERESQUEMA(anio, idmes, idpreferencia, codigo_st, cantidad, codigo_dt, iddescuento, idmotivodescuento, idlista, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idpreferencia);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, cantidad);
					insert.setBigDecimal(6, codigo_dt);
					insert.setBigDecimal(7, iddescuento);
					insert.setBigDecimal(8, idmotivodescuento);
					insert.setBigDecimal(9, idlista);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoErEsquemaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoErEsquemaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoErEsquemaUpdate(BigDecimal idesquema, BigDecimal anio,
			BigDecimal idmes, BigDecimal idpreferencia, String codigo_st,
			BigDecimal cantidad, BigDecimal codigo_dt, BigDecimal iddescuento,
			BigDecimal idmotivodescuento, BigDecimal idlista,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idesquema == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idesquema ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idpreferencia == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreferencia ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (idlista == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlista ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoErEsquema WHERE idesquema = "
					+ idesquema.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOERESQUEMA SET anio=?, idmes=?, idpreferencia=?, codigo_st=?, cantidad=?, codigo_dt=?, iddescuento=?, idmotivodescuento=?, idlista=?, idempresa=?, usuarioact=?, fechaact=? WHERE idesquema=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idpreferencia);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, cantidad);
					insert.setBigDecimal(6, codigo_dt);
					insert.setBigDecimal(7, iddescuento);
					insert.setBigDecimal(8, idmotivodescuento);
					insert.setBigDecimal(9, idlista);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idesquema);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoErEsquemaUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoErEsquemaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	//

	public BigDecimal getBacoTmAsignacionTotalSocios(BigDecimal idcampacabe,
			String filtros, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""

				+ "SELECT COUNT(DISTINCT cl.idcliente) "
				+ "  FROM clientesclientes cl  "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa "
				+ "       INNER JOIN globallocalidades lo ON cd.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
				+ "       INNER JOIN clientesprecargaclientes pcc ON cl.idcliente = pcc.idcliente AND cl.idempresa = pcc.idempresa "
				+ "       INNER JOIN vclientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa AND ca.fhasta IS NULL "
				+ " WHERE cl.idempresa =  " + idempresa.toString()
				+ "   AND cl.idcliente NOT IN ("
				+ "                            SELECT idcliente "
				+ "                              FROM bacotmseleccionsocio "
				+ "                             WHERE idcampacabe = "
				+ idcampacabe + " AND idempresa = " + idempresa + ")" + filtros
				+ ";";

		BigDecimal total = new BigDecimal(-1);
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getBigDecimal(1);
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getBacoTmAsignacionTotalSocios( BigDecimal idesquema ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmAsignacionTotalSocios( BigDecimal idesquema )  "
							+ ex);
		}
		return total;
	}

	public String bacoTmAsignacionSocioCreate(BigDecimal idcampacabe,
			BigDecimal idtelemark, String filtros, String limit,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		long registros = 0;
		// validaciones de datos:
		// 1. nulidad de campos

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (idcampacabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe ";
		if (idtelemark == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtelemark ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina

		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ " INSERT INTO bacotmseleccionsocio(idcampacabe, idcliente, idtelemark, idempresa, usuarioalt)"
						+ " SELECT DISTINCT ?, cl.idcliente, ?, cl.idempresa, ? "
						+ "   FROM clientesclientes cl  "
						+ "        INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa "
						+ "        INNER JOIN globallocalidades lo ON cd.idlocalidad = lo.idlocalidad "
						+ "        INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
						+ "        INNER JOIN clientesprecargaclientes pcc ON cl.idcliente = pcc.idcliente AND cl.idempresa = pcc.idempresa "
						+ "        INNER JOIN vclientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
						+ "        INNER JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa AND ca.fhasta IS NULL "
						+ "  WHERE cl.idempresa = ? "
						+ "    AND cl.idcliente NOT IN ("
						+ "                      SELECT idcliente "
						+ "                        FROM bacotmseleccionsocio "
						+ "                       WHERE idcampacabe = ? AND idempresa = ? "
						+ "                      )" + filtros + "  " + limit
						+ ";";

				PreparedStatement insert = dbconn.prepareStatement(ins);
				insert.setBigDecimal(1, idcampacabe);
				insert.setBigDecimal(2, idtelemark);
				insert.setString(3, usuarioalt);
				insert.setBigDecimal(4, idempresa);
				insert.setBigDecimal(5, idcampacabe);
				insert.setBigDecimal(6, idempresa);

				registros = insert.executeUpdate();

				salida = registros + "";

			}

		} catch (SQLException sqlException) {

			salida = "SQLE: No fue posible generar asignacin.";
			log.error("Error SQL public String bacoErEsquemaCreate(.....)"
					+ sqlException);

		} catch (Exception ex) {
			salida = "EX: No fue posible generar asignacin.";
			log
					.error("Error excepcion public String bacoErEsquemaCreate(.....)"
							+ ex);
		}

		return salida;

	}

	/**
	 * PROCESO DE ENTREGAS REGULARES. BEGIN 20090331 - EJV.
	 */

	public String setEntregasRegulares(int anio, int mes, BigDecimal idempresa,
			String usuarioalt) throws EJBException, SQLException {
		String salida = "OK";

		// boolean hasEsquemas = false;
		Calendar cal = new GregorianCalendar();
		cal.set(anio, mes - 1, 1, 0, 0, 0);
		String origenpedido = "ER";
		String tipopedido = "N";
		java.sql.Timestamp fechapedido = new java.sql.Timestamp(cal
				.getTimeInMillis());

		Hashtable htPorcentajeIva = new Hashtable();
		Iterator iterator;
		String status = "";
		Double grandTotal = new Double(0.00);
		Double grandTotalIva = new Double(0.00);
		Hashtable htArticulos = new Hashtable();
		BigDecimal idestado = new BigDecimal(-1);
		long contador = 0;

		Properties properties = this.props;

		java.sql.Date hoy = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());

		try {
			// properties.load(ClientesBean.class
			// .getResourceAsStream("system.properties"));
			iterator = getClientestablaivaAll(100, 0, idempresa).iterator();
			while (iterator.hasNext()) {
				String[] iva = (String[]) iterator.next();
				htPorcentajeIva.put(iva[0], iva[2]);
			}

			ResultSet rsPreferencias = getPreferencias4ER(anio, mes, idempresa);
			while (rsPreferencias.next()) {
				BigDecimal curIdPreferencia = rsPreferencias.getBigDecimal(1);

				log.debug(" * ER-preferencia: " + curIdPreferencia);
				ResultSet rsEntregas = getEntregasRegulares(curIdPreferencia,
						anio, mes, idempresa);

				BigDecimal curIdCliente = new BigDecimal(-1);
				BigDecimal idcliente = new BigDecimal(-1);
				// 20100211 EJV Mantis 383
				BigDecimal idtipoiva = new BigDecimal(-1);

				// for (int z = 0; z < 5; z++)
				// log.info("-@-");
				// listOpenFiles();
				// for (int z = 0; z < 5; z++)
				// log.info("-@-");

				long pid = pid();

				while (rsEntregas.next()) {

					idcliente = rsEntregas.getBigDecimal("idcliente");

					if (idcliente.longValue() != curIdCliente.longValue()) {

						if (curIdCliente.longValue() > 0) {

							/*----*/
							List listCliente = getClientesClientesPK(
									curIdCliente, idempresa);

							if (listCliente != null && !listCliente.isEmpty()) {

								String[] datos = (String[]) listCliente.get(0);

								BigDecimal idsucursal = new BigDecimal(-1); // *

								// --

								BigDecimal idcondicion = new BigDecimal(
										datos[8]);
								BigDecimal idvendedor = new BigDecimal(
										datos[27]);
								BigDecimal idlista = new BigDecimal(datos[16]);
								BigDecimal idmoneda = new BigDecimal(datos[14]);
								// --------------------------------->
								// 20100211 EJV Mantis 383
								// BigDecimal idtipoiva = new
								// BigDecimal(datos[6]);
								// <---------------------------------
								//
								BigDecimal porcentajeTipoIva = new BigDecimal(
										htPorcentajeIva.get(
												idtipoiva.toString())
												.toString());

								List listDomiDef = getClientesDomiciliosClienteDefault(
										curIdCliente, idempresa);

								if (listDomiDef != null
										&& !listDomiDef.isEmpty()) {

									String[] datosDom = (String[]) listDomiDef
											.get(0);

									BigDecimal idsucuclie = new BigDecimal(
											datosDom[0]);// *
									BigDecimal idexpreso = new BigDecimal(
											datosDom[21] != null ? datosDom[21]
													: "-1");
									String obsentrega = datosDom[40];
									BigDecimal idzona = new BigDecimal(
											datosDom[19] != null ? datosDom[19]
													: "-1");
									// 20100804 - EJV - Reasignacion -->
									BigDecimal idanexolocalidad = new BigDecimal(
											datosDom[39] != null ? datosDom[39]
													: "-1");
									// <--

									BigDecimal idtarjeta = new BigDecimal(-1);// *

									// Valores forzados.-->
									BigDecimal comision = new BigDecimal(0);// *
									BigDecimal ordencompra = new BigDecimal(0);// *
									String obsarmado = "";// *
									BigDecimal recargo1 = new BigDecimal(0);// *
									BigDecimal recargo2 = new BigDecimal(0);// *
									BigDecimal recargo3 = new BigDecimal(0);// *
									BigDecimal recargo4 = new BigDecimal(0);// *
									BigDecimal bonific1 = new BigDecimal(0);// *
									BigDecimal bonific2 = new BigDecimal(0);// *
									BigDecimal bonific3 = new BigDecimal(0);// *
									BigDecimal cotizacion = new BigDecimal(0);// *
									BigDecimal totaliva = new BigDecimal(-1);// *
									BigDecimal idprioridad = new BigDecimal(1);// *
									BigDecimal cuotas = new BigDecimal(1);// *
									// Valores forzados.<--

									// EJV - 20090925
									// totaliva = new BigDecimal(
									// GeneralBean
									// .getNumeroFormateado(
									// Float
									// .parseFloat((grandTotal
									// .doubleValue()
									// * (1 + porcentajeTipoIva
									// .doubleValue() / 100) + "")),
									// 10, 2));

									totaliva = new BigDecimal(grandTotal
											.doubleValue()
											+ grandTotalIva.doubleValue());
									// < ---

									// 20110802 - EJV - Mantis 759 -->
									// idtarjeta = new BigDecimal(-1);// *
									if (idcondicion.intValue() == 5) {
										idtarjeta = getTarjetaClienteERyPO(
												curIdCliente, hoy, anio, mes,
												true, "ER", idempresa,
												usuarioalt);
										if (cuotas.intValue() == 0) {
											cuotas = new BigDecimal(1);
										}

									}

									// // Condicion asociada a tarjetas de
									// credito.
									// if (idcondicion.longValue() == 5) {
									//
									// /*
									// *
									// t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito
									// * ,t.idcliente,t.idtipotarjeta,tt.
									// * tipotarjeta, t
									// * .nrotarjeta,t.nrocontrol
									// * ,t.fecha_emision::DATE ,
									// * t.fecha_vencimiento
									// * ::DATE,t.titular,t.orden,t .activa,
									// * t.idempresa,t.usuarioalt,t.usuarioact
									// * ,t.fechaalt,t.fechaact
									// */
									//
									// List listaTarjetasCredito =
									// getClienteTarjetasCliente(
									// 100, 0, curIdCliente, idempresa);
									//
									// if (listaTarjetasCredito != null
									// && !listaTarjetasCredito
									// .isEmpty()) {
									//
									// Iterator iter = listaTarjetasCredito
									// .iterator();
									//
									// // java.sql.Date hoy = new
									// // java.sql.Date(
									// // Calendar.getInstance()
									// // .getTimeInMillis());
									//
									// while (iter.hasNext()) {
									//
									// String datosTarjeta[] = (String[]) iter
									// .next();
									//
									// // || (datosTarjeta[12])-
									// // 20110126 - EJV - Mantis 667
									// if (datosTarjeta[12] == null
									// || !(datosTarjeta[12])
									// .equalsIgnoreCase("S")) {
									//
									// status =
									// "ER: condicion de pago Tarjeta: tarjeta inactiva para cliente:"
									// + curIdCliente;
									// // 20110126 - EJV Mantis 667
									// //
									// (java.sql.Date.valueOf(datosTarjeta[9]).after(hoy))
									// } else if (java.sql.Date
									// .valueOf(
									// datosTarjeta[9])
									// .before(hoy)) {
									// status =
									// "ER: condicion de pago Tarjeta: tarjeta vencida para cliente:"
									// + curIdCliente;
									// } else {
									//
									// idtarjeta = new BigDecimal(
									// datosTarjeta[0]);
									// status = "";
									//
									// break;
									// }
									//
									// // 20110126 - EJV Mantis 667 -->
									// if (!status
									// .equalsIgnoreCase(""))
									// pedidosEntregaRegularLogCreate(
									// curIdCliente,
									// new BigDecimal(anio),
									// new BigDecimal(mes),
									// status, idempresa,
									// usuarioalt);
									// // <--
									// status = "";
									// // --> 20110405 - EJV Mantis 700
									// // Si no hay tarjetas que
									// // cumplan las condiciones de
									// // validez, se asigna como
									// // default la de orden uno (1) o
									// // en su defecto alguna
									// // existente.
									// // 20110630 - EJV -- > Siempre
									// // asignar alguna.
									// if (datosTarjeta[12]
									// .equalsIgnoreCase("S"))
									// // <--
									// idtarjeta = new BigDecimal(
									// datosTarjeta[0]);
									// else if (idtarjeta.longValue() < 1
									// || datosTarjeta[11]
									// .equalsIgnoreCase("1"))
									// // <--
									// idtarjeta = new BigDecimal(
									// datosTarjeta[0]);
									// else if (idtarjeta.longValue() < 1)
									// // <--
									// idtarjeta = new BigDecimal(
									// datosTarjeta[0]);
									// // <--
									// }
									//
									// } else {
									//
									// status =
									// "ER: condicion de pago Tarjeta: no hay tarjeta asociada para cliente:"
									// + curIdCliente;
									//
									// log.warn(status);
									//
									// }
									//
									// if (cuotas.intValue() == 0) {
									// cuotas = new BigDecimal(1);
									// }
									//
									// }
									// <--

									// aca poner pedidosCreate

									BigDecimal idcampacabe = null;

									log
											.info("(Interno)LLAMADA A PC CLIENTE --> "
													+ curIdCliente);
									if (status.equalsIgnoreCase("")) {

										// 20110124 - EJV - Mantis 597 -->
										BigDecimal idpromocion = null;
										// <--

										String[] resultado = pedidosNormalesCreate(
												idcampacabe, idestado,
												curIdCliente, idsucursal,
												idsucuclie, fechapedido,
												idcondicion, idvendedor,
												idexpreso, comision,
												ordencompra, obsarmado,
												obsentrega, recargo1, recargo2,
												recargo3, recargo4, bonific1,
												bonific2, bonific3, idlista,
												idmoneda, cotizacion,
												idtipoiva, totaliva,
												idprioridad, idzona, idtarjeta,
												cuotas, origenpedido,
												new BigDecimal(grandTotal
														.doubleValue()),
												tipopedido, htArticulos,
												new BigDecimal(-10),
												idanexolocalidad, idpromocion,
												null, new java.sql.Date(
														fechapedido.getTime()),
												usuarioalt, idempresa,
												properties);

										try {
											new BigDecimal(resultado[0]);
										} catch (Exception e) {
											status = resultado[0];
										}

									} else {
										log
												.warn("Proceso de ER no genera pedido para cliente: "
														+ curIdCliente);
										log.warn(status);
									}

								} else {
									status = "ER: no se pudo recuperar datos para domicilio default cliente: "
											+ curIdCliente;
									log.warn(status);
								}

							} else {
								status = "ER: no puede recuparar datos para el cliente: "
										+ curIdCliente;
								log.warn(status);
							}

							/*----*/

							if (!status.equalsIgnoreCase(""))
								pedidosEntregaRegularLogCreate(curIdCliente,
										new BigDecimal(anio), new BigDecimal(
												mes), status, idempresa,
										usuarioalt);

						}

						curIdCliente = idcliente;
						grandTotal = new Double(0.00);
						grandTotalIva = new Double(0.00);
						htArticulos = new Hashtable();

					}

					status = "";
					// para el total decabecera del pedido.

					idestado = rsEntregas.getBigDecimal("idestado");
					// BigDecimal idmotivo =
					// rsEntregas.getBigDecimal("idmotivo");
					// BigDecimal idpreferencia = rsEntregas
					// .getBigDecimal("idpreferencia");
					String codigo_st = rsEntregas.getString("codigo_st");
					BigDecimal cantidad = rsEntregas.getBigDecimal("cantidad");
					BigDecimal codigo_dt = rsEntregas
							.getBigDecimal("codigo_dt");
					Double precio = new Double(rsEntregas.getDouble("precio"));
					BigDecimal iddescuento = rsEntregas
							.getBigDecimal("iddescuento");
					BigDecimal porc_descuento = rsEntregas
							.getBigDecimal("porc_descuento");
					Double total = new Double(rsEntregas.getDouble("total"));

					String unimed_st = rsEntregas.getString("unimed_st");
					String idmotivodescuento = rsEntregas
							.getString("idmotivodescuento");
					log.debug("============================= ");
					log.debug("- cliente : " + idcliente);

					/*
					 * EJV - 20090925
					 */

					// BigDecimal tipoiva_st = GeneralBean.setNull(
					// new BigDecimal(datosArticulo[24]), 0);
					// BigDecimal porciva_st = new BigDecimal(
					// datosArticulo[26]);
					// BigDecimal totaliva_st = new BigDecimal(
					// datosArticulo[27]);
					// BigDecimal cantidad_sb = new BigDecimal(
					// datosArticulo[28]);
					// BigDecimal compromiso_sb = new BigDecimal(
					// datosArticulo[29]);
					// String inventa_st = datosArticulo[30];
					BigDecimal tipoiva_st = rsEntregas
							.getBigDecimal("tipoiva_st");
					BigDecimal porciva_st = rsEntregas
							.getBigDecimal("porciva_st");
					BigDecimal totaliva_st = rsEntregas
							.getBigDecimal("totaliva_st");
					BigDecimal cantidad_sb = rsEntregas
							.getBigDecimal("canti_sb");
					BigDecimal compromiso_sb = rsEntregas
							.getBigDecimal("pedid_sb");
					String inventa_st = rsEntregas.getString("tipoiva_st");
					String tipograv_exen = rsEntregas
							.getString("tipograv_exen");
					// --------------------------------->
					// 20100211 EJV Mantis 383
					idtipoiva = rsEntregas.getBigDecimal("idtipoiva");
					// <---------------------------------
					/**/

					String[] datosArticulo = new String[33];
					datosArticulo[0] = codigo_st;
					datosArticulo[10] = cantidad.toString();
					datosArticulo[9] = codigo_dt.toString();
					datosArticulo[4] = porc_descuento.toString();
					datosArticulo[5] = precio.toString();
					datosArticulo[11] = total.toString();
					datosArticulo[17] = iddescuento.toString();
					datosArticulo[18] = iddescuento.toString();
					datosArticulo[19] = porc_descuento.toString();
					datosArticulo[20] = porc_descuento.toString();
					datosArticulo[13] = unimed_st;
					// <<ejv
					// TODO: Motivo descuento.
					datosArticulo[21] = idmotivodescuento;
					// EJV 20090925
					datosArticulo[24] = tipoiva_st.toString();
					datosArticulo[26] = porciva_st.toString();
					datosArticulo[27] = totaliva_st.toString();
					datosArticulo[28] = cantidad_sb.toString();
					datosArticulo[29] = compromiso_sb.toString();
					datosArticulo[30] = inventa_st;

					grandTotal = new Double(grandTotal.doubleValue()
							+ total.doubleValue());
					grandTotalIva = new Double(grandTotalIva.doubleValue()
							+ totaliva_st.doubleValue());

					// log.warn("A - codigo_st: " + codigo_st);
					// for (int m = 0; m < datosArticulo.length; m++)
					// log.info("datosArticulo [" + m + "]:"
					// + datosArticulo[m]);
					htArticulos.put(codigo_st, datosArticulo);

					if (contador % 10 == 0) {
						log.info("# -- >       PID: " + pid);
					}

				}

				// /////////////////////////////////////////////////////////////
				/* ENCAPSULAR --> */

				/*----*/

				if (idcliente != null && idcliente.longValue() > -1) {

					List listCliente = getClientesClientesPK(idcliente,
							idempresa);

					if (listCliente != null && !listCliente.isEmpty()) {

						String[] datos = (String[]) listCliente.get(0);

						BigDecimal idsucursal = new BigDecimal(-1); // *

						// --

						BigDecimal idcondicion = new BigDecimal(datos[8]);
						BigDecimal idvendedor = new BigDecimal(datos[27]);
						BigDecimal idlista = new BigDecimal(datos[16]);
						BigDecimal idmoneda = new BigDecimal(datos[14]);
						// --------------------------------->
						// 20100211 EJV Mantis 383
						// BigDecimal idtipoiva = new BigDecimal(datos[6]);
						// <---------------------------------
						//
						BigDecimal porcentajeTipoIva = new BigDecimal(
								htPorcentajeIva.get(idtipoiva.toString())
										.toString());

						List listDomiDef = getClientesDomiciliosClienteDefault(
								idcliente, idempresa);

						if (listDomiDef != null && !listDomiDef.isEmpty()) {

							String[] datosDom = (String[]) listDomiDef.get(0);

							BigDecimal idsucuclie = new BigDecimal(datosDom[0]);// *
							BigDecimal idexpreso = new BigDecimal(
									datosDom[21] != null ? datosDom[21] : "-1");
							String obsentrega = datosDom[40];
							BigDecimal idzona = new BigDecimal(
									datosDom[19] != null ? datosDom[19] : "-1");

							// 20100804 - EJV - Reasignacion -->
							BigDecimal idanexolocalidad = new BigDecimal(
									datosDom[39] != null ? datosDom[39] : "-1");
							// <--

							BigDecimal idtarjeta = new BigDecimal(-1);// *

							// Valores forzados.-->
							BigDecimal comision = new BigDecimal(0);// *
							BigDecimal ordencompra = new BigDecimal(0);// *
							String obsarmado = "";// *
							BigDecimal recargo1 = new BigDecimal(0);// *
							BigDecimal recargo2 = new BigDecimal(0);// *
							BigDecimal recargo3 = new BigDecimal(0);// *
							BigDecimal recargo4 = new BigDecimal(0);// *
							BigDecimal bonific1 = new BigDecimal(0);// *
							BigDecimal bonific2 = new BigDecimal(0);// *
							BigDecimal bonific3 = new BigDecimal(0);// *
							BigDecimal cotizacion = new BigDecimal(0);// *
							BigDecimal totaliva = new BigDecimal(-1);// *
							BigDecimal idprioridad = new BigDecimal(1);// *
							BigDecimal cuotas = new BigDecimal(1);// *
							// Valores forzados.<--

							// EJV - 20090925
							// totaliva = new BigDecimal(
							// GeneralBean
							// .getNumeroFormateado(
							// Float
							// .parseFloat((grandTotal
							// .doubleValue()
							// * (1 + porcentajeTipoIva
							// .doubleValue() / 100) + "")),
							// 10, 2));

							totaliva = new BigDecimal(grandTotal.doubleValue()
									+ grandTotalIva.doubleValue());
							// < ---

							// Condicion asociada a tarjetas de credito.
							// 20110802 - EJV - Mantis 759 -->
							if (idcondicion.intValue() == 5) {
								idtarjeta = getTarjetaClienteERyPO(idcliente,
										hoy, anio, mes, true, "ER", idempresa,
										usuarioalt);

								if (cuotas.intValue() == 0) {
									cuotas = new BigDecimal(1);
								}
							}

							// if (idcondicion.longValue() == 5) {
							//
							// /*
							// *
							// t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito
							// * ,t.idcliente,t.idtipotarjeta,tt.tipotarjeta,
							// * t
							// * .nrotarjeta,t.nrocontrol,t.fecha_emision::DATE
							// * ,
							// * t.fecha_vencimiento::DATE,t.titular,t.orden,t
							// * .activa,
							// * t.idempresa,t.usuarioalt,t.usuarioact
							// * ,t.fechaalt,t.fechaact
							// */
							//
							// List listaTarjetasCredito =
							// getClienteTarjetasCliente(
							// 100, 0, idcliente, idempresa);
							//
							// if (listaTarjetasCredito != null
							// && !listaTarjetasCredito.isEmpty()) {
							//
							// Iterator iter = listaTarjetasCredito
							// .iterator();
							//
							// // java.sql.Date hoy = new java.sql.Date(
							// // Calendar.getInstance()
							// // .getTimeInMillis());
							//
							// while (iter.hasNext()) {
							//
							// String datosTarjeta[] = (String[]) iter
							// .next();
							// // || (datosTarjeta[12]) 20110126 - EJV
							// // Mantis 667
							// if (datosTarjeta[12] == null
							// || !(datosTarjeta[12])
							// .equalsIgnoreCase("S")) {
							// status =
							// "ER(Last): condicion de pago Tarjeta: tarjeta inactiva para cliente:"
							// + idcliente;
							// // 20110126 - EJV Mantis 667
							// //
							// (java.sql.Date.valueOf(datosTarjeta[9]).after(hoy))
							// } else if (java.sql.Date.valueOf(
							// datosTarjeta[9]).before(hoy)) {
							// status =
							// "ER(Last): condicion de pago Tarjeta: tarjeta vencida para cliente:"
							// + idcliente;
							// } else {
							//
							// idtarjeta = new BigDecimal(
							// datosTarjeta[0]);
							// status = "";
							//
							// break;
							// }
							//
							// // 20110126 - EJV Mantis 667 -->
							// if (!status.equalsIgnoreCase(""))
							// pedidosEntregaRegularLogCreate(
							// idcliente, new BigDecimal(
							// anio),
							// new BigDecimal(mes),
							// status, idempresa,
							// usuarioalt);
							// // <--
							// status = "";
							// // <--
							// status = "";
							// // --> 20110405 - EJV Mantis 700
							// // Si no hay tarjetas que
							// // cumplan las condiciones de
							// // validez, se asigna como
							// // default la de orden uno (1) o en su
							// // defecto alguna existente.
							// // 20110630 - EJV -- > Siempre
							// // asignar alguna.
							// if (datosTarjeta[12]
							// .equalsIgnoreCase("S"))
							// // <--
							// idtarjeta = new BigDecimal(
							// datosTarjeta[0]);
							// else if (idtarjeta.longValue() < 1
							// || datosTarjeta[11]
							// .equalsIgnoreCase("1"))
							// // <--
							// idtarjeta = new BigDecimal(
							// datosTarjeta[0]);
							// else if (idtarjeta.longValue() < 1)
							// // <--
							// idtarjeta = new BigDecimal(
							// datosTarjeta[0]);
							// // <--
							//
							// }
							//
							// } else {
							//
							// status =
							// "ER(Last): condicion de pago Tarjeta: no hay tarjeta asociada para cliente:"
							// + idcliente;
							//
							// log.warn(status);
							//
							// }
							//
							// if (cuotas.intValue() == 0) {
							// cuotas = new BigDecimal(1);
							// }
							//
							// }
							// <--

							// aca poner pedidosCreate

							BigDecimal idcampacabe = null;
							// 20110124 - EJV - Mantis 597 -->
							BigDecimal idpromocion = null;
							// <--

							log.info("(LAST)LLAMADA A PC CLIENTE --> "
									+ idcliente);
							if (status.equalsIgnoreCase("")) {
								String[] resultado = pedidosNormalesCreate(
										idcampacabe,
										idestado,
										idcliente,
										idsucursal,
										idsucuclie,
										fechapedido,
										idcondicion,
										idvendedor,
										idexpreso,
										comision,
										ordencompra,
										obsarmado,
										obsentrega,
										recargo1,
										recargo2,
										recargo3,
										recargo4,
										bonific1,
										bonific2,
										bonific3,
										idlista,
										idmoneda,
										cotizacion,
										idtipoiva,
										totaliva,
										idprioridad,
										idzona,
										idtarjeta,
										cuotas,
										origenpedido,
										new BigDecimal(grandTotal.doubleValue()),
										tipopedido,
										htArticulos,
										new BigDecimal(-10),
										idanexolocalidad,
										idpromocion,
										null,
										new java.sql.Date(fechapedido.getTime()),
										usuarioalt, idempresa, props);

								try {
									new BigDecimal(resultado[0]);
								} catch (Exception e) {
									status = resultado[0];
								}

							} else {
								log
										.warn("(Last)Proceso de ER no genera pedido para cliente: "
												+ idcliente);
								log.warn(status);
							}

						} else {
							status = "ER(Last): no se pudo recuperar datos para domicilio default cliente: "
									+ idcliente;
							log.warn(status);
						}

					} else {
						status = "ER(Last): no puede recuparar datos para el cliente: "
								+ idcliente;
						log.warn(status);
					}

					/*----*/

					if (!status.equalsIgnoreCase(""))
						pedidosEntregaRegularLogCreate(idcliente,
								new BigDecimal(anio), new BigDecimal(mes),
								status, idempresa, usuarioalt);

				} else
					log.warn("NO EXISTE DATA PARA PREFERENCIA: "
							+ curIdPreferencia);

				// /////////////////////////////////////////////////////////////

				/* ENCAPSULAR <-- */

				rsEntregas.close();

			}

			rsPreferencias.close();

		} catch (Exception ex) {
			salida = "EX: Se produjo un excepcion al generar entregas regulares";
			log.error("setEntregasRegulares: Salida por exception: " + ex);
		}
		return salida;
	}

	//	
	// public String setEntregasRegulares_BKP(int anio, int mes,
	// BigDecimal idempresa, String usuarioalt) throws EJBException { // throws
	// // EJBException
	// String salida = "OK";
	//
	// // boolean hasEsquemas = false;
	// Calendar cal = new GregorianCalendar();
	// cal.set(anio, mes - 1, 10, 0, 0, 0);
	// String origenpedido = "ER";
	// String tipopedido = "N";
	// Timestamp fechapedido = new Timestamp(cal.getTimeInMillis());
	//
	// Hashtable htPorcentajeIva = new Hashtable();
	// Iterator iterator;
	// String status = "";
	//
	// try {
	//
	// iterator = getClientestablaivaAll(100, 0, idempresa).iterator();
	// while (iterator.hasNext()) {
	// String[] iva = (String[]) iterator.next();
	// htPorcentajeIva.put(iva[0], iva[2]);
	// }
	//
	// ResultSet rsPreferencias = getPreferencias4ER(anio, mes, idempresa);
	// while (rsPreferencias.next()) {
	// BigDecimal curIdPreferencia = rsPreferencias.getBigDecimal(1);
	//
	// log.debug(" * ER-preferencia: " + curIdPreferencia);
	// ResultSet rsEntregas = getEntregasRegulares(curIdPreferencia,
	// anio, mes, idempresa);
	//
	// // BigDecimal curIdCliente = new BigDecimal(-1);
	// while (rsEntregas.next()) {
	// BigDecimal idcliente = rsEntregas
	// .getBigDecimal("idcliente");
	//
	// status = "";
	// // para el total decabecera del pedido.
	// Double grandTotal = new Double(0.00);
	// Double grantTotalIva = new Double(0.00);
	//
	// BigDecimal idestado = rsEntregas.getBigDecimal("idestado");
	// BigDecimal idmotivo = rsEntregas.getBigDecimal("idmotivo");
	// BigDecimal idpreferencia = rsEntregas
	// .getBigDecimal("idpreferencia");
	// String codigo_st = rsEntregas.getString("codigo_st");
	// BigDecimal cantidad = rsEntregas.getBigDecimal("cantidad");
	// BigDecimal codigo_dt = rsEntregas
	// .getBigDecimal("codigo_dt");
	// Double precio = new Double(rsEntregas.getDouble("precio"));
	// BigDecimal iddescuento = rsEntregas
	// .getBigDecimal("iddescuento");
	// BigDecimal porc_descuento = rsEntregas
	// .getBigDecimal("porc_descuento");
	// Double total = new Double(rsEntregas.getDouble("total"));
	//
	// String unimed_st = rsEntregas.getString("unimed_st");
	// String idmotivodescuento = rsEntregas
	// .getString("idmotivodescuento");
	// log.debug("============================= ");
	// log.debug("- cliente : " + idcliente);
	//
	// /*
	// * EJV - 20090925
	// */
	//
	// // BigDecimal tipoiva_st = GeneralBean.setNull(
	// // new BigDecimal(datosArticulo[24]), 0);
	// // BigDecimal porciva_st = new BigDecimal(
	// // datosArticulo[26]);
	// // BigDecimal totaliva_st = new BigDecimal(
	// // datosArticulo[27]);
	// // BigDecimal cantidad_sb = new BigDecimal(
	// // datosArticulo[28]);
	// // BigDecimal compromiso_sb = new BigDecimal(
	// // datosArticulo[29]);
	// // String inventa_st = datosArticulo[30];
	// BigDecimal tipoiva_st = rsEntregas
	// .getBigDecimal("tipoiva_st");
	// BigDecimal porciva_st = rsEntregas
	// .getBigDecimal("porciva_st");
	// BigDecimal totaliva_st = rsEntregas
	// .getBigDecimal("totaliva_st");
	// BigDecimal cantidad_sb = rsEntregas
	// .getBigDecimal("canti_sb");
	// BigDecimal compromiso_sb = rsEntregas
	// .getBigDecimal("pedid_sb");
	// String inventa_st = rsEntregas.getString("tipoiva_st");
	// String tipograv_exen = rsEntregas
	// .getString("tipograv_exen");
	// /**/
	//
	// Hashtable htArticulos = new Hashtable();
	//
	// String[] datosArticulo = new String[33];
	// BigDecimal curIdCliente = idcliente;
	// datosArticulo[0] = codigo_st;
	// datosArticulo[10] = cantidad.toString();
	// datosArticulo[9] = codigo_dt.toString();
	// datosArticulo[4] = porc_descuento.toString();
	// datosArticulo[5] = precio.toString();
	// datosArticulo[11] = total.toString();
	// datosArticulo[17] = iddescuento.toString();
	// datosArticulo[18] = iddescuento.toString();
	// datosArticulo[19] = porc_descuento.toString();
	// datosArticulo[20] = porc_descuento.toString();
	// datosArticulo[13] = unimed_st;
	// // <<ejv
	// // TODO: Motivo descuento.
	// datosArticulo[21] = idmotivodescuento;
	// // EJV 20090925
	// datosArticulo[24] = tipoiva_st.toString();
	// datosArticulo[26] = porciva_st.toString();
	// datosArticulo[27] = totaliva_st.toString();
	// datosArticulo[28] = cantidad_sb.toString();
	// datosArticulo[29] = compromiso_sb.toString();
	// datosArticulo[30] = inventa_st;
	//
	// grandTotal = new Double(grandTotal.doubleValue()
	// + total.doubleValue());
	// grantTotalIva = new Double(grantTotalIva.doubleValue()
	// + totaliva_st.doubleValue());
	//
	// // log.warn("A - codigo_st: " + codigo_st);
	// // for (int m = 0; m < datosArticulo.length; m++)
	// // log.info("datosArticulo [" + m + "]:"
	// // + datosArticulo[m]);
	// htArticulos.put(codigo_st, datosArticulo);
	//
	// while (curIdCliente.compareTo(idcliente) == 0
	// && rsEntregas.next()) {
	//
	// datosArticulo = new String[33];
	//
	// idcliente = rsEntregas.getBigDecimal("idcliente");
	// // curIdCliente = idcliente;
	// idestado = rsEntregas.getBigDecimal("idestado");
	// idmotivo = rsEntregas.getBigDecimal("idmotivo");
	// idpreferencia = rsEntregas
	// .getBigDecimal("idpreferencia");
	// codigo_st = rsEntregas.getString("codigo_st");
	// cantidad = rsEntregas.getBigDecimal("cantidad");
	// codigo_dt = rsEntregas.getBigDecimal("codigo_dt");
	// precio = new Double(rsEntregas.getDouble("precio"));
	// porc_descuento = rsEntregas
	// .getBigDecimal("porc_descuento");
	// total = new Double(rsEntregas.getDouble("total"));
	// unimed_st = rsEntregas.getString("unimed_st");
	// idmotivodescuento = rsEntregas
	// .getString("idmotivodescuento");
	//
	// // EJV - 20090925
	// tipoiva_st = rsEntregas.getBigDecimal("tipoiva_st");
	// porciva_st = rsEntregas.getBigDecimal("porciva_st");
	// totaliva_st = rsEntregas.getBigDecimal("totaliva_st");
	// cantidad_sb = rsEntregas.getBigDecimal("canti_sb");
	// compromiso_sb = rsEntregas.getBigDecimal("pedid_sb");
	// inventa_st = rsEntregas.getString("tipoiva_st");
	// tipograv_exen = rsEntregas.getString("tipograv_exen");
	// //
	//
	// // ----------------
	// datosArticulo[0] = codigo_st;
	// datosArticulo[10] = cantidad.toString();
	// datosArticulo[9] = codigo_dt.toString();
	// datosArticulo[4] = porc_descuento.toString();
	// datosArticulo[5] = precio.toString();
	// datosArticulo[11] = total.toString();
	// datosArticulo[17] = iddescuento.toString();
	// datosArticulo[18] = iddescuento.toString();
	// datosArticulo[19] = porc_descuento.toString();
	// datosArticulo[20] = porc_descuento.toString();
	// datosArticulo[13] = unimed_st;
	// datosArticulo[21] = idmotivodescuento;
	//
	// // EJV 20090925
	// datosArticulo[24] = tipoiva_st.toString();
	// datosArticulo[26] = porciva_st.toString();
	// datosArticulo[27] = totaliva_st.toString();
	// datosArticulo[28] = cantidad_sb.toString();
	// datosArticulo[29] = compromiso_sb.toString();
	// datosArticulo[30] = inventa_st;
	// //
	//
	// // log.warn("B - codigo_st: " + codigo_st);
	// // for (int m = 0; m < datosArticulo.length; m++)
	// // log.info("datosArticulo [" + m + "]:"
	// // + datosArticulo[m]);
	// htArticulos.put(codigo_st, datosArticulo);
	// grandTotal = new Double(grandTotal.doubleValue()
	// + total.doubleValue());
	// grantTotalIva = new Double(grantTotalIva.doubleValue()
	// + totaliva_st.doubleValue());
	//
	// rsEntregas.next();
	// }
	//
	// /*----*/
	// List listCliente = getClientesClientesPK(idcliente,
	// idempresa);
	//
	// if (listCliente != null && !listCliente.isEmpty()) {
	//
	// String[] datos = (String[]) listCliente.get(0);
	//
	// BigDecimal idsucursal = new BigDecimal(-1); // *
	//
	// // --
	//
	// BigDecimal idcondicion = new BigDecimal(datos[8]);
	// BigDecimal idvendedor = new BigDecimal(datos[27]);
	// BigDecimal idlista = new BigDecimal(datos[16]);
	// BigDecimal idmoneda = new BigDecimal(datos[14]);
	// BigDecimal idtipoiva = new BigDecimal(datos[6]);
	// //
	// BigDecimal porcentajeTipoIva = new BigDecimal(
	// htPorcentajeIva.get(idtipoiva.toString())
	// .toString());
	//
	// List listDomiDef = getClientesDomiciliosClienteDefault(
	// idcliente, idempresa);
	//
	// if (listDomiDef != null && !listDomiDef.isEmpty()) {
	//
	// String[] datosDom = (String[]) listDomiDef.get(0);
	//
	// BigDecimal idsucuclie = new BigDecimal(datosDom[0]);// *
	// BigDecimal idexpreso = new BigDecimal(
	// datosDom[21] != null ? datosDom[21] : "-1");
	// String obsentrega = datosDom[40];
	// BigDecimal idzona = new BigDecimal(
	// datosDom[19] != null ? datosDom[19] : "-1");
	//
	// BigDecimal idtarjeta = new BigDecimal(-1);// *
	//
	// // Valores forzados.-->
	// BigDecimal comision = new BigDecimal(0);// *
	// BigDecimal ordencompra = new BigDecimal(0);// *
	// String obsarmado = "";// *
	// BigDecimal recargo1 = new BigDecimal(0);// *
	// BigDecimal recargo2 = new BigDecimal(0);// *
	// BigDecimal recargo3 = new BigDecimal(0);// *
	// BigDecimal recargo4 = new BigDecimal(0);// *
	// BigDecimal bonific1 = new BigDecimal(0);// *
	// BigDecimal bonific2 = new BigDecimal(0);// *
	// BigDecimal bonific3 = new BigDecimal(0);// *
	// BigDecimal cotizacion = new BigDecimal(0);// *
	// BigDecimal totaliva = new BigDecimal(-1);// *
	// BigDecimal idprioridad = new BigDecimal(1);// *
	// BigDecimal cuotas = new BigDecimal(1);// *
	// // Valores forzados.<--
	//
	// // EJV - 20090925
	// // totaliva = new BigDecimal(
	// // GeneralBean
	// // .getNumeroFormateado(
	// // Float
	// // .parseFloat((grandTotal
	// // .doubleValue()
	// // * (1 + porcentajeTipoIva
	// // .doubleValue() / 100) + "")),
	// // 10, 2));
	//
	// totaliva = new BigDecimal(grandTotal.doubleValue()
	// + grantTotalIva.doubleValue());
	// // < ---
	//
	// // Condicion asociada a tarjetas de credito.
	// if (idcondicion.longValue() == 5) {
	//
	// /*
	// * t.idtarjeta,t.idtarjetacredito,tm.tarjetacredito
	// * ,t.idcliente,t.idtipotarjeta,tt.tipotarjeta,
	// * t
	// * .nrotarjeta,t.nrocontrol,t.fecha_emision::DATE
	// * ,
	// * t.fecha_vencimiento::DATE,t.titular,t.orden,t
	// * .activa,
	// * t.idempresa,t.usuarioalt,t.usuarioact
	// * ,t.fechaalt,t.fechaact
	// */
	//
	// List listaTarjetasCredito = getClienteTarjetasCliente(
	// 100, 0, idcliente, idempresa);
	//
	// if (listaTarjetasCredito != null
	// && !listaTarjetasCredito.isEmpty()) {
	//
	// Iterator iter = listaTarjetasCredito
	// .iterator();
	//
	// java.sql.Date hoy = new java.sql.Date(
	// Calendar.getInstance()
	// .getTimeInMillis());
	//
	// while (iter.hasNext()) {
	//
	// String datosTarjeta[] = (String[]) iter
	// .next();
	//
	// if (datosTarjeta[12] == null
	// || (datosTarjeta[12])
	// .equalsIgnoreCase("S")) {
	//
	// status = "ER: condicion de pago Tarjeta: tarjeta inactiva para cliente:"
	// + idcliente;
	//
	// } else if (java.sql.Date.valueOf(
	// datosTarjeta[9]).after(hoy)) {
	// status = "ER: condicion de pago Tarjeta: tarjeta vencida para cliente:"
	// + idcliente;
	// } else {
	//
	// idtarjeta = new BigDecimal(
	// datosTarjeta[0]);
	// status = "";
	//
	// break;
	// }
	//
	// status = "";
	//
	// }
	//
	// } else {
	//
	// status =
	// "ER: condicion de pago Tarjeta: no hay tarjeta asociada para cliente:"
	// + idcliente;
	//
	// log.warn(status);
	//
	// }
	//
	// if (cuotas.intValue() == 0) {
	// cuotas = new BigDecimal(1);
	// }
	//
	// }
	//
	// // aca poner pedidosCreate
	//
	// BigDecimal idcampacabe = null;
	//
	// if (status.equalsIgnoreCase("")) {
	// String[] resultado = pedidosNormalesCreate(
	// idcampacabe, idestado, idcliente,
	// idsucursal, idsucuclie, fechapedido,
	// idcondicion, idvendedor, idexpreso,
	// comision, ordencompra, obsarmado,
	// obsentrega, recargo1, recargo2,
	// recargo3, recargo4, bonific1, bonific2,
	// bonific3, idlista, idmoneda,
	// cotizacion, idtipoiva, totaliva,
	// idprioridad, idzona, idtarjeta, cuotas,
	// origenpedido, new BigDecimal(grandTotal
	// .doubleValue()), tipopedido,
	// htArticulos, new BigDecimal(-10),
	// usuarioalt, idempresa, null);
	//
	// try {
	// new BigDecimal(resultado[0]);
	// } catch (Exception e) {
	// status = resultado[0];
	// }
	//
	// } else {
	// log
	// .warn("Proceso de ER no genera pedido para cliente: "
	// + idcliente);
	// log.warn(status);
	// }
	//
	// } else {
	// status =
	// "ER: no se pudo recuperar datos para domicilio default cliente: "
	// + idcliente;
	// log.warn(status);
	// }
	//
	// } else {
	// status = "ER: no puede recuparar datos para el cliente: "
	// + idcliente;
	// log.warn(status);
	// }
	//
	// /*----*/
	// if (!status.equalsIgnoreCase(""))
	// pedidosEntregaRegularLogCreate(idcliente,
	// new BigDecimal(anio), new BigDecimal(mes),
	// status, idempresa, usuarioalt);
	//
	// }
	//
	// rsEntregas.close();
	//
	// }
	//
	// rsPreferencias.close();
	//
	// } catch (Exception ex) {
	// salida = "EX: Se produjo un excepcion al generar entregas regulares";
	// log.error("setEntregasRegulares: Salida por exception: " + ex);
	// }
	// return salida;
	// }
	//
	//	

	private java.sql.ResultSet getPreferencias4ER(int anio, int mes,
			BigDecimal idempresa) throws EJBException { // throws EJBException
		/*
		 * Recorrido de preferencias para entregas Regulares.
		 */
		java.sql.ResultSet salida = null;
		String cQuery = "                  "
				+ " SELECT idpreferencia, preferencia"
				+ "   FROM clientespreferencias" + "  WHERE idempresa = "
				+ idempresa.toString() + " ORDER BY 1 ";
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			salida = rsSalida;

		} catch (SQLException sqlException) {
			log.error("getPrerencias4ER : Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getPrerencias4ER: Salida por exception: " + ex);
		}
		return salida;
	}

	private java.sql.ResultSet getEntregasRegulares(BigDecimal idpreferencia,
			int anio, int mes, BigDecimal idempresa) throws EJBException { // throws
		// EJBException
		/*
		 * Devolver un resultset con todo lo necesario para generar entregas
		 * regulares Filtra por preferencia con el objeto de "cortar" rapido si
		 * no estan dadas las condiciones. Por lo que deberia ser instanciado
		 * por otro bucle que recorra todas las preferencias.
		 */
		java.sql.ResultSet salida = null;
		String cQuery = ""
				+ "SELECT es.idcliente, "
				+ "       es.idestado, "
				+ "       es.idmotivo,   "
				+ "       precarga.idpreferencia, "
				+ "       esquema.codigo_st, "
				+ "       esquema.cantidad, "
				+ "       esquema.codigo_dt, "
				+ "       CASE WHEN esquema.iddescuento IS NULL THEN 0 ELSE esquema.iddescuento  END AS iddescuento, "
				+ "       CASE WHEN esquema.idmotivodescuento IS NULL THEN 0 ELSE esquema.idmotivodescuento END AS idmotivodescuento, "
				+ "       lista.precio::numeric(18,2) as precio, "
				+ "       CASE WHEN descu.iddescuento IS NULL THEN 0 ELSE descu.iddescuento END  AS iddescuento,  "
				+ "       CASE WHEN descu.por_desc IS NULL THEN 0 ELSE descu.por_desc END  AS porc_descuento, "
				+ "       ((esquema.cantidad * lista.precio) - ( (CASE WHEN descu.por_desc IS NULL THEN 0 ELSE descu.por_desc END) * (esquema.cantidad * lista.precio) / 100 )  )::numeric(18,2) AS total, "
				+ "       st.unimed_st, "
				+ "       COALESCE(ve.idvendedor, -1) AS idvendedor,"
				+ ""
				/**/
				+ "       COALESCE(si.idstockiva, -1) AS idstockiva, "
				+ "       COALESCE(si.porcentaje,0.00) AS porcentaje, "
				+ "       COALESCE(si.tipoexen_grav, 'G') AS tipograv_exen, "
				// -------------------------------->
				// 20100310 - EJV - Mantis - 383
				+ "       (CASE WHEN COALESCE(si.tipoexen_grav, 'G') = 'G' THEN ti.porcent1 ELSE 0 END)::NUMERIC(18, 2) AS porciva_st_mal_no_usar,  "
				+ "       (CASE WHEN COALESCE(si.tipoexen_grav, 'G') = 'G' THEN CASE WHEN gl.idtipoiva IS NOT NULL THEN il.porcent1 ELSE ti.porcent1 END ELSE 0 END)::NUMERIC(18, 2) AS porciva_st,  "
				// <--------------------------------
				//				
				+ "       st.tipoiva_st, "

				// -------------------------------->
				// 20100310 - EJV - Mantis - 383
				//
				+ "       ( ( ((esquema.cantidad * lista.precio) - ( (CASE WHEN descu.por_desc IS NULL THEN 0 ELSE descu.por_desc END) * (esquema.cantidad * lista.precio) / 100 )  )::numeric(18,2) * (CASE WHEN COALESCE(si.tipoexen_grav, 'G') = 'G' THEN ti.porcent1 ELSE 0 END)::NUMERIC(18, 2) ) / 100)::NUMERIC(18, 2) AS totaliva_st_mal_no_usar, "
				+ "       (  "
				+ "         ( "
				+ "           ((esquema.cantidad * lista.precio) -  "
				+ "            ( (CASE WHEN descu.por_desc IS NULL THEN 0 ELSE (descu.por_desc * (esquema.cantidad * lista.precio)) / 100 END)) "
				+ "           )::numeric(18,2) *  "
				+ "           (CASE WHEN COALESCE(si.tipoexen_grav, 'G') = 'G'  "
				+ "                 THEN CASE WHEN gl.idtipoiva IS NOT NULL THEN il.porcent1 ELSE ti.porcent1 END "
				+ "                 ELSE 0 "
				+ "             END "
				+ "           )::NUMERIC(18, 2) "
				+ "         ) / 100 "
				+ "       )::NUMERIC(18, 2) AS totaliva_st,  "
				// <--------------------------------
				//					
				+ "       COALESCE(sb.canti_sb::NUMERIC(18, 2), 0.00) AS canti_sb, "
				+ "       COALESCE(sb.pedid_sb::NUMERIC(18, 2), 0.00) AS pedid_sb,"
				+ "       st.inventa_st, "
				+ "       COALESCE(fm.codigo_fm, -1) AS codigo_fm, "
				+ "       COALESCE(fm.descrip_fm, '') AS descrip_fm,"
				+ "       st.inventa_st, "
				// -------------------------------->
				// 20100310 - EJV - Mantis - 383
				//

				+ "       CASE WHEN gl.idtipoiva IS NOT NULL THEN gl.idtipoiva ELSE cl.idtipoiva END AS idtipoiva, "
				+ "       CASE WHEN gl.idtipoiva IS NOT NULL THEN il.porcent1 ELSE ti.porcent1 END AS porcentiva, "
				+ "       cl.idtipoiva AS idivacliente, "
				+ "       ti.porcent1 AS porivacliente, "
				+ "       gl.idtipoiva AS idtipoivaloca, "
				+ "       il.porcent1 AS porivaloca			 "
				// <--------------------------------
				+ "  FROM clientesestadoshoy es "
				+ "       INNER JOIN clientesclientes cl ON ( es.idcliente = cl.idcliente AND es.idempresa = cl.idempresa ) "
				// -------------------------------->
				// 20100310 - EJV - Mantis - 383
				+ "       INNER JOIN clientesdomicilios dom ON cl.idcliente = dom.idcliente AND cl.idempresa = dom.idempresa AND dom.esdefault = 'S' "
				+ "       INNER JOIN clientesanexolocalidades ax ON dom.idanexolocalidad = ax.idanexolocalidad AND dom.idempresa = ax.idempresa "
				+ "        LEFT JOIN globallocalidades gl ON ax.idlocalidad = gl.idlocalidad AND ax.idempresa = "
				+ idempresa
				+ "        LEFT JOIN clientestablaiva il ON  gl.idtipoiva = il.idtipoiva AND il.idempresa = "
				+ idempresa
				// <--------------------------------
				//
				+ "       INNER JOIN clientestablaiva ti ON ( cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa ) "
				+ "       INNER JOIN clientesperiodicidadentrega per ON( es.idcliente = per.idcliente AND es.idempresa = per.idempresa AND per.idmes = "
				+ mes
				+ ") "
				+ "       INNER JOIN clientesprecargaclientes  precarga ON( es.idcliente = precarga.idcliente AND es.idempresa = precarga.idempresa ) "
				+ "       INNER JOIN bacoeresquema esquema ON ( precarga.idpreferencia = esquema.idpreferencia AND precarga.idempresa = esquema.idempresa AND esquema.anio = "
				+ anio
				+ "   AND esquema.idmes = "
				+ mes
				+ ") "
				+ "       INNER JOIN clienteslistasdeprecios lista ON ( esquema.idlista = lista.idlista AND esquema.idempresa = lista.idempresa and esquema.codigo_st = lista.codigo_st ) "
				+ "       INNER JOIN stockstock st ON (  st.idempresa = esquema.idempresa and st.codigo_st = esquema.codigo_st ) "
				+ "        LEFT JOIN clientesdescuentos descu ON ( esquema.iddescuento = descu.iddescuento AND esquema.idempresa = descu.idempresa ) "
				+ "        LEFT JOIN clientesvendedor ve ON ( precarga.idvendedorasignado = ve.idvendedor AND precarga.idempresa = ve.idempresa ) "
				/**/
				+ "        LEFT JOIN stockstockbis sb ON esquema.codigo_st = sb.articu_sb AND esquema.codigo_dt = sb.deposi_sb "
				+ "              AND esquema.idempresa = sb.idempresa "

				+ "        LEFT JOIN stockiva si ON st.tipoiva_st = si.idstockiva AND st.idempresa = si.idempresa "
				+ "        LEFT JOIN stockgrupos gr ON st.grupo_st = gr.codigo_gr AND st.idempresa = gr.idempresa "
				+ "        LEFT JOIN stockfamilias fm ON gr.codigo_fm = fm.codigo_fm AND gr.idempresa = fm.idempresa "
				/**/
				+ " WHERE es.idempresa = "
				+ idempresa.toString()
				+ " "
				+ "   AND es.idestado = 1 "
				+ "   AND es.idcliente NOT IN (SELECT idcliente "
				+ "                              FROM clientessuspentregasregulares "
				+ "                             WHERE anio = "
				+ anio
				+ "                               AND mes = "
				+ mes
				+ "                               AND idempresa = "
				+ idempresa.toString()
				// Mantis 524 - EJV -->
				+ "                               AND fbaja IS NULL "
				// <--

				// +
				// " --AND es.idcliente = clientessuspentregasregulares.idcliente"
				// +

				+ "                            ) "
				+ "   AND es.idcliente NOT IN( "
				+ "          SELECT cabe.idcliente  "
				+ "            FROM pedidos_cabe cabe "
				+ "                 INNER JOIN pedidos_deta deta ON( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa)"
				+ "                 INNER JOIN bacoeresquema e ON ( deta.codigo_st = e.codigo_st and deta.idempresa = e.idempresa "
				+ "                         AND date_part('year',  deta.fecha) = e.anio AND date_part('month', deta.fecha) = e.idmes ) "
				+ "          WHERE e.anio = "
				+ anio
				+ "            AND e.idmes = "
				+ mes
				+ "            AND cabe.origenpedido = 'ER' AND e.idpreferencia =  "
				+ idpreferencia
				+ ")  "
				// + "   AND precarga.idtipoclie IN (1,2,6,7,8,9,10,11,18) "
				// 20101119 - EJV - Mantis 610
				// + "   AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18) "
				// + "   AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18, 24) "
				// 20110802 - EJV - Mantis 760 -->
				+ "   AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18, 24, 25, 30) "
				// <--
				+ "   AND precarga.idpreferencia = "
				+ idpreferencia.toString()
				+ "  ORDER BY es.idcliente, esquema.codigo_st";
		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);
			salida = rsSalida;

		} catch (SQLException sqlException) {
			log.error("getEntregasRegulares : Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getEntregasRegulares: Salida por exception: " + ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidosEntregaRegularLog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Apr 07 14:06:19 GYT 2009
	 */

	public List getPedidosEntregaRegularLogAll(long limit, long offset,
			int anio, int idmes, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlog,l.idcliente, cl.razon, l.anio, m.idmes, m.mes,l.error,l.usuarioalt,l.usuarioact,l.fechaalt,l.fechaact "
				+ "  FROM pedidosentregaregularlog l"
				+ "       INNER JOIN clientesclientes cl ON l.idcliente = cl.idcliente AND l.idempresa = cl.idempresa "
				+ "       INNER JOIN globalmeses m ON l.mes =  m.idmes "
				+ " WHERE l.anio = " + anio + " AND m.idmes = " + idmes
				+ "   AND l.idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEntregaRegularLogAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosEntregaRegularLogOcu(long limit, long offset,
			String ocurrencia, int anio, int idmes, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT l.idlog,l.idcliente, cl.razon, l.anio,m.idmes, m.mes,l.error,l.usuarioalt,l.usuarioact,l.fechaalt,l.fechaact "
				+ "  FROM pedidosentregaregularlog l"
				+ "       INNER JOIN clientesclientes cl ON l.idcliente = cl.idcliente AND l.idempresa = cl.idempresa "
				+ "       INNER JOIN globalmeses m ON l.mes =  m.idmes "
				+ " WHERE (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND l.anio = " + anio
				+ "   AND m.idmes = " + idmes + " AND l.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEntregaRegularLogOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// Log de proceso de entregas regulares.

	public String pedidosEntregaRegularLogCreate(BigDecimal idcliente,
			BigDecimal anio, BigDecimal mes, String error,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (mes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: mes ";
		if (error == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: error ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (error.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: error ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO PEDIDOSENTREGAREGULARLOG(idcliente, anio, mes, error, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, anio);
				insert.setBigDecimal(3, mes);
				insert.setString(4, error);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosEntregaRegularLogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosEntregaRegularLogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// Consulta y totales de necesidad para Entregas Regulares.

	public List getERegularesNecesidad(int anio, int idmes, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""

				+ "SELECT er.codigo_dt, er.descrip_dt, er.codigo_st, er.descri2_st, er.necesidad, "
				// EJV - Mantis 518 - 20100429 -->
				// +
				// "        er.generado, sb.canti_sb::NUMERIC(18) AS disponible, sb.pedid_sb AS reserva, er.preferencia, er.idpreferencia "
				+ "        er.generado, COALESCE(sb.canti_sb, 0)::NUMERIC(18) AS disponible, "
				+ "       COALESCE(sb.pedid_sb, 0)::NUMERIC(18) AS reserva, er.preferencia, er.idpreferencia "
				// <--
				+ "  FROM ( "
				+ "	 SELECT SUM(esquema.cantidad) AS necesidad_quitar,  "
				+ "         SUM(CASE WHEN su.idcodigo IS NULL THEN esquema.cantidad  WHEN fbaja IS NULL  THEN 0 ELSE esquema.cantidad END) AS necesidad, "
				+ "         esquema.codigo_st, st.descri2_st, "
				+ "         COALESCE(SUM(ped.cantidad), 0)::NUMERIC(18) AS generado, de.codigo_dt, de.descrip_dt, cp.idpreferencia, cp.preferencia, su.fbaja, es.idempresa "
				+ "	  FROM clientesestadoshoy es "
				+ "	       INNER JOIN clientesclientes cl ON( es.idcliente = cl.idcliente AND es.idempresa = cl.idempresa ) "
				+ "	       INNER JOIN clientesperiodicidadentrega per ON( es.idcliente = per.idcliente AND es.idempresa = per.idempresa AND per.idmes = "
				+ idmes
				+ ") "
				+ "	       INNER JOIN clientesprecargaclientes  precarga ON( es.idcliente = precarga.idcliente AND es.idempresa = precarga.idempresa ) "
				+ "	       INNER JOIN bacoeresquema esquema ON ( precarga.idpreferencia = esquema.idpreferencia AND precarga.idempresa = esquema.idempresa AND esquema.anio = "
				+ anio
				+ "   AND esquema.idmes = "
				+ idmes
				+ ") "
				+ "	       INNER JOIN clienteslistasdeprecios lista ON ( esquema.idlista = lista.idlista AND esquema.idempresa = lista.idempresa and esquema.codigo_st = lista.codigo_st ) "
				+ "	       INNER JOIN stockdepositos de ON ( esquema.codigo_dt = de.codigo_dt AND esquema.idempresa = de.idempresa ) "
				+ "	       INNER JOIN clientespreferencias cp ON (precarga.idpreferencia = cp.idpreferencia AND precarga.idempresa = cp.idempresa) "
				+ "	       INNER JOIN stockstock st ON ( st.idempresa = esquema.idempresa AND st.codigo_st = esquema.codigo_st )"
				// 20100413 - EJV -->
				+ "         LEFT JOIN clientessuspentregasregulares su ON es.idcliente = su.idcliente AND es.idempresa = su.idempresa  AND su.fbaja IS NULL AND su.mes = "
				+ idmes
				+ " AND su.anio = "
				+ anio
				// <--
				+ "		    LEFT JOIN  "
				+ "		     ( "
				+ "		   SELECT cabe.idcliente, deta.codigo_st, COALESCE(deta.cantidad, 0) AS cantidad, cabe.idempresa "
				+ "		      FROM pedidos_cabe cabe "
				+ "			   INNER JOIN pedidos_deta deta ON( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				// Mantis 518 -->
				+ "            INNER JOIN clientesprecargaclientes pr ON cabe.idcliente = pr.idcliente AND cabe.idempresa = pr.idempresa "
				// <--
				+ "			   INNER JOIN bacoeresquema e ON deta.codigo_st = e.codigo_st and deta.idempresa = e.idempresa "
				+ "				      AND date_part('year',  deta.fecha) = e.anio AND date_part('month', deta.fecha) = e.idmes "
				// Mantis 518 -->
				+ "                   AND e.idempresa = pr.idempresa AND e.idpreferencia = pr.idpreferencia  "
				// <--
				+ "		     WHERE e.anio = "
				+ anio
				+ "		       AND e.idmes = "
				+ idmes
				+ "            AND cabe.origenpedido = 'ER' ) ped  ON es.idcliente = ped.idcliente AND es.idempresa = ped.idempresa  AND esquema.codigo_st =  ped.codigo_st  AND esquema.idempresa = ped.idempresa "
				+ "	  WHERE es.idempresa = "
				+ idempresa.toString()
				+ "    AND es.idestado = 1 "
				// 20101119 - EJV - Mantis 610
				// + "	     AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18)  "
				// 20110802 - EJV - Mantis 760 -->
				// + "	     AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18, 24)  "
				+ "   AND cl.idtipoclie IN (1,2,6,7,8,9,10,11,18, 24, 25, 30) "
				// <--
				// + " AND precarga.idpreferencia = 1 "
				+ "	GROUP BY esquema.codigo_st, st.descri2_st, de.codigo_dt, de.descrip_dt, cp.idpreferencia, cp.preferencia, su.fbaja, es.idempresa "
				+ "	) er  "
				// EJV - Mantis 518 - 20100429 -->
				// +
				// "            INNER JOIN stockstockbis sb ON ( er.codigo_dt = sb.deposi_sb  AND er.idempresa = sb.idempresa  AND er.codigo_st = sb.articu_sb AND er.idempresa = sb.idempresa ) "
				+ "             LEFT JOIN stockstockbis sb ON ( er.codigo_dt = sb.deposi_sb  AND er.idempresa = sb.idempresa  AND er.codigo_st = sb.articu_sb AND er.idempresa = sb.idempresa ) "
				// <--
				+ "ORDER BY er.idpreferencia, er.codigo_st ;";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getERegularesNecesidad()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * PROCESO DE ENTREGAS REGULARES. END
	 */

	public String getPivotContar(String tabla, String campoAlias)
			throws EJBException {
		String salida = "";
		try {
			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery("select distinct "
					+ campoAlias + " from " + tabla + " order by 1 ");
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				salida += " ,SUM( CASE "
						+ campoAlias
						+ " WHEN '"
						+ rsSalida.getString(1)
						+ "' THEN 1 END"
						+ " ) AS "
						+ rsSalida.getString(1).replace(' ', '_').toLowerCase()
								.trim();
			}
		} catch (SQLException sqlException) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String getPivotContar(String tabla, String campoAlias, String cWhere)
			throws EJBException {
		String salida = "";
		try {
			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery("select distinct "
					+ campoAlias + " from " + tabla + " where " + cWhere
					+ " order by 1 ");
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				salida += " ,SUM( CASE "
						+ campoAlias
						+ " WHEN '"
						+ rsSalida.getString(1)
						+ "' THEN 1 END"
						+ " ) AS "
						+ rsSalida.getString(1).replace(' ', '_').toLowerCase()
								.trim();
			}
		} catch (SQLException sqlException) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public String getPivotSumar(String tabla, String campoAlias,
			String campoSuma) throws EJBException {
		String salida = "";
		try {
			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery("select distinct "
					+ campoAlias + " from " + tabla + " order by 1 ");
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				salida += " ,SUM( CASE "
						+ campoAlias
						+ " WHEN '"
						+ rsSalida.getString(1)
						+ "' THEN "
						+ campoSuma
						+ " END"
						+ " ) AS P"
						+ rsSalida.getString(1).replace(' ', '_').toLowerCase()
								.trim();
			}
		} catch (SQLException sqlException) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	private String getPivotSumar(String tabla, String campoAlias,
			String campoSuma, String whereC) throws EJBException {
		String salida = "";
		try {
			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery("select distinct "
					+ campoAlias + " from " + tabla + " " + whereC
					+ " order by 1 ");
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				salida += " ,SUM( CASE "
						+ campoAlias
						+ " WHEN '"
						+ rsSalida.getString(1)
						+ "' THEN "
						+ campoSuma
						+ " END"
						+ " ) AS P"
						+ rsSalida.getString(1).replace(' ', '_').toLowerCase()
								.trim();
			}
		} catch (SQLException sqlException) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getPivotContar(String tabla, String campoAlias) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public ResultSet getClientesSociosAsignados(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select sel.usuario as telemarketer "
				+ getPivotContar("vseleccionsocios", "categoriasocio")
				+ ", count(*) as Total_Telmarketer "
				+ " from  vseleccionsocios sel " + " WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString() + " group by sel.usuario ORDER BY 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesSociosAsignados() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignados()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesSociosAsignadosTotales(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select 'TOTAL' as telemarketer "
				+ getPivotContar("vseleccionsocios", "categoriasocio")
				+ ", count(*) as Total_Telmarketer "
				+ " from  vseleccionsocios sel " + " WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString() + " ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesSociosAsignados() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignados()  "
							+ ex);
		}
		return rsSalida;
	}

	// solo para sacar un grafico
	public ResultSet getClientesSociosAsignadosTotalesDS(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		String cQuery = "" + " select categoriasocio, count(*) as total "
				+ " from  vseleccionsocios sel  WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString()
				+ "group by categoriasocio order by 2 desc ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSociosAsignadosTotalesDS() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignadosTotalesDS()  "
							+ ex);
		}
		return rsSalida;
	}

	// solo para sacar un grafico
	public ResultSet getClientesSociosAsignadosTotalesDS1(
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		String cQuery = ""
				+ " select count(*) as total,categoriasocio ,categoriasocio  "
				+ " from  vseleccionsocios sel  WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString()
				+ "group by categoriasocio order by 1 desc ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSociosAsignadosTotalesDS() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignadosTotalesDS()  "
							+ ex);
		}
		return rsSalida;
	}

	// solo para sacar un grafico
	public ResultSet getClientesSociosAsignadosTotalesDS2(
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		String cQuery = ""
				+ " select usuario as Telemarketer, count(*) as Total "
				+ " from  vseleccionsocios sel  WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString() + "group by usuario order by 2 desc ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSociosAsignadosTotalesDS() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignadosTotalesDS()  "
							+ ex);
		}
		return rsSalida;
	}

	// solo para sacar un grafico
	public ResultSet getClientesSociosAsignadosTotalesDS3(
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		String cQuery = "" + " select count(*) as total,usuario ,usuario  "
				+ " from  vseleccionsocios sel  WHERE idempresa= "
				+ idempresa.toString() + " and idcampacabe = "
				+ idcampania.toString() + "group by usuario order by 1 desc ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSociosAsignadosTotalesDS() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignadosTotalesDS()  "
							+ ex);
		}
		return rsSalida;
	}

	// total llamados
	public List getLlamados4Campania4Resultado(String fechaD, String fechaH,
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		List vecSalida = new ArrayList();
		try {
			ResultSet rsTelemarketers = getTelemarketers(idempresa);
			BigDecimal totalGralLlamadas = new BigDecimal(0);
			BigDecimal totalGralClientes = new BigDecimal(0);
			String[] sSalida = new String[4];
			while (rsTelemarketers.next()) {
				sSalida = new String[4];
				sSalida[0] = rsTelemarketers.getString("telemarketer");
				ResultSet rsResultados = getResultadosLlamadas(idempresa);
				BigDecimal totalLlamadas = new BigDecimal(0);
				BigDecimal totalClientes = new BigDecimal(0);
				while (rsResultados.next()) {
					sSalida = new String[4];
					sSalida[0] = rsTelemarketers.getString("telemarketer");
					sSalida[1] = rsResultados.getString("resultado");
					BigDecimal idResultado = rsResultados
							.getBigDecimal("idresultado");
					sSalida[2] = getTotalLlamadas(
							rsTelemarketers.getString("telemarketer"),
							idResultado, fechaD, fechaH, idcampania, idempresa)
							.toString();
					sSalida[3] = getTotalLlamadasClientes(
							rsTelemarketers.getString("telemarketer"),
							idResultado, fechaD, fechaH, idcampania, idempresa)
							.toString();
					totalLlamadas = totalLlamadas
							.add(new BigDecimal(sSalida[2]));
					totalClientes = totalClientes
							.add(new BigDecimal(sSalida[3]));

					vecSalida.add(sSalida);
				}
				totalGralLlamadas = totalGralLlamadas.add(totalLlamadas);
				totalGralClientes = totalGralClientes.add(totalClientes);
				sSalida = new String[4];
				sSalida[0] = "";
				sSalida[1] = "TOTAL";
				sSalida[2] = totalLlamadas.toString();
				sSalida[3] = totalClientes.toString();
				vecSalida.add(sSalida);
				sSalida = new String[4];
				// lo hago saltar un renglon
				sSalida[0] = "";
				sSalida[1] = "";
				sSalida[2] = "";
				sSalida[3] = "";
				vecSalida.add(sSalida);

			}
			sSalida = new String[4];
			// lo hago saltar un renglon
			sSalida[0] = "";
			sSalida[1] = "";
			sSalida[2] = "";
			sSalida[3] = "";
			vecSalida.add(sSalida);
			sSalida = new String[4];
			sSalida[0] = "";
			sSalida[1] = "TOTAL GENERAL";
			sSalida[2] = totalGralLlamadas.toString();
			sSalida[3] = totalGralClientes.toString();
			vecSalida.add(sSalida);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getLlamados4Campania4Resultado( String fechaD, String fechaH, BigDecimal idempresa )  "
							+ ex);
		}
		return vecSalida;
	}

	private ResultSet getTelemarketers(BigDecimal idempresa)
			throws EJBException {
		// objetivo: recuperar unicamenta las usuarias telemarketers
		// atencion: Este metodo es privado, solamente va en clientesBean (no en
		// cllientes.java)
		ResultSet rsSalida = null;
		try {
			Statement statement = dbconn.createStatement();
			String cQuery = ""
					+ "select idusuario, upper(usuario) as telemarketer from globalusuarios "
					+ " where idusuario in( select idusuario from globalusuariosgrupos where idgrupo = 17) and idempresa="
					+ idempresa.toString() + " order by 2; ";

			// log.info("el metodo getTelemarketers:" + cQuery );
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("getTelemarketers(BigDecimal idempresa) Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTelemarketers(BigDecimal idempresa) Salida por exception: "
							+ ex);
		}
		return rsSalida;
	}

	private ResultSet getResultadosLlamadas(BigDecimal idempresa)
			throws EJBException {
		// objetivo: recuperar unicamenta las usuarias telemarketers
		// atencion: Este metodo es privado, solamente va en clientesBean (no en
		// cllientes.java)
		ResultSet rsSalida = null;
		try {
			Statement statement = dbconn.createStatement();
			String cQuery = ""
					+ "select idresultado, upper(resultado) as resultado from bacotmresultados  "
					+ " where idempresa =" + idempresa.toString()
					+ " order by 2; ";
			// log.info("el metodo getResultadosLlamadas:" + cQuery );
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("getResultadosLlamadas(BigDecimal idempresa) Error SQL: "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("getResultadosLlamadas(BigDecimal idempresa) Salida por exception: "
							+ ex);
		}
		return rsSalida;
	}

	private BigDecimal getTotalLlamadas(String telemarketer,
			BigDecimal idresultado, String fechaD, String fechaH,
			BigDecimal idcampania, BigDecimal idempresa) throws EJBException {
		BigDecimal salida = new BigDecimal(0);
		try {
			Statement statement = dbconn.createStatement();
			String cQuery = "" + " select count(idcliente) as total "
					+ " from bacotmllamados " + " where idresultado = "
					+ idresultado.toString() + " and idcampacabe = "
					+ idcampania.toString()
					+ " and fechaalt::date between to_date('" + fechaD
					+ "','dd/mm/yyyy') and to_date('" + fechaH
					+ "','dd/mm/yyyy')" + " and idempresa = "
					+ idempresa.toString() + " and upper(usuarioalt) = '"
					+ telemarketer.toUpperCase().trim() + "'";
			// log.info("el metodo getTotalLlamadas:" + cQuery );
			ResultSet rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next())
				salida = rsSalida.getBigDecimal("total");
		} catch (SQLException sqlException) {
			log
					.error("getTotalLlamadas( String telemarketer, BigDecimal idresultado BigDecimal idempresa ) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalLlamadas( String telemarketer, BigDecimal idresultado BigDecimal idempresa ) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	private BigDecimal getTotalLlamadasClientes(String telemarketer,
			BigDecimal idresultado, String fechaD, String fechaH,
			BigDecimal idcampania, BigDecimal idempresa) {
		BigDecimal salida = new BigDecimal(0);
		try {
			Statement statement = dbconn.createStatement();
			String cQuery = "" + " select count(distinct idcliente) as total "
					+ " from bacotmllamados " + " where idresultado = "
					+ idresultado.toString() + " and idcampacabe = "
					+ idcampania.toString()
					+ " and fechaalt::date between to_date('" + fechaD
					+ "','dd/mm/yyyy') and to_date('" + fechaH
					+ "','dd/mm/yyyy')" + " and idempresa = "
					+ idempresa.toString() + " and upper(usuarioalt) = '"
					+ telemarketer.toUpperCase().trim() + "'";
			// log.info("el metodo getTotalLlamadasClientes:" + cQuery );
			ResultSet rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null && rsSalida.next())
				salida = rsSalida.getBigDecimal("total");
		} catch (SQLException sqlException) {
			log
					.error("getTotalLlamadasClientes( String telemarketer, BigDecimal idresultado BigDecimal idempresa ) Error SQL: "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("getTotalLlamadasClientes( String telemarketer, BigDecimal idresultado BigDecimal idempresa ) Salida por exception: "
							+ ex);
		}
		return salida;
	}

	public ResultSet getClientesVentasporProductosyCampania(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " cabe.usuarioalt as telemarketer, "
				+ " deta.codigo_st as producto, "
				+ " sum(deta.cantidad) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad")
				+ " from "
				+ " pedidos_cabe cabe join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa) "
				+ " where cabe.idempresa = "
				+ idempresa
				+ "   AND cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " and cabe.idestado in(1,2)" // pendiente o realizado
				+ " and upper(cabe.usuarioalt) in (select upper(usuario) from globalusuarios where idusuario in( select idusuario from globalusuariosgrupos where idgrupo=17)) " // solo
				// telemarketers
				+ " and origenpedido <> 'ER' " + " group by "
				+ " cabe.usuarioalt, deta.codigo_st " + " ORDER BY 1, 3 desc  ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesVentasporProductosyCampania() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesVentasporProductosyCampania()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesVentasporProductos(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " deta.codigo_st as producto,"
				+ " sum(deta.cantidad) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad")
				+ " from "
				+ " pedidos_cabe cabe join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa)"
				+ " where cabe.idempresa = "
				+ idempresa
				+ "   AND cabe.fechaalt::date between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " and cabe.idestado in(1,2) " // pendiente o realizado
				+ " and upper(cabe.usuarioalt) in (select upper(usuario) from globalusuarios where idusuario in( select idusuario from globalusuariosgrupos where idgrupo=17))" // solo
				// telemarketers
				+ " and origenpedido <> 'ER' " + " group by "
				+ " deta.codigo_st " + " ORDER BY 2 desc ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesVentasporProductosyCampania() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesVentasporProductosyCampania()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesVentasporCategorias(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " csocios.categoriasocio as categoria, "
				+ " deta.codigo_st as producto, "
				+ " sum(deta.cantidad) as total"
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad")
				+ " from "
				+ " pedidos_cabe cabe join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa) "
				+ " join bacotmcategorizaciones categ "
				+ "        on (  cabe.idcliente = categ.idcliente and  fhasta is null) "
				+ "              join bacotmcategoriassocios csocios on ( categ.idcategoria = csocios.idcategoriasocio ) "
				+ " where cabe.idempresa = "
				+ idempresa
				+ "   AND cabe.fechaalt::date between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " and cabe.idestado in(1,2)" // pendiente o realizado
				+ " and upper(cabe.usuarioalt) in (select upper(usuario) from globalusuarios where idusuario in( select idusuario from globalusuariosgrupos where idgrupo=17)) " // solo
				// telemarketers
				+ " and origenpedido <> 'ER' " + " group by "
				+ " csocios.categoriasocio, " + " deta.codigo_st "
				+ " ORDER BY 1, 2 desc ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesVentasporProductosyCampania() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesVentasporProductosyCampania()  "
							+ ex);
		}
		return rsSalida;
	}

	public List getLClientesEstadnoCompro(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {

		// 20091013 - EJV - se cambio estado Harcode 5 X 11
		String cQuery = ""
				+ " select "
				+ " mot.motivo,"
				+ " count(ll.idllamado) as cantidad "
				+ " from "
				+ " bacotmmotivos mot "
				+ " left join bacotmllamados ll on ( mot.idmotivo = ll.idmotivo and mot.idempresa = ll.idempresa and idresultado=11)"
				+ " where ll.idcampacabe = " + idcampania.toString()
				+ " and mot.idempresa = " + idempresa.toString() + " group by "
				+ " mot.motivo " + " order by 2 desc,1 ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getLClientesEstadnoCompro()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getLClientesEstadTotal(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " select "
				+ " 'Total' as indicador,"
				+ " count(ll.idllamado) as total "
				+ " from "
				+ " bacotmmotivos mot "
				+ " left join bacotmllamados ll on ( mot.idmotivo = ll.idmotivo and mot.idempresa = ll.idempresa and idresultado=5) "
				+ " where ll.idcampacabe = " + idcampania.toString()
				+ " and mot.idempresa = " + idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getLClientesEstadTotal()  "
							+ ex);
		}
		return vecSalida;
	}

	public ResultSet getClientesCategoriaProvincia(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select " + " pr.provincia,"
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where deta.fechaalt::date between to_date('"
				+ fdesde
				+ "', 'dd/mm/yyyy') "
				+ " and to_date('"
				+ fhasta
				+ "', 'dd/mm/yyyy') "
				+ " and deta.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) "
				+ " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvincia() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvincia()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaTotal(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " 'TOTAL' as Total,"
				+ " sum(deta.cantidad)::numeric(18,0) as totales "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where deta.fechaalt::date between to_date('" + fdesde
				+ "', 'dd/mm/yyyy') " + " and to_date('" + fhasta
				+ "', 'dd/mm/yyyy') " + " and deta.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) "
				+ " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvinciaTotal() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvinciaTotal()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaDS(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " pr.provincia,"
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where deta.fechaalt::date between to_date('" + fdesde
				+ "', 'dd/mm/yyyy') " + " and to_date('" + fhasta
				+ "', 'dd/mm/yyyy') " + " and deta.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) " + " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvinciaDS() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvinciaDS()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaDS1(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ " pr.provincia,"
				+ " pr.provincia "
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where deta.fechaalt::date between to_date('" + fdesde
				+ "', 'dd/mm/yyyy') " + " and to_date('" + fhasta
				+ "', 'dd/mm/yyyy') " + " and deta.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) " + " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvinciaDS1() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvinciaDS1()  "
							+ ex);
		}
		return rsSalida;
	}

	/**
	 * Metodos para la entidad: pedidosCambioEstadosLog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Jun 23 15:26:30 GYT 2009
	 * 
	 */

	public String[] callPedidosCabeUpdateEstado(BigDecimal idpedido,
			BigDecimal idestadoanterior, BigDecimal idestadonuevo,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		String[] retorno = new String[] { "", "" };
		Iterator iterDetalle;

		dbconn.setAutoCommit(false);

		try {

			if (idestadoanterior.longValue() == 2) {
				salida = "El pedido ya fue procesado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 4) {
				salida = "El pedido ya fue anulado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 5) {
				salida = "El pedido ya fue rechazado, no es posible cambiar su estado.";
			} else if (idestadoanterior.equals(idestadonuevo)) {
				salida = "El nuevo estado debe ser diferente del estado actual.";
			} else if (idestadonuevo.longValue() > 5) {
				salida = "El nuevo estado no permite operaciones, comuniquese a sistemas - estado["
						+ idestadonuevo + "].";
			} else if (idestadonuevo.longValue() == 2) {
				salida = "No es posible asignar el estado seleccionado, el mismo solo se asigna automaticamente.";
			} else if (idestadoanterior.longValue() > 5) {
				salida = "El estado actual del pedido no permite acciones sobre este, no es posible cambiar su estado.";
			}

			if (salida.equalsIgnoreCase("OK")) {

				salida = pedidosCabeUpdEstado(idpedido, idestadonuevo,
						idempresa, usuarioalt);

				if (idestadonuevo.longValue() == 4
						|| idestadonuevo.longValue() == 5) {
					/*
					 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
					 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
					 * codigo_dt,entrega,usuarioalt,usuarioact,fechaalt,fechaact
					 */

					iterDetalle = getPedidosDetaXPedido(idpedido, idempresa)
							.iterator();

					while (iterDetalle.hasNext()
							&& salida.equalsIgnoreCase("OK")) {

						String[] datos = (String[]) iterDetalle.next();

						String inventa_st = datos[13];
						String articu_sb = datos[2];
						BigDecimal deposi_sb = new BigDecimal(datos[11]);
						BigDecimal canti_sb = new BigDecimal(datos[7]);
						BigDecimal pedid_sb = new BigDecimal(datos[7]).negate();
						BigDecimal cantidadEnReserva = new BigDecimal(0);

						// for(int r=0;r<datos.length ;r++)log.info("datos[" + r
						// + "]: " + datos[r]);

						if (inventa_st.equalsIgnoreCase("N"))
							continue;

						cantidadEnReserva = GeneralBean
								.getCantidadReservaArticuloDeposito(articu_sb,
										deposi_sb, idempresa, dbconn);

						if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

							salida = StockBean.stockStockBisCantidadesUpdate(
									articu_sb, deposi_sb, canti_sb, pedid_sb,
									dbconn, usuarioalt, idempresa);
						} else {
							salida = "No es posible Anular el pedido, la cantidad en reserva ["
									+ cantidadEnReserva
									+ "] es menor a la del pedido ["
									+ pedid_sb.abs()
									+ "]. Art.: "
									+ articu_sb
									+ " - Dep.: " + deposi_sb;
							break;
						}

						// EJV - 20100630
						// -------------------------------------------------------
						// REFERIDOS -- >

						bacoRefCatalogoActualizaCantidades(idpedido, articu_sb,
								pedid_sb, usuarioalt, idempresa);

						// < --
						// -------------------------------------------------------

					}

					try {

						retorno = BCBean.interfacesAnularPedidoBaco(idpedido,
								usuarioalt, idempresa, props);
						salida = retorno[0];

					} catch (Exception e) {
						salida = "(EX) Error al intentear anula pedido BACO.";
						log
								.error("callPedidosCabeUpdateEstado(): Imposible acutalizar pedido BACO: ["
										+ idpedido + "] - " + e);
					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					salida = pedidosCambioEstadosLogCreate(idpedido,
							idestadoanterior, idestadonuevo, "N", idempresa,
							usuarioalt);

				}
			}

		} catch (Exception e) {

			salida = "Se produjo una exepcion al intentar cambiar el estado del pedido.";
			log.error("callPedidosCabeUpdateEstado(...): " + e);

		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();

		} else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return new String[] { salida, retorno[1] };

	}

	public String callPedidosRegalosCabeUpdateEstado(
			BigDecimal idpedido_regalos_cabe, BigDecimal idestadoanterior,
			BigDecimal idestadonuevo, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		Iterator iterDetalle;
		int reservaStock = -1000;

		dbconn.setAutoCommit(false);

		try {

			/*
			 * 
			 * 1;"RESERVADO" 2;"ARMADO DE ESQUEMA" 3;"PENDIENTE" 4;"REALIZADO"
			 * 5;"ANULADO"
			 */

			if (idestadoanterior.longValue() == 99) {
				salida = "El pedido fue anulado, no es posible cambiar su estado.";
			} else if (idestadoanterior.equals(idestadonuevo)) {
				salida = "El nuevo estado debe ser diferente del estado actual.";
			} else if (idestadoanterior.longValue() == 1
					&& idestadonuevo.longValue() != 2
					&& idestadonuevo.longValue() != 3
					&& idestadonuevo.longValue() != 99) {
				salida = "El pedido se encuentra en reserva, solo puede pasar a Estado Armado de Esquema, Pendiente o Anulado.";
			} else if (idestadoanterior.longValue() == 2
					&& idestadonuevo.longValue() != 4
					&& idestadonuevo.longValue() != 99) {
				salida = "El pedido se encuentra en Armado de Esquema, solo puede pasar a Estado  Realizado  o Anulado.";
			} else if (idestadoanterior.longValue() == 3
					&& idestadonuevo.longValue() != 4
					&& idestadonuevo.longValue() != 99) {
				salida = "El pedido se encuentra en pendiente, solo puede pasar a Realizado o Anulado.";
			} else if (idestadoanterior.longValue() == 4
			// 20120210 - EJV -- Verificando para realizar cambios en envio de
					// mails, se detecto que la evaluacion contemplaba estado
					// anterior
					// solamente.-->
					// && idestadoanterior.longValue() != 99) {
					&& idestadonuevo.longValue() != 99) {
				// <--
				salida = "El pedido se encuentra en realizado, solo puede pasar a Anulado.";
			}

			if (salida.equalsIgnoreCase("OK")) {

				if (idestadonuevo.longValue() == 99) {

					reservaStock = getPedidoRegalosReservaStock(
							idpedido_regalos_cabe, idempresa);

					// 20101125 - EJV
					if (reservaStock == 1) {

						// 20101113-EJV-Verifca que sea posible la anulacion, si
						// es
						// detectado que posee al menos un pedido hijo y que
						// este
						// esta vivo, o bien que posee al menos una orden de
						// entrega
						// viva, no debe permitir anular hasta que no se "MATE"
						// cualquiera de los otros, llamense pedido hijo o
						// entrega.
						salida = pedidosRegalosValidarDependencias(
								idpedido_regalos_cabe, idempresa);

						/*
						 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
						 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
						 * codigo_dt
						 * ,entrega,usuarioalt,usuarioact,fechaalt,fechaact
						 */

						iterDetalle = getPedidosRegalosDetaXPedido(
								idpedido_regalos_cabe, idempresa).iterator();

						while (iterDetalle.hasNext()
								&& salida.equalsIgnoreCase("OK")) {

							String[] datos = (String[]) iterDetalle.next();

							String inventa_st = datos[13];
							String articu_sb = datos[2];
							BigDecimal deposi_sb = new BigDecimal(datos[11]);
							BigDecimal canti_sb = new BigDecimal(datos[7]);
							BigDecimal pedid_sb = new BigDecimal(datos[7])
									.negate();
							BigDecimal cantidadEnReserva = new BigDecimal(0);

							// for(int r=0;r<datos.length ;r++)log.info("datos["
							// + r
							// + "]: " + datos[r]);

							if (inventa_st.equalsIgnoreCase("N"))
								continue;

							cantidadEnReserva = GeneralBean
									.getCantidadReservaArticuloDeposito(
											articu_sb, deposi_sb, idempresa,
											dbconn);

							if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

								salida = StockBean
										.stockStockBisCantidadesUpdate(
												articu_sb, deposi_sb, canti_sb,
												pedid_sb, dbconn, usuarioalt,
												idempresa);
							} else {
								salida = "No es posible Anular el pedido, la cantidad en reserva ["
										+ cantidadEnReserva
										+ "] es menor a la del pedido ["
										+ pedid_sb.abs()
										+ "]. Art.: "
										+ articu_sb + " - Dep.: " + deposi_sb;
								break;
							}

						}

					} else if (reservaStock == 0) {

						log.info("ANULACION DE PEDIDOS DE REGALOS "
								+ idpedido_regalos_cabe
								+ ": no reservo stock. ");

					} else if (reservaStock < 0) {

						salida = "No es posible cambiar estado,imposible verificar si el pedido reservo stock o no, cod.: "
								+ reservaStock;

					}

				}

				log.debug("PEDIDO: " + idpedido_regalos_cabe
						+ " - Reserva.Stock:  " + reservaStock);

				if (salida.equalsIgnoreCase("OK")) {

					salida = pedidosRegalosCabeUpdEstado(idpedido_regalos_cabe,
							idestadonuevo, idempresa, usuarioalt);
					if (salida.equalsIgnoreCase("OK")) {
						salida = pedidosCambioEstadosLogCreate(
								idpedido_regalos_cabe, idestadoanterior,
								idestadonuevo, "R", idempresa, usuarioalt);
					}

				}
			}

		} catch (Exception e) {

			salida = "Se produjo una exepcion al intentar cambiar el estado del pedido.";
			log.error("callPedidosRegalosCabeUpdateEstado(...): " + e);

		}

		if (salida.equalsIgnoreCase("OK"))
			dbconn.commit();
		else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return salida;

	}

	// 20101119 - EJV - Mantis 602
	public String[] callPedidosRegalosEntregasCabeUpdateEstado(
			BigDecimal idpedido_regalos_cabe,
			BigDecimal idpedido_regalos_entrega_cabe,
			BigDecimal idestadoanterior, BigDecimal idestadonuevo,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		String[] retorno = new String[] { "", "" };
		Iterator iterDetalle;
		int reservaStock = -1000;

		dbconn.setAutoCommit(false);

		try {

			if (idestadoanterior.longValue() == 2) {
				salida = "El pedido ya fue procesado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 4) {
				salida = "El pedido ya fue anulado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 5) {
				salida = "El pedido ya fue rechazado, no es posible cambiar su estado.";
			} else if (idestadoanterior.equals(idestadonuevo)) {
				salida = "El nuevo estado debe ser diferente del estado actual.";
			} else if (idestadonuevo.longValue() > 5) {
				salida = "El nuevo estado no permite operaciones, comuniquese a sistemas - estado["
						+ idestadonuevo + "].";
			} else if (idestadonuevo.longValue() == 2) {
				salida = "No es posible asignar el estado seleccionado, el mismo solo se asigna automaticamente.";
			} else if (idestadoanterior.longValue() > 5) {
				salida = "El estado actual del pedido no permite acciones sobre este, no es posible cambiar su estado.";
			}

			if (salida.equalsIgnoreCase("OK")) {

				salida = pedidosRegalosEntregasCabeUpdEstado(
						idpedido_regalos_entrega_cabe, idestadonuevo,
						idempresa, usuarioalt);

				if (idestadonuevo.longValue() == 4
						|| idestadonuevo.longValue() == 5) {
					/*
					 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
					 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
					 * codigo_dt,entrega,usuarioalt,usuarioact,fechaalt,fechaact
					 */

					reservaStock = getPedidoRegalosReservaStock(
							idpedido_regalos_cabe, idempresa);

					// 20101126 - EJV

					if (reservaStock == 0) {
						// Si el pedido de regalos del que depende la entrega no
						// reserva stock, quiere decir que lo hizo esta, por lo
						// que
						// es necesario liberar la reserva.
						iterDetalle = getPedidosRegalosEntregasDetaXEntrega(
								idpedido_regalos_entrega_cabe, idempresa)
								.iterator();

						while (iterDetalle.hasNext()
								&& salida.equalsIgnoreCase("OK")) {

							String[] datos = (String[]) iterDetalle.next();

							String inventa_st = datos[13];
							String articu_sb = datos[2];
							BigDecimal deposi_sb = new BigDecimal(datos[11]);
							BigDecimal canti_sb = new BigDecimal(datos[7]);
							BigDecimal pedid_sb = new BigDecimal(datos[7])
									.negate();
							BigDecimal cantidadEnReserva = new BigDecimal(0);

							// for(int r=0;r<datos.length ;r++)log.info("datos["
							// + r
							// + "]: " + datos[r]);

							if (inventa_st.equalsIgnoreCase("N"))
								continue;

							cantidadEnReserva = GeneralBean
									.getCantidadReservaArticuloDeposito(
											articu_sb, deposi_sb, idempresa,
											dbconn);

							if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

								salida = StockBean
										.stockStockBisCantidadesUpdate(
												articu_sb, deposi_sb, canti_sb,
												pedid_sb, dbconn, usuarioalt,
												idempresa);
							} else {
								salida = "No es posible Anular entrega, la cantidad en reserva ["
										+ cantidadEnReserva
										+ "] es menor a la del pedido ["
										+ pedid_sb.abs()
										+ "]. Art.: "
										+ articu_sb + " - Dep.: " + deposi_sb;
								break;
							}

						}

					} else if (reservaStock == 1) {
						// Si el pedido de regalos del que depende la entrega si
						// reserva stock, quiere decir que esta no lo hizo, por
						// lo que
						// es no necesario liberar la reserva.
						log.info("ANULACION DE ENTREGA "
								+ idpedido_regalos_entrega_cabe
								+ ", DEPENDIENTE DE PEDIDO DE REGALOS"
								+ idpedido_regalos_cabe
								+ ": no reservo stock. ");

					} else if (reservaStock < 0) {

						salida = "No es posible cambiar estado,imposible verificar si el pedido reservo stock o no, cod.: "
								+ reservaStock;

					}

					// 20101126 - Mantis 602 - Entregas no pasan Baco, por ende
					// no se anulan -->
					// try {
					//
					// retorno = BCBean.interfacesAnularPedidoBaco(
					// idpedido_regalos_entrega_cabe, usuarioalt,
					// idempresa, props);
					// salida = retorno[0];
					//
					// } catch (Exception e) {
					// salida = "(EX) Error al intentear anula pedido BACO.";
					// log
					// .error("callPedidosCabeUpdateEstado(): Imposible acutalizar pedido BACO: ["
					// + idpedido_regalos_entrega_cabe
					// + "] - " + e);
					// }
					// <--

				}

				if (salida.equalsIgnoreCase("OK")) {

					salida = pedidosCambioEstadosLogCreate(
							idpedido_regalos_entrega_cabe, idestadoanterior,
							idestadonuevo, "E", idempresa, usuarioalt);

				}
			}

		} catch (Exception e) {

			salida = "Se produjo una exepcion al intentar cambiar el estado del pedido.";
			log.error("callPedidosRegalosEntregasCabeUpdateEstado(...): " + e);

		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();

		} else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return new String[] { salida, retorno[1] };

	}

	private String pedidosRegalosValidarDependencias(
			BigDecimal idpedido_regalos_cabe, BigDecimal idempresa)
			throws EJBException {
		String salida = "OK";

		try {
			String[] datos;
			String[] datosEntrega;

			String cQuery = ""
					+ "SELECT pc.idpedido_regalos_cabe, pc.idpedido_regalos_padre, pc.idestado, es.estado "
					+ "  FROM pedidos_regalos_cabe pc "
					+ "       INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa "
					+ " WHERE pc.idpedido_regalos_padre =  "
					+ idpedido_regalos_cabe
					+ " AND pc.idpedido_regalos_cabe <> "
					+ idpedido_regalos_cabe + "   AND pc.idempresa = "
					+ idempresa;

			// RECUPERA EL/LOS HIJO/S
			Iterator itHijos = getLista(cQuery).iterator();
			while (itHijos.hasNext()) {

				datos = (String[]) itHijos.next();
				// 20101113 - ULTIMAS LINEAS !

				// No necesita ir a verificar las entregas, se supone que si
				// estan con estado anulado, las entregas tambien lo deberian
				// estar, por lo que solo se valida el estado de los pedidos
				// hijos.

				if (datos[2].equals("1")) {
					salida = "No es posible anular el pedido de regalos "
							+ idpedido_regalos_cabe
							+ ", el mismo posee pedido hijo " + datos[0]
							+ ", con estado " + datos[3] + ".";
					break;
				} else if (datos[2].equals("3")) {

					salida = "No es posible anular el pedido de regalos "
							+ idpedido_regalos_cabe
							+ ", el mismo posee pedido hijo " + datos[0]
							+ ", con estado " + datos[3] + ".";
					break;

				} else if (datos[2].equals("4")) {
					salida = "No es posible anular el pedido de regalos "
							+ idpedido_regalos_cabe
							+ ", el mismo posee pedido hijo " + datos[0]
							+ ", con estado " + datos[3] + ".";
					break;
				}

			}

			if (salida.equalsIgnoreCase("OK")) {

				// Valida que no tenga entregas directamente relacionadas a el,
				// por lo que es la condicion de pedido sin transformacion,
				// pudiendo ser pedido padre o hijo.
				cQuery = ""
						+ "SELECT pc.idpedido_regalos_entrega_cabe, pc.idpedido_regalos_cabe, pc.idestado, es.estado  "
						+ "  FROM pedidos_regalos_entregas_cabe pc "
						+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa "
						+ " WHERE pc.idpedido_regalos_cabe = "
						+ idpedido_regalos_cabe + "   AND pc.idempresa = "
						+ idempresa
						+ "   and pc.idestado NOT IN (4, 5, 7) LIMIT 1 ";

				Iterator itEntregas = getLista(cQuery).iterator();

				if (itEntregas.hasNext()) {

					datosEntrega = (String[]) itEntregas.next();
					salida = "No es posible anular el pedido de regalos "
							+ idpedido_regalos_cabe
							+ ", el mismo posee entregas asociadas "
							+ datosEntrega[0] + ", con estado "
							+ datosEntrega[3] + ".";

				}

			}

		} catch (Exception e) {
			log.error("pedidosRegalosValidarDependencias(): " + e);
		}

		return salida;

	}

	private int getPedidoRegalosEstadoPedido(BigDecimal idpedido_regalos_cabe,
			BigDecimal idempresa) throws EJBException {
		int idestado = -90;

		String cQuery = ""
				+ "SELECT idestado FROM pedidos_regalos_cabe WHERE idpedido_regalos_cabe = "
				+ idpedido_regalos_cabe + " AND idempresa = " + idempresa;

		try {

			Iterator itEstado = getLista(cQuery).iterator();

			if (itEstado.hasNext()) {
				String[] datos = (String[]) itEstado.next();
				idestado = Integer.parseInt(datos[0]);
			}

		} catch (Exception e) {
			idestado = -100;
			log.error("getPedidoRegalosEstadoPedido(): " + e);
		}

		return idestado;
	}

	// ---------------------------------------

	public String[] callPedidosCabeUpdateEstadoPreconf(BigDecimal idpedido,
			BigDecimal idestadoanterior, BigDecimal idestadonuevo,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		String[] retorno = new String[] { "", "" };
		Iterator iterDetalle;

		dbconn.setAutoCommit(false);

		try {

			// if (idestadoanterior.longValue() == 2) {
			// salida =
			// "El pedido ya fue procesado, no es posible cambiar su estado.";
			// } else
			if (idestadoanterior.longValue() == 4) {
				salida = "El pedido ya fue anulado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 5) {
				salida = "El pedido ya fue rechazado, no es posible cambiar su estado.";
			} else if (idestadoanterior.equals(idestadonuevo)) {
				salida = "El nuevo estado debe ser diferente del estado actual.";
			} else if (idestadonuevo.longValue() == 1
					|| idestadonuevo.longValue() == 2
					|| idestadonuevo.longValue() == 3) {
				salida = "El nuevo estado debe ser ANULADO - RECHAZADO.";

			} else if (idestadonuevo.longValue() > 5) {
				salida = "El nuevo estado no permite operaciones, comuniquese a sistemas - estado["
						+ idestadonuevo + "].";
			} else if (idestadoanterior.longValue() > 5) {
				salida = "El estado actual del pedido no permite acciones sobre este, no es posible cambiar su estado.";
			}

			if (salida.equalsIgnoreCase("OK")) {

				salida = pedidosCabeUpdEstado(idpedido, idestadonuevo,
						idempresa, usuarioalt);

				if (idestadonuevo.longValue() == 4
						|| idestadonuevo.longValue() == 5) {
					/*
					 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
					 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
					 * codigo_dt,entrega,usuarioalt,usuarioact,fechaalt,fechaact
					 */

					iterDetalle = getPedidosDetaXPedido(idpedido, idempresa)
							.iterator();

					while (iterDetalle.hasNext()
							&& salida.equalsIgnoreCase("OK")) {

						String[] datos = (String[]) iterDetalle.next();

						String inventa_st = datos[13];
						String articu_sb = datos[2];
						BigDecimal deposi_sb = new BigDecimal(datos[11]);
						BigDecimal canti_sb = new BigDecimal(datos[7]);
						BigDecimal pedid_sb = new BigDecimal(datos[7]).negate();
						BigDecimal cantidadEnReserva = new BigDecimal(0);

						// for(int r=0;r<datos.length ;r++)log.info("datos[" + r
						// + "]: " + datos[r]);

						if (inventa_st.equalsIgnoreCase("N"))
							continue;

						cantidadEnReserva = GeneralBean
								.getCantidadReservaArticuloDeposito(articu_sb,
										deposi_sb, idempresa, dbconn);

						if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

							salida = StockBean.stockStockBisCantidadesUpdate(
									articu_sb, deposi_sb, canti_sb, pedid_sb,
									dbconn, usuarioalt, idempresa);
						} else {
							salida = "No es posible Anular el pedido, la cantidad en reserva ["
									+ cantidadEnReserva
									+ "] es menor a la del pedido ["
									+ pedid_sb.abs()
									+ "]. Art.: "
									+ articu_sb
									+ " - Dep.: " + deposi_sb;
							break;
						}

						// EJV - 20100630
						// -------------------------------------------------------
						// REFERIDOS -- >

						bacoRefCatalogoActualizaCantidades(idpedido, articu_sb,
								pedid_sb, usuarioalt, idempresa);

						// < --
						// -------------------------------------------------------

					}

					try {

						retorno = BCBean
								.interfacesAnularPedidoBacoPreconformacion(
										idpedido, usuarioalt, idempresa, props);
						salida = retorno[0];

					} catch (Exception e) {
						salida = "(EX) Error al intentear anula pedido BACO.";
						log
								.error("callPedidosCabeUpdateEstadoPreconf(): Imposible acutalizar pedido BACO: ["
										+ idpedido + "] - " + e);
					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					salida = pedidosCambioEstadosLogCreate(idpedido,
							idestadoanterior, idestadonuevo, "N", idempresa,
							usuarioalt);

				}
			}

		} catch (Exception e) {

			salida = "Se produjo una exepcion al intentar cambiar el estado del pedido.";
			log.error("callPedidosCabeUpdateEstadoPreconf(...): " + e);

		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();

		} else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return new String[] { salida, retorno[1] };

	}

	public String callPedidosRegalosCabeUpdateEstadoPreconf(
			BigDecimal idpedido, BigDecimal idestadoanterior,
			BigDecimal idestadonuevo, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {

		String salida = "OK";
		Iterator iterDetalle;

		dbconn.setAutoCommit(false);

		try {

			/*
			 * 
			 * 1;"PENDIENTE" 2;"REALIZADO" 3;"RESERVADO" 4;"ANULADO"
			 * 5;"RECHAZADO"
			 */

			// if (idestadoanterior.longValue() == 2) {
			// salida =
			// "El pedido ya fue procesado, no es posible cambiar su estado.";
			// } else
			if (idestadoanterior.longValue() == 3
					&& idestadonuevo.longValue() != 1
					&& idestadonuevo.longValue() != 4) {
				salida = "El pedido se encuentra en reserva, solo puede pasar a Estado Pendiente o Anulado.";
			} else if (idestadoanterior.longValue() == 4) {
				salida = "El pedido ya fue anulado, no es posible cambiar su estado.";
			} else if (idestadoanterior.longValue() == 5) {
				salida = "El pedido ya fue rechazado, no es posible cambiar su estado.";
			} else if (idestadoanterior.equals(idestadonuevo)) {
				salida = "El nuevo estado debe ser diferente del estado actual.";
			} else if (idestadonuevo.longValue() == 1
					|| idestadonuevo.longValue() == 2
					|| idestadonuevo.longValue() == 3) {
				salida = "El nuevo estado debe ser ANULADO - RECHAZADO.";
			} else if (idestadonuevo.longValue() > 5) {
				salida = "El nuevo estado no permite operaciones, comuniquese a sistemas - estado["
						+ idestadonuevo + "].";
			} else if (idestadoanterior.longValue() > 5) {
				salida = "El estado actual del pedido no permite acciones sobre este, no es posible cambiar su estado.";
			}

			if (salida.equalsIgnoreCase("OK")) {

				salida = pedidosRegalosCabeUpdEstado(idpedido, idestadonuevo,
						idempresa, usuarioalt);

				if (idestadonuevo.longValue() == 4
						|| idestadonuevo.longValue() == 5) {
					/*
					 * idpedido_deta,idpedido_cabe,codigo_st,fecha,renglon,
					 * precio,saldo,cantidad,bonific,codigo_md,cantuni,
					 * codigo_dt,entrega,usuarioalt,usuarioact,fechaalt,fechaact
					 */

					iterDetalle = getPedidosRegalosDetaXPedido(idpedido,
							idempresa).iterator();

					while (iterDetalle.hasNext()
							&& salida.equalsIgnoreCase("OK")) {

						String[] datos = (String[]) iterDetalle.next();

						String inventa_st = datos[13];
						String articu_sb = datos[2];
						BigDecimal deposi_sb = new BigDecimal(datos[11]);
						BigDecimal canti_sb = new BigDecimal(datos[7]);
						BigDecimal pedid_sb = new BigDecimal(datos[7]).negate();
						BigDecimal cantidadEnReserva = new BigDecimal(0);

						// for(int r=0;r<datos.length ;r++)log.info("datos[" + r
						// + "]: " + datos[r]);

						if (inventa_st.equalsIgnoreCase("N"))
							continue;

						cantidadEnReserva = GeneralBean
								.getCantidadReservaArticuloDeposito(articu_sb,
										deposi_sb, idempresa, dbconn);

						if (cantidadEnReserva.add(pedid_sb).longValue() >= 0) {

							salida = StockBean.stockStockBisCantidadesUpdate(
									articu_sb, deposi_sb, canti_sb, pedid_sb,
									dbconn, usuarioalt, idempresa);
						} else {
							salida = "No es posible Anular el pedido, la cantidad en reserva ["
									+ cantidadEnReserva
									+ "] es menor a la del pedido ["
									+ pedid_sb.abs()
									+ "]. Art.: "
									+ articu_sb
									+ " - Dep.: " + deposi_sb;
							break;
						}

					}

				}

				if (salida.equalsIgnoreCase("OK")) {

					salida = pedidosCambioEstadosLogCreate(idpedido,
							idestadoanterior, idestadonuevo, "R", idempresa,
							usuarioalt);

				}
			}

		} catch (Exception e) {

			salida = "Se produjo una exepcion al intentar cambiar el estado del pedido.";
			log.error("callPedidosRegalosCabeUpdateEstadoPreconf(...): " + e);

		}

		if (salida.equalsIgnoreCase("OK"))
			dbconn.commit();
		else
			dbconn.rollback();

		dbconn.setAutoCommit(true);

		return salida;

	}

	// ---------------------------------------
	// por primary key (primer campo por defecto)

	public List getPedidosCambioEstadosLogPedido(BigDecimal idpedido,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String entidadEstados = tipopedido.equalsIgnoreCase("R") ? "pedidosregalosestados"
				: "pedidosestados";
		String cQuery = ""
				+ "SELECT l.idlog,l.idpedido,l.idestadoanterior, ant.estado,l.idestadonuevo, nue.estado, "
				+ "       l.idempresa,l.usuarioalt,l.usuarioact,l.fechaalt,l.fechaact "
				+ "  FROM pedidoscambioestadoslog l "
				+ "           INNER JOIN "
				+ entidadEstados
				+ " ant ON l.idestadoanterior = ant.idestado AND l.idempresa = ant.idempresa "
				+ "           INNER JOIN  "
				+ entidadEstados
				+ " nue ON l.idestadonuevo = nue.idestado AND l.idempresa = nue.idempresa "
				+ " WHERE l.idpedido = " + idpedido.toString()
				+ "     AND l.tipo = '" + tipopedido
				+ "'     AND l.idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Error SQL en el metodo : getPedidosCambioEstadosLogPedido( BigDecimal idpedido ) "
							+ ex);
		}
		return vecSalida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String pedidosCambioEstadosLogCreate(BigDecimal idpedido,
			BigDecimal idestadoanterior, BigDecimal idestadonuevo,
			String tipopedido, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido ";
		if (idestadoanterior == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadoanterior ";
		if (idestadonuevo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadonuevo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("OK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO pedidoscambioestadoslog"
						+ " (idpedido, idestadoanterior, idestadonuevo, tipo, idempresa, usuarioalt )"
						+ " VALUES " + "(?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idpedido);
				insert.setBigDecimal(2, idestadoanterior);
				insert.setBigDecimal(3, idestadonuevo);
				insert.setString(4, tipopedido);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);

				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Fallo log cambio estado pedido.";
			}
		} catch (SQLException sqlException) {
			salida = "SQLE: Imposible generar log cambio estado pedido.";
			log
					.error("Error SQL public String pedidosCambioEstadosLogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: Imposible generar log cambio estado pedido.";
			log
					.error("Error excepcion public String pedidosCambioEstadosLogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String callInterfacesPreconformacionTotalRemitosPedido(
			BigDecimal idpedidocabedelta) throws EJBException {

		String salida = "0";

		try {

			salida = BCBean.interfacesPreconformacionTotalRemitosPedido(
					idpedidocabedelta, props);

		} catch (Exception e) {
			log.error("callInterfacesPreconformacionTotalRemitosPedido: " + e);
		}

		return salida;
	}

	public String callInterfacesPreconformacionTotalPedidosRemito(
			BigDecimal idpedidocabedelta, int totalRemitos) throws EJBException {
		String xnremito = "";
		String salida = "";
		try {

			xnremito = BCBean.interfacesPreconformacionGetPedidosRemito(
					idpedidocabedelta, props);

			salida = BCBean.interfacesPreconformacionTotalPedidosRemito(
					xnremito, props);

		} catch (Exception e) {
			log.error("callInterfacesPreconformacionTotalPedidosRemito: " + e);
		}

		return salida;
	}

	/**
	 * Metodos para cunsulta: pedidosConDescuento Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Wed Jul 15 09:28:13 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosConDescuentoAll(long limit, long offset,
			BigDecimal idtipoclie, BigDecimal mes, BigDecimal anio,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_cabe, cl.idtipoclie, tc.tipoclie, cl.idcliente, cl.razon, ex.idexpreso, ex.expreso, "
				+ "  	  es.idestado, es.estado, es.motivo, es.fechadesde, pc.fechapedido, pc.origenpedido, "
				+ "  	  pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientestipoclie tc ON ( cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa ) "
				+ "       INNER JOIN vclientesestadoshoy es ON ( cl.idcliente = es.idcliente AND cl.idempresa = es.idempresa ) "
				+ "       INNER JOIN pedidos_cabe pc ON (pc.idcliente = cl.idcliente AND cl.idempresa = pc.idempresa) "
				+ "       INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND pc.idempresa = ex.idempresa "
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "   AND cl.idtipoclie = " + idtipoclie.toString()
				+ "   AND DATE_PART('YEAR',pc.fechapedido) = "
				+ anio.toString()
				+ "   AND DATE_PART('MONTH',pc.fechapedido) = "
				+ mes.toString() + "   AND es.idestado = "
				+ idestado.toString() + "   AND pc.idpedido_cabe NOT IN ( "
				+ "		          SELECT idpedido_cabe "
				+ "		            FROM pedidos_deta  "
				+ "		           WHERE porcdesc_apli = 0 AND idempresa = "
				+ idempresa.toString() + ")  ORDER BY 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosConDescuentoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosConDescuentoOcu(long limit, long offset,
			String ocurrencia, BigDecimal idtipoclie, BigDecimal mes,
			BigDecimal anio, BigDecimal idestado, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_cabe, cl.idtipoclie, tc.tipoclie, cl.idcliente, cl.razon, ex.idexpreso, ex.expreso, "
				+ "  	  es.idestado, es.estado, es.motivo, es.fechadesde, pc.fechapedido, pc.origenpedido, "
				+ "  	  pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientestipoclie tc ON ( cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa ) "
				+ "       INNER JOIN vclientesestadoshoy es ON ( cl.idcliente = es.idcliente AND cl.idempresa = es.idempresa ) "
				+ "       INNER JOIN pedidos_cabe pc ON (pc.idcliente = cl.idcliente AND cl.idempresa = pc.idempresa) "
				+ "       INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND pc.idempresa = ex.idempresa "
				+ " WHERE cl.idempresa = "
				+ idempresa.toString()
				+ "   AND cl.idtipoclie = "
				+ idtipoclie.toString()
				+ "   AND DATE_PART('YEAR',pc.fechapedido) = "
				+ anio.toString()
				+ "   AND DATE_PART('MONTH',pc.fechapedido) = "
				+ mes.toString()
				+ "   AND es.idestado = "
				+ idestado.toString()
				+ "   AND pc.idpedido_cabe NOT IN ( "
				+ "		          SELECT idpedido_cabe "
				+ "		            FROM pedidos_deta  "
				+ "		           WHERE porcdesc_apli = 0 AND idempresa = "
				+ idempresa.toString()
				+ ") "
				+ "AND (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  ORDER BY 3  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosConDescuentoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para cunsulta: pedidosEvaluacion Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Wed Jul 15 09:28:13 GYT 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosEvaluacionAll(long limit, long offset,
			BigDecimal idtipoclie, BigDecimal mes, BigDecimal anio,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe, idtipoclie, tipoclie, idcliente, razon, idexpreso, expreso, "
				+ "       idestado, estado, motivo, fechadesde, fechapedido, origenpedido, "
				+ "       idestadopedido, estadopedido, idempresa, usuarioalt, usuarioact, fechaalt, fechaact  "
				+ "  FROM ( "
				+ "	SELECT pc.idpedido_cabe, cl.idtipoclie, tc.tipoclie, cl.idcliente, cl.razon, ex.idexpreso, ex.expreso,  "
				+ "	       es.idestado, es.estado, es.motivo, es.fechadesde, pc.fechapedido, pc.origenpedido,  "
				+ "	       pc.idestado AS idestadopedido, pes.estado AS estadopedido,  "
				+ "               pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact  "
				+ "	  FROM clientesclientes cl  "
				+ "	       INNER JOIN clientestipoclie tc ON ( cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa )  "
				+ "	       INNER JOIN vclientesestadoshoy es ON ( cl.idcliente = es.idcliente AND cl.idempresa = es.idempresa )  "
				+ "	       LEFT JOIN pedidos_cabe pc ON (pc.idcliente = cl.idcliente AND cl.idempresa = pc.idempresa  "
				+ "		     AND DATE_PART('YEAR',pc.fechapedido) = "
				+ anio.toString()
				+ "                     AND DATE_PART('MONTH',pc.fechapedido) = "
				+ mes.toString()
				+ ")"
				+ "	       LEFT JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND pc.idempresa = ex.idempresa  "
				+ "               LEFT JOIN pedidosestados pes ON pc.idestado = pes.idestado AND pc.idempresa = pes.idestado "
				+ "	 WHERE cl.idempresa =  " + idempresa.toString()
				+ "	   AND cl.idtipoclie =  " + idtipoclie.toString()
				+ "	   AND es.idestado = " + idestado.toString()
				+ "       )evaluacion "
				+ " WHERE idpedido_cabe IS NULL OR idestadopedido IN (4, 5)   "
				+ " ORDER BY 5  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEvaluacionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosEvaluacionOcu(long limit, long offset,
			String ocurrencia, BigDecimal idtipoclie, BigDecimal mes,
			BigDecimal anio, BigDecimal idestado, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe, idtipoclie, tipoclie, idcliente, razon, idexpreso, expreso, "
				+ "       idestado, estado, motivo, fechadesde, fechapedido, origenpedido, "
				+ "       idestadopedido, estadopedido, idempresa, usuarioalt, usuarioact, fechaalt, fechaact  "
				+ "  FROM ( "
				+ "	SELECT pc.idpedido_cabe, cl.idtipoclie, tc.tipoclie, cl.idcliente, cl.razon, ex.idexpreso, ex.expreso,  "
				+ "	       es.idestado, es.estado, es.motivo, es.fechadesde, pc.fechapedido, pc.origenpedido,  "
				+ "	       pc.idestado AS idestadopedido, pes.estado AS estadopedido,  "
				+ "               pc.idempresa, pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact  "
				+ "	  FROM clientesclientes cl  "
				+ "	       INNER JOIN clientestipoclie tc ON ( cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa )  "
				+ "	       INNER JOIN vclientesestadoshoy es ON ( cl.idcliente = es.idcliente AND cl.idempresa = es.idempresa )  "
				+ "	       LEFT JOIN pedidos_cabe pc ON (pc.idcliente = cl.idcliente AND cl.idempresa = pc.idempresa  "
				+ "		     AND DATE_PART('YEAR',pc.fechapedido) = "
				+ anio.toString()
				+ "                     AND DATE_PART('MONTH',pc.fechapedido) = "
				+ mes.toString()
				+ ")"
				+ "	       LEFT JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND pc.idempresa = ex.idempresa  "
				+ "               LEFT JOIN pedidosestados pes ON pc.idestado = pes.idestado AND pc.idempresa = pes.idestado "
				+ "	 WHERE cl.idempresa =  "
				+ idempresa.toString()
				+ "	   AND cl.idtipoclie =  "
				+ idtipoclie.toString()
				+ "	   AND es.idestado = "
				+ idestado.toString()
				+ "       )evaluacion "
				+ " WHERE (idpedido_cabe IS NULL OR idestadopedido IN (4, 5) )  "
				+ "AND (UPPER(razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR idcliente::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  ORDER BY 5  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosEvaluacionOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getCosnultaVendedoresResumenVendedores(String anio,
			BigDecimal mes, BigDecimal idvendedor, BigDecimal idempresa)
			throws EJBException {

		String cQuery = " select" + " tipo, " + " concepto," + " cantidad,"
				+ " importe " + " from " + " VENDEDORESmovResumen " + " where "
				+ " idvendedor = " + idvendedor.toString()
				+ " and anioliquidacion = " + anio.toString()
				+ " and mesLiquidacion = " + mes.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaVendedoresResumenVendedores()  "
							+ ex);
		}
		return vecSalida;
	}

	// Detalle de asociaciones
	public List getCosnultaVendedoresDetalleAsociaciones(String anio,
			BigDecimal mes, BigDecimal idvendedor, BigDecimal idempresa)
			throws EJBException {

		String cQuery = " select " + "	csocio ," + " apellido ," + " nombre ,"
				+ " fingreso," + " anioAsociacion," + " mesAsociacion,"
				+ " totalCuotas," + " actualcuota," + "	importeTotal,"
				+ " importeCuota " + "	from " + "	VENDEDORESmovAsociaciones "
				+ "	where " + " idvendedor = " + idvendedor.toString()
				+ " and mesLiquidacion = " + mes.toString()
				+ " and anioLiquidacion = " + anio.toString()
				+ " and tipo = 'FC' " + " order by 1";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaVendedoresDetalleAsociaciones()  "
							+ ex);
		}
		return vecSalida;
	}

	// Notas de credito por ci
	public List getCosnultaVendedoresNotasdecreditoporCI(String anio,
			BigDecimal mes, BigDecimal idvendedor, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "select " + " csocio," + " apellido, " + " nombre, "
				+ " totalCuotas, " + " importeTotal, " + " importeCuota "
				+ " from " + " VENDEDORESmovAsociaciones " + " where "
				+ " idvendedor = " + idvendedor.toString()
				+ " and mesLiquidacion = " + mes.toString()
				+ " and anioLiquidacion = " + anio.toString()
				+ " and tipo = 'NC' " + " order by 1";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaVendedoresNotasdecreditoporCI()  "
							+ ex);
		}
		return vecSalida;
	}

	// Detalle de Movimiento en Cartera
	public List getCosnultaVendedoresDetalleMovimientoCartera(String anio,
			BigDecimal mes, BigDecimal idvendedor, BigDecimal idempresa)
			throws EJBException {

		String cQuery = " select" + " tipo, " + " csocio, " + " apellido, "
				+ " nombre, " + " importeTotal, " + " importeliquidacion "
				+ " from " + " VENDEDORESmovCartera " + " where "
				+ " idvendedor = " + idvendedor.toString()
				+ " and mesLiquidacion  = " + mes.toString()
				+ " and anioLiquidacion = " + anio.toString() + " order by 1";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaVendedoresDetalleMovimientoCartera()  "
							+ ex);
		}
		return vecSalida;
	}

	// Analisis de estado por ao de ingreso.
	public List getCosnultaEstadoporanioIngreso(String fechadesde,
			String fechahasta, BigDecimal idestado, String reporte,
			BigDecimal idempresa) throws EJBException {

		String cQuery = " select "
				+ " date_part('year',pr.fechadeingreso) as anioingreso, "
				+ " count(*) as socios "
				+ " from "
				+ " clientesclientes cl "
				+ " join clientesprecargaclientes pr on ( cl.idcliente = pr.idcliente and cl.idempresa = pr.idempresa)"
				+ " where "
				+ " cl.idcliente in (select idcliente from clientesestadosclientes where idestado ="
				+ idestado.toString() + " and fechadesde between '"
				+ fechadesde.toString() + "' and '" + fechahasta.toString()
				+ "' and idempresa = " + idempresa.toString() + ")"
				+ " group by " + " date_part('year',pr.fechadeingreso) "
				+ " order by 1 ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaEstadoporanioIngreso()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getCosnultaporVendedor(String fechadesde, String fechahasta,
			BigDecimal idestado, String reporte, BigDecimal idempresa)
			throws EJBException {

		String cQuery = " select "
				+ " ven.vendedor, "
				+ " count(*) as socios "
				+ " from "
				+ " clientesclientes cl"
				+ " join clientesprecargaclientes pr on ( cl.idcliente = pr.idcliente and cl.idempresa = pr.idempresa) "
				+ " join clientesvendedor ven on ( pr.idvendedorasignado =  ven.idvendedor and pr.idempresa = ven.idempresa) "
				+ " where "
				+ " cl.idcliente in (select idcliente from clientesestadosclientes where idestado = "
				+ idestado.toString() + " and fechadesde between '"
				+ fechadesde.toString() + "' and '" + fechahasta.toString()
				+ "') " + " and cl.idempresa = " + idempresa.toString()
				+ " group by ven.vendedor " + " order by 1 ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaEstadoporanioIngreso()  "
							+ ex);
		}
		return vecSalida;
	}

	public ResultSet getCosnultaporVendedorMotivos(String fechadesde,
			String fechahasta, BigDecimal idestado, String reporte,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select "
				+ " ven.vendedor, "
				+ " count(*) as socios "
				+ getPivotContar("clientesmotivos", "motivo", "idestado="
						+ idestado.toString())
				+ " from "
				+ " clientesclientes cl"
				+ " join clientesprecargaclientes pr on ( cl.idcliente = pr.idcliente and cl.idempresa = pr.idempresa) "
				+ " join clientesvendedor ven on ( pr.idvendedorasignado =  ven.idvendedor and pr.idempresa = ven.idempresa) "
				+ " join clientesestadosclientes estcli on (cl.idcliente = estcli.idcliente and cl.idempresa = estcli.idempresa) "
				+ " join clientesestados est on (estcli.idestado = est.idestado and estcli.idempresa = est.idempresa) "
				+ " join clientesmotivos mot on (est.idestado = mot.idestado and est.idempresa = mot.idestado)  "
				+ " where "
				+ " cl.idcliente in (select idcliente from clientesestadosclientes where idestado = "
				+ idestado.toString() + " and fechadesde between '"
				+ fechadesde.toString() + "' and '" + fechahasta.toString()
				+ "') " + " and cl.idempresa = " + idempresa.toString()
				+ " group by ven.vendedor " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesSociosAsignados() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignados()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getConsultaporporDistribuidoryMotivodeBaja(
			String fechadesde, String fechahasta, BigDecimal idestado,
			String reporte, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select " + " expre.expreso, "
				+ " count(*) as socios "
				+ getPivotContar("clientesmotivos", "motivo", "idestado="
						+ idestado.toString())
				+ " from "
				+ " clientesclientes cl "
				+ " join clientesdomicilios dom  on ( cl.idcliente = dom.idcliente and cl.idempresa = dom.idempresa ) "
				+ " join clientesanexolocalidades anexo on ( dom.idlocalidad = anexo.idlocalidad and dom.idempresa = anexo.idempresa ) "
				+ " join clientesexpresoszonas exzonas on ( anexo.idexpresozona = exzonas.codigo and anexo.idempresa = exzonas.idempresa) "
				+ " join clientesexpresos expre on ( exzonas.idexpreso = expre.idexpreso and exzonas.idempresa = expre.idempresa ) "
				+ " join clientesestadosclientes estcli on (cl.idcliente = estcli.idcliente and cl.idempresa = estcli.idempresa) "
				+ " join clientesestados est on (estcli.idestado = est.idestado and estcli.idempresa = est.idempresa) "
				+ " join clientesmotivos mot on (est.idestado = mot.idestado and est.idempresa = mot.idestado) "
				+ " where "
				+ " cl.idcliente in (select idcliente from clientesestadosclientes where idestado = "
				+ idestado.toString()
				+ " and fechadesde between '"
				+ fechadesde.toString()
				+ "' and '"
				+ fechahasta.toString()
				+ "') " + " and cl.idempresa = " + idempresa.toString()
				// + " and dom.esdefault ='S'
				+ " group by " + " expre.expreso " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getConsultaporporDistribuidoryMotivodeBaja() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getConsultaporporDistribuidoryMotivodeBaja()  "
							+ ex);
		}
		return rsSalida;
	}

	// arreglar
	public ResultSet getConsultaporProvinciayMotivo(String fechadesde,
			String fechahasta, BigDecimal idestado, String reporte,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = " select " + " prov.provincia,"
				+ " count(*) as socios "
				+ getPivotContar("clientesmotivos", "motivo", "idestado="
						+ idestado.toString())
				+ " from "
				+ " clientesclientes cl "
				+ " join clientesdomicilios dom  on ( cl.idcliente = dom.idcliente and cl.idempresa = dom.idempresa ) "
				+ " join clientesanexolocalidades anexo on ( dom.idlocalidad = anexo.idlocalidad and dom.idempresa = anexo.idempresa )  "
				+ " join globallocalidades loca on ( anexo.idlocalidad = loca.idlocalidad ) "
				+ " join globalprovincias  prov on ( loca.idprovincia = prov.idprovincia ) "
				+ " join clientesestadosclientes estcli on (cl.idcliente = estcli.idcliente and cl.idempresa = estcli.idempresa) "
				+ " join clientesestados est on (estcli.idestado = est.idestado and estcli.idempresa = est.idempresa) "
				+ " join clientesmotivos mot on (est.idestado = mot.idestado and est.idempresa = mot.idestado) "
				+ " where "
				+ " cl.idcliente in (select idcliente from clientesestadosclientes where idestado = "
				+ idestado.toString()
				+ " and fechadesde between '"
				+ fechadesde.toString()
				+ "' and '"
				+ fechahasta.toString()
				+ "') "
				+ " and cl.idempresa = "
				+ idempresa.toString()
				+ " group by " + " prov.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getConsultaporProvinciayMotivo() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getConsultaporProvinciayMotivo()  "
							+ ex);
		}
		return rsSalida;
	}

	public List getCosnultaPedidosPendientesRevisar(String fechadesde,
			String fechahasta, BigDecimal idempresa, BigDecimal idestado,
			BigDecimal idtipoclie) throws EJBException {

		String cQuery = ""
				+ "SELECT tc.tipoclie, COALESCE(es.estado,'sin estado') AS estado, "
				+ "       cl.razon,  cl.idcliente "
				+ " FROM pedidos_cabe pc "
				+ "      INNER JOIN pedidosestados on pc.idestado = pedidosestados.idestado and pc.idempresa = pedidosestados.idempresa "
				+ "      INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
				+ "      INNER JOIN clientestipoclie tc ON cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa "
				+ "       LEFT JOIN vclientesestadoshoy es ON cl.idcliente = es.idcliente AND cl.idempresa = es.idempresa "
				+ "WHERE pedidosestados.idestado = 1 " + "  AND es.idestado = "
				+ idestado.toString() + "  AND tc.idtipoclie =  "
				+ idtipoclie.toString() + "  AND pc.fechapedido BETWEEN '"
				+ fechadesde.toString() + "' AND '" + fechahasta.toString()
				+ "' AND pc.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaEstadoporanioIngreso()  "
							+ ex);
		}
		return vecSalida;
	}

	// seleccion de socios para llamadas sin socio
	public List getCosnultaSeleccionClientesLLamadas(BigDecimal idcampania,
			BigDecimal idresultado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " select "
				+ " bacotmllamados.idllamado, "
				+ " bacotmllamados.idcliente,"
				+ " clientesclientes.razon,"
				+ " clientesprecargaclientes.fechadeingreso, "
				+ " bacotmllamados.fecharellamada, "
				+ " vclientesestadoshoy.estado, "
				+ " vclientesestadoshoy.motivo, "
				+ " bacotmcategoriassocios.categoriasocio, "
				+ " bacotmllamados.observaciones "
				+ " from  "
				+ " bacotmllamados "
				+ " inner join clientesclientes on bacotmllamados.idcliente = clientesclientes.idcliente and bacotmllamados.idempresa = clientesclientes.idempresa "
				+ " left join clientesprecargaclientes on bacotmllamados.idcliente = clientesprecargaclientes.idcliente and bacotmllamados.idempresa = clientesprecargaclientes.idempresa "
				+ " left join vclientesestadoshoy on bacotmllamados.idcliente = vclientesestadoshoy.idcliente and bacotmllamados.idempresa = vclientesestadoshoy.idempresa "
				+ " inner join bacotmcategorizaciones on bacotmllamados.idcliente = bacotmcategorizaciones.idcliente and bacotmllamados.idempresa = bacotmcategorizaciones.idempresa "
				+ " left join bacotmcategoriassocios on bacotmcategorizaciones.idcategorizacion = bacotmcategoriassocios.idcategoriasocio and bacotmcategorizaciones.idempresa = bacotmcategoriassocios.idempresa "
				+ " where bacotmllamados.idcampacabe = "
				+ idcampania.toString()
				+ " and bacotmllamados.idresultado =  "
				+ idresultado.toString()
				+ " and bacotmllamados.idempresa = "
				+ idempresa.toString()
				+ " and bacotmcategorizaciones.idcategorizacion = (select max(idcategorizacion) from bacotmcategorizaciones os where os.idcliente = bacotmcategorizaciones.idcliente and os.idempresa = bacotmcategorizaciones.idempresa ) ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaSeleccionClientesLLamadas()  "
							+ ex);
		}
		return vecSalida;
	}

	// seleccion de socios para llamadas con socio
	public List getCosnultaSeleccionClientesLLamadasconCliente(
			BigDecimal idcampania, BigDecimal idcliente,
			BigDecimal idresultado, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " select "
				+ " bacotmllamados.idllamado, "
				+ " bacotmllamados.idcliente,"
				+ " clientesclientes.razon,"
				+ " clientesprecargaclientes.fechadeingreso, "
				+ " bacotmllamados.fecharellamada, "
				+ " vclientesestadoshoy.estado, "
				+ " vclientesestadoshoy.motivo, "
				+ " bacotmcategoriassocios.categoriasocio, "
				+ " bacotmllamados.observaciones "
				+ " from  "
				+ " bacotmllamados "
				+ " inner join clientesclientes on bacotmllamados.idcliente = clientesclientes.idcliente and bacotmllamados.idempresa = clientesclientes.idempresa "
				+ " left join clientesprecargaclientes on bacotmllamados.idcliente = clientesprecargaclientes.idcliente and bacotmllamados.idempresa = clientesprecargaclientes.idempresa "
				+ " left join vclientesestadoshoy on bacotmllamados.idcliente = vclientesestadoshoy.idcliente and bacotmllamados.idempresa = vclientesestadoshoy.idempresa "
				+ " inner join bacotmcategorizaciones on bacotmllamados.idcliente = bacotmcategorizaciones.idcliente and bacotmllamados.idempresa = bacotmcategorizaciones.idempresa "
				+ " left join bacotmcategoriassocios on bacotmcategorizaciones.idcategorizacion = bacotmcategoriassocios.idcategoriasocio and bacotmcategorizaciones.idempresa = bacotmcategoriassocios.idempresa "
				+ " where bacotmllamados.idcampacabe = "
				+ idcampania.toString()
				+ " and clientesclientes.idcliente = "
				+ idcliente.toString()
				+ " and bacotmllamados.idresultado =  "
				+ idresultado.toString()
				+ " and bacotmllamados.idempresa = "
				+ idempresa.toString()
				+ " and bacotmcategorizaciones.idcategorizacion = (select max(idcategorizacion) from bacotmcategorizaciones os where os.idcliente = bacotmcategorizaciones.idcliente and os.idempresa = bacotmcategorizaciones.idempresa ) ";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCosnultaSeleccionClientesLLamadas()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesCampaiaAnterioresLovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		Calendar hoy = new GregorianCalendar();
		Timestamp fecha = new Timestamp(hoy.getTime().getTime());
		String cQuery = "SELECT idcampacabe,campacabe,fDesde,fHasta FROM bacotmcampacabe "
				+ " where fHasta < "
				+ "'"
				+ fecha
				+ "'"
				+ " and idempresa = "
				+ idempresa
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCampaiaAnterioresLovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public ResultSet getClientesCategoriaProvincia(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " pr.provincia,"
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where " + " campac.idcampacabe    = "
				+ idcampania.toString() + " and deta.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) " + " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvincia() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvincia()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaTotal(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " 'TOTAL' as Total,"
				+ " sum(deta.cantidad)::numeric(18,0) as totales "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where " + " campac.idcampacabe    = "
				+ idcampania.toString() + " and campac.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) "
				+ " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvinciaTotal() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvinciaTotal()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaDS(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " pr.provincia,"
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where " + " campac.idcampacabe    = "
				+ idcampania.toString() + " and campac.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) " + " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvincia() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvincia()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesCategoriaProvinciaDS1(BigDecimal idcampania,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " sum(deta.cantidad)::numeric(18,0) as total "
				+ " pr.provincia,"
				+ " pr.provincia "
				+ " from "
				+ " globalprovincias pr "
				+ " join globallocalidades loca on ( pr.idprovincia = loca.idprovincia ) "
				+ " join clientesdomicilios  domi on ( loca.idlocalidad = domi.idlocalidad ) "
				+ " join pedidos_cabe cabe on ( domi.iddomicilio = cabe.idsucuclie and domi.idempresa = cabe.idempresa) "
				+ " join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa ) "
				+ " join bacotmcampacabe campac on ( cabe.fechapedido between campac.fdesde and campac.fhasta and cabe.idempresa = campac.idempresa) "
				+ " join bacotmcampadeta campad on ( campac.idcampacabe = campad.idcampacabe and campac.idempresa = campad.idempresa ) "
				+ " join bacotmcategorizaciones cat on (cabe.idcliente = cat.idcliente and cabe.idempresa = cat.idempresa and cat.fhasta is null) "
				+ " join bacotmcategoriassocios csoc on ( cat.idcategoria = csoc.idcategoriasocio and cat.idempresa = csoc.idempresa ) "
				+ " where " + " campac.idcampacabe    = "
				+ idcampania.toString() + " and campac.idempresa  = "
				+ idempresa.toString()
				+ " and deta.codigo_st in ( campad.codigo_st ) " + " group by "
				+ " pr.provincia " + " order by 1 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesCategoriaProvincia() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCategoriaProvincia()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesSociosAsignadosTotalesDS1(String fdesde,
			String fhasta, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;

		String cQuery = ""
				+ " select count(*) as total,categoriasocio ,categoriasocio  "
				+ " from  vseleccionsocios sel  WHERE idempresa= "
				+ idempresa.toString()
				+ " and fechaalt::date between to_date('" + fdesde
				+ "', 'dd/mm/yyyy') " + " and to_date('" + fhasta
				+ "', 'dd/mm/yyyy') "
				+ "group by categoriasocio order by 1 desc ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesSociosAsignadosTotalesDS1() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSociosAsignadosTotalesDS1()  "
							+ ex);
		}
		return rsSalida;
	}

	public String SuspensiondeEntregasRegularesCreate(BigDecimal idcliente,
			BigDecimal anio, BigDecimal mes, BigDecimal idempresa,
			String usuarioalt, BigDecimal idmotsusp) throws EJBException {
		String salida = "NOOK";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO clientessuspentregasregulares(idcliente,anio,mes,idempresa,usuarioalt,idmotsusp ) VALUES (?,?,?,?,?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, anio);
				insert.setBigDecimal(3, mes);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				insert.setBigDecimal(6, idmotsusp);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String SuspensiondeEntregasRegularesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String SuspensiondeEntregasRegularesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// reasignacion de socios
	public BigDecimal getBacoTmReasignacionTotalSocios(BigDecimal idcampacabe,
			String filtros, BigDecimal idempresa, BigDecimal idtelemark)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT COUNT(DISTINCT cl.idcliente) "
				+ "  FROM clientesclientes cl  "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa "
				+ "       INNER JOIN globallocalidades lo ON cd.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
				+ "       INNER JOIN clientesprecargaclientes pcc ON cl.idcliente = pcc.idcliente AND cl.idempresa = pcc.idempresa "
				+ "       INNER JOIN vclientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa AND ca.fhasta IS NULL "
				+ " WHERE cl.idempresa =  " + idempresa.toString()
				+ "   AND cl.idcliente IN ("
				+ "                            SELECT idcliente "
				+ "                              FROM bacotmseleccionsocio "
				+ "                             WHERE idcampacabe = "
				+ idcampacabe + " AND idempresa = " + idempresa
				+ " and idtelemark = " + idtelemark + ")" + filtros + ";";
		BigDecimal total = new BigDecimal(-1);
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getBigDecimal(1);
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getBacoTmReasignacionTotalSocios( BigDecimal idesquema ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTmReasignacionTotalSocios( BigDecimal idesquema )  "
							+ ex);
		}
		return total;
	}

	/*
	 * // aca tendria que borrar en la tabla bacotmseleccionsocio los datos de
	 * la public String bacoTmReasignacionSocioDelete(BigDecimal idcampacabe,
	 * BigDecimal idempresa, BigDecimal idtelemark) throws EJBException { String
	 * salida = "NOOK"; String cQuery = ""; try { Statement statement =
	 * dbconn.createStatement(); cQuery = " DELETE FROM bacotmseleccionsocio " +
	 * " WHERE idcampacabe = " + idcampacabe.toString() + " and idempresa = " +
	 * idempresa.toString() + " and idtelemark = " + idtelemark.toString();
	 * statement.execute(cQuery); salida = "OK"; } catch (SQLException
	 * sqlException) { salida = "Imposible eliminar el registro."; log.error(
	 * "Error SQL en el metodo : bacoTmReasignacionSocioDelete( BigDecimal idcampacabe ) "
	 * + sqlException); } catch (Exception ex) { salida =
	 * "Imposible eliminar el registro."; log.error(
	 * "Salida por exception: en el metodo: bacoTmReasignacionSocioDelete( BigDecimal idcampacabe )  "
	 * + ex); } return salida; }
	 * 
	 * public String bacoTmReasignacionSocioIserto(BigDecimal idcampacabe,
	 * BigDecimal idtelemarkdestino, String filtros, String limit, BigDecimal
	 * idempresa, String usuarioalt) throws EJBException { String salida = "OK";
	 * long registros = 0; // validaciones de datos: // 1. nulidad de campos
	 * 
	 * if (idempresa == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idempresa "; if
	 * (idcampacabe == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idcampacabe "; if
	 * (idtelemarkdestino == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: idtelemarkdestino ";
	 * if (usuarioalt == null) salida =
	 * "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt "; // 2.
	 * sin nada desde la pagina
	 * 
	 * if (usuarioalt.equalsIgnoreCase("")) salida =
	 * "Error: No se puede dejar vacio el campo: usuarioalt ";
	 * 
	 * // fin validaciones
	 * 
	 * try { if (salida.equalsIgnoreCase("OK")) { String ins = "" +
	 * " INSERT INTO bacotmseleccionsocio(idcampacabe, idcliente, idtelemark, idempresa, usuarioalt)"
	 * + " SELECT DISTINCT ?, cl.idcliente, ?, cl.idempresa, ? " +
	 * "   FROM clientesclientes cl  " +
	 * "        INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa "
	 * +
	 * "        INNER JOIN globallocalidades lo ON cd.idlocalidad = lo.idlocalidad "
	 * +
	 * "        INNER JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
	 * +
	 * "        INNER JOIN clientesprecargaclientes pcc ON cl.idcliente = pcc.idcliente AND cl.idempresa = pcc.idempresa "
	 * +
	 * "        INNER JOIN vclientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
	 * +
	 * "        INNER JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa AND ca.fhasta IS NULL "
	 * + "  WHERE cl.idempresa = ? " + "    AND cl.idcliente NOT IN (" +
	 * "                      SELECT idcliente " +
	 * "                        FROM bacotmseleccionsocio " +
	 * "                       WHERE idcampacabe = ? AND idempresa = ? " +
	 * "                      )" + filtros + "  " + limit + ";";
	 * PreparedStatement insert = dbconn.prepareStatement(ins);
	 * insert.setBigDecimal(1, idcampacabe); insert.setBigDecimal(2,
	 * idtelemarkdestino); insert.setString(3, usuarioalt);
	 * insert.setBigDecimal(4, idempresa); insert.setBigDecimal(5, idcampacabe);
	 * insert.setBigDecimal(6, idempresa);
	 * 
	 * registros = insert.executeUpdate();
	 * 
	 * salida = registros + "";
	 * 
	 * }
	 * 
	 * } catch (SQLException sqlException) {
	 * 
	 * salida = "SQLE: No fue posible generar asignacin."; log
	 * .error("Error SQL public String bacoTmReasignacionSocioIserto(.....)" +
	 * sqlException);
	 * 
	 * } catch (Exception ex) { salida =
	 * "EX: No fue posible generar asignacin."; log
	 * .error("Error excepcion public String bacoTmReasignacionSocioIserto(.....)"
	 * + ex); }
	 * 
	 * return salida;
	 * 
	 * }
	 */
	// REASIGNACION DE SOCIOS MODIFICADA 03/02/2010 FGP
	public String bacoTmReasignacionSocioUpdate(BigDecimal idcampacabe,
			BigDecimal idtelemarkorigen, BigDecimal idtelemarkdestino,
			String filtros, String limit, BigDecimal idempresa,
			String usuarioact, String idclientedesde, String idclientehasta)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		long registros = 0;
		long totalregistros = 0;

		try {
			PreparedStatement insert = null;
			ResultSet rsSalida = null;
			List vecSalida = new ArrayList();
			if (limit.equals("") && idclientedesde.equals("")
					&& idclientehasta.equals("")) {
				String cQuery = ""
						+ " select idseleccion as  total from bacotmseleccionsocio"
						+ " WHERE idcampacabe = " + idcampacabe.toString()
						+ " and idempresa = " + idempresa.toString()
						+ " and idtelemark = " + idtelemarkorigen.toString();
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
			}
			if (!limit.equals("") && idclientedesde.equals("")
					&& idclientehasta.equals("")) {
				String cQuery = ""
						+ " select idseleccion as  total from bacotmseleccionsocio"
						+ " WHERE idcampacabe = " + idcampacabe.toString()
						+ " and idempresa = " + idempresa.toString()
						+ " and idtelemark = " + idtelemarkorigen.toString()
						+ limit;
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
			}
			if (limit.equals("") && !idclientedesde.equals("")
					&& !idclientehasta.equals("")) {
				String cQuery = ""
						+ " select idseleccion as  total from bacotmseleccionsocio"
						+ " WHERE idcampacabe = " + idcampacabe.toString()
						+ " and idempresa = " + idempresa.toString()
						+ " and idtelemark = " + idtelemarkorigen.toString()
						+ " and idcliente between " + idclientedesde.toString()
						+ " and " + idclientehasta.toString();
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
			}
			if (!limit.equals("") && !idclientedesde.equals("")
					&& !idclientehasta.equals("")) {
				String cQuery = ""
						+ " select idseleccion as  total from bacotmseleccionsocio"
						+ " WHERE idcampacabe = " + idcampacabe.toString()
						+ " and idempresa = " + idempresa.toString()
						+ " and idtelemark = " + idtelemarkorigen.toString()
						+ " and idcliente between " + idclientedesde.toString()
						+ " and " + idclientehasta.toString() + limit;
				Statement statement = dbconn.createStatement();
				rsSalida = statement.executeQuery(cQuery);
			}

			while (rsSalida.next()) {
				String sql = ""
						+ " UPDATE bacotmseleccionsocio SET idtelemark = ?,usuarioact = ?  where idseleccion = "
						+ rsSalida.getLong("total");
				insert = dbconn.prepareStatement(sql);
				insert.setBigDecimal(1, idtelemarkdestino);
				insert.setString(2, usuarioact);
				registros = insert.executeUpdate();
				totalregistros = totalregistros + 1;
			}
			salida = totalregistros + "";
		} catch (SQLException sqlException) {

			salida = "SQLE: No fue posible generar asignacion.";
			log
					.error("Error SQL public String bacoTmReasignacionSocioUpdate(.....)"
							+ sqlException);

		} catch (Exception ex) {
			salida = "EX: No fue posible generar asignacion.";
			log
					.error("Error excepcion public String bacoTmReasignacionSocioUpdate(.....)"
							+ ex);
		}

		return salida;

	}

	public ResultSet getClientesBajasporVendedor(String anio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				// + " mes.idmes, "
				+ " mes.mes, "
				+ " ven.vendedor, "
				+ " count(precarga.idprecarga) as asociaciones, "
				+ " count(esta.idcliente) as bajas "
				+ getPivotSumar("globalmeses", "idmes", "1")// ,"idmes = date_part('month',precarga.fechadeingreso)")
				+ " from "
				+ " clientesvendedor ven "
				+ " join clientesprecargaclientes precarga on (ven.idvendedor = precarga.idvendedorasignado and ven.idempresa = precarga.idempresa) "
				+ " left join globalmeses mes on (  mes.idmes = date_part('month',precarga.fechadeingreso) ) "
				+ " left join clientesestadosclientes esta on ( precarga.idcliente = esta.idcliente and esta.idestado = 2 and date_part('month',esta.fechadesde) = mes.idmes ) "
				+ " where " + " ven.idempresa = " + idempresa.toString()
				+ " and date_part('year',precarga.fechadeingreso) = "
				+ anio.toString() + " group by " + " mes.idmes," + " mes.mes, "
				+ " ven.vendedor " + " order by 3,mes.idmes ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL en el metodo : getClientesBajasporVendedor() "
					+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesBajasporVendedor()  "
							+ ex);
		}
		return rsSalida;
	}

	public ResultSet getClientesBajasporVendedorTotal(String anio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				// + " mes.idmes, "
				+ " mes.mes, "
				+ " 'TOTAL' as total,"
				+ " count(precarga.idprecarga) as asociaciones, "
				+ " count(esta.idcliente) as bajas "
				+ getPivotContar("globalmeses", "mes", "esta.idcliente")
				+ " from "
				+ " clientesvendedor ven "
				+ " join clientesprecargaclientes precarga on (ven.idvendedor = precarga.idvendedorasignado and ven.idempresa = precarga.idempresa) "
				+ " left join globalmeses mes on (  mes.idmes = date_part('month',precarga.fechadeingreso) ) "
				+ " left join clientesestadosclientes esta on ( precarga.idcliente = esta.idcliente and esta.idestado = 2 and date_part('month',esta.fechadesde) = mes.idmes ) "
				+ " where " + " ven.idempresa = " + idempresa.toString()
				+ " and date_part('year',precarga.fechadeingreso) = "
				+ anio.toString() + " group by " + " mes.idmes," + " mes.mes, "
				+ " ven.vendedor " + " order by 3,mes.idmes ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesBajasporVendedorTotal() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesBajasporVendedorTotal()  "
							+ ex);
		}
		return rsSalida;
	}

	public List getVPedidosEstadoconFechaAll(long limit, long offset,
			BigDecimal idestado, String tipopedido, BigDecimal idempresa,
			String fdesde, String fhasta) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa "
				+ "  FROM VPEDIDOSESTADO WHERE "
				+ (idestado.longValue() > 0 ? " idestado = "
						+ idestado.toString() + " AND " : "") + " idempresa = "
				+ idempresa.toString() + " AND UPPER(tipopedido) = '"
				+ tipopedido.toUpperCase() + "' AND fechapedido between '"
				+ fdesde.toString() + "' and '" + fhasta.toString() + "'"
				+ "  ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoconFechaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVPedidosEstadoconFechaOcu(long limit, long offset,
			BigDecimal idestado, String tipopedido, String ocurrencia,
			BigDecimal idempresa, String fdesde, String fhasta)
			throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "       origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa "
				+ "  FROM VPEDIDOSESTADO WHERE  "
				+ (idestado.longValue() > 0 ? " idestado = "
						+ idestado.toString() + " AND " : "")
				+ "  ( idcliente::VARCHAR  LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(razon)  LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " AND UPPER(tipopedido) = '"
				+ tipopedido.toUpperCase() + "' and fechapedido between '"
				+ fdesde.toString() + "' and '" + fhasta.toString() + "'"
				+ " ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosEstadoconFechaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/*
	 * 
	 * */
	public List getPedidoStockNegativoAll(long limit, long offset,
			String codigo_st, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_cabe, es.idestado, es.estado, pc.idcliente, cl.razon, "
				+ "       pd.codigo_st, pd.cantidad_sb, pc.usuarioalt AS usuario, pd.fecha, "
				+ "       pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact   "
				+ "  FROM pedidos_deta pd "
				+ "       INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
				+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa AND pc.idestado IN (1, 3)"
				+ " WHERE pd.cantidad_sb < 1 "
				+ (!codigo_st.equals("") ? " AND codigo_st = '" + codigo_st
						+ "'" : "") + " AND pd.idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidoStockNegativoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidoStockNegativoOcu(long limit, long offset,
			String ocurrencia, String codigo_st, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_cabe, es.idestado, es.estado, pc.idcliente, cl.razon,  "
				+ "       pd.codigo_st, pd.cantidad_sb, pc.usuarioalt AS usuario, pd.fecha, "
				+ "       pc.usuarioalt, pc.usuarioact, pc.fechaalt, pc.fechaact   "
				+ "  FROM pedidos_deta pd "
				+ "       INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
				+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
				+ "       INNER JOIN pedidosestados es ON pc.idestado = es.idestado AND pc.idempresa = es.idempresa  AND pc.idestado IN (1, 3)"
				+ " WHERE cantidad_sb < 1 "
				+ (!codigo_st.equals("") ? " AND codigo_st = '" + codigo_st
						+ "'" : "") + " AND "
				+ " (pc.idcliente::VARCHAR LIKE '%" + ocurrencia + "%' OR "
				+ " UPPER(cl.razon) LIKE '%" + ocurrencia.toUpperCase()
				+ "%') AND pd.idempresa = " + idempresa.toString()
				+ " ORDER BY 1 DESC LIMIT " + limit + " OFFSET  " + offset
				+ ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidoStockNegativoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// lov suspension entregas regulares motivos
	public List getClientesSuspensionMotivosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " SELECT idmotsusp,motsusp,"
				+ "       usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientessuspentregasregularesmotivos WHERE idempresa="
				+ idempresa.toString() + " ORDER BY 2 DESC LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesSuspensionMotivosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public ResultSet getClientesVentasporProductosyCampaniaporTelemark(
			String fechaD, String fechaH, BigDecimal idempresa,
			String idtelemark) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ " select "
				+ " cabe.usuarioalt as telemarketer, "
				+ " deta.codigo_st as producto, "
				+ " sum(deta.cantidad) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad")
				+ " from "
				+ " pedidos_cabe cabe join pedidos_deta deta on ( cabe.idpedido_cabe = deta.idpedido_cabe and cabe.idempresa = deta.idempresa) "
				+ " where cabe.idempresa = "
				+ idempresa
				+ "   AND cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " and cabe.idestado in(1,2)" // pendiente o realizado
				+ " and upper(cabe.usuarioalt) in (select upper(usuario) from globalusuarios where idusuario in( select idusuario from globalusuariosgrupos where idgrupo=17)) " // solo
				// telemarketers
				+ " and origenpedido <> 'ER' "
				+ " and UPPER(cabe.usuarioalt) =  " + "'"
				+ idtelemark.toUpperCase() + "'" + " group by "
				+ " cabe.usuarioalt, deta.codigo_st " + " ORDER BY 1, 3 desc  ";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesVentasporProductosyCampaniaporTelemark() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesVentasporProductosyCampaniaporTelemark()  "
							+ ex);
		}
		return rsSalida;
	}

	public static void closeResultset(ResultSet rs) {

		try {

			if (rs != null)
				rs.close();

		} catch (SQLException sqle) {

			log.error("(SQLE)closeResultset: " + sqle);

		} catch (Exception e) {

			log.error("(E)closeResultset: " + e);
		}

	}

	/**
	 * Metodos para la entidad: bacoObsequiosLocalidad Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Nov 04 15:51:58 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoObsequiosLocalidadAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ol.idobsequio,ol.idlocalidad,l.localidad, l.cpostal, "
				+ "             p.idprovincia, p.provincia,ol.cartaoregalo,ol.informecarta, ol.restaurant,"
				// 20110331 - EJV - Mantis 685 -->
				+ "             ct.idclusterlogistica, ct.clusterlogistica, "
				// <--
				+ "             ol.idempresa,ol.usuarioalt,ol.usuarioact,ol.fechaalt,ol.fechaact "
				+ "   FROM bacoobsequioslocalidad ol "
				+ "            INNER JOIN globallocalidades l ON ol.idlocalidad = l.idlocalidad "
				+ "            INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "

				// 20110331 - EJV - Mantis 685 -->
				+ "            LEFT JOIN bacoclusterslogistica ct ON ol.idclusterlogistica = ct.idclusterlogistica  AND ol.idempresa = ct.idempresa "
				// <--
				+ " WHERE ol.idempresa = " + idempresa.toString()
				+ "  ORDER BY p.provincia, l.localidad  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosLocalidadAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoObsequiosLocalidadOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ol.idobsequio,ol.idlocalidad,l.localidad, l.cpostal, "
				+ "             p.idprovincia, p.provincia,ol.cartaoregalo,ol.informecarta, ol.restaurant,"
				// 20110331 - EJV - Mantis 685 -->
				+ "             ct.idclusterlogistica, ct.clusterlogistica, "
				// <--
				+ "             ol.idempresa,ol.usuarioalt,ol.usuarioact,ol.fechaalt,ol.fechaact "
				+ "   FROM bacoobsequioslocalidad ol "
				+ "             INNER JOIN globallocalidades l ON ol.idlocalidad = l.idlocalidad "
				+ "             INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "
				// 20110331 - EJV - Mantis 685 -->
				+ "       LEFT JOIN bacoclusterslogistica ct ON bo.idclusterlogistica = ct.idclusterlogistica  AND bo.idempresa = ct.idempresa"
				// <--
				+ " WHERE (UPPER(l.localidad) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(l.cpostal) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(ol.restaurant) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND ol.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY p.provincia, l.localidad  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosLocalidadOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoObsequiosLocalidadPK(BigDecimal idobsequio,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ol.idobsequio,ol.idlocalidad,l.localidad,ol.cartaoregalo,ol.informecarta,"
				+ "            ol.restaurant, ct.idclusterlogistica, ct.clusterlogistica,"
				+ "            ol.idempresa,ol.usuarioalt,ol.usuarioact,ol.fechaalt,ol.fechaact "
				+ "  FROM bacoobsequioslocalidad ol "
				+ "       INNER JOIN globallocalidades l ON ol.idlocalidad = l.idlocalidad "
				// 20110331 - EJV - Mantis 685 -->
				+ "       LEFT JOIN bacoclusterslogistica ct ON ol.idclusterlogistica = ct.idclusterlogistica  AND ol.idempresa = ct.idempresa"
				// <--
				+ " WHERE ol.idobsequio=" + idobsequio.toString()
				+ " AND ol.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosLocalidadPK( BigDecimal idobsequio )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoObsequiosLocalidadDelete(BigDecimal idobsequio,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOOBSEQUIOSLOCALIDAD WHERE idobsequio="
				+ idobsequio.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOOBSEQUIOSLOCALIDAD WHERE idobsequio="
						+ idobsequio.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoObsequiosLocalidadDelete( BigDecimal idobsequio, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoObsequiosLocalidadDelete( BigDecimal idobsequio, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoObsequiosLocalidadCreate(BigDecimal idlocalidad,
			String cartaoregalo, String informecarta, String restaurant,
			BigDecimal idclusterlogistica, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (cartaoregalo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cartaoregalo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (cartaoregalo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cartaoregalo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (getTotalEntidadFiltro("bacoobsequioslocalidad",
				"WHERE idlocalidad=" + idlocalidad + " AND cartaoregalo='"
						+ cartaoregalo.toUpperCase() + "'", idempresa) > 0)
			salida = "Error: Ya existe definido el tipo de obsequio para la localidad. ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO bacoobsequioslocalidad"
						+ "       (idlocalidad, cartaoregalo, informecarta, restaurant, idclusterlogistica, idempresa, usuarioalt ) "
						+ "VALUES (?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idlocalidad);
				insert.setString(2, cartaoregalo);
				insert.setString(3, informecarta);
				insert.setString(4, restaurant);
				insert.setBigDecimal(5, idclusterlogistica);
				insert.setBigDecimal(6, idempresa);
				insert.setString(7, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoObsequiosLocalidadCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoObsequiosLocalidadCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoObsequiosLocalidadCreateOrUpdate(BigDecimal idobsequio,
			BigDecimal idlocalidad, String cartaoregalo, String informecarta,
			String restaurant, BigDecimal idclusterlogistica,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idobsequio ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (cartaoregalo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cartaoregalo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (cartaoregalo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cartaoregalo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoObsequiosLocalidad WHERE idobsequio = "
					+ idobsequio.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOOBSEQUIOSLOCALIDAD SET idlocalidad=?, cartaoregalo=?, informecarta=?, restaurant=?, idclusterlogistica=?,  idempresa=?, usuarioact=?, fechaact=? WHERE idobsequio=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idlocalidad);
					insert.setString(2, cartaoregalo);
					insert.setString(3, informecarta);
					insert.setString(4, restaurant);
					insert.setBigDecimal(5, idclusterlogistica);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idobsequio);
				} else {
					String ins = "INSERT INTO BACOOBSEQUIOSLOCALIDAD(idlocalidad, cartaoregalo, informecarta, restaurant,idclusterlogistica, idempresa, usuarioalt ) "
							+ "VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idlocalidad);
					insert.setString(2, cartaoregalo);
					insert.setString(3, informecarta);
					insert.setString(4, restaurant);
					insert.setBigDecimal(5, idclusterlogistica);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoObsequiosLocalidadCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoObsequiosLocalidadCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoObsequiosLocalidadUpdate(BigDecimal idobsequio,
			BigDecimal idlocalidad, String cartaoregalo, String informecarta,
			String restaurant, BigDecimal idclusterlogistica,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idobsequio ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (cartaoregalo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cartaoregalo ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (cartaoregalo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: cartaoregalo ";

		if (getTotalEntidadFiltro("bacoobsequioslocalidad",
				"WHERE idlocalidad=" + idlocalidad + " AND cartaoregalo='"
						+ cartaoregalo.toUpperCase() + "' AND idobsequio <> "
						+ idobsequio, idempresa) > 0)
			salida = "Error: Ya existe definido el tipo de obsequio para la localidad. ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoObsequiosLocalidad WHERE idobsequio = "
					+ idobsequio.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOOBSEQUIOSLOCALIDAD SET idlocalidad=?, cartaoregalo=?, informecarta=?, restaurant=?, idclusterlogistica=? ,idempresa=?, usuarioact=?, fechaact=? WHERE idobsequio=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idlocalidad);
					insert.setString(2, cartaoregalo);
					insert.setString(3, informecarta);
					insert.setString(4, restaurant);
					insert.setBigDecimal(5, idclusterlogistica);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idobsequio);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoObsequiosLocalidadUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoObsequiosLocalidadUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoProcesoObsequios Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Nov 05 11:24:51 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoProcesoObsequiosAll(long limit, long offset,
			BigDecimal idtipoobsequio, int mesCumpleanos, int anio, int mes,
			BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		cQuery = "SELECT cl.idcliente, cl.razon, pc.fechadenacimiento, dm.calle, dm.idanexolocalidad, ax.idlocalidad, lo.localidad, "
				+ "       pv.idprovincia, pv.provincia, es.idestado, es.estado, "
				+ "       COALESCE(bo.cartaoregalo, 'N') AS cartaoregalo, "
				+ "       CASE bo.cartaoregalo "
				+ "           WHEN 'C' THEN 'CARTA' "
				+ "           WHEN 'R' THEN 'REGALO'"
				+ "       ELSE "
				+ "           'NO DEF.' END AS descobs, informecarta, "
				+ "       CASE WHEN pe.idpedido_cabe IS NOT NULL THEN 'GENERADO' ELSE  'PENDIENTE' END AS permite," // COALESCE(t.tot,
				// 0)
				// AS
				// tot,
				+ "       cl.idempresa, cl.usuarioalt, cl.usuarioact, cl.fechaalt, cl.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientesdomicilios dm ON cl.idcliente = dm.idcliente AND cl.idempresa = dm.idempresa AND dm.esdefault = 'S' "
				+ "       INNER JOIN clientesprecargaclientes pc ON cl.idcliente = pc.idcliente AND cl.idempresa = pc.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON dm.idanexolocalidad = ax.idanexolocalidad AND dm.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia "
				+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa AND es.idestado = 1 "
				+ "        LEFT JOIN bacoobsequioslocalidad bo ON lo.idlocalidad = bo.idlocalidad AND bo.idempresa = "
				+ idempresa.toString()
				+ "        LEFT JOIN pedidos_cabe pe ON cl.idcliente = pe.idcliente AND cl.idempresa = pe.idempresa "
				+ "               AND pe.idestado <> 4 AND  DATE_PART('MONTH', pe.fechapedido) = "
				+ mes
				+ "               AND DATE_PART('YEAR', pe.fechapedido) = "
				+ anio
				+ "               AND pe.origenpedido = 'PO' || "
				+ idtipoobsequio
				// Subquery indica si ya se genero para el proceso para ese
				// ao.
				// -------->
				// + "        LEFT JOIN ( "
				// +
				// "                   SELECT COUNT(1) AS tot, idcliente, idempresa "
				// + "                     FROM pedidos_cabe "
				// +
				// "                    WHERE idestado <> 4 AND origenpedido = 'PO' || "
				// + idtipoobsequio
				// +
				// "                      AND DATE_PART('YEAR', fechapedido) = "
				// + anio
				// + "                      AND idempresa = "
				// + idempresa
				// + "                    GROUP BY idcliente,  "
				// + "                             idempresa, origenpedido, "
				// +
				// "                             DATE_PART('YEAR', fechapedido) "
				// +
				// "                  )t ON cl.idcliente = t.idcliente AND t.idempresa = cl.idempresa "
				// < -------
				+ " WHERE cl.idtipoclie IN (1, 10) AND cl.idempresa = "
				+ idempresa.toString()
				+ "   AND DATE_PART('MONTH', pc.fechadenacimiento) = "
				+ mesCumpleanos
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoProcesoObsequiosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoProcesoObsequiosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idtipoobsequio, int mesCumpleanos,
			int anio, int mes, BigDecimal idempresa) throws EJBException {

		String cQuery = "";
		cQuery = "SELECT cl.idcliente, cl.razon, pc.fechadenacimiento, dm.calle, dm.idanexolocalidad, ax.idlocalidad, lo.localidad, "
				+ "       pv.idprovincia, pv.provincia, es.idestado, es.estado, "
				+ "       COALESCE(bo.cartaoregalo, 'N') AS cartaoregalo, "
				+ "       CASE bo.cartaoregalo "
				+ "           WHEN 'C' THEN 'CARTA' "
				+ "           WHEN 'R' THEN 'REGALO'"
				+ "       ELSE "
				+ "           'NO DEF.' END AS descobs, bo.informecarta, "
				+ "       CASE WHEN pe.idpedido_cabe IS NOT NULL THEN 'GENERADO' ELSE  'PENDIENTE' END AS permite," // COALESCE(t.tot,
				// 0)
				// AS
				// tot,
				+ "       cl.idempresa, cl.usuarioalt, cl.usuarioact, cl.fechaalt, cl.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientesdomicilios dm ON cl.idcliente = dm.idcliente AND cl.idempresa = dm.idempresa AND dm.esdefault = 'S' "
				+ "       INNER JOIN clientesprecargaclientes pc ON cl.idcliente = pc.idcliente AND cl.idempresa = pc.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON dm.idanexolocalidad = ax.idanexolocalidad AND dm.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia "
				+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa  AND es.idestado = 1 "
				+ "        LEFT JOIN bacoobsequioslocalidad bo ON lo.idlocalidad = bo.idlocalidad  AND bo.idempresa = "
				+ idempresa.toString()
				+ "        LEFT JOIN pedidos_cabe pe ON cl.idcliente = pe.idcliente AND cl.idempresa = pe.idempresa "
				+ "              AND pe.idestado <> 4 AND  DATE_PART('MONTH', pe.fechapedido) = "
				+ mes
				+ "              AND  DATE_PART('YEAR', pe.fechapedido) = "
				+ anio
				+ "              AND pe.origenpedido = 'PO' || "
				+ idtipoobsequio

				// Subquery indica si ya se genero para el proceso para ese
				// ao
				// (Por ahroa stand-by).
				// -------->
				// + "        LEFT JOIN ( "
				// +
				// "                   SELECT COUNT(1) AS tot, idcliente, idempresa "
				// + "                     FROM pedidos_cabe "
				// +
				// "                    WHERE idestado <> 4 AND origenpedido = 'PO' || "
				// + idtipoobsequio
				// +
				// "                      AND DATE_PART('YEAR', fechapedido) = "
				// + anio
				// + "                      AND idempresa = "
				// + idempresa
				// + "                    GROUP BY idcliente,  "
				// + "                             idempresa, origenpedido, "
				// +
				// "                             DATE_PART('YEAR', fechapedido) "
				// +
				// "                  )t ON cl.idcliente = t.idcliente AND t.idempresa = cl.idempresa "
				// < -------

				+ "WHERE (UPPER(cl.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(cl.idcliente::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')AND cl.idtipoclie IN (1, 10) AND cl.idempresa = "
				+ idempresa.toString()
				+ "   AND DATE_PART('MONTH', pc.fechadenacimiento) = "
				+ mesCumpleanos
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoProcesoObsequiosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoProcesObsequiosFromFileAll(long limit, long offset,
			String tablename, String[] idclienteTmp, boolean impactaTmp,
			BigDecimal idtipoobsequio, int anio, int mes, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		Statement pstatement = null;
		String cQuery = "";
		long total = -1;
		List vecSalida = new ArrayList();

		try {

			pstatement = dbconn.createStatement();

			if (impactaTmp) {

				total = getTotalEntidadFiltro(
						"(SELECT table_name, 1 AS idempresa FROM information_schema.tables) entidad ",
						"  WHERE table_name = '" + tablename + "_aux' ",
						idempresa);

				String qDDL = "";
				String qDML = "";

				if (total > 0) {

					qDDL = "DROP TABLE " + tablename + "_aux";
					pstatement.addBatch(qDDL);

					qDDL = "DROP TABLE " + tablename;
					pstatement.addBatch(qDDL);

				}

				qDDL = "CREATE TEMPORARY TABLE "
						// qDDL = "CREATE  TABLE "
						+ tablename
						+ "_aux (idcliente numeric(18), idempresa numeric(18));";

				pstatement.addBatch(qDDL);

				for (int r = 0; r < idclienteTmp.length; r++) {

					// log.debug("DATOS - idclienteTmp[" + r + "]: "
					// + idclienteTmp[r]);
					qDML = "INSERT INTO " + tablename + "_aux  VALUES( "
							+ idclienteTmp[r] + ", " + idempresa + " );";
					pstatement.addBatch(qDML);

				}

				qDDL = "CREATE TEMPORARY TABLE "
						// qDDL = "CREATE  TABLE "
						+ tablename
						+ " AS "
						+ "SELECT cl.idcliente, cl.razon, pc.fechadenacimiento, dm.calle, dm.idanexolocalidad, "
						+ "       ax.idlocalidad, COALESCE(lo.localidad, 'INDEFINIDA') AS localidad, "
						+ "       COALESCE(pv.idprovincia, -1) AS idprovincia, COALESCE(pv.provincia, 'INDEFINIDA') AS provincia, "
						+ "       es.idestado, es.estado, "
						+ "       'R' AS cartaoregalo,"
						// EJV 20091222 - Mantis 489
						// +
						// "       COALESCE(bo.cartaoregalo, 'N') AS cartaoregalo, "
						// + "       CASE bo.cartaoregalo "
						// + "           WHEN 'C' THEN 'CARTA' "
						// + "           WHEN 'R' THEN 'REGALO'"
						// + "       ELSE "
						// +
						// "           'NO DEF.' END AS descobs, informecarta, "
						+ "       'REGALO' AS descobs, '' AS informecarta, "
						+ "       CASE WHEN pe.idpedido_cabe IS NOT NULL THEN 'GENERADO' ELSE  'PENDIENTE' END AS permite,"
						// COALESCE(t.tot, 0) AS tot,
						+ "       cl.idempresa, cl.usuarioalt, cl.usuarioact, cl.fechaalt, cl.fechaact "
						+ "  FROM "
						+ tablename
						+ "_aux aux "
						+ "       INNER JOIN clientesclientes cl ON aux.idcliente = cl.idcliente "
						+ "       INNER JOIN clientesdomicilios dm ON cl.idcliente = dm.idcliente AND cl.idempresa = dm.idempresa AND dm.esdefault = 'S' "
						+ "       INNER JOIN clientesprecargaclientes pc ON cl.idcliente = pc.idcliente AND cl.idempresa = pc.idempresa "
						+ "       INNER JOIN clientesanexolocalidades ax ON dm.idanexolocalidad = ax.idanexolocalidad AND dm.idempresa = ax.idempresa "
						+ "       LEFT JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
						+ "       LEFT JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia "
						+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
						// EJV 20091222 - Mantis 489
						// +
						// "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa AND es.idestado = 1 "
						+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa  "
						// EJV 20091222 - Mantis 489
						// +
						// "        LEFT JOIN bacoobsequioslocalidad bo ON lo.idlocalidad = bo.idlocalidad AND bo.cartaoregalo = 'R'"
						+ "        LEFT JOIN pedidos_cabe pe ON cl.idcliente = pe.idcliente AND cl.idempresa = pe.idempresa "
						+ "               AND pe.idestado <> 4 AND  DATE_PART('MONTH', pe.fechapedido) = "
						+ mes
						+ "               AND DATE_PART('YEAR', pe.fechapedido) = "
						+ anio
						+ "               AND pe.origenpedido = 'PO' || "
						+ idtipoobsequio
						// Subquery indica si ya se genero para el proceso para
						// ese
						// ao.
						// -------->
						// + "        LEFT JOIN ( "
						// +
						// "                   SELECT COUNT(1) AS tot, idcliente, idempresa "
						// + "                     FROM pedidos_cabe "
						// +
						// "                    WHERE idestado <> 4 AND origenpedido = 'PO' || "
						// + idtipoobsequio
						// +
						// "                      AND DATE_PART('YEAR', fechapedido) = "
						// + anio
						// + "                      AND idempresa = "
						// + idempresa
						// + "                    GROUP BY idcliente,  "
						// +
						// "                             idempresa, origenpedido, "
						// +
						// "                             DATE_PART('YEAR', fechapedido) "
						// +
						// "                  )t ON cl.idcliente = t.idcliente AND t.idempresa = cl.idempresa "
						// < -------
						// EJV 20091222 - Mantis 489
						// +
						// " WHERE cl.idtipoclie IN (1, 10) AND cl.idempresa = "
						+ " WHERE cl.idempresa = " + idempresa.toString()
						+ "  ORDER BY 2;";

				// log.info("qDDL: " + qDDL);

				pstatement.addBatch(qDDL);
				pstatement.executeBatch();

			}

			// ----

			cQuery = ""
					+ "SELECT idcliente, razon, fechadenacimiento, calle, idanexolocalidad, idlocalidad, localidad, "
					+ "       idprovincia, provincia, idestado, estado, cartaoregalo, descobs, informecarta, permite, "
					+ "       idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
					+ "  FROM  " + tablename + " LIMIT " + limit + " OFFSET "
					+ offset;

			// log.info("------");
			// log.info("------");
			// log.info("cQuery: " + cQuery);
			// log.info("------");
			// log.info("------");

			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			ResultSetMetaData md = rsSalida.getMetaData();
			while (rsSalida.next()) {
				int totCampos = md.getColumnCount() - 1;
				String[] sSalida = new String[totCampos + 1];
				int i = 0;
				while (i <= totCampos) {
					sSalida[i] = rsSalida.getString(++i);
				}
				vecSalida.add(sSalida);
			}
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getBacoProcesObsequiosFromFileAll() "
							+ sqlException
							+ " - Next: "
							+ sqlException.getNextException());

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoProcesObsequiosFromFileAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: bacoTipoObsequios Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Nov 05 14:51:35 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoTipoObsequiosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipoobsequio,tipoobsequio,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM bacotipoobsequios WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoTipoObsequiosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * @Comment: PROCESO DE OBSEQUIOS - EJV -- > BEGIN
	 * @author ejv
	 * @date: 20091106
	 * 
	 * */

	public String[] setProcesoObsequios(String[] vecIdcliente, int anio,
			int idmes, BigDecimal idtipoobsequio, boolean fromfile,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		String warnings = "";

		BigDecimal idcampacabe = null;
		BigDecimal idestado = new BigDecimal(1);
		BigDecimal idcliente = new BigDecimal(-1);
		BigDecimal idsucursal = new BigDecimal(-1);
		BigDecimal idsucuclie = new BigDecimal(-1);
		BigDecimal idcondicion = new BigDecimal(-1);
		BigDecimal idvendedor = new BigDecimal(-1);
		BigDecimal idexpreso = new BigDecimal(-1);
		BigDecimal comision = new BigDecimal(0);
		BigDecimal ordencompra = null;
		String obsarmado = "";
		String obsentrega = "";
		BigDecimal recargo = new BigDecimal(0);
		BigDecimal bonific = new BigDecimal(0);
		BigDecimal idlista = new BigDecimal(-1);
		BigDecimal idmoneda = new BigDecimal(-1);
		BigDecimal cotizacion = new BigDecimal(0);
		BigDecimal idtipoiva = new BigDecimal(-1);
		BigDecimal totaliva = new BigDecimal(0);
		BigDecimal idprioridad = new BigDecimal(1);
		BigDecimal idzona = new BigDecimal(-1);
		// 20100804 - EJV - Reasignacion -->
		BigDecimal idanexolocalidad = new BigDecimal(-1);
		// <--

		BigDecimal idtarjeta = new BigDecimal(-1);

		// 20110818 - EJV - Error al generar plan de cuotas para generacion de
		// tarjetas -->
		// BigDecimal cuotas = new BigDecimal(0);
		BigDecimal cuotas = new BigDecimal(1);
		// <--

		String origenpedido = "PO";
		BigDecimal total = new BigDecimal(0);
		String tipopedido = "N";
		List listEsquemaPorTipo = new ArrayList();
		Hashtable htArticulos = new Hashtable();
		Hashtable htArticulosRegalo = new Hashtable();
		Hashtable htArticulosCarta = new Hashtable();
		List listCliente = new ArrayList();
		String[] resultado = new String[2];

		java.sql.Date hoy = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());
		Calendar cal = new GregorianCalendar();
		cal.set(anio, idmes - 1, 1, 0, 0, 0);

		Timestamp fechapedido = new Timestamp(cal.getTimeInMillis());
		origenpedido += idtipoobsequio;

		log.info("BEGIN CALL{ setProcesoObsequios }");

		try {

			listEsquemaPorTipo = getBacoObsequiosEsquemaPeriodo(idmes, anio,
					idtipoobsequio, "R", idempresa);

			warnings += setHashEsquemaObsequios(listEsquemaPorTipo,
					htArticulosRegalo)
					+ "\n";

			listEsquemaPorTipo = getBacoObsequiosEsquemaPeriodo(idmes, anio,
					idtipoobsequio, "C", idempresa);

			warnings += setHashEsquemaObsequios(listEsquemaPorTipo,
					htArticulosCarta)
					+ "\n";

			for (int i = 0; vecIdcliente != null && i < vecIdcliente.length; i++) {

				idcliente = new BigDecimal(vecIdcliente[i]);

				log.info("PEDIDO PO-CLIENTE: " + idcliente);

				listCliente = getClientesClientesPK(idcliente, idempresa);

				if (listCliente != null && !listCliente.isEmpty()) {

					String[] datos = (String[]) listCliente.get(0);

					idsucursal = new BigDecimal(-1);

					// --
					/*
					 * 
					 * 20091126 - EJV Esto no debe ir, si es obsequio la
					 * condicion de pago no interesa
					 */
					// idcondicion = new BigDecimal(datos[8]);
					// HARDCODE como 2-Contra Entrega
					// idcondicion = new BigDecimal(2);
					// 20110102 - EJV - Mantis 670: se quita HARDCODE
					idcondicion = new BigDecimal(datos[8]);

					idvendedor = new BigDecimal(datos[27]);
					idlista = new BigDecimal(datos[16]);
					idmoneda = new BigDecimal(datos[14]);
					idtipoiva = new BigDecimal(datos[6]);

					List listDomiDef = getClientesDomiciliosClienteDefault(
							idcliente, idempresa);

					if (listDomiDef != null && !listDomiDef.isEmpty()) {

						String[] datosDom = (String[]) listDomiDef.get(0);

						idsucuclie = new BigDecimal(datosDom[0]);// *
						idexpreso = new BigDecimal(
								datosDom[21] != null ? datosDom[21] : "-1");
						obsentrega = datosDom[40];
						idzona = new BigDecimal(
								datosDom[19] != null ? datosDom[19] : "-1");

						// 20100804 - EJV - Reasignacion -->
						idanexolocalidad = new BigDecimal(
								datosDom[39] != null ? datosDom[39] : "-1");
						// <--

						// 20110802 - EJV - Mantis 759 -->
						// idtarjeta = new BigDecimal(-1);// *
						if (idcondicion.intValue() == 5)
							idtarjeta = getTarjetaClienteERyPO(idcliente, hoy,
									anio, idmes, false, "PO", idempresa,
									usuarioalt);
						else
							idtarjeta = new BigDecimal(-1);// *
						// <--

						// Por definicion siempre que obsequio desde archivo, el
						// tipo de obsequio es un regalo.

						if (fromfile) {

							htArticulos = htArticulosRegalo;
						} else if (datosDom[41].equalsIgnoreCase("R")) {

							htArticulos = htArticulosRegalo;
						} else if (datosDom[41].equalsIgnoreCase("C")) {

							htArticulos = htArticulosCarta;

						} else {

							htArticulos = new Hashtable();
						}

						// 20110124 - EJV - Mantis 597 -->
						BigDecimal idpromocion = null;
						// <--

						resultado = pedidosNormalesCreate(idcampacabe,
								idestado, idcliente, idsucursal, idsucuclie,
								fechapedido, idcondicion, idvendedor,
								idexpreso, comision, ordencompra, obsarmado,
								obsentrega, recargo, recargo, recargo, recargo,
								bonific, bonific, bonific, idlista, idmoneda,
								cotizacion, idtipoiva, totaliva, idprioridad,
								idzona, idtarjeta, cuotas, origenpedido, total,
								tipopedido, htArticulos, new BigDecimal(-10),
								idanexolocalidad, idpromocion, null,
								new java.sql.Date(fechapedido.getTime()),
								usuarioalt, idempresa, props);

						warnings += resultado[0]
								+ " / "
								+ (resultado[1] != null
										&& resultado[1].equals("") ? resultado[1]
										.replace("#",
												"Cantidades insuficientes: ")
										: "") + "\n";

						// --

					} else {

						warnings += "No hay domicilio default para el cliente: "
								+ idcliente + "\n";

						log.warn("No hay domicilio default para el cliente: "
								+ idcliente);
					}

				} else {

					warnings += "No fue posible recuperar datos para el cliente: "
							+ idcliente + "\n";
					log.warn("No fue posible recuperar datos para el cliente: "
							+ idcliente);
				}

			}

		} catch (Exception e) {
			log.error("setProcesoObsequios(): " + e);
		}

		log.info("\n===========================================");
		log.info(warnings + "\n===========================================");

		log.info("END CALL{ setProcesoObsequios }");

		return new String[] { salida, warnings.replaceAll("\n", "<BR>") };

	}

	// 20110802 - EJV - Mantis 759 -->
	private BigDecimal getTarjetaClienteERyPO(BigDecimal idcliente,
			java.sql.Date hoy, int anio, int mes, boolean registra,
			String proceso, BigDecimal idempresa, String usuarioalt) {

		BigDecimal idtarjeta = new BigDecimal(-1);
		String status = "";

		try {

			List listaTarjetasCredito = getClienteTarjetasCliente(100, 0,
					idcliente, idempresa);

			if (listaTarjetasCredito != null && !listaTarjetasCredito.isEmpty()) {

				Iterator iter = listaTarjetasCredito.iterator();

				// java.sql.Date hoy = new java.sql.Date(Calendar.getInstance()
				// .getTimeInMillis());

				while (iter.hasNext()) {

					String datosTarjeta[] = (String[]) iter.next();

					// || (datosTarjeta[12])-
					// 20110126 - EJV - Mantis 667
					if (datosTarjeta[12] == null
							|| !(datosTarjeta[12]).equalsIgnoreCase("S")) {

						status = proceso
								+ ": condicion de pago Tarjeta: tarjeta inactiva para cliente:"
								+ idcliente;
						// 20110126 - EJV Mantis 667
						// (java.sql.Date.valueOf(datosTarjeta[9]).after(hoy))
					} else if (java.sql.Date.valueOf(datosTarjeta[9]).before(
							hoy)) {
						status = proceso
								+ ": condicion de pago Tarjeta: tarjeta vencida para cliente:"
								+ idcliente;
					} else {

						idtarjeta = new BigDecimal(datosTarjeta[0]);
						status = "";

						break;
					}

					// 20110126 - EJV Mantis 667 -->
					if (!status.equalsIgnoreCase("") && registra)
						pedidosEntregaRegularLogCreate(idcliente,
								new BigDecimal(anio), new BigDecimal(mes),
								status, idempresa, usuarioalt);
					// <--
					status = "";
					// --> 20110405 - EJV Mantis 700
					// Si no hay tarjetas que
					// cumplan las condiciones de
					// validez, se asigna como
					// default la de orden uno (1) o
					// en su defecto alguna
					// existente.
					// 20110630 - EJV -- > Siempre
					// asignar alguna.
					if (datosTarjeta[12].equalsIgnoreCase("S"))
						// <--
						idtarjeta = new BigDecimal(datosTarjeta[0]);
					else if (idtarjeta.longValue() < 1
							|| datosTarjeta[11].equalsIgnoreCase("1"))
						// <--
						idtarjeta = new BigDecimal(datosTarjeta[0]);
					else if (idtarjeta.longValue() < 1)
						// <--
						idtarjeta = new BigDecimal(datosTarjeta[0]);
					// <--
				}

			} else {

				status = proceso
						+ ": condicion de pago Tarjeta: no hay tarjeta asociada para cliente:"
						+ idcliente;
				log.warn(status);
				if (registra)
					pedidosEntregaRegularLogCreate(idcliente, new BigDecimal(
							anio), new BigDecimal(mes), status, idempresa,
							usuarioalt);

			}

		} catch (Exception e) {
			log.error("getTarjetaClienteERyPO(): " + e);
		}

		return idtarjeta;

	}

	// <--
	public List getBacoObsequiosEsquemaPeriodo(int idmes, int anio,
			BigDecimal idtipoobsequio, String cartaoregalo, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT eq.codigo_st, eq.cantidad, eq.codigo_dt, st.unimed_st, "
				+ "       COALESCE(sb.canti_sb, -9999) AS canti_sb, "
				+ "       COALESCE(sb.pedid_sb, -9999) AS pedid_sb, "
				+ "       inventa_st,  st.tipoiva_st, tob.idmotivodescuento,"
				+ "       st.idempresa, st.usuarioalt, st.usuarioact, st.fechaalt, st.fechaact "
				+ "  FROM stockstock st "
				+ "       INNER JOIN bacoobsequiosesquema eq ON st.codigo_st = eq.codigo_st AND st.idempresa = eq.idempresa  "
				+ "       INNER JOIN bacotipoobsequios tob ON eq.idtipoobsequio = tob.idtipoobsequio AND eq.idempresa = tob.idempresa "
				+ "        LEFT JOIN stockstockbis sb ON eq.codigo_st = sb.articu_sb AND eq.idempresa = sb.idempresa AND eq.codigo_dt = sb.deposi_sb "
				+ "WHERE eq.anio = " + anio + "  AND eq.idmes = " + idmes
				+ "  AND eq.idtipoobsequio =  " + idtipoobsequio
				+ "  AND eq.cartaoregalo = '" + cartaoregalo + "' "
				+ "  AND eq.idempresa = " + idempresa;

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosEsquemaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public String setHashEsquemaObsequios(List listEsquema, Hashtable htArt) {

		String salida = "OK";

		Iterator iter;
		try {
			iter = listEsquema.iterator();

			while (iter.hasNext()) {

				String[] datosArticulo = new String[33];
				String[] aux = (String[]) iter.next();

				/*
				 * 
				 * eq.codigo_st, eq.cantidad, eq.codigo_dt, st.unimed_st,
				 * COALESCE(sb.canti_sb, -9999) AS canti_sb,
				 * COALESCE(sb.pedid_sb, -9999) AS pedid_sb, inventa_st,
				 * st.tipoiva_st, tob.idmotivodescuento, st.idempresa,
				 * st.usuarioalt, st.usuarioact, st.fechaalt, st.fechaact
				 */

				datosArticulo[0] = aux[0];
				datosArticulo[10] = aux[1];
				datosArticulo[9] = aux[2];
				datosArticulo[4] = "100";
				datosArticulo[5] = "0";
				datosArticulo[11] = "0";
				datosArticulo[17] = "4";
				datosArticulo[18] = "4";
				datosArticulo[19] = "100";
				datosArticulo[20] = "100";
				datosArticulo[13] = aux[3];
				datosArticulo[21] = aux[8];
				datosArticulo[24] = aux[7];
				datosArticulo[26] = "0";
				datosArticulo[27] = "0";
				datosArticulo[28] = aux[4];
				datosArticulo[29] = aux[5];
				datosArticulo[30] = aux[6];

				if (datosArticulo[28].equalsIgnoreCase("-9999")) {
					salida = "Articulo " + aux[0]
							+ " inexistente en deposito definido en esquema.";
					log.warn("setHashEsquemaObsequios(): " + salida);
					htArt.clear();
					break;
				}

				// for (int x = 0; x < datosArticulo.length; x++)
				// log.info("datosArticulo[" + x + "]:" + datosArticulo[x]);

				htArt.put(aux[0], datosArticulo);

			}

		} catch (Exception e) {
			salida = "(E) Error al cargar datos de articulo para detalle de pedido.";
			log.error("setHashEsquemaObsequios():" + e);
		}

		return salida;
	}

	/**
	 * Metodos para la entidad: bacoObsequiosEsquema Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri Nov 06 11:36:23 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoObsequiosEsquemaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT oe.idesquema,oe.anio,oe.idmes, gm.mes,oe.idtipoobsequio,ti.tipoobsequio,"
				+ "       oe.codigo_st,st.descrip_st,oe.codigo_dt, dt.descrip_dt,oe.cantidad,oe.cartaoregalo,"
				+ "       oe.idempresa,oe.usuarioalt,oe.usuarioact,oe.fechaalt,oe.fechaact "
				+ "  FROM bacoobsequiosesquema oe "
				+ "       INNER JOIN globalmeses gm ON oe.idmes = gm.idmes "
				+ "       INNER JOIN bacotipoobsequios ti ON oe.idtipoobsequio = ti.idtipoobsequio AND oe.idempresa = ti.idempresa "
				+ "       INNER JOIN stockstock st ON oe.codigo_st = st.codigo_st AND oe.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON oe.codigo_dt = dt.codigo_dt AND oe.idempresa = dt.idempresa "
				+ " WHERE oe.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2, 3  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosEsquemaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoObsequiosEsquemaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT oe.idesquema,oe.anio,oe.idmes, gm.mes,oe.idtipoobsequio,ti.tipoobsequio,"
				+ "       oe.codigo_st,st.descrip_st,oe.codigo_dt, dt.descrip_dt,oe.cantidad,oe.cartaoregalo,"
				+ "       oe.idempresa,oe.usuarioalt,oe.usuarioact,oe.fechaalt,oe.fechaact "
				+ "  FROM bacoobsequiosesquema oe "
				+ "       INNER JOIN globalmeses gm ON oe.idmes = gm.idmes "
				+ "       INNER JOIN bacotipoobsequios ti ON oe.idtipoobsequio = ti.idtipoobsequio AND oe.idempresa = ti.idempresa "
				+ "       INNER JOIN stockstock st ON oe.codigo_st = st.codigo_st AND oe.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON oe.codigo_dt = dt.codigo_dt AND oe.idempresa = dt.idempresa "
				+ " WHERE (UPPER(oe.anio::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND oe.idempresa = "
				+ idempresa.toString() + " ORDER BY 2, 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosEsquemaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoObsequiosEsquemaPK(BigDecimal idesquema,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT oe.idesquema,oe.anio,oe.idmes, gm.mes,oe.idtipoobsequio,ti.tipoobsequio,"
				+ "       oe.codigo_st,st.descrip_st,oe.codigo_dt, dt.descrip_dt,oe.cantidad,oe.cartaoregalo,"
				+ "       oe.idempresa,oe.usuarioalt,oe.usuarioact,oe.fechaalt,oe.fechaact "
				+ "  FROM bacoobsequiosesquema oe "
				+ "       INNER JOIN globalmeses gm ON oe.idmes = gm.idmes "
				+ "       INNER JOIN bacotipoobsequios ti ON oe.idtipoobsequio = ti.idtipoobsequio AND oe.idempresa = ti.idempresa "
				+ "       INNER JOIN stockstock st ON oe.codigo_st = st.codigo_st AND oe.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos dt ON oe.codigo_dt = dt.codigo_dt AND oe.idempresa = dt.idempresa "
				+ " WHERE oe.idesquema=" + idesquema.toString()
				+ "   AND oe.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoObsequiosEsquemaPK( BigDecimal idesquema )  "
							+ ex);
		}
		return vecSalida;
	}

	public boolean isExisteBacoObsequiosEsquemaPeriodo(int anio, int idmes,
			BigDecimal idtipoobsequio, String cartaoregalo, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		boolean existeesquemaperiodo = false;
		String cQuery = ""
				+ "SELECT COUNT(1) FROM bacoobsequiosesquema               "
				+ " WHERE anio=" + anio + "   AND idmes = " + idmes
				+ "   AND idtipoobsequio = " + idtipoobsequio
				+ "   AND UPPER(cartaoregalo) = '" + cartaoregalo.toUpperCase()
				+ "'  AND idempresa = " + idempresa.toString() + ";";

		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {
				if (rsSalida.next()) {
					existeesquemaperiodo = rsSalida.getInt(1) != 0 ? true
							: false;
				}
			}

		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : isExisteBacoObsequiosEsquemaPeriodo( BigDecimal idesquema ) "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: isExisteBacoObsequiosEsquemaPeriodo( BigDecimal idesquema )  "
							+ ex);
		}
		return existeesquemaperiodo;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoObsequiosEsquemaDelete(BigDecimal idesquema,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOOBSEQUIOSESQUEMA WHERE idesquema="
				+ idesquema.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOOBSEQUIOSESQUEMA WHERE idesquema="
						+ idesquema.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoObsequiosEsquemaDelete( BigDecimal idesquema, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoObsequiosEsquemaDelete( BigDecimal idesquema, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoObsequiosEsquemaCreate(BigDecimal anio, BigDecimal idmes,
			BigDecimal idtipoobsequio, String codigo_st, BigDecimal codigo_dt,
			BigDecimal cantidad, String cartaoregalo, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idtipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoobsequio ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOOBSEQUIOSESQUEMA(anio, idmes, idtipoobsequio, codigo_st, codigo_dt, cantidad, cartaoregalo, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, anio);
				insert.setBigDecimal(2, idmes);
				insert.setBigDecimal(3, idtipoobsequio);
				insert.setString(4, codigo_st);
				insert.setBigDecimal(5, codigo_dt);
				insert.setBigDecimal(6, cantidad);
				insert.setString(7, cartaoregalo);
				insert.setBigDecimal(8, idempresa);
				insert.setString(9, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoObsequiosEsquemaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoObsequiosEsquemaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoObsequiosEsquemaCreateOrUpdate(BigDecimal idesquema,
			BigDecimal anio, BigDecimal idmes, BigDecimal idtipoobsequio,
			String codigo_st, BigDecimal codigo_dt, BigDecimal cantidad,
			String cartaoregalo, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idesquema == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idesquema ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idtipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoobsequio ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoObsequiosEsquema WHERE idesquema = "
					+ idesquema.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOOBSEQUIOSESQUEMA SET anio=?, idmes=?, idtipoobsequio=?, codigo_st=?, codigo_dt=?, cantidad=?, cartaoregalo=?, idempresa=?, usuarioact=?, fechaact=? WHERE idesquema=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idtipoobsequio);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, codigo_dt);
					insert.setBigDecimal(6, cantidad);
					insert.setString(7, cartaoregalo);
					insert.setBigDecimal(8, idempresa);
					insert.setString(9, usuarioact);
					insert.setTimestamp(10, fechaact);
					insert.setBigDecimal(11, idesquema);
				} else {
					String ins = "INSERT INTO BACOOBSEQUIOSESQUEMA(anio, idmes, idtipoobsequio, codigo_st, codigo_dt, cantidad, cartaoregalo, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idtipoobsequio);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, codigo_dt);
					insert.setBigDecimal(6, cantidad);
					insert.setString(7, cartaoregalo);
					insert.setBigDecimal(8, idempresa);
					insert.setString(9, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoObsequiosEsquemaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoObsequiosEsquemaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoObsequiosEsquemaUpdate(BigDecimal idesquema,
			BigDecimal anio, BigDecimal idmes, BigDecimal idtipoobsequio,
			String codigo_st, BigDecimal codigo_dt, BigDecimal cantidad,
			String cartaoregalo, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idesquema == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idesquema ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idtipoobsequio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoobsequio ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoObsequiosEsquema WHERE idesquema = "
					+ idesquema.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOOBSEQUIOSESQUEMA SET anio=?, idmes=?, idtipoobsequio=?, codigo_st=?, codigo_dt=?, cantidad=?, cartaoregalo=?, idempresa=?, usuarioact=?, fechaact=? WHERE idesquema=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idtipoobsequio);
					insert.setString(4, codigo_st);
					insert.setBigDecimal(5, codigo_dt);
					insert.setBigDecimal(6, cantidad);
					insert.setString(7, cartaoregalo);
					insert.setBigDecimal(8, idempresa);
					insert.setString(9, usuarioact);
					insert.setTimestamp(10, fechaact);
					insert.setBigDecimal(11, idesquema);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoObsequiosEsquemaUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoObsequiosEsquemaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * PROCESO DE OBSEQUIOS - EJV < -- END
	 * */

	public static int pid() {

		String id = java.lang.management.ManagementFactory.getRuntimeMXBean()
				.getName();
		String[] ids = id.split("@");
		return Integer.parseInt(ids[0]);
	}

	public static void listOpenFiles() throws IOException {

		String os = System.getProperties().getProperty("os.name");
		long total = 0;

		if (os != null && os.equalsIgnoreCase("linux")) {

			int pid = pid();
			Runtime runtime = Runtime.getRuntime();
			Process process = runtime.exec("lsof -p " + pid);
			InputStream is = process.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);
			String line;

			while ((line = br.readLine()) != null) {
				// log.info(line);
				total++;
			}

			for (int r = 0; r < 50; r++)
				log.info("### - TOTAL OPEN FILES: " + total);
		}

	}

	// TODO: ver porque NO funciona
	public static long countOpenFilesByPid(long pid) throws IOException {
		long count = -1;
		String os = System.getProperties().getProperty("os.name");

		log.info("call {countOpenFilesByPid} - Antes ");
		if (os != null && os.equalsIgnoreCase("linux")) {

			Runtime runtime = Runtime.getRuntime();
			Process process = runtime.exec("lsof -p " + pid + " | wc -l ");
			InputStream is = process.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);
			String line;

			while ((line = br.readLine()) != null) {
				log.info("line.trim(): " + line.trim());
				count = Long.parseLong(line.trim());
			}
		}

		return count;
	}

	/**
	 * Metodos para la entidad: pedidos_Regalos_Entregas_Cabe Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Fri Nov 13 10:00:59 GMT-03:00 2009
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getPedidos_Regalos_Entregas_CabeAll(long limit, long offset,
			BigDecimal idpedido_regalos_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT ec.idpedido_regalos_entrega_cabe,ec.idpedido_regalos_cabe, "
				+ "       ec.idestado, es.estado,ec.idsucursal,ec.fechapedido, "
				+ "       ec.idsucuclie,ec.idexpreso,ec.obsarmado,ec.obsentrega,ec.idprioridad,ec.idzona, "

				+ "       de.calle, de.nro, de.piso, de.depto, de.cpa, de.postal, de.contacto, de.cargocontacto, "
				+ "       lo.localidad, pv.provincia, de.telefonos, de.celular, de.fax, de.web, "

				+ "       ec.idempresa,ec.usuarioalt,ec.usuarioact,ec.fechaalt,ec.fechaact  "
				+ "  FROM pedidos_regalos_entregas_cabe ec "

				+ "       INNER JOIN pedidosestados es ON ec.idestado = es.idestado AND ec.idempresa = es.idempresa "

				+ "       INNER JOIN pedidosdomiciliosentrega de ON ec.idsucuclie = de.iddomicilio AND ec.idempresa = de.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON ec.idanexolocalidad = ax.idanexolocalidad  AND ec.idempresa = ax.idempresa "

				// 20100804 - EJV - Reasignacion -->
				// +
				+ "       INNER JOIN clientesanexolocalidades anlo ON de.idanexolocalidad = anlo.idanexolocalidad AND de.idempresa = anlo.idempresa "
				// <--

				+ "       INNER JOIN globallocalidades lo ON anlo.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia		 "
				+ " WHERE ec.idpedido_regalos_cabe = "
				+ idpedido_regalos_cabe.toString() + " AND ec.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY ec.fechapedido, ec.idestado DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_Regalos_Entregas_CabeAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidos_Regalos_Entregas_CabeOcu(long limit, long offset,
			String ocurrencia, BigDecimal idpedido_regalos_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ec.idpedido_regalos_entrega_cabe,ec.idpedido_regalos_cabe, "
				+ "       ec.idestado, es.estado,ec.idsucursal,ec.fechapedido, "
				+ "       ec.idsucuclie,ec.idexpreso,ec.obsarmado,ec.obsentrega,ec.idprioridad,ec.idzona, "

				+ "       de.calle, de.nro, de.piso, de.depto, de.cpa, de.postal, de.contacto, de.cargocontacto, "
				+ "       lo.localidad, pv.provincia, de.telefonos, de.celular, de.fax, de.web,  "

				+ "       ec.idempresa,ec.usuarioalt,ec.usuarioact,ec.fechaalt,ec.fechaact  "
				+ "  FROM pedidos_regalos_entregas_cabe ec "

				+ "       INNER JOIN pedidosestados es ON ec.idestado = es.idestado AND ec.idempresa = es.idempresa "

				+ "       INNER JOIN pedidosdomiciliosentrega de ON ec.idsucuclie = de.iddomicilio AND ec.idempresa = de.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON de.idanexolocalidad = ax.idanexolocalidad  AND de.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia		 "
				+ " WHERE (UPPER(de.contacto) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(de.calle) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND ec.idpedido_regalos_cabe = "
				+ idpedido_regalos_cabe.toString() + " AND ec.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_Regalos_Entregas_CabeOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidos_Regalos_Entregas_CabePK(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT ec.idpedido_regalos_entrega_cabe,ec.idpedido_regalos_cabe, "
				+ "       ec.idestado, es.estado,ec.idsucursal,ec.fechapedido, "
				+ "       ec.idsucuclie,ec.idexpreso,ec.obsarmado,ec.obsentrega,ec.idprioridad,ec.idzona, "

				+ "       de.calle, de.nro, de.piso, de.depto, de.cpa, de.postal, de.contacto, de.cargocontacto, "
				+ "       lo.localidad, pv.provincia, de.telefonos, de.celular, de.fax, de.web, "

				+ "       ec.idempresa,ec.usuarioalt,ec.usuarioact,ec.fechaalt,ec.fechaact  "
				+ "  FROM pedidos_regalos_entregas_cabe ec "
				+ "       INNER JOIN pedidosestados es ON ec.idestado = es.idestado AND ec.idempresa = es.idempresa "
				+ "       INNER JOIN pedidosdomiciliosentrega de ON ec.idsucuclie = de.iddomicilio AND ec.idempresa = de.idempresa "
				+ "       INNER JOIN clientesanexolocalidades ax ON de.idanexolocalidad = ax.idanexolocalidad  AND de.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia		 "
				+ " WHERE ec.idpedido_regalos_entrega_cabe = "
				+ idpedido_regalos_entrega_cabe.toString()
				+ " AND ec.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_Regalos_Entregas_CabePK( BigDecimal idpedido_regalos_entrega_cabe )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidos_Regalos_Entregas_CabeDelete(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOS_REGALOS_ENTREGAS_CABE WHERE idpedido_regalos_entrega_cabe="
				+ idpedido_regalos_entrega_cabe.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOS_REGALOS_ENTREGAS_CABE WHERE idpedido_regalos_entrega_cabe="
						+ idpedido_regalos_entrega_cabe.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidos_Regalos_Entregas_CabeDelete( BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidos_Regalos_Entregas_CabeDelete( BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	public String pedidosRegalosEntregasAnular(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_regalos_entrega_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_regalos_entrega_cabe ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = ""
					+ "SELECT COUNT(*) FROM pedidos_Regalos_Entregas_Cabe WHERE idpedido_regalos_entrega_cabe = "
					+ idpedido_regalos_entrega_cabe.toString()
					+ " AND idestado = 1 AND idempresa = "
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE PEDIDOS_REGALOS_ENTREGAS_CABE "
							+ "    SET idestado=?, usuarioact=?, fechaact=?"
							+ "  WHERE idpedido_regalos_entrega_cabe=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, new BigDecimal(4));
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idpedido_regalos_entrega_cabe);
					insert.setBigDecimal(5, idempresa);

					int i = insert.executeUpdate();
					if (i > 0)
						salida = "Entrega anulada correctamente";
					else
						salida = "Imposible anular entrega.";
				} else {
					salida = "Entrega inexistente o modificada desde otra sesion.";
				}

			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidos_Regalos_Entregas_CabeUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidos_Regalos_Entregas_CabeUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidos_Regalos_Entregas_CabeCreate(
			BigDecimal idpedido_regalos_cabe, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idexpreso, String obsarmado,
			String obsentrega, BigDecimal idprioridad, BigDecimal idzona,
			BigDecimal idanexolocalidad, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idsucuclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucuclie ";
		if (fechapedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idprioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO pedidos_regalos_entregas_cabe"
						+ "                    (idpedido_regalos_cabe, idestado, idcliente, idsucursal, idsucuclie, fechapedido, idexpreso, "
						+ "                     obsarmado, obsentrega, idprioridad, idzona, idanexolocalidad, idempresa, usuarioalt ) "
						+ "       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:

				insert.setBigDecimal(1, idpedido_regalos_cabe);
				insert.setBigDecimal(2, idestado);
				insert.setBigDecimal(3, idcliente);
				insert.setBigDecimal(4, idsucursal);
				insert.setBigDecimal(5, idsucuclie);
				insert.setTimestamp(6, fechapedido);
				insert.setBigDecimal(7, idexpreso);
				insert.setString(8, obsarmado);
				insert.setString(9, obsentrega);
				insert.setBigDecimal(10, idprioridad);
				insert.setBigDecimal(11, idzona);
				insert.setBigDecimal(12, idanexolocalidad);
				insert.setBigDecimal(13, idempresa);
				insert.setString(14, usuarioalt);

				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar cabecera para entrega. ";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar cabecera para entrega.";
			log
					.error("Error SQL public String pedidos_Regalos_Entregas_CabeCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar cabecera para entrega.";
			log
					.error("Error excepcion public String pedidos_Regalos_Entregas_CabeCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidos_Regalos_Entregas_CabeCreateOrUpdate(
			BigDecimal idpedido_regalos_entrega_cabe,
			BigDecimal idpedido_regalos_cabe, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idexpreso, String obsarmado,
			String obsentrega, BigDecimal idprioridad, BigDecimal idzona,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_regalos_entrega_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_regalos_entrega_cabe ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idsucuclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucuclie ";
		if (fechapedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idprioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_Regalos_Entregas_Cabe WHERE idpedido_regalos_entrega_cabe = "
					+ idpedido_regalos_entrega_cabe.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_REGALOS_ENTREGAS_CABE SET idpedido_regalos_cabe=?, idestado=?, idcliente=?, idsucursal=?, idsucuclie=?, fechapedido=?, idexpreso=?, obsarmado=?, obsentrega=?, idprioridad=?, idzona=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpedido_regalos_entrega_cabe=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idpedido_regalos_cabe);
					insert.setBigDecimal(2, idestado);
					insert.setBigDecimal(3, idcliente);
					insert.setBigDecimal(4, idsucursal);
					insert.setBigDecimal(5, idsucuclie);
					insert.setTimestamp(6, fechapedido);
					insert.setBigDecimal(7, idexpreso);
					insert.setString(8, obsarmado);
					insert.setString(9, obsentrega);
					insert.setBigDecimal(10, idprioridad);
					insert.setBigDecimal(11, idzona);
					insert.setBigDecimal(12, idempresa);
					insert.setString(13, usuarioact);
					insert.setTimestamp(14, fechaact);
					insert.setBigDecimal(15, idpedido_regalos_entrega_cabe);
				} else {
					String ins = "INSERT INTO PEDIDOS_REGALOS_ENTREGAS_CABE(idpedido_regalos_cabe, idestado, idcliente, idsucursal, idsucuclie, fechapedido, idexpreso, obsarmado, obsentrega, idprioridad, idzona, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idpedido_regalos_cabe);
					insert.setBigDecimal(2, idestado);
					insert.setBigDecimal(3, idcliente);
					insert.setBigDecimal(4, idsucursal);
					insert.setBigDecimal(5, idsucuclie);
					insert.setTimestamp(6, fechapedido);
					insert.setBigDecimal(7, idexpreso);
					insert.setString(8, obsarmado);
					insert.setString(9, obsentrega);
					insert.setBigDecimal(10, idprioridad);
					insert.setBigDecimal(11, idzona);
					insert.setBigDecimal(12, idempresa);
					insert.setString(13, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidos_Regalos_Entregas_CabeCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidos_Regalos_Entregas_CabeCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidos_Regalos_Entregas_CabeUpdate(
			BigDecimal idpedido_regalos_entrega_cabe,
			BigDecimal idpedido_regalos_cabe, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idexpreso, String obsarmado,
			String obsentrega, BigDecimal idprioridad, BigDecimal idzona,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_regalos_entrega_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_regalos_entrega_cabe ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idsucuclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucuclie ";
		if (fechapedido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechapedido ";
		if (idprioridad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idprioridad ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidos_Regalos_Entregas_Cabe WHERE idpedido_regalos_entrega_cabe = "
					+ idpedido_regalos_entrega_cabe.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOS_REGALOS_ENTREGAS_CABE SET idpedido_regalos_cabe=?, idestado=?, idcliente=?, idsucursal=?, idsucuclie=?, fechapedido=?, idexpreso=?, obsarmado=?, obsentrega=?, idprioridad=?, idzona=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpedido_regalos_entrega_cabe=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idpedido_regalos_cabe);
					insert.setBigDecimal(2, idestado);
					insert.setBigDecimal(3, idcliente);
					insert.setBigDecimal(4, idsucursal);
					insert.setBigDecimal(5, idsucuclie);
					insert.setTimestamp(6, fechapedido);
					insert.setBigDecimal(7, idexpreso);
					insert.setString(8, obsarmado);
					insert.setString(9, obsentrega);
					insert.setBigDecimal(10, idprioridad);
					insert.setBigDecimal(11, idzona);
					insert.setBigDecimal(12, idempresa);
					insert.setString(13, usuarioact);
					insert.setTimestamp(14, fechaact);
					insert.setBigDecimal(15, idpedido_regalos_entrega_cabe);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidos_Regalos_Entregas_CabeUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidos_Regalos_Entregas_CabeUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getPedidosRegalosEntregasDisponible(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT st.oid, rd.codigo_st, st.descrip_st, de.descrip_dt,  "
				+ "       COALESCE(sb.canti_sb, 0)::NUMERIC(18,2)AS stockdispon, COALESCE(sb.pedid_sb, 0)::NUMERIC(18,2) AS stockreserva, "
				+ "       rd.cantidad::NUMERIC(18,2) AS cantpedido, COALESCE(co.insumido, 0)::NUMERIC(18,2) AS insumidopedido, "
				+ "       (rd.cantidad - COALESCE(co.insumido, 0))::NUMERIC(18,2) AS dispopedido, de.codigo_dt "
				+ "  FROM pedidos_regalos_deta rd  "
				+ "       INNER JOIN stockstock st ON rd.codigo_st = st.codigo_st AND rd.idempresa = st.idempresa "
				+ "       INNER JOIN stockdepositos de ON rd.codigo_dt = de.codigo_dt AND rd.idempresa = de.idempresa "
				+ "        LEFT JOIN stockstockbis sb ON  rd.codigo_st = sb.articu_sb AND rd.codigo_dt = sb.deposi_sb "
				+ "              AND rd.idempresa = sb.idempresa "
				+ "        LEFT JOIN "
				+ "                (  "
				+ "		SELECT ec.idpedido_regalos_cabe, ed.codigo_st,  ed.codigo_dt, SUM(ed.cantidad) AS insumido, ec.idempresa "
				+ "		  FROM pedidos_regalos_entregas_cabe ec "
				+ "		       INNER JOIN pedidos_regalos_entregas_deta ed ON ec.idpedido_regalos_entrega_cabe = ed.idpedido_regalos_entrega_cabe "
				+ "			      AND ec.idempresa = ed.idempresa AND ec.idestado <> 4 "
				+ "		 GROUP BY ec.idpedido_regalos_cabe, ed.codigo_st,  ed.codigo_dt, ec.idempresa "
				+ "		 ) co ON rd.idpedido_regalos_cabe = co.idpedido_regalos_cabe AND rd.codigo_st = co.codigo_st AND rd.codigo_dt = co.codigo_dt AND rd.idempresa = co.idempresa  "
				+ " WHERE rd.idpedido_regalos_cabe = "
				+ idpedido_regalos_entrega_cabe.toString()
				+ " AND rd.idempresa = " + idempresa.toString();

		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosEntregasDisponible( ... )  "
							+ ex);
		}

		return vecSalida;

	}

	public List getPedidosRegalosCabeHeader(BigDecimal idpedido_regalos_cabe,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT rc.idpedido_regalos_cabe, idpedido_regalos_padre, es.idestado, es.estado, cl.idcliente, cl.razon, "
				+ "       rc.fechapedido, rc.obsarmado, rc.obsentrega, pr.idprioridad, pr.prioridad "
				+ "  FROM pedidos_regalos_cabe rc "
				+ "       INNER JOIN clientesclientes cl ON rc.idcliente = cl.idcliente AND rc.idempresa = cl.idempresa "
				+ "       INNER JOIN pedidosregalosestados es ON rc.idestado = es.idestado AND rc.idempresa = es.idempresa "
				+ "       INNER JOIN pedidosprioridades pr ON rc.idprioridad = pr.idprioridad "

				+ " WHERE rc.idpedido_regalos_cabe = "
				+ idpedido_regalos_cabe.toString() + " AND rc.idempresa = "
				+ idempresa.toString();

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosCabeHeader( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	public String[] pedidosRegalosEntregasCreate(
			BigDecimal idpedido_regalos_cabe, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idsucursal, BigDecimal idsucuclie,
			Timestamp fechapedido, BigDecimal idexpreso, String obsarmado,
			String obsentrega, BigDecimal idprioridad,
			BigDecimal idzona,
			String[] codigo_st,
			String[] cant_entrega,

			//

			String calle, String nro, String piso, String depto, String cpa,
			String postal, String contacto, String cargocontacto,
			String telefonos, String celular, String fax, String web,
			BigDecimal idanexolocalidad,

			//

			String[] codigo_dt, BigDecimal idempresa, String usuarioalt)
			throws EJBException, SQLException {
		String salida = "OK";
		BigDecimal idcobrador = new BigDecimal(-1);
		BigDecimal idremitocliente = null;
		int renglon = 0;
		BigDecimal idpedido_regalos_entrega_cabe = new BigDecimal(-1);
		String entrega = "N";
		BigDecimal cantidad_sb = new BigDecimal(0);
		BigDecimal compromiso_sb = new BigDecimal(0);
		Hashtable htDisponible = new Hashtable();
		int reservaStock = -1000;
		// validaciones de datos:
		// 1. nulidad de campos

		try {

			dbconn.setAutoCommit(false);

			Iterator iterDisponible = getPedidosRegalosEntregasDisponible(
					idpedido_regalos_cabe, idempresa).iterator();

			while (iterDisponible != null && iterDisponible.hasNext()) {

				String[] disp = (String[]) iterDisponible.next();
				htDisponible.put(disp[1], disp[8]);

			}

			if (idsucuclie.longValue() < 1) {

				salida = pedidosDomiciliosEntregaCreate(idcliente, calle, nro,
						piso, depto, cpa, postal, contacto, cargocontacto,
						telefonos, celular, fax, web, idanexolocalidad,
						idcobrador, idempresa, usuarioalt);

				if (salida.equalsIgnoreCase("OK")) {

					idsucuclie = GeneralBean.getValorSequencia(
							"seq_pedidosdomiclilios", dbconn);

					if (idsucuclie == null || idsucuclie.longValue() < 1)
						salida = "Error al recuperar secuencia de domicilios.";

				}

			}

			if (salida.equalsIgnoreCase("OK")) {

				salida = pedidos_Regalos_Entregas_CabeCreate(
						idpedido_regalos_cabe, idestado, idcliente, idsucursal,
						idsucuclie, fechapedido, idexpreso, obsarmado,
						obsentrega, idprioridad, idzona, idanexolocalidad,
						idempresa, usuarioalt);

				if (salida.equalsIgnoreCase("OK")) {

					idpedido_regalos_entrega_cabe = GeneralBean
							.getValorSequencia(
									"seq_pedidos_regalos_entregas_cabe", dbconn);

					if (idpedido_regalos_entrega_cabe == null
							|| idpedido_regalos_entrega_cabe.longValue() < 1)
						salida = "Error al recuperar Nro. de Entrega.";

					for (int j = 0; codigo_st != null && j < codigo_st.length
							&& salida.equalsIgnoreCase("OK"); j++) {

						if (cant_entrega[j] == null
								|| cant_entrega[j].trim().equals("")
								|| cant_entrega[j].trim().equals("0"))
							continue;

						BigDecimal cantidad = new BigDecimal(cant_entrega[j]);
						BigDecimal disponible = new BigDecimal(htDisponible
								.get(codigo_st[j])
								+ "");

						if (disponible.compareTo(cantidad) < 0) {
							salida = "Cantidades disponibles para "
									+ codigo_st[j]
									+ " modificadas desde otra sesion.";
							break;
						}

						salida = pedidos_Regalos_Entregas_DetaCreate(
								idpedido_regalos_entrega_cabe, codigo_st[j],
								fechapedido, new BigDecimal(++renglon),
								cantidad, entrega, idremitocliente,
								cantidad_sb, compromiso_sb, new BigDecimal(
										codigo_dt[j]), idempresa, usuarioalt);

						if (salida.equalsIgnoreCase("OK")) {

							reservaStock = getPedidoRegalosReservaStock(
									idpedido_regalos_cabe, idempresa);

							if (reservaStock < 0) {

								salida = "No fue posible determinar si el Pedido de Regalos "
										+ idpedido_regalos_cabe
										+ ", del cual depende esta entrega reservo stock o no: "
										+ reservaStock;

							} else if (reservaStock == 0) {

								String[] resultado = new String[] {};
								resultado = stockStockBisCantPediCreateUpdate(
										codigo_st[j], new BigDecimal(
												codigo_dt[j]), cantidad,
										usuarioalt, idempresa, dbconn);

								// Guardar alertas de stock con cantidad en
								// cero.
								salida = resultado[0];
								// salida[1] += resultado[1];

							} else if (reservaStock == 1) {
								log
										.info("Entrega no reserva stock, la misma fue hecha por el pedido de regalos"
												+ idpedido_regalos_cabe
												+ ", del cual depende.");
							}

						}

					}

				}

			}

		} catch (Exception ex) {
			salida = "(EX) Ocurrio una excepcion al generar entrega.";
			log
					.error("Error excepcion public String pedidosRegalosEntregasCreate(.....)"
							+ ex);
		}

		if (salida.equalsIgnoreCase("OK")) {

			dbconn.commit();

			// 20100218 -- TODO:
			// if (salida.equalsIgnoreCase("OK")) {

			Properties properties = null;
			BigDecimal idcampacabe = null;
			BigDecimal idcondicion = null;
			BigDecimal totaliva = new BigDecimal(0);
			BigDecimal idtarjeta = new BigDecimal(-1);
			BigDecimal cuotas = new BigDecimal(0);
			String origenpedido = "R";
			BigDecimal total = new BigDecimal(0);
			BigDecimal cotizacion = idpedido_regalos_cabe;
			Hashtable htArticulos = new Hashtable();

			if (properties == null || properties.isEmpty())
				properties = this.props;

			try {

				String conmutador = "OFF";

				if (conmutador.equals("")) {

					for (int j = 0; codigo_st != null && j < codigo_st.length
							&& salida.equalsIgnoreCase("OK"); j++) {

						if (cant_entrega[j] == null
								|| cant_entrega[j].trim().equals("")
								|| cant_entrega[j].trim().equals("0"))
							continue;

						String[] datos = new String[33];

						datos[0] = codigo_st[j];
						datos[10] = cant_entrega[j];
						datos[20] = "0";
						datos[11] = "0";
						datos[27] = "0";

						// llenar HASHARTICULOS
						htArticulos.put(codigo_st[j], datos);

					}

					BCBean.InterFacesGenerarEntregasRegalos(
							idpedido_regalos_entrega_cabe, idcampacabe,
							idcliente, idsucuclie, fechapedido, idcondicion,
							obsarmado, obsentrega, totaliva, idprioridad,
							idzona, idtarjeta, cuotas, origenpedido, total,
							cotizacion, htArticulos, usuarioalt, idempresa,
							properties);

				} else if (conmutador.equals("D1")) {

					// PRUEBAS PARA LA GENERACION DE CAMPANIA EN BACO ...

					// BCBean.getSetCampaniaActivaBaco(idempresa,
					// usuarioalt, dbconn, dbconn);

				} else {
					log
							.warn(" ----------------           !!  ATENCION !!                ----------------");
					log
							.warn("|                                                                                  |");
					log
							.warn("|  INTERFACE ENTREGAS  DELTA < - > BACO APAGADA  |");
					log
							.warn("|                                                                                  |");
					log
							.warn(" ----------------                      ***                      -----------------");
				}

			} catch (Exception eBC) {
				log
						.error("EXC - pedidosRegalosEntregasCreate(.....), al ejecutarse INTERFACE BACO / pedido ["
								+ idpedido_regalos_cabe
								+ "]-entrega["
								+ idpedido_regalos_entrega_cabe + "] : " + eBC);
			}

			// }

		} else {

			dbconn.rollback();
		}

		dbconn.setAutoCommit(false);

		return new String[] { salida, idpedido_regalos_entrega_cabe.toString(),
				idsucuclie.toString() };

	}

	public List getPedidos_Regalos_Entregas_DetaOne(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""

				+ "SELECT ed.idpedido_regalos_entrega_deta,ed.idpedido_regalos_entrega_cabe, "
				+ "       ed.codigo_st, st.descrip_st, ed.fecha, ed.renglon, ed.cantidad, ed.entrega, ed.idremitocliente, "
				+ "       ed.cantidad_sb, ed.compromiso_sb, "
				+ "       ed.idempresa,ed.usuarioalt,ed.usuarioact,ed.fechaalt,ed.fechaact "
				+ "  FROM pedidos_regalos_entregas_deta ed   "
				+ "       INNER JOIN stockstock st ON ed.codigo_st = st.codigo_st AND ed.idempresa = st.idempresa "
				+ " WHERE ed.idpedido_regalos_entrega_cabe="
				+ idpedido_regalos_entrega_cabe.toString()
				+ " AND ed.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidos_Regalos_Entregas_DetaPK( BigDecimal idpedido_regalos_entrega_deta )  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)
	public List getPedidosRegalosEntregasDetaXEntrega(
			BigDecimal idpedido_regalos_entrega_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT pd.idpedido_regalos_entrega_deta, pd.idpedido_regalos_entrega_cabe, pd.codigo_st, pd.fecha, pd.renglon, 0 AS precio, "
				+ "            0 AS saldo, pd.cantidad, 0 AS bonific, -1 AS codigo_md, 0 AS cantuni, "
				+ "            pd.codigo_dt, pd.entrega, COALESCE(st.inventa_st, 'S') AS inventa_st,  "
				+ "             pd.usuarioalt, pd.usuarioact, pd.fechaalt, pd.fechaact "
				+ "  FROM pedidos_regalos_entregas_deta pd "
				+ "            INNER JOIN stockstock st ON pd.codigo_st  = st.codigo_st AND pd.idempresa = st.idempresa "
				+ "WHERE pd.idpedido_regalos_entrega_cabe="
				+ idpedido_regalos_entrega_cabe.toString()
				+ "  AND pd.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosEntregasDetaXEntrega( BigDecimal idpedido_cabe, idempresa )  "
							+ ex);
		}
		return vecSalida;
	}

	public String pedidos_Regalos_Entregas_DetaCreate(
			BigDecimal idpedido_regalos_entrega_cabe, String codigo_st,
			Timestamp fecha, BigDecimal renglon, BigDecimal cantidad,
			String entrega, BigDecimal idremitocliente, BigDecimal cantidad_sb,
			BigDecimal compromiso_sb, BigDecimal codigo_dt,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_regalos_entrega_cabe == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_regalos_entrega_cabe ";
		if (codigo_st == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_st ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (renglon == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: renglon ";
		if (cantidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: cantidad ";
		if (entrega == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: entrega ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (codigo_st.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: codigo_st ";
		if (entrega.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: entrega ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO PEDIDOS_REGALOS_ENTREGAS_DETA"
						+ "              (idpedido_regalos_entrega_cabe, codigo_st, fecha, renglon, cantidad, entrega, idremitocliente, cantidad_sb, compromiso_sb, codigo_dt, idempresa, usuarioalt ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idpedido_regalos_entrega_cabe);
				insert.setString(2, codigo_st);
				insert.setTimestamp(3, fecha);
				insert.setBigDecimal(4, renglon);
				insert.setBigDecimal(5, cantidad);
				insert.setString(6, entrega);
				insert.setBigDecimal(7, idremitocliente);
				insert.setBigDecimal(8, cantidad_sb);
				insert.setBigDecimal(9, compromiso_sb);
				insert.setBigDecimal(10, codigo_dt);
				insert.setBigDecimal(11, idempresa);
				insert.setString(12, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar detalle de entrega para art.:  "
							+ codigo_st + ".";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar detalle de entrega para art.:  "
					+ codigo_st + ".";
			log
					.error("Error SQL public String pedidos_Regalos_Entregas_DetaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar detalle de entrega para art.:  "
					+ codigo_st + ".";
			log
					.error("Error excepcion public String pedidos_Regalos_Entregas_DetaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosDomiciliosEntregaCreate(BigDecimal idcliente,
			String calle, String nro, String piso, String depto, String cpa,
			String postal, String contacto, String cargocontacto,
			String telefonos, String celular, String fax, String web,
			BigDecimal idanexolocalidad, BigDecimal idcobrador,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (calle == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: calle ";
		if (contacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: contacto ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (calle.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: calle ";
		if (contacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: contacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO PEDIDOSDOMICILIOSENTREGA(idcliente, calle, nro, piso, depto, cpa, postal, contacto, cargocontacto, telefonos, celular, fax, web, idanexolocalidad, idcobrador, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setString(2, calle);
				insert.setString(3, nro);
				insert.setString(4, piso);
				insert.setString(5, depto);
				insert.setString(6, cpa);
				insert.setString(7, postal);
				insert.setString(8, contacto);
				insert.setString(9, cargocontacto);
				insert.setString(10, telefonos);
				insert.setString(11, celular);
				insert.setString(12, fax);
				insert.setString(13, web);
				insert.setBigDecimal(14, idanexolocalidad);
				insert.setBigDecimal(15, idcobrador);
				insert.setBigDecimal(16, idempresa);
				insert.setString(17, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar direccion de entrega.";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar direccion de entrega.";
			log
					.error("Error SQL public String pedidosDomiciliosEntregaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar direccion de entrega.";
			log
					.error("Error excepcion public String pedidosDomiciliosEntregaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidosDomiciliosEntrega Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Nov 13 10:00:09 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosDomiciliosEntregaAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT dm.iddomicilio,dm.idcliente,dm.calle,dm.nro,dm.piso,dm.depto,"
				+ "       dm.cpa,dm.postal,dm.contacto,dm.cargocontacto,dm.telefonos,dm.celular,"
				+ "       dm.fax,dm.web,dm.idanexolocalidad,dm.idcobrador, "
				+ "       ex.idexpreso, ex.expreso, zo.idzona, zo.zona,"
				+ "       lo.idlocalidad, lo.localidad, pv.idprovincia, pv.provincia,"
				+ "       dm.idempresa,dm.usuarioalt,dm.usuarioact,dm.fechaalt,dm.fechaact "
				+ "  FROM pedidosdomiciliosentrega dm"
				+ "       INNER JOIN clientesanexolocalidades ax ON dm.idanexolocalidad = ax.idanexolocalidad "
				+ "              AND dm.idempresa = ax.idempresa "
				+ "       INNER JOIN clientesexpresoszonas ez ON ax.idexpresozona  = ez.codigo AND ax.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos ex ON ez.idexpreso  = ex.idexpreso AND ez.idempresa = ex.idempresa "
				+ "       INNER JOIN clienteszonas zo ON ez.idzona  = zo.idzona AND ez.idempresa = zo.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad  = lo.idlocalidad  "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia  = pv.idprovincia  "
				+ " WHERE dm.idcliente = " + idcliente + " AND dm.idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosDomiciliosEntregaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosDomiciliosEntregaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT dm.iddomicilio,dm.idcliente,dm.calle,dm.nro,dm.piso,dm.depto,"
				+ "       dm.cpa,dm.postal,dm.contacto,dm.cargocontacto,dm.telefonos,dm.celular,"
				+ "       dm.fax,dm.web,dm.idanexolocalidad,dm.idcobrador, "
				+ "       ex.idexpreso, ex.expreso, zo.idzona, zo.zona,"
				+ "       lo.idlocalidad, lo.localidad, pv.idprovincia, pv.provincia,"
				+ "       dm.idempresa,dm.usuarioalt,dm.usuarioact,dm.fechaalt,dm.fechaact "
				+ "  FROM pedidosdomiciliosentrega dm"
				+ "       INNER JOIN clientesanexolocalidades ax ON dm.idanexolocalidad = ax.idanexolocalidad "
				+ "              AND dm.idempresa = ax.idempresa "
				+ "       INNER JOIN clientesexpresoszonas ez ON ax.idexpresozona  = ez.codigo AND ax.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos ex ON ez.idexpreso  = ex.idexpreso AND ez.idempresa = ex.idempresa "
				+ "       INNER JOIN clienteszonas zo ON ez.idzona  = zo.idzona AND ez.idempresa = zo.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad  = lo.idlocalidad  "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia  = pv.idprovincia  "
				+ " WHERE (UPPER(dm.calle) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND dm.idcliente = "
				+ idcliente + " AND dm.idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosDomiciliosEntregaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// Resumen de Ventas por Periodo TM
	// -- 30/11/2009: cep son dos metodos porque es muy enquilombado el listado.
	public List getClientesResumenVentasporPeriodoTMFINAL(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {

		List vecEntrada = getClientesResumenVentasporPeriodoTM(fechaD, fechaH,
				idempresa);
		Iterator iterEntrada = vecEntrada.iterator();
		List vecSalida = new ArrayList();
		while (iterEntrada.hasNext()) {
			String[] sCampos = (String[]) iterEntrada.next();
			String curTelemarketer = sCampos[0];
			String curUmedida = sCampos[2];
			vecSalida.add(sCampos); // van siempre
			String[] sCamposTotales = sCampos;
			sCamposTotales[0] = "TOTALES";
			sCamposTotales[1] = "TOTALES";
			sCamposTotales[2] = "TOTALES";
			while (curTelemarketer.equalsIgnoreCase(sCampos[0])
					&& curUmedida.equalsIgnoreCase(sCampos[2])
					&& iterEntrada.hasNext()) {
				curTelemarketer = sCampos[0];
				curUmedida = sCampos[2];
				sCampos = (String[]) iterEntrada.next();
				vecSalida.add(sCampos);
				for (int i = 3; i < sCampos.length; i++) {
					BigDecimal valor = new BigDecimal(sCamposTotales[i]);
					valor = valor.add(valor);
					sCamposTotales[i] = valor.toString();
				}
			}
			vecSalida.add(sCamposTotales);
		}
		return vecSalida;
	}

	private List getClientesResumenVentasporPeriodoTM(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {
		String cQuery = "" + " select "
				+ " pedidos_deta.usuarioalt as Telemark, "
				+ " stockfamilias.descrip_fm as Familia, "
				+ " stockmedidas.descrip_md as Unidad, "
				+ " sum(pedidos_deta.cantidad::numeric(18,0)) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " pedidos_deta "
				+ " inner join pedidos_cabe on pedidos_deta.idpedido_cabe = pedidos_cabe.idpedido_cabe and pedidos_deta.idempresa = pedidos_cabe.idempresa "
				+ " inner join stockstock on pedidos_deta.codigo_st = stockstock.codigo_st and pedidos_deta.idempresa = stockstock.idempresa "
				+ " inner join stockgrupos on stockstock.grupo_st = stockgrupos.codigo_gr and stockstock.idempresa = stockgrupos.idempresa "
				+ " inner join stockfamilias on stockgrupos.codigo_fm = stockfamilias.codigo_fm and stockgrupos.idempresa = stockfamilias.idempresa "
				+ " inner join globalusuarios on pedidos_deta.usuarioalt = globalusuarios.usuario and pedidos_deta.idempresa = globalusuarios.idempresa "
				+ " inner join globalusuariosgrupos on globalusuarios.idusuario = globalusuariosgrupos.idusuario "
				+ " inner join globalgrupos on globalusuariosgrupos.idgrupo = globalgrupos.idgrupo "
				+ " inner join stockmedidas on pedidos_deta.codigo_md = stockmedidas.codigo_md and pedidos_deta.idempresa = stockmedidas.idempresa "
				+ " where "
				+ " globalgrupos.idgrupo = 17 "
				+ " and pedidos_cabe.origenpedido = '' "
				+ " and  pedidos_cabe.idestado in (1,2) "
				+ " and pedidos_cabe.idempresa = "
				+ idempresa
				+ " and pedidos_cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " group by "
				+ " pedidos_deta.usuarioalt, "
				+ " stockfamilias.descrip_fm, "
				+ " stockmedidas.descrip_md "
				+ " order by 1,3 ";
		List vecSalida = getLista(cQuery);
		return vecSalida;

	}

	// Total Resumen de Ventas por Periodo TM
	public ResultSet getClientesResumenVentasporPeriodoTMTotal(String fechaD,
			String fechaH, BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select "
				+ " pedidos_deta.usuarioalt as Telemark, " + "'---',"
				+ " stockmedidas.descrip_md as Unidad, " + " 'TOTAL' as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " pedidos_deta "
				+ " inner join pedidos_cabe on pedidos_deta.idpedido_cabe = pedidos_cabe.idpedido_cabe and pedidos_deta.idempresa = pedidos_cabe.idempresa "
				+ " inner join stockstock on pedidos_deta.codigo_st = stockstock.codigo_st and pedidos_deta.idempresa = stockstock.idempresa "
				+ " inner join stockgrupos on stockstock.grupo_st = stockgrupos.codigo_gr and stockstock.idempresa = stockgrupos.idempresa "
				+ " inner join stockfamilias on stockgrupos.codigo_fm = stockfamilias.codigo_fm and stockgrupos.idempresa = stockfamilias.idempresa "
				+ " inner join globalusuarios on pedidos_deta.usuarioalt = globalusuarios.usuario and pedidos_deta.idempresa = globalusuarios.idempresa "
				+ " inner join globalusuariosgrupos on globalusuarios.idusuario = globalusuariosgrupos.idusuario "
				+ " inner join globalgrupos on globalusuariosgrupos.idgrupo = globalgrupos.idgrupo "
				+ " inner join stockmedidas on pedidos_deta.codigo_md = stockmedidas.codigo_md and pedidos_deta.idempresa = stockmedidas.idempresa "
				+ " where "
				+ " globalgrupos.idgrupo = 17 "
				+ " and pedidos_cabe.origenpedido = '' "
				+ " and  pedidos_cabe.idestado in (1,2) "
				+ " and pedidos_cabe.idempresa = "
				+ idempresa
				+ " and pedidos_cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " group by "
				+ " pedidos_deta.usuarioalt, "
				+ " stockmedidas.descrip_md " + " order by 1,3 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesResumenVentasporPeriodoTMTotal() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesResumenVentasporPeriodoTMTotal()  "
							+ ex);
		}
		return rsSalida;
	}

	// Resumen de Ventas por Periodo Otros Sectores
	public ResultSet getClientesResumenVentasporPeriodoOtrosSectores(
			String fechaD, String fechaH, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select "
				+ " stockfamilias.descrip_fm as Familia, "
				+ " stockmedidas.descrip_md as Unidad, "
				+ " sum(pedidos_deta.cantidad::numeric(18,0)) as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " pedidos_deta "
				+ " inner join pedidos_cabe on pedidos_deta.idpedido_cabe = pedidos_cabe.idpedido_cabe and pedidos_deta.idempresa = pedidos_cabe.idempresa "
				+ " inner join stockstock on pedidos_deta.codigo_st = stockstock.codigo_st and pedidos_deta.idempresa = stockstock.idempresa "
				+ " inner join stockgrupos on stockstock.grupo_st = stockgrupos.codigo_gr and stockstock.idempresa = stockgrupos.idempresa "
				+ " inner join stockfamilias on stockgrupos.codigo_fm = stockfamilias.codigo_fm and stockgrupos.idempresa = stockfamilias.idempresa "
				+ " inner join globalusuarios on pedidos_deta.usuarioalt = globalusuarios.usuario and pedidos_deta.idempresa = globalusuarios.idempresa "
				+ " inner join globalusuariosgrupos on globalusuarios.idusuario = globalusuariosgrupos.idusuario "
				+ " inner join globalgrupos on globalusuariosgrupos.idgrupo = globalgrupos.idgrupo "
				+ " inner join stockmedidas on pedidos_deta.codigo_md = stockmedidas.codigo_md and pedidos_deta.idempresa = stockmedidas.idempresa "
				+ " where "
				+ " globalgrupos.idgrupo <> 17 "
				+ " and pedidos_cabe.origenpedido = '' "
				+ " and  pedidos_cabe.idestado in (1,2) "
				+ " and pedidos_cabe.idempresa = "
				+ idempresa
				+ " and pedidos_cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " group by "
				+ " stockfamilias.descrip_fm, "
				+ " stockmedidas.descrip_md " + " order by 1,3 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesResumenVentasporPeriodoOtrosSectores() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesResumenVentasporPeriodoOtrosSectores()  "
							+ ex);
		}
		return rsSalida;
	}

	// Total Resumen de Ventas por Periodo TM
	public ResultSet getClientesResumenVentasporPeriodoOtrosSectoresTotal(
			String fechaD, String fechaH, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "" + " select " + "'---',"
				+ " stockmedidas.descrip_md as Unidad, " + " 'TOTAL' as total "
				+ getPivotSumar("pedidos_deta", "porcdesc_apli::int",
						"cantidad::numeric(18,0)")
				+ " from "
				+ " pedidos_deta "
				+ " inner join pedidos_cabe on pedidos_deta.idpedido_cabe = pedidos_cabe.idpedido_cabe and pedidos_deta.idempresa = pedidos_cabe.idempresa "
				+ " inner join stockstock on pedidos_deta.codigo_st = stockstock.codigo_st and pedidos_deta.idempresa = stockstock.idempresa "
				+ " inner join stockgrupos on stockstock.grupo_st = stockgrupos.codigo_gr and stockstock.idempresa = stockgrupos.idempresa "
				+ " inner join stockfamilias on stockgrupos.codigo_fm = stockfamilias.codigo_fm and stockgrupos.idempresa = stockfamilias.idempresa "
				+ " inner join globalusuarios on pedidos_deta.usuarioalt = globalusuarios.usuario and pedidos_deta.idempresa = globalusuarios.idempresa "
				+ " inner join globalusuariosgrupos on globalusuarios.idusuario = globalusuariosgrupos.idusuario "
				+ " inner join globalgrupos on globalusuariosgrupos.idgrupo = globalgrupos.idgrupo "
				+ " inner join stockmedidas on pedidos_deta.codigo_md = stockmedidas.codigo_md and pedidos_deta.idempresa = stockmedidas.idempresa "
				+ " where "
				+ " globalgrupos.idgrupo <> 17 "
				+ " and pedidos_cabe.origenpedido = '' "
				+ " and  pedidos_cabe.idestado in (1,2) "
				+ " and pedidos_cabe.idempresa = "
				+ idempresa
				+ " and pedidos_cabe.fechaalt::DATE between to_date('"
				+ fechaD
				+ "','dd/mm/yyyy') and to_date('"
				+ fechaH
				+ "','dd/mm/yyyy')"
				+ " group by "
				+ " pedidos_deta.usuarioalt, "
				+ " stockmedidas.descrip_md " + " order by 1,3 ";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log
					.error("Error SQL en el metodo : getClientesResumenVentasporPeriodoOtrosSectoresTotal() "
							+ sqlException);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesResumenVentasporPeriodoOtrosSectoresTotal()  "
							+ ex);
		}
		return rsSalida;
	}

	/**
	 * Metodos para la entidad: clientesRemitosLeyendas Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Dec 10 09:15:59 GMT-03:00 2009
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRemitosLeyendasAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " SELECT ly.idleyenda, ly.anio, ly.idmes, me.mes, lo.idlocalidad, "
				+ "        COALESCE(lo.localidad, 'TODAS'), lo.cpostal, pr.idprovincia, "
				+ "        COALESCE(pr.provincia, 'TODAS'), ly.leyenda, ccb.idclub, ccb.club, ccb.logo, "
				+ "        ly.idempresa, ly.usuarioalt, ly.usuarioact, ly.fechaalt, ly.fechaact"
				+ "   FROM clientesremitosleyendas ly"
				+ "         INNER JOIN globalmeses me ON ly.idmes = me.idmes "
				+ "         INNER JOIN clientesclub ccb ON ly.idclub = ccb.idclub AND ly.idempresa = ccb.idempresa "
				+ "         LEFT JOIN globallocalidades lo ON ly.idlocalidad = lo.idlocalidad "
				+ "         LEFT JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
				+ "  WHERE ly.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY ly.anio DESC, ly.idmes DESC, pr.provincia, lo.localidad, lo.cpostal  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosLeyendasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRemitosLeyendasOcu(long limit, long offset,
			String auxFiltro, BigDecimal idempresa) throws EJBException {

		String cQuery = ""

				+ " SELECT idleyenda, anio, idmes, mes, idlocalidad, localidad, cpostal, idprovincia, provincia, leyenda, idclub, club, logo,"
				+ "        idempresa, usuarioalt, usuarioact, fechaalt, fechaact"
				+ "   FROM ("
				+ "         SELECT ly.idleyenda, ly.anio, ly.idmes, me.mes, lo.idlocalidad, "
				+ "                COALESCE(lo.localidad, 'TODAS') AS localidad, lo.cpostal, pr.idprovincia, "
				+ "                COALESCE(pr.provincia, 'TODAS') AS provincia, ly.leyenda, ccb.idclub, ccb.club, ccb.logo, "
				+ "                ly.idempresa, ly.usuarioalt, ly.usuarioact, ly.fechaalt, ly.fechaact"
				+ "           FROM clientesremitosleyendas ly"
				+ "                 INNER JOIN globalmeses me ON ly.idmes = me.idmes "
				+ "                 INNER JOIN clientesclub ccb ON ly.idclub = ccb.idclub AND ly.idempresa = ccb.idempresa "
				+ "                 LEFT JOIN globallocalidades lo ON ly.idlocalidad = lo.idlocalidad "
				+ "                 LEFT JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
				+ "       ) AS entidad  "
				+ "  WHERE idempresa = "
				+ idempresa.toString()
				+ auxFiltro
				+ " ORDER BY anio DESC, idmes DESC, provincia, localidad, cpostal   LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosLeyendasOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesRemitosLeyendasPK(BigDecimal idleyenda,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " SELECT ly.idleyenda, ly.anio, ly.idmes, me.mes, COALESCE(lo.idlocalidad, -1), "
				+ "        COALESCE(lo.localidad, 'TODAS'), lo.cpostal, COALESCE(pr.idprovincia, -1), "
				+ "        COALESCE(pr.provincia, 'TODAS'), ly.leyenda, ccb.idclub, ccb.club, "
				+ "        ly.idempresa, ly.usuarioalt, ly.usuarioact, ly.fechaalt, ly.fechaact"
				+ "   FROM clientesremitosleyendas ly"
				+ "        INNER JOIN clientesclub ccb ON ly.idclub = ccb.idclub AND ly.idempresa = ccb.idempresa "
				+ "        INNER JOIN globalmeses me ON ly.idmes = me.idmes "
				+ "         LEFT JOIN globallocalidades lo ON ly.idlocalidad = lo.idlocalidad "
				+ "         LEFT JOIN globalprovincias pr ON lo.idprovincia = pr.idprovincia "
				+ "  WHERE ly.idleyenda=" + idleyenda.toString()
				+ " AND ly.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosLeyendasPK( BigDecimal idleyenda )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesRemitosLeyendasDelete(BigDecimal idleyenda,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESREMITOSLEYENDAS WHERE idleyenda="
				+ idleyenda.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESREMITOSLEYENDAS WHERE idleyenda="
						+ idleyenda.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesRemitosLeyendasDelete( BigDecimal idleyenda, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesRemitosLeyendasDelete( BigDecimal idleyenda, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	public String clientesRemitosLeyendasDeleteMultiple(String[] idleyenda,
			BigDecimal idempresa) throws EJBException {

		String salida = "Registros Eliminados Corrctamente.";
		String cQuery = "";
		try {
			Statement statement = dbconn.createStatement();

			for (int i = 0; i < idleyenda.length; i++) {

				cQuery = "DELETE FROM clientesremitosleyendas WHERE idleyenda="
						+ idleyenda[i].toString() + " AND idempresa="
						+ idempresa.toString();
				statement.addBatch(cQuery);
			}

			statement.executeBatch();

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible ejecutar  batch de borrado.";
			log
					.error("Error SQL en el metodo : clientesRemitosLeyendasDeleteMultiple( BigDecimal idleyenda, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible ejecutar  batch de borrado.";
			log
					.error("Salida por exception: en el metodo: clientesRemitosLeyendasDeleteMultiple( BigDecimal idleyenda, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesRemitosLeyendasCreate(String criterio,
			BigDecimal anio, BigDecimal idmes, BigDecimal idlocalidad,
			BigDecimal idprovincia, String leyenda, BigDecimal idclub,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (leyenda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: leyenda ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		if (idclub == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclub ";

		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (leyenda.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: leyenda ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "";
				PreparedStatement insert = null;

				if (criterio.equalsIgnoreCase("T")) {

					ins = ""
							+ "INSERT INTO CLIENTESREMITOSLEYENDAS(anio, idmes, idlocalidad, leyenda, idclub, idempresa, usuarioalt )"
							+ " VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, new BigDecimal(-1));
					insert.setString(4, leyenda);
					insert.setBigDecimal(5, idclub);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
					int n = insert.executeUpdate();
					if (n == 1)
						salida = "Alta Correcta";

				} else if (criterio.equalsIgnoreCase("L")) {

					ins = ""
							+ "INSERT INTO CLIENTESREMITOSLEYENDAS(anio, idmes, idlocalidad, leyenda,  idclub, idempresa, usuarioalt )"
							+ " VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idlocalidad);
					insert.setString(4, leyenda);
					insert.setBigDecimal(5, idclub);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
					int n = insert.executeUpdate();
					if (n == 1)
						salida = "Alta Correcta";

				} else if (criterio.equalsIgnoreCase("P")) {

					ins = ""
							+ "INSERT INTO clientesremitosleyendas(anio, idmes, idlocalidad, leyenda, idclub, idempresa, usuarioalt )"
							+ " SELECT ?, ?, idlocalidad, ?, ?, ?, ? "
							+ "   FROM globallocalidades WHERE idprovincia = ? "
							+ "    AND idlocalidad NOT IN ( "
							+ "                             SELECT idlocalidad "
							+ "                               FROM clientesremitosleyendas"
							+ "                              WHERE anio=? AND idmes=? AND idempresa=? )"
							+ "    AND cpostal IS NOT NULL ";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setString(3, leyenda);
					insert.setBigDecimal(4, idclub);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioalt);
					insert.setBigDecimal(7, idprovincia);
					insert.setBigDecimal(8, anio);
					insert.setBigDecimal(9, idmes);
					insert.setBigDecimal(10, idempresa);
					int n = insert.executeUpdate();
					if (n > 0)
						salida = "Alta Correcta";

				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesRemitosLeyendasCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesRemitosLeyendasCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesRemitosLeyendasUpdate(BigDecimal idleyenda,
			BigDecimal anio, BigDecimal idmes, BigDecimal idlocalidad,
			String leyenda, BigDecimal idclub, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idleyenda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idleyenda ";
		if (anio == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: anio ";
		if (idmes == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmes ";
		if (idlocalidad == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idlocalidad ";
		if (leyenda == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: leyenda ";
		if (idclub == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclub ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (leyenda.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: leyenda ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRemitosLeyendas WHERE idleyenda = "
					+ idleyenda.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE CLIENTESREMITOSLEYENDAS"
							+ "   SET anio=?, idmes=?, idlocalidad=?, leyenda=?, idclub=?, idempresa=?, usuarioact=?, fechaact=?"
							+ " WHERE idleyenda=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, anio);
					insert.setBigDecimal(2, idmes);
					insert.setBigDecimal(3, idlocalidad);
					insert.setString(4, leyenda);
					insert.setBigDecimal(5, idclub);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idleyenda);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesRemitosLeyendasUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesRemitosLeyendasUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	//

	public List getClientesRemitosByIdentificador(String idctrlremito,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = "";

		if (tipopedido.equalsIgnoreCase("N"))

			cQuery = " SELECT cr.idremitocliente, pc.idcliente, cl.razon, pc.idpedido_cabe,  "
					+ "       LPAD(cr.nrosucursal::VARCHAR, 4, '0') || '-' || LPAD(cr.nroremitocliente::VARCHAR, 8, '0') AS remito,  "
					+ "       cr.nrohojaarmado, cr.nrohojarutafinal "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidos_deta pd ON cr.idremitocliente = pd.idremitocliente AND cr.idempresa = pd.idempresa "
					+ "       INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE cr.idctrlremito = '"
					+ idctrlremito.toString().toUpperCase()
					+ "' AND cr.idempresa = "
					+ idempresa.toString()
					+ " GROUP BY cr.idremitocliente, pc.idcliente, cl.razon, pc.idpedido_cabe,  "
					+ "        LPAD(cr.nrosucursal::VARCHAR, 4, '0') || '-' || LPAD(cr.nroremitocliente::VARCHAR, 8, '0'),  "
					+ "        cr.nrohojaarmado, cr.nrohojarutafinal, cr.idctrlremito "
					+ " ORDER BY 4;";
		else
			cQuery = ""
					+ "SELECT cr.idremitocliente, pc.idcliente, cl.razon || ' - ' || de.contacto AS razon, pc.idpedido_regalos_entrega_cabe,  "
					+ "            LPAD(cr.nrosucursal::VARCHAR, 4, '0') || '-' || LPAD(cr.nroremitocliente::VARCHAR, 8, '0') AS remito,  "
					+ "            cr.nrohojaarmado, cr.nrohojarutafinal "
					+ "  FROM clientesremitos cr "
					+ "            INNER JOIN pedidos_regalos_entregas_deta pd ON cr.idremitocliente = pd.idremitocliente AND cr.idempresa = pd.idempresa "
					+ "            INNER JOIN pedidos_regalos_entregas_cabe pc ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
					+ "            INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ "            INNER JOIN pedidosdomiciliosentrega de ON pc.idsucuclie = de.iddomicilio AND pc.idempresa = de.idempresa "
					+ "WHERE cr.idctrlremito = '"
					+ idctrlremito.toString().toUpperCase()
					+ "' AND cr.idempresa =  "
					+ idempresa.toString()
					+ " GROUP BY cr.idremitocliente, pc.idcliente, cl.razon || ' - ' || de.contacto, pc.idpedido_regalos_entrega_cabe,  "
					+ "       LPAD(cr.nrosucursal::VARCHAR, 4, '0') || '-' || LPAD(cr.nroremitocliente::VARCHAR, 8, '0'),  "
					+ "       cr.nrohojaarmado, cr.nrohojarutafinal "
					+ " ORDER BY 4;		 ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosByIdentificador( BigDecimal idleyenda )  "
							+ ex);
		}
		return vecSalida;
	}

	// CLIENTES DOMICILIOS RESUMIDOS
	/*
	 * Nota: esta metodo se hizo debido a que en Delta el campo idanexolocalidad
	 * viene siempre con un valor, en cambio en delta_jaso tiene que ir null
	 * entonces replique el metodo y cambien el INNER JOIN por LEFT JOIN en
	 * varias juntas
	 */
	public List getClientesDomiciliosClienteResumido(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT d.iddomicilio,d.idcliente, t.idtipodomicilio, t.tipodomicilio, d.esdefault,d.calle,d.nro,d.piso,d.depto,d.idlocalidad,l.localidad,"
				+ "       d.cpa,COALESCE(l.cpostal, ''),d.contacto,d.cargocontacto,d.telefonos,d.celular,d.fax,d.web,z.idzona,z.zona,"
				+ "       e.idexpreso,e.expreso,d.idcobrador,c.cobrador,d.idvendedor, v.vendedor, cl.idtipoiva, td.tipodocumento, cl.nrodocumento, cl.brutos,"
				+ "       d.idempresa,d.usuarioalt,d.usuarioact,d.fechaalt,d.fechaact ,"
				+ "       date_part('day',  now() - COALESCE(d.fechaact, d.fechaalt) ) as diasauditados, "
				+ "       p.idprovincia, p.provincia, xl.idanexolocalidad, d.obsentrega "
				+ "  FROM clientesdomicilios d "
				+ "        INNER JOIN clientesclientes cl ON d.idcliente = cl.idcliente AND cl.idempresa = d.idempresa "
				+ "        INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento and cl.idempresa = td.idempresa "
				+ "        INNER JOIN clientestiposdomicilios t ON d.idtipodomicilio = t.idtipodomicilio  AND d.idempresa = t.idempresa "
				+ "  LEFT JOIN clientesanexolocalidades xl ON d.idanexolocalidad = xl.idanexolocalidad AND d.idempresa = xl.idempresa"
				+ "        INNER JOIN globallocalidades l ON d.idlocalidad = l.idlocalidad "
				+ "        INNER JOIN globalprovincias p ON l.idprovincia = p.idprovincia "

				+ "  LEFT JOIN clientesexpresoszonas ez ON xl.idexpresozona = ez.codigo AND xl.idempresa = ez.idempresa "
				+ "  LEFT JOIN clienteszonas z ON ez.idzona = z.idzona AND ez.idempresa = z.idempresa "
				+ "  LEFT JOIN clientesexpresos e ON ez.idexpreso = e.idexpreso AND ez.idempresa = e.idempresa "

				+ "        LEFT JOIN clientesvendedor v ON d.idvendedor = v.idvendedor "
				+ "        LEFT JOIN clientescobradores c ON d.idcobrador = c.idcobrador AND d.idempresa = c.idempresa "
				+ " WHERE d.idcliente = "
				+ idcliente.toString()
				+ "   AND d.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY p.provincia, l.localidad, d.calle, d.nro, d.contacto  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesDomiciliosCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesRelaciones Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri Feb 12 16:17:05 GMT-03:00 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRelacionesAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT cr.idrelacion, cr.idclienteroot, ro.razon AS razonroot, cr.idclientebranch, br.razon AS razonbranch, 1 as tipo,"
				+ "       ir.idtipoiva AS idtipoivaroot, ir.tipoiva AS tipoivaroot, ib.idtipoiva AS idtipoivabranch, ib.tipoiva AS tipoivabranch, "
				+ "       cr.idempresa, cr.usuarioalt, cr.usuarioact, cr.fechaalt, cr.fechaact "
				+ "  FROM clientesrelaciones cr "
				+ "       INNER JOIN clientesclientes ro ON cr.idclienteroot = ro.idcliente AND cr.idempresa = ro.idempresa "
				+ "       INNER JOIN clientesclientes br ON cr.idclientebranch = br.idcliente AND cr.idempresa = br.idempresa "
				+ "       INNER JOIN clientestablaiva ir ON ro.idtipoiva = ir.idtipoiva AND ro.idempresa = ir.idempresa "
				+ "       INNER JOIN clientestablaiva ib ON br.idtipoiva = ib.idtipoiva AND br.idempresa = ib.idempresa "
				+ " WHERE cr.idempresa = "
				+ idempresa.toString()
				+ "   AND cr.idclienteroot = "
				+ idcliente.toString()
				+ " UNION ALL "
				+ "SELECT cr.idrelacion, cr.idclienteroot, ro.razon AS razonroot, cr.idclientebranch, br.razon AS razonbranch, 2 as tipo,"
				+ "       ir.idtipoiva AS idtipoivaroot, ir.tipoiva AS tipoivaroot, ib.idtipoiva AS idtipoivabranch, ib.tipoiva AS tipoivabranch, "
				+ "       cr.idempresa, cr.usuarioalt, cr.usuarioact, cr.fechaalt, cr.fechaact "
				+ "  FROM clientesrelaciones cr "
				+ "       INNER JOIN clientesclientes ro ON cr.idclienteroot = ro.idcliente AND cr.idempresa = ro.idempresa "
				+ "       INNER JOIN clientesclientes br ON cr.idclientebranch = br.idcliente AND cr.idempresa = br.idempresa "
				+ "       INNER JOIN clientestablaiva ir ON ro.idtipoiva = ir.idtipoiva AND ro.idempresa = ir.idempresa "
				+ "       INNER JOIN clientestablaiva ib ON br.idtipoiva = ib.idtipoiva AND br.idempresa = ib.idempresa "
				+ " WHERE cr.idempresa = " + idempresa.toString()
				+ "   AND cr.idclientebranch = " + idcliente.toString()
				+ " ORDER BY 6, 3  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = getLista(cQuery);
		return vecSalida;

	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRelacionesOcu(long limit, long offset,
			BigDecimal idcliente, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT cr.idrelacion, cr.idclienteroot, ro.razon AS razonroot, cr.idclientebranch, br.razon AS razonbranch, 1 as tipo,"
				+ "       ir.idtipoiva AS idtipoivaroot, ir.tipoiva AS tipoivaroot, ib.idtipoiva AS idtipoivabranch, ib.tipoiva AS tipoivabranch, "
				+ "       cr.idempresa, cr.usuarioalt, cr.usuarioact, cr.fechaalt, cr.fechaact "
				+ "  FROM clientesrelaciones cr "
				+ "       INNER JOIN clientesclientes ro ON cr.idclienteroot = ro.idcliente AND cr.idempresa = ro.idempresa "
				+ "       INNER JOIN clientesclientes br ON cr.idclientebranch = br.idcliente AND cr.idempresa = br.idempresa "
				+ "       INNER JOIN clientestablaiva ir ON ro.idtipoiva = ir.idtipoiva AND ro.idempresa = ir.idempresa "
				+ "       INNER JOIN clientestablaiva ib ON br.idtipoiva = ib.idtipoiva AND br.idempresa = ib.idempresa "
				+ " WHERE (br.idcliente::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(br.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  "
				+ "   AND cr.idempresa = "
				+ idempresa.toString()
				+ "   AND cr.idclienteroot = "
				+ idcliente.toString()
				+ " UNION ALL "
				+ "SELECT cr.idrelacion, cr.idclienteroot, ro.razon AS razonroot, cr.idclientebranch, br.razon AS razonbranch, 2 as tipo,"
				+ "       ir.idtipoiva AS idtipoivaroot, ir.tipoiva AS tipoivaroot, ib.idtipoiva AS idtipoivabranch, ib.tipoiva AS tipoivabranch, "
				+ "       cr.idempresa, cr.usuarioalt, cr.usuarioact, cr.fechaalt, cr.fechaact "
				+ "  FROM clientesrelaciones cr "
				+ "       INNER JOIN clientesclientes ro ON cr.idclienteroot = ro.idcliente AND cr.idempresa = ro.idempresa "
				+ "       INNER JOIN clientesclientes br ON cr.idclientebranch = br.idcliente AND cr.idempresa = br.idempresa "
				+ "       INNER JOIN clientestablaiva ir ON ro.idtipoiva = ir.idtipoiva AND ro.idempresa = ir.idempresa "
				+ "       INNER JOIN clientestablaiva ib ON br.idtipoiva = ib.idtipoiva AND br.idempresa = ib.idempresa "
				+ " WHERE (br.idcliente::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(br.razon) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  "
				+ "   AND cr.idempresa = "
				+ idempresa.toString()
				+ "   AND cr.idclientebranch = "
				+ idcliente.toString()
				+ " ORDER BY 6, 3  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesRelacionesPK(BigDecimal idrelacion,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idrelacion,idclienteroot,idclientebranch,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM clientesrelaciones WHERE idrelacion="
				+ idrelacion.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = getLista(cQuery);
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesRelacionesDelete(BigDecimal idrelacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM clientesrelaciones WHERE idrelacion="
				+ idrelacion.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM clientesrelaciones WHERE idrelacion="
						+ idrelacion.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesRelacionesDelete( BigDecimal idrelacion, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesRelacionesDelete( BigDecimal idrelacion, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesRelacionesCreate(BigDecimal idclienteroot,
			BigDecimal idclientebranch, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idclienteroot == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclienteroot ";
		if (idclientebranch == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclientebranch ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {

				String ins = "INSERT INTO clientesrelaciones(idclienteroot, idclientebranch, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idclienteroot);
				insert.setBigDecimal(2, idclientebranch);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String clientesRelacionesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesRelacionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesRelacionesCreateOrUpdate(BigDecimal idrelacion,
			BigDecimal idclienteroot, BigDecimal idclientebranch,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idrelacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrelacion ";
		if (idclienteroot == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclienteroot ";
		if (idclientebranch == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclientebranch ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRelaciones WHERE idrelacion = "
					+ idrelacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE clientesrelaciones SET idclienteroot=?, idclientebranch=?, idempresa=?, usuarioact=?, fechaact=? WHERE idrelacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idclienteroot);
					insert.setBigDecimal(2, idclientebranch);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idrelacion);
				} else {
					String ins = "INSERT INTO clientesrelaciones(idclienteroot, idclientebranch, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idclienteroot);
					insert.setBigDecimal(2, idclientebranch);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesRelacionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesRelacionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesRelacionesUpdate(BigDecimal idrelacion,
			BigDecimal idclienteroot, BigDecimal idclientebranch,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idrelacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrelacion ";
		if (idclienteroot == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclienteroot ";
		if (idclientebranch == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclientebranch ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesRelaciones WHERE idrelacion = "
					+ idrelacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESRELACIONES SET idclienteroot=?, idclientebranch=?, idempresa=?, usuarioact=?, fechaact=? WHERE idrelacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idclienteroot);
					insert.setBigDecimal(2, idclientebranch);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idrelacion);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String clientesRelacionesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesRelacionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidosAnulacionRemitosLog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Feb 23 17:03:04 GMT-03:00 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosAnulacionRemitosLogAll(long limit, long offset,
			String tipopedido, BigDecimal idempresa) throws EJBException {

		String cQuery = "";
		if (tipopedido.equalsIgnoreCase("N"))
			cQuery = ""
					+ "SELECT lg.idlog, lg.idtransaccion, lg.idpedido, cr.nrosucursal, cr.nroremitocliente, "
					+ "       cl.idcliente, cl.razon, lg.usuarioalt, lg.fechaalt "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidosanulacionremitoslog lg ON cr.idremitocliente = lg.idremitocliente AND cr.idempresa = lg.idempresa "
					+ "       INNER JOIN pedidos_cabe pc ON lg.idpedido = pc.idpedido_cabe AND lg.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE lg.tipopedido = '" + tipopedido.toUpperCase()
					+ "' AND cr.idempresa = " + idempresa.toString()
					+ " ORDER BY 2, 5  LIMIT " + limit + " OFFSET  " + offset
					+ ";";
		else if (tipopedido.equalsIgnoreCase("R"))
			cQuery = ""
					+ "SELECT lg.idlog, lg.idtransaccion, lg.idpedido, cr.nrosucursal, cr.nroremitocliente, "
					+ "       cl.idcliente, cl.razon, lg.usuarioalt, lg.fechaalt "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidosanulacionremitoslog lg ON cr.idremitocliente = lg.idremitocliente AND cr.idempresa = lg.idempresa "
					+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON lg.idpedido = pc.idpedido_regalos_entrega_cabe AND lg.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE lg.tipopedido = '" + tipopedido.toUpperCase()
					+ "' AND cr.idempresa = " + idempresa.toString()
					+ " ORDER BY 2, 5  LIMIT " + limit + " OFFSET  " + offset
					+ ";";

		List vecSalida = getLista(cQuery);
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosAnulacionRemitosLogOcu(long limit, long offset,
			String tipopedido, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = "";
		if (tipopedido.equalsIgnoreCase("N"))
			cQuery = ""
					+ "SELECT lg.idlog, lg.idtransaccion, lg.idpedido, cr.nrosucursal, cr.nroremitocliente, "
					+ "       cl.idcliente, cl.razon, lg.usuarioalt, lg.fechaalt "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidosanulacionremitoslog lg ON cr.idremitocliente = lg.idremitocliente AND cr.idempresa = lg.idempresa "
					+ "       INNER JOIN pedidos_cabe pc ON lg.idpedido = pc.idpedido_cabe AND lg.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE (cl.idcliente::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "' OR cr.nroremitocliente::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "' OR lg.idpedido::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "') AND lg.tipopedido = '" + tipopedido.toUpperCase()
					+ "'  AND cr.idempresa = " + idempresa.toString()
					+ " ORDER BY 2, 5  LIMIT " + limit + " OFFSET  " + offset
					+ ";";

		else if (tipopedido.equalsIgnoreCase("R"))
			cQuery = ""
					+ "SELECT lg.idlog, lg.idtransaccion, lg.idpedido, cr.nrosucursal, cr.nroremitocliente, "
					+ "       cl.idcliente, cl.razon, lg.usuarioalt, lg.fechaalt "
					+ "  FROM clientesremitos cr "
					+ "       INNER JOIN pedidosanulacionremitoslog lg ON cr.idremitocliente = lg.idremitocliente AND cr.idempresa = lg.idempresa "
					+ "       INNER JOIN pedidos_regalos_entregas_cabe pc ON lg.idpedido = pc.idpedido_regalos_entrega_cabe AND lg.idempresa = pc.idempresa "
					+ "       INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa "
					+ " WHERE (cl.idcliente::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "' OR cr.nroremitocliente::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "' OR lg.idpedido::varchar = '"
					+ ocurrencia.toUpperCase().trim()
					+ "') AND lg.tipopedido = '" + tipopedido.toUpperCase()
					+ "'  AND cr.idempresa = " + idempresa.toString()
					+ " ORDER BY 2, 5  LIMIT " + limit + " OFFSET  " + offset
					+ ";";
		List vecSalida = getLista(cQuery);

		return vecSalida;
	}

	public List getClientesExpresosCPostalAll(long limit, long offset,
			String cpostal, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ex.idexpreso, ex.expreso, "
				+ "       cl.idcliente, cl.razon, es.idestado, es.estado,  "
				+ "       tc.idtipoclie, tc.tipoclie,  "
				+ "       gl.idlocalidad, gl.localidad, "
				+ "       gp.idprovincia, gp.provincia, "
				+ "       fu_periodicidad(cl.idcliente, cl.idempresa) AS periodicodad, "
				+ "       cl.idempresa, cl.usuarioalt, cl.usuarioact, cl.fechaalt, cl.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa  "
				+ "       INNER JOIN clientestipoclie tc ON cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa AND cd.esdefault = 'S' "
				+ "       INNER JOIN clientesanexolocalidades ax ON cd.idanexolocalidad = ax.idanexolocalidad AND cd.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades gl ON ax.idlocalidad = gl.idlocalidad  "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia "
				+ "       INNER JOIN clientesexpresoszonas ez ON ax.idexpresozona = ez.codigo AND ax.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso AND ex.idempresa = ex.idempresa	 "
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "   AND TRIM(gl.cpostal) = '" + cpostal.trim().toString()
				+ "' ORDER BY es.estado   LIMIT " + limit + " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesExpresosCPostalAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesXExpresoAll(long limit, long offset,
			BigDecimal idexpreso, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ex.idexpreso, ex.expreso, "
				+ "       cl.idcliente, cl.razon, es.idestado, es.estado,  "
				+ "       tc.idtipoclie, tc.tipoclie,  "
				+ "       gl.idlocalidad, gl.localidad, "
				+ "       gp.idprovincia, gp.provincia, "
				+ "       fu_periodicidad(cl.idcliente, cl.idempresa) AS periodicodad, "
				+ "       cl.idempresa, cl.usuarioalt, cl.usuarioact, cl.fechaalt, cl.fechaact "
				+ "  FROM clientesclientes cl "
				+ "       INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
				+ "       INNER JOIN clientesestados es ON eh.idestado = es.idestado AND eh.idempresa = es.idempresa  "
				+ "       INNER JOIN clientestipoclie tc ON cl.idtipoclie = tc.idtipoclie AND cl.idempresa = tc.idempresa "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa AND cd.esdefault = 'S' "
				+ "       INNER JOIN clientesanexolocalidades ax ON cd.idanexolocalidad = ax.idanexolocalidad AND cd.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades gl ON ax.idlocalidad = gl.idlocalidad  "
				+ "       INNER JOIN globalprovincias gp ON gl.idprovincia = gp.idprovincia "
				+ "       INNER JOIN clientesexpresoszonas ez ON ax.idexpresozona = ez.codigo AND ax.idempresa = ez.idempresa "
				+ "       INNER JOIN clientesexpresos ex ON ez.idexpreso = ex.idexpreso AND ex.idempresa = ex.idempresa	 "
				+ " WHERE cl.idempresa = " + idempresa.toString()
				+ "   AND ex.idexpreso =  " + idexpreso.toString()
				+ " ORDER BY es.estado   LIMIT " + limit + " OFFSET  " + offset
				+ ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesXExpresoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesIndicadoresTipos Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Apr 29 15:16:19 GMT-03:00 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesIndicadoresTiposAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idtipoindicador,tipoindicador, idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientesindicadorestipos WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresTiposAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesIndicadoresTiposOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipoindicador,tipoindicador,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientesindicadorestipos WHERE (UPPER(tipoindicador) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresTiposOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesIndicadoresTiposPK(BigDecimal idtipoindicador,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idtipoindicador,tipoindicador,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM clientesindicadorestipos" + " WHERE idtipoindicador="
				+ idtipoindicador.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresTiposPK( BigDecimal idtipoindicador )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesIndicadoresTiposDelete(BigDecimal idtipoindicador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESINDICADORESTIPOS WHERE idtipoindicador="
				+ idtipoindicador.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESINDICADORESTIPOS WHERE idtipoindicador="
						+ idtipoindicador.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesIndicadoresTiposDelete( BigDecimal idtipoindicador, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesIndicadoresTiposDelete( BigDecimal idtipoindicador, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesIndicadoresTiposCreate(String tipoindicador,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipoindicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoindicador ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESINDICADORESTIPOS(tipoindicador, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipoindicador);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresTiposCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresTiposCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesIndicadoresTiposCreateOrUpdate(
			BigDecimal idtipoindicador, String tipoindicador,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoindicador ";
		if (tipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipoindicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoindicador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresTipos WHERE idtipoindicador = "
					+ idtipoindicador.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESTIPOS SET tipoindicador=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipoindicador=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoindicador);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipoindicador);
				} else {
					String ins = "INSERT INTO CLIENTESINDICADORESTIPOS(tipoindicador, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipoindicador);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresTiposCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresTiposCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesIndicadoresTiposUpdate(BigDecimal idtipoindicador,
			String tipoindicador, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoindicador ";
		if (tipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipoindicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoindicador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresTipos WHERE idtipoindicador = "
					+ idtipoindicador.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESTIPOS SET tipoindicador=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipoindicador=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipoindicador);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idtipoindicador);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesIndicadoresTiposUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresTiposUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesIndicadoresManuales Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Apr 30 10:30:20 GMT-03:00 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesIndicadoresManualesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT im.idindicador,im.indicador,im.idtipoindicador, it.tipoindicador ,im.queryseleccion,"
				+ "       im.idempresa,im.usuarioalt,im.usuarioact,im.fechaalt,im.fechaact "
				+ "  FROM clientesindicadoresmanuales  im "
				+ "       INNER JOIN clientesindicadorestipos it ON im.idtipoindicador = it.idtipoindicador AND im.idempresa = it.idempresa  "
				+ " WHERE im.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresManualesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesIndicadoresManualesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT im.idindicador,im.indicador,im.idtipoindicador, it.tipoindicador ,im.queryseleccion,"
				+ "       im.idempresa,im.usuarioalt,im.usuarioact,im.fechaalt,im.fechaact "
				+ "  FROM clientesindicadoresmanuales im "
				+ "       INNER JOIN clientesindicadorestipos it ON im.idtipoindicador = it.idtipoindicador AND im.idempresa = it.idempresa  "
				+ " WHERE (UPPER(im.indicador) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND im.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresManualesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesIndicadoresManualesPK(BigDecimal idindicador,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idindicador,indicador,idtipoindicador,queryseleccion,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM CLIENTESINDICADORESMANUALES WHERE idindicador="
				+ idindicador.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresManualesPK( BigDecimal idindicador )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesIndicadoresManualesDelete(BigDecimal idindicador,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESINDICADORESMANUALES WHERE idindicador="
				+ idindicador.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESINDICADORESMANUALES WHERE idindicador="
						+ idindicador.toString().toString()
						+ " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesIndicadoresManualesDelete( BigDecimal idindicador, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesIndicadoresManualesDelete( BigDecimal idindicador, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesIndicadoresManualesCreate(String indicador,
			BigDecimal idtipoindicador, String queryseleccion,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (indicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: indicador ";
		if (idtipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (indicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: indicador ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESINDICADORESMANUALES(indicador, idtipoindicador, queryseleccion, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, indicador);
				insert.setBigDecimal(2, idtipoindicador);
				insert.setString(3, queryseleccion);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresManualesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresManualesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesIndicadoresManualesCreateOrUpdate(
			BigDecimal idindicador, String indicador,
			BigDecimal idtipoindicador, String queryseleccion,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idindicador ";
		if (indicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: indicador ";
		if (idtipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (indicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: indicador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresManuales WHERE idindicador = "
					+ idindicador.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESMANUALES SET indicador=?, idtipoindicador=?, queryseleccion=?, idempresa=?, usuarioact=?, fechaact=? WHERE idindicador=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, indicador);
					insert.setBigDecimal(2, idtipoindicador);
					insert.setString(3, queryseleccion);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idindicador);
				} else {
					String ins = "INSERT INTO CLIENTESINDICADORESMANUALES(indicador, idtipoindicador, queryseleccion, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, indicador);
					insert.setBigDecimal(2, idtipoindicador);
					insert.setString(3, queryseleccion);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresManualesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresManualesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesIndicadoresManualesUpdate(BigDecimal idindicador,
			String indicador, BigDecimal idtipoindicador,
			String queryseleccion, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idindicador ";
		if (indicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: indicador ";
		if (idtipoindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoindicador ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (indicador.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: indicador ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresManuales WHERE idindicador = "
					+ idindicador.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESMANUALES SET indicador=?, idtipoindicador=?, queryseleccion=?, idempresa=?, usuarioact=?, fechaact=? WHERE idindicador=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, indicador);
					insert.setBigDecimal(2, idtipoindicador);
					insert.setString(3, queryseleccion);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idindicador);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesIndicadoresManualesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresManualesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesIndicadoresClientes Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Apr 30 15:18:45 GMT-03:00 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesIndicadoresClientesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT ci.iddato,ci.idcliente, cl.razon,ci.idindicador, im.indicador,ci.valor,"
				+ "       ci.idempresa,ci.usuarioalt,ci.usuarioact,ci.fechaalt,ci.fechaact "
				+ "  FROM clientesindicadoresclientes ci "
				+ "       INNER JOIN clientesclientes cl ON ci.idcliente = cl.idcliente AND ci.idempresa = ci.idempresa "
				+ "       INNER JOIN clientesindicadoresmanuales im ON ci.idindicador = im.idindicador AND ci.idempresa = im.idempresa "
				+ " WHERE ci.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresClientesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesIndicadoresClientesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT ci.iddato,ci.idcliente, cl.razon,ci.idindicador, im.indicador,ci.valor,"
				+ "       ci.idempresa,ci.usuarioalt,ci.usuarioact,ci.fechaalt,ci.fechaact "
				+ "  FROM clientesindicadoresclientes ci "
				+ "       INNER JOIN clientesclientes cl ON ci.idcliente = cl.idcliente AND ci.idempresa = ci.idempresa "
				+ "       INNER JOIN clientesindicadoresmanuales im ON ci.idindicador = im.idindicador AND ci.idempresa = im.idempresa "
				+ " WHERE (UPPER(ci.idcliente::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND ci.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresClientesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesIndicadoresClientesPK(BigDecimal iddato,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT ci.iddato,ci.idcliente, cl.razon,ci.idindicador, im.indicador,ci.valor,"
				+ "       ci.idempresa,ci.usuarioalt,ci.usuarioact,ci.fechaalt,ci.fechaact "
				+ "  FROM clientesindicadoresclientes ci "
				+ "       INNER JOIN clientesclientes cl ON ci.idcliente = cl.idcliente AND ci.idempresa = ci.idempresa "
				+ "       INNER JOIN clientesindicadoresmanuales im ON ci.idindicador = im.idindicador AND ci.idempresa = im.idempresa "
				+ " WHERE ci.iddato=" + iddato.toString()
				+ "   AND ci.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresClientesPK( BigDecimal iddato )  "
							+ ex);
		}
		return vecSalida;
	}

	// por cliente

	public List getClientesIndicadoresXClienteAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT ci.iddato,ci.idcliente, cl.razon,ci.idindicador, im.indicador,ci.valor,"
				+ "       ci.idempresa,ci.usuarioalt,ci.usuarioact,ci.fechaalt,ci.fechaact "
				+ "  FROM clientesindicadoresclientes ci "
				+ "       INNER JOIN clientesclientes cl ON ci.idcliente = cl.idcliente AND ci.idempresa = ci.idempresa "
				+ "       INNER JOIN clientesindicadoresmanuales im ON ci.idindicador = im.idindicador AND ci.idempresa = im.idempresa "
				+ " WHERE ci.idcliente = " + idcliente.toString()
				+ "   AND ci.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresClientesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesIndicadoresXClienteOcu(long limit, long offset,
			BigDecimal idcliente, String ocurrencia, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT ci.iddato,ci.idcliente, cl.razon,ci.idindicador, im.indicador,ci.valor,"
				+ "       ci.idempresa,ci.usuarioalt,ci.usuarioact,ci.fechaalt,ci.fechaact "
				+ "  FROM clientesindicadoresclientes ci "
				+ "       INNER JOIN clientesclientes cl ON ci.idcliente = cl.idcliente AND ci.idempresa = ci.idempresa "
				+ "       INNER JOIN clientesindicadoresmanuales im ON ci.idindicador = im.idindicador AND ci.idempresa = im.idempresa "
				+ " WHERE (UPPER(ci.idcliente::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND ci.idcliente = "
				+ idcliente.toString() + "  AND ci.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesIndicadoresXClienteOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesIndicadoresClientesDelete(BigDecimal iddato,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESINDICADORESCLIENTES WHERE iddato="
				+ iddato.toString() + " AND idempresa=" + idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESINDICADORESCLIENTES WHERE iddato="
						+ iddato.toString().toString()
						+ " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesIndicadoresClientesDelete( BigDecimal iddato, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesIndicadoresClientesDelete( BigDecimal iddato, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesIndicadoresClientesCreate(BigDecimal idcliente,
			BigDecimal idindicador, BigDecimal valor, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idindicador ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		if (getTotalEntidadFiltro("clientesindicadoresclientes",
				" WHERE idcliente = " + idcliente + " AND idindicador = "
						+ idindicador, idempresa) > 0L)
			salida = "El indicador seleccionado ya se encuentra asociado al cliente.";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESINDICADORESCLIENTES(idcliente, idindicador, valor, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idindicador);
				insert.setBigDecimal(3, valor);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresClientesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresClientesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesIndicadoresClientesCreateOrUpdate(BigDecimal iddato,
			BigDecimal idcliente, BigDecimal idindicador, BigDecimal valor,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddato == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddato ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idindicador ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresClientes WHERE iddato = "
					+ iddato.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESCLIENTES SET idcliente=?, idindicador=?, valor=?, idempresa=?, usuarioact=?, fechaact=? WHERE iddato=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idindicador);
					insert.setBigDecimal(3, valor);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, iddato);
				} else {
					String ins = "INSERT INTO CLIENTESINDICADORESCLIENTES(idcliente, idindicador, valor, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idindicador);
					insert.setBigDecimal(3, valor);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesIndicadoresClientesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresClientesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesIndicadoresClientesUpdate(BigDecimal iddato,
			BigDecimal idcliente, BigDecimal idindicador, BigDecimal valor,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (iddato == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: iddato ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idindicador == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idindicador ";
		if (valor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: valor ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (getTotalEntidadFiltro("clientesindicadoresclientes",
				" WHERE idcliente = " + idcliente + " AND idindicador = "
						+ idindicador + " AND iddato <> " + iddato, idempresa) > 0L)
			salida = "El indicador seleccionado ya se encuentra asociado al cliente.";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesIndicadoresClientes WHERE iddato = "
					+ iddato.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESINDICADORESCLIENTES SET idcliente=?, idindicador=?, valor=?, idempresa=?, usuarioact=?, fechaact=? WHERE iddato=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idindicador);
					insert.setBigDecimal(3, valor);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, iddato);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesIndicadoresClientesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesIndicadoresClientesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefOperaciones Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Jun 15 11:08:58 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefOperacionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idoperacion,operacion,descripcion,puntaje,tipo,signo,fechadesde,fechahasta,fechabaja, proceso,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM bacorefoperaciones "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefOperacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getBacoRefOperacionesXProceso(String proceso,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idoperacion,operacion,descripcion,puntaje,tipo,signo,fechadesde,fechahasta,fechabaja, proceso,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM bacorefoperaciones "
				+ " WHERE fechabaja IS NULL AND idempresa = "
				+ idempresa.toString() + " AND LOWER(proceso) = '"
				+ proceso.toLowerCase() + "'  ORDER BY 2 ;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefOperacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefOperacionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idoperacion,operacion,descripcion,puntaje,tipo,signo,fechadesde,fechahasta,fechabaja, proceso, "
				+ "       idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacorefoperaciones"
				+ " WHERE (UPPER(operacion) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefOperacionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefOperacionesPK(BigDecimal idoperacion,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idoperacion,operacion,descripcion,puntaje,tipo,signo,fechadesde,fechahasta,fechabaja, proceso, "
				+ "       idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM bacorefoperaciones WHERE idoperacion="
				+ idoperacion.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefOperacionesPK( BigDecimal idoperacion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefOperacionesDelete(BigDecimal idoperacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFOPERACIONES WHERE idoperacion="
				+ idoperacion.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFOPERACIONES WHERE idoperacion="
						+ idoperacion.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefOperacionesDelete( BigDecimal idoperacion, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefOperacionesDelete( BigDecimal idoperacion, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	public String bacoRefOperacionesDeleteLogico(BigDecimal idoperacion,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		java.sql.Date fechabaja = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());
		// validaciones de datos:
		// 1. nulidad de campos
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefOperaciones WHERE idoperacion = "
					+ idoperacion.toString() + " AND fechabaja IS NULL ";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFOPERACIONES SET  fechabaja=?, idempresa=?, usuarioact=?, fechaact=? WHERE idoperacion=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setDate(1, fechabaja);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idoperacion);

					int i = insert.executeUpdate();
					if (i > 0)
						salida = "Baja Lgica Correcta";
					else
						salida = "Imposible generar baja lgica el registro.";

				} else {

					salida = "Registro inexistente o fecha de baja asignada desde otra sesin.";

				}

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar baja lgica el registro.";
			log
					.error("Error SQL public String bacoRefOperacionesDeleteLogico(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar baja lgica el registro.";
			log
					.error("Error excepcion public String bacoRefOperacionesDeleteLogico(.....)"
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefOperacionesCreate(String operacion,
			String descripcion, BigDecimal puntaje, String tipo, String signo,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			java.sql.Date fechabaja, String proceso, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (signo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: signo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		if (signo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: signo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// getTotalEntidadFiltro(entidad, filtro, idempresa);

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFOPERACIONES(operacion, descripcion, puntaje, tipo, signo, fechadesde, fechahasta, fechabaja, proceso, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, operacion);
				insert.setString(2, descripcion);
				insert.setBigDecimal(3, puntaje);
				insert.setString(4, tipo);
				insert.setString(5, signo);
				insert.setDate(6, fechadesde);
				insert.setDate(7, fechahasta);
				insert.setDate(8, fechabaja);
				insert.setString(9, proceso);
				insert.setBigDecimal(10, idempresa);
				insert.setString(11, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefOperacionesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefOperacionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefOperacionesCreateOrUpdate(BigDecimal idoperacion,
			String operacion, String descripcion, BigDecimal puntaje,
			String tipo, String signo, java.sql.Date fechadesde,
			java.sql.Date fechahasta, java.sql.Date fechabaja, String proceso,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (signo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: signo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		if (signo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: signo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefOperaciones WHERE idoperacion = "
					+ idoperacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFOPERACIONES SET operacion=?, descripcion=?, puntaje=?, tipo=?, signo=?, fechadesde=?, fechahasta=?, fechabaja=?, proceso=?, idempresa=?, usuarioact=?, fechaact=? WHERE idoperacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, operacion);
					insert.setString(2, descripcion);
					insert.setBigDecimal(3, puntaje);
					insert.setString(4, tipo);
					insert.setString(5, signo);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					insert.setString(9, proceso);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idoperacion);
				} else {
					String ins = "INSERT INTO BACOREFOPERACIONES(operacion, descripcion, puntaje, tipo, signo, fechadesde, fechahasta, fechabaja, proceso, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, operacion);
					insert.setString(2, descripcion);
					insert.setBigDecimal(3, puntaje);
					insert.setString(4, tipo);
					insert.setString(5, signo);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					insert.setString(9, proceso);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefOperacionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefOperacionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefOperacionesUpdate(BigDecimal idoperacion,
			String operacion, String descripcion, BigDecimal puntaje,
			String tipo, String signo, java.sql.Date fechadesde,
			java.sql.Date fechahasta, java.sql.Date fechabaja, String proceso,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (signo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: signo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		if (signo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: signo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefOperaciones WHERE idoperacion = "
					+ idoperacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFOPERACIONES SET operacion=?, descripcion=?, puntaje=?, tipo=?, signo=?, fechadesde=?, fechahasta=?, fechabaja=?, proceso=?, idempresa=?, usuarioact=?, fechaact=? WHERE idoperacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, operacion);
					insert.setString(2, descripcion);
					insert.setBigDecimal(3, puntaje);
					insert.setString(4, tipo);
					insert.setString(5, signo);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					insert.setString(9, proceso);
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idoperacion);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefOperacionesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefOperacionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefCatalogo Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Jun 15 15:54:26 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefCatalogoAll(long limit, long offset, String filtro,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcatalogo, codigo_st, descrip_st, puntaje, comprometido, utilizado, fechadesde, fechahasta, fechabaja,"
				+ "             idcatalogocategoria, catalogocategoria, "
				+ "             idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
				+ "  FROM("
				+ "          SELECT cgo.idcatalogo, cgo.codigo_st, cgo.descrip_st, cgo.puntaje, cgo.comprometido, cgo.utilizado, cgo.fechadesde, cgo.fechahasta, cgo.fechabaja,"
				+ "                       cia.idcatalogocategoria, cia.catalogocategoria, "
				+ "                       cgo.idempresa, cgo.usuarioalt, cgo.usuarioact, cgo.fechaalt, cgo.fechaact"
				+ "             FROM bacorefcatalogo cgo "
				+ "                       INNER JOIN  bacorefcatalogocategoria  cia ON cgo.idcatalogocategoria = cia.idcatalogocategoria AND cgo.idempresa = cia.idempresa "
				+ "          ) catalogo " + " WHERE idempresa = "
				+ idempresa.toString() + filtro + "  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefCatalogoOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cgo.idcatalogo, cgo.codigo_st, cgo.descrip_st, cgo.puntaje, cgo.comprometido, cgo.utilizado, cgo.fechadesde, cgo.fechahasta, cgo.fechabaja,"
				+ "             cia.idcatalogocategoria, cia.catalogocategoria, "
				+ "            cgo.idempresa, cgo.usuarioalt, cgo.usuarioact, cgo.fechaalt, cgo.fechaact"
				+ "   FROM bacorefcatalogo cgo "
				+ "             INNER JOIN  bacorefcatalogocategoria  cia ON cgo.idcatalogocategoria = cia.idcatalogocategoria AND cgo.idempresa = cia.idempresa "
				+ " WHERE (UPPER(cgo.codigo_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(cgo.descrip_st) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%' ) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' )  AND cgo.idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefCatalogoPK(BigDecimal idcatalogo, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idcatalogo,codigo_st,descrip_st,puntaje,comprometido,utilizado,fechadesde,fechahasta,fechabaja,"
				// 20120315 - EJV - Mantis 702 -->
				+ "             idcatalogocategoria, "
				// <--
				+ "            idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacorefcatalogo WHERE idcatalogo="
				+ idcatalogo.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoPK( BigDecimal idcatalogo )  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getBacoRefCatalogoPuntos(String codigo_st,
			java.sql.Date fecha, BigDecimal idempresa) throws EJBException {
		BigDecimal puntos = new BigDecimal(-1);
		String cQuery = "SELECT puntaje  FROM bacorefcatalogo "
				+ "WHERE codigo_st='"
				+ codigo_st
				+ "' AND '"
				+ fecha
				+ "'::DATE BETWEEN fechadesde AND fechahasta AND fechabaja IS NULL  AND idempresa = "
				+ idempresa.toString() + ";";

		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {

				if (rsSalida.next()) {

					puntos = rsSalida.getBigDecimal(1);

				} else
					log.warn("No existe catalogo-referidos: " + codigo_st);

			} else
				log.warn("Error al intentar recuperar catalogo-referidos: "
						+ codigo_st);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoPuntos( BigDecimal idcatalogo )  "
							+ ex);
		}

		return puntos;

	}

	public BigDecimal getCountPedidoBacoRefCtaCte(BigDecimal idpedido,
			BigDecimal idempresa) throws EJBException {
		BigDecimal total = new BigDecimal(-15);
		String cQuery = "SELECT COUNT(idpedido)  FROM bacorefctacte "
				+ "WHERE idpedido=" + idpedido + " AND idempresa = "
				+ idempresa.toString() + ";";

		try {

			Statement statement = dbconn.createStatement();
			ResultSet rsSalida = statement.executeQuery(cQuery);

			if (rsSalida != null) {
				total = new BigDecimal(-10);

				if (rsSalida.next()) {

					total = rsSalida.getBigDecimal(1);

				} else
					log
							.warn("No existe registro de totalizacion en cta-cte referidos para pedido : "
									+ idpedido);

			} else
				log
						.warn("Error al intentar recuperar  registro de totalizacion en cta-cte referidos para pedido : "
								+ idpedido);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCountPedidoBacoRefCtaCte( BigDecimal idcatalogo )  "
							+ ex);
		}

		return total;

	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefCatalogoDelete(BigDecimal idcatalogo,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFCATALOGO WHERE idcatalogo="
				+ idcatalogo.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFCATALOGO WHERE idcatalogo="
						+ idcatalogo.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefCatalogoDelete( BigDecimal idcatalogo, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefCatalogoDelete( BigDecimal idcatalogo, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	public String bacoRefCatalogoDeleteLogico(BigDecimal idcatalogo,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		java.sql.Date fechabaja = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcatalogo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcatalogo ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCatalogo WHERE idcatalogo = "
					+ idcatalogo.toString() + " AND fechabaja IS NULL";
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE bacorefcatalogo SET  fechabaja=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcatalogo=?;";
					insert = dbconn.prepareStatement(sql);

					insert.setDate(1, fechabaja);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idcatalogo);

					int i = insert.executeUpdate();
					if (i > 0)
						salida = "Baja Lgica Correcta";
					else
						salida = "Imposible generar baja lgica.";

				} else {
					salida = "Registro inexistente o fecha de baja asignada desde otra sesin.";
				}

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar baja lgica.";
			log
					.error("Error SQL public String bacoRefCatalogoDeleteLogico(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar baja lgica.";
			log
					.error("Error excepcion public String bacoRefCatalogoDeleteLogico(.....)"
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefCatalogoCreate(String codigo_st, String descrip_st,
			BigDecimal puntaje, BigDecimal comprometido, BigDecimal utilizado,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			java.sql.Date fechabaja,
			// 20120315 - EJV - Mantis 702 -->
			BigDecimal idcatalogocategoria,
			// <--
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (comprometido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comprometido ";
		if (utilizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: utilizado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";
		// 20120315 - EJV - Mantis 702 -->
		if (idcatalogocategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoria ";
		// <--

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO BACOREFCATALOGO"
						+ "              (codigo_st,descrip_st, puntaje, comprometido, utilizado, fechadesde, fechahasta, fechabaja, idcatalogocategoria, idempresa, usuarioalt )"
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, codigo_st);
				insert.setString(2, descrip_st);
				insert.setBigDecimal(3, puntaje);
				insert.setBigDecimal(4, comprometido);
				insert.setBigDecimal(5, utilizado);
				insert.setDate(6, fechadesde);
				insert.setDate(7, fechahasta);
				insert.setDate(8, fechabaja);
				// 20120315 - EJV - Mantis 702 -->
				insert.setBigDecimal(9, idcatalogocategoria);
				// <--

				insert.setBigDecimal(10, idempresa);
				insert.setString(11, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefCatalogoCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefCatalogoCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefCatalogoCreateOrUpdate(BigDecimal idcatalogo,
			String codigo_st, String descrip_st, BigDecimal puntaje,
			BigDecimal comprometido, BigDecimal utilizado,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			java.sql.Date fechabaja, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcatalogo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcatalogo ";
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (comprometido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comprometido ";
		if (utilizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: utilizado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCatalogo WHERE idcatalogo = "
					+ idcatalogo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFCATALOGO SET codigo_st=?, descrip_st=?, puntaje=?, comprometido=?, utilizado=?, fechadesde=?, fechahasta=?, fechabaja=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcatalogo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, codigo_st);
					insert.setString(2, descrip_st);
					insert.setBigDecimal(3, puntaje);
					insert.setBigDecimal(4, comprometido);
					insert.setBigDecimal(5, utilizado);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idcatalogo);
				} else {
					String ins = "INSERT INTO BACOREFCATALOGO(codigo_st,descrip_st, puntaje, comprometido, utilizado, fechadesde, fechahasta, fechabaja, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, codigo_st);
					insert.setString(2, descrip_st);
					insert.setBigDecimal(3, puntaje);
					insert.setBigDecimal(4, comprometido);
					insert.setBigDecimal(5, utilizado);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefCatalogoCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefCatalogoCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefCatalogoUpdate(BigDecimal idcatalogo,
			String codigo_st, String descrip_st, BigDecimal puntaje,
			BigDecimal comprometido, BigDecimal utilizado,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			java.sql.Date fechabaja,

			// 20120315 - EJV - Mantis 702 -->
			BigDecimal idcatalogocategoria,

			// <--

			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcatalogo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcatalogo ";
		if (puntaje == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntaje ";
		if (comprometido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comprometido ";
		if (utilizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: utilizado ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idcatalogocategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: categoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCatalogo WHERE idcatalogo = "
					+ idcatalogo.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE BACOREFCATALOGO "
							+ "      SET codigo_st=?, descrip_st=?, puntaje=?, comprometido=?, utilizado=?, fechadesde=?, fechahasta=?, fechabaja=?,  idcatalogocategoria=?, idempresa=?, usuarioact=?, fechaact=? "
							+ "WHERE idcatalogo=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, codigo_st);
					insert.setString(2, descrip_st);
					insert.setBigDecimal(3, puntaje);
					insert.setBigDecimal(4, comprometido);
					insert.setBigDecimal(5, utilizado);
					insert.setDate(6, fechadesde);
					insert.setDate(7, fechahasta);
					insert.setDate(8, fechabaja);
					// 20120315 - EJV - Mantis 702 -->
					insert.setBigDecimal(9, idcatalogocategoria);
					// <--
					insert.setBigDecimal(10, idempresa);
					insert.setString(11, usuarioact);
					insert.setTimestamp(12, fechaact);
					insert.setBigDecimal(13, idcatalogo);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefCatalogoUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefCatalogoUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefCatalogoUpdateCantidades(String codigo_st,
			BigDecimal comprometido, BigDecimal utilizado, java.sql.Date fecha,
			BigDecimal idempresa, String usuarioact,
			// 20120410 - EJV - Mantis 702 -->
			Connection conn
	// <--
	) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (comprometido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: comprometido ";
		if (utilizado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: utilizado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCatalogo WHERE codigo_st = '"
					+ codigo_st.toString()
					+ "'  AND fechabaja IS NULL AND '"
					+ fecha
					+ "'::DATE BETWEEN fechadesde AND fechahasta AND idempresa = "
					+ idempresa.toString();
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE bacorefcatalogo "
						+ "      SET comprometido=(comprometido+(?)), "
						+ "             utilizado=(utilizado+(?)), usuarioact=?, fechaact=?"
						+ " WHERE codigo_st=? AND idempresa=? "
						+ "      AND fechabaja IS NULL AND ? BETWEEN fechadesde AND fechahasta;";

				insert = conn.prepareStatement(sql);

				insert.setBigDecimal(1, comprometido);
				insert.setBigDecimal(2, utilizado);
				insert.setString(3, usuarioact);
				insert.setTimestamp(4, fechaact);
				insert.setString(5, codigo_st);
				insert.setBigDecimal(6, idempresa);
				insert.setDate(7, fecha);

			}

			int i = insert.executeUpdate();
			if (i != 1)
				salida = "No fue posible actualizar registro de catalogo, posiblemente fuera de rango de fechas.";

		} catch (SQLException sqlException) {
			salida = "(SQL)No fue posible actualizar registro de catalogo.";
			log
					.error("Error SQL public String bacoRefCatalogoUpdateCantidades(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible actualizar registro de catalogo.";
			log
					.error("Error excepcion public String bacoRefCatalogoUpdateCantidades(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefCatalogoActualizaCantidades(BigDecimal idpedido,
			String articu_sb, BigDecimal pedid_sb, String usuarioalt,
			BigDecimal idempresa) throws EJBException {

		String salida = "OK";

		try {

			// EJV - 20100630
			// -------------------------------------------------------
			// REFERIDOS -- >

			BigDecimal countPedidoctacta = getCountPedidoBacoRefCtaCte(
					idpedido, idempresa);
			if (countPedidoctacta.longValue() > 0) {

				java.sql.Date fecha = new java.sql.Date(Calendar.getInstance()
						.getTimeInMillis());
				bacoRefCatalogoUpdateCantidades(articu_sb, new BigDecimal(0),
						pedid_sb, fecha, idempresa, usuarioalt, dbconn);

			}

			// < --
			// -------------------------------------------------------

		} catch (Exception e) {
			log.error("bacoRefCatalogoActualizaCantidades(): " + e);
		}

		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefFuentes Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Tue Jun 15 17:55:58 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefFuentesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idfuente,fuente,idcliente,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM bacoreffuentes WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefFuentesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefFuentesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idfuente,fuente,idcliente,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacoreffuentes WHERE (UPPER(FUENTE) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefFuentesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefFuentesPK(BigDecimal idfuente, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idfuente,fuente,idcliente,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM bacoreffuentes WHERE idfuente=" + idfuente.toString()
				+ " AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefFuentesPK( BigDecimal idfuente )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefFuentesDelete(BigDecimal idfuente, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFFUENTES WHERE idfuente="
				+ idfuente.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFFUENTES WHERE idfuente="
						+ idfuente.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefFuentesDelete( BigDecimal idfuente, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefFuentesDelete( BigDecimal idfuente, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefFuentesCreate(String fuente, BigDecimal idcliente,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFFUENTES(fuente, idcliente, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, fuente);
				insert.setBigDecimal(2, idcliente);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefFuentesCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefFuentesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefFuentesCreateOrUpdate(BigDecimal idfuente,
			String fuente, BigDecimal idcliente, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idfuente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idfuente ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefFuentes WHERE idfuente = "
					+ idfuente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFFUENTES SET fuente=?, idcliente=?, idempresa=?, usuarioact=?, fechaact=? WHERE idfuente=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, fuente);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idfuente);
				} else {
					String ins = "INSERT INTO BACOREFFUENTES(fuente, idcliente, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, fuente);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefFuentesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefFuentesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefFuentesUpdate(BigDecimal idfuente, String fuente,
			BigDecimal idcliente, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idfuente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idfuente ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefFuentes WHERE idfuente = "
					+ idfuente.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFFUENTES SET fuente=?, idcliente=?, idempresa=?, usuarioact=?, fechaact=? WHERE idfuente=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, fuente);
					insert.setBigDecimal(2, idcliente);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idfuente);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefFuentesUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefFuentesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefPrepro Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Wed Jun 16 10:12:02 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefPreproAll(long limit, long offset, String filtro,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				//
				+ "SELECT idpreprospecto, nombre, apellido, idreferente, razon, idvendedor, vendedor, idfuente, fuente, fecha,"
				+ "             telefono, celular, email, idprovincia, provincia, idlocalidad, localidad, observaciones, procesado,"
				+ "             idrefestado, refestado, idrefsubestado, refsubestado,  "
				+ "             idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
				+ "   FROM ( "
				//
				+ "              SELECT pp.idpreprospecto,pp.nombre,pp.apellido,pp.idreferente,cl.razon,pp.idvendedor,v.vendedor,pp.idfuente, rf.fuente, pp.fecha,"
				+ "                           pp.telefono,pp.celular,pp.email,pp.idprovincia,pv.provincia,pp.idlocalidad,lo.localidad,pp.observaciones,pp.procesado,"
				// 
				+ "                           res.idrefestado, res.refestado,  ses.idrefsubestado,  ses.refsubestado, "
				//
				+ "                           pp.idempresa,pp.usuarioalt,pp.usuarioact,pp.fechaalt,pp.fechaact "
				+ "                 FROM bacorefprepro pp"
				+ "                           INNER JOIN bacoreffuentes rf ON pp.idfuente = rf.idfuente AND pp.idempresa = rf.idempresa "
				+ "                           INNER JOIN clientesclientes cl ON pp.idreferente = cl.idcliente AND pp.idempresa = cl.idempresa "
				+ "                           INNER JOIN clientesvendedor v ON pp.idvendedor = v.idvendedor AND pp.idempresa = v.idempresa "
				+ "                           INNER JOIN bacorefestados res ON pp.idrefestado = res.idrefestado AND pp.idempresa = res.idempresa "
				+ "                             LEFT JOIN bacorefsubestados ses ON pp.idrefsubestado = ses.idrefsubestado AND pp.idempresa = ses.idempresa "
				+ "                             LEFT JOIN globalprovincias pv ON pp.idprovincia = pv.idprovincia "
				+ "                             LEFT JOIN globallocalidades lo ON pp.idlocalidad = lo.idlocalidad "
				+ "         ) brpp  " + " WHERE idempresa = "
				+ idempresa.toString() + filtro
				+ "  ORDER BY procesado , apellido , nombre LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefPreproAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefPreproOcu(long limit, long offset, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT pp.idpreprospecto,pp.nombre,pp.apellido,pp.idreferente,cl.razon,pp.idvendedor,v.vendedor,pp.idfuente, rf.fuente, pp.fecha,"
				+ "             pp.telefono,pp.celular,pp.email,pp.idprovincia,pv.provincia,pp.idlocalidad,lo.localidad,pp.observaciones,pp.procesado,"
				+ "             pp.idempresa,pp.usuarioalt,pp.usuarioact,pp.fechaalt,pp.fechaact"
				+ "   FROM bacorefprepro pp"
				+ "             INNER JOIN bacoreffuentes rf ON pp.idfuente = rf.idfuente AND pp.idempresa = rf.idempresa "
				+ "             INNER JOIN clientesclientes cl ON pp.idreferente = cl.idcliente AND pp.idempresa = cl.idempresa "
				+ "             INNER JOIN clientesvendedor v ON pp.idvendedor = v.idvendedor AND pp.idempresa = v.idempresa "
				+ "               LEFT JOIN globalprovincias pv ON pp.idprovincia = pv.idprovincia "
				+ "               LEFT JOIN globallocalidades lo ON pp.idlocalidad = lo.idlocalidad "
				+ " WHERE (UPPER(pp.idpreprospecto::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(pp.nombre) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(pp.apellido) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND pp.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY pp.procesado ,pp.apellido , pp.nombre   LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefPreproOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefPreproPK(BigDecimal idpreprospecto,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT pp.idpreprospecto,pp.nombre,pp.apellido,pp.idreferente,cl.razon,pp.idvendedor,v.vendedor,pp.idfuente, rf.fuente, pp.fecha,"
				+ "             pp.telefono,pp.celular,pp.email,pp.idprovincia,pv.provincia,pp.idlocalidad,lo.localidad,pp.observaciones,pp.procesado,"
				+ "             pp.idrefestado, pp.idrefsubestado, "
				+ "             res.refestado, ses.refsubestado, "
				+ "             pp.idempresa,pp.usuarioalt,pp.usuarioact,pp.fechaalt,pp.fechaact"
				+ "   FROM bacorefprepro pp"
				+ "             INNER JOIN bacoreffuentes rf ON pp.idfuente = rf.idfuente AND pp.idempresa = rf.idempresa "
				+ "             INNER JOIN clientesclientes cl ON pp.idreferente = cl.idcliente AND pp.idempresa = cl.idempresa "
				+ "             INNER JOIN clientesvendedor v ON pp.idvendedor = v.idvendedor AND pp.idempresa = v.idempresa "
				//
				+ "              INNER JOIN bacorefestados res ON pp.idrefestado = res.idrefestado AND pp.idempresa = res.idempresa "
				+ "                LEFT JOIN bacorefsubestados ses ON pp.idrefsubestado = ses.idrefsubestado AND pp.idempresa = ses.idempresa "
				//
				+ "                LEFT JOIN globalprovincias pv ON pp.idprovincia = pv.idprovincia "
				+ "                LEFT JOIN globallocalidades lo ON pp.idlocalidad = lo.idlocalidad "
				+ " WHERE pp.idpreprospecto=" + idpreprospecto.toString()
				+ " AND pp.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefPreproPK( BigDecimal idpreprospecto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefPreproDelete(BigDecimal idpreprospecto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM bacorefprepro WHERE idpreprospecto="
				+ idpreprospecto.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFPREPRO WHERE idpreprospecto="
						+ idpreprospecto.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefPreproDelete( BigDecimal idpreprospecto, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefPreproDelete( BigDecimal idpreprospecto, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefPreproCreate(String nombre, String apellido,
			BigDecimal idreferente, BigDecimal idvendedor, BigDecimal idfuente,
			Date fecha, String telefono, String celular, String email,
			BigDecimal idprovincia, BigDecimal idlocalidad,
			String observaciones, BigDecimal procesado,
			// 20120314 - EJV - Mantis 702 -->
			BigDecimal idrefestado, BigDecimal idrefsubestado,
			// <--
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (apellido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: apellido ";
		if (idreferente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreferente ";
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idfuente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idfuente ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (procesado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesado ";
		// 20120314 - EJV - Mantis 702 -->
		if (idrefestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefestado ";
		// <--

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (apellido.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: apellido ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = ""
						+ "INSERT INTO BACOREFPREPRO"
						+ "              (nombre, apellido, idreferente, idvendedor, idfuente, fecha, telefono, celular, email, idprovincia, idlocalidad, observaciones, procesado, idrefestado, idrefsubestado, idempresa, usuarioalt ) "
						+ " VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, nombre);
				insert.setString(2, apellido);
				insert.setBigDecimal(3, idreferente);
				insert.setBigDecimal(4, idvendedor);
				insert.setBigDecimal(5, idfuente);
				insert.setDate(6, fecha);
				insert.setString(7, telefono);
				insert.setString(8, celular);
				insert.setString(9, email);
				insert.setBigDecimal(10, idprovincia);
				insert.setBigDecimal(11, idlocalidad);
				insert.setString(12, observaciones);
				insert.setBigDecimal(13, procesado);
				insert.setBigDecimal(14, idrefestado);
				insert.setBigDecimal(15, idrefsubestado);
				insert.setBigDecimal(16, idempresa);
				insert.setString(17, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefPreproCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefPreproCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefPreproCreateOrUpdate(BigDecimal idpreprospecto,
			String nombre, String apellido, BigDecimal idreferente,
			BigDecimal idvendedor, BigDecimal idfuente, Date fecha,
			String telefono, String celular, String email,
			BigDecimal idprovincia, BigDecimal idlocalidad,
			String observaciones, BigDecimal procesado, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpreprospecto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreprospecto ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (apellido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: apellido ";
		if (idreferente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreferente ";
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idfuente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idfuente ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (procesado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (apellido.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: apellido ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefPrepro WHERE idpreprospecto = "
					+ idpreprospecto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFPREPRO SET nombre=?, apellido=?, idreferente=?, idvendedor=?, idfuente=?, fecha=?, telefono=?, celular=?, email=?, idprovincia=?, idlocalidad=?, observaciones=?, procesado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpreprospecto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, nombre);
					insert.setString(2, apellido);
					insert.setBigDecimal(3, idreferente);
					insert.setBigDecimal(4, idvendedor);
					insert.setBigDecimal(5, idfuente);
					insert.setDate(6, fecha);
					insert.setString(7, telefono);
					insert.setString(8, celular);
					insert.setString(9, email);
					insert.setBigDecimal(10, idprovincia);
					insert.setBigDecimal(11, idlocalidad);
					insert.setString(12, observaciones);
					insert.setBigDecimal(13, procesado);
					insert.setBigDecimal(14, idempresa);
					insert.setString(15, usuarioact);
					insert.setTimestamp(16, fechaact);
					insert.setBigDecimal(17, idpreprospecto);
				} else {
					String ins = "INSERT INTO BACOREFPREPRO(nombre, apellido, idreferente, idvendedor, idfuente, fecha, telefono, celular, email, idprovincia, idlocalidad, observaciones, procesado, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, nombre);
					insert.setString(2, apellido);
					insert.setBigDecimal(3, idreferente);
					insert.setBigDecimal(4, idvendedor);
					insert.setBigDecimal(5, idfuente);
					insert.setDate(6, fecha);
					insert.setString(7, telefono);
					insert.setString(8, celular);
					insert.setString(9, email);
					insert.setBigDecimal(10, idprovincia);
					insert.setBigDecimal(11, idlocalidad);
					insert.setString(12, observaciones);
					insert.setBigDecimal(13, procesado);
					insert.setBigDecimal(14, idempresa);
					insert.setString(15, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefPreproCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefPreproCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefPreproUpdate(BigDecimal idpreprospecto, String nombre,
			String apellido, BigDecimal idreferente, BigDecimal idvendedor,
			BigDecimal idfuente, Date fecha, String telefono, String celular,
			String email, BigDecimal idprovincia, BigDecimal idlocalidad,
			String observaciones, BigDecimal procesado,
			// 20120314 - EJV - Mantis 702 -->
			BigDecimal idrefestado, BigDecimal idrefsubestado,
			// <--
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpreprospecto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpreprospecto ";
		if (nombre == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nombre ";
		if (apellido == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: apellido ";
		if (idreferente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreferente ";
		if (idvendedor == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idvendedor ";
		if (idfuente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idfuente ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (procesado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesado ";
		// 20120314 - EJV - Mantis 702 -->
		if (idrefestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefestado ";
		// <--
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (nombre.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: nombre ";
		if (apellido.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: apellido ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefPrepro WHERE idpreprospecto = "
					+ idpreprospecto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = ""
							+ "UPDATE BACOREFPREPRO "
							+ "     SET nombre=?, apellido=?, idreferente=?, idvendedor=?, idfuente=?, fecha=?, telefono=?, celular=?, email=?, idprovincia=?, idlocalidad=?, observaciones=?, procesado=?, idrefestado=?, idrefsubestado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpreprospecto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, nombre);
					insert.setString(2, apellido);
					insert.setBigDecimal(3, idreferente);
					insert.setBigDecimal(4, idvendedor);
					insert.setBigDecimal(5, idfuente);
					insert.setDate(6, fecha);
					insert.setString(7, telefono);
					insert.setString(8, celular);
					insert.setString(9, email);
					insert.setBigDecimal(10, idprovincia);
					insert.setBigDecimal(11, idlocalidad);
					insert.setString(12, observaciones);
					insert.setBigDecimal(13, procesado);
					insert.setBigDecimal(14, idrefestado);
					insert.setBigDecimal(15, idrefsubestado);
					insert.setBigDecimal(16, idempresa);
					insert.setString(17, usuarioact);
					insert.setTimestamp(18, fechaact);
					insert.setBigDecimal(19, idpreprospecto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefPreproUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefPreproUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefCtaCte Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Thu Jun 17 12:34:05 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefCtaCteAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cc.idctacte,cc.idcliente,cc.idoperacion, ro.operacion, ro.descripcion,cc.idreferido,cc.puntos,cc.fecha,"
				+ "             cc.observaciones, "
				+ "             CASE WHEN ro.operacion = 'PREPRO' THEN  fu_preprospecto(cc.idreferido, cc.idempresa) ELSE '' END prepro, "
				+ "             cc.idempresa,cc.usuarioalt,cc.usuarioact,cc.fechaalt,cc.fechaact "
				+ "   FROM bacorefctacte cc "
				+ "             INNER JOIN bacorefoperaciones ro ON cc.idoperacion = ro.idoperacion AND cc.idempresa = ro.idempresa "
				+ " WHERE cc.idempresa = " + idempresa
				+ "     AND cc.idcliente=" + idcliente
				+ " ORDER BY  1 DESC    LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefCtaCteOcu(long limit, long offset, String ocurrencia,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cc.idctacte,cc.idcliente,cc.idoperacion, ro.operacion, ro.descripcion,cc.idreferido,cc.puntos,cc.fecha,"
				+ "             cc.observaciones, "
				+ "             CASE WHEN ro.operacion = 'PREPRO' THEN  fu_preprospecto(cc.idreferido, cc.idempresa) ELSE '' END prepro, "
				+ "             cc.idempresa,cc.usuarioalt,cc.usuarioact,cc.fechaalt,cc.fechaact "
				+ "   FROM bacorefctacte cc "
				+ "             INNER JOIN bacorefoperaciones ro ON cc.idoperacion = ro.idoperacion AND cc.idempresa = ro.idempresa"
				+ " WHERE cc.idempresa = " + idempresa.toString()
				+ "     AND cc.idcliente=" + idcliente.toString()
				+ " WHERE (UPPER(ro.operacion) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%') AND cc.idcliente = "
				+ idcliente.toString() + "  AND cc.idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCteOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)

	public List getBacoRefCtaCteReportePuntos(BigDecimal idvendedor,
			BigDecimal idcliente, java.sql.Date fechadesde,
			java.sql.Date fechahasta, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT DISTINCT cl.idcliente, cl.razon, ps.puntos, pv.provincia, lo.localidad, telefonos, celular,fu_mail(cd.iddomicilio, cd.idempresa) "
				+ "  FROM clientesclientes cl  "
				+ "       INNER JOIN clientesprecargaclientes pr ON cl.idcliente = pr.idcliente AND cl.idempresa = pr.idempresa "
				+ "       INNER JOIN clientesdomicilios cd ON cl.idcliente = cd.idcliente AND cl.idempresa = cd.idempresa AND cd.esdefault = 'S' "
				+ "       INNER JOIN clientesanexolocalidades ax ON cd.idanexolocalidad = ax.idanexolocalidad AND cd.idempresa = ax.idempresa "
				+ "       INNER JOIN globallocalidades lo ON ax.idlocalidad = lo.idlocalidad "
				+ "       INNER JOIN globalprovincias pv ON lo.idprovincia = pv.idprovincia "
				+ "       INNER JOIN bacorefctacte cc ON cl.idcliente = cc.idcliente AND cl.idempresa = cc.idempresa "
				+ "       INNER JOIN ( "
				+ "                   SELECT SUM(puntos) AS puntos, idcliente, idempresa FROM bacorefctacte GROUP BY idcliente, idempresa "
				+ "                  ) ps ON cl.idcliente = ps.idcliente AND cl.idempresa = ps.idempresa "
				+ " WHERE cc.fecha BETWEEN '"
				+ fechadesde
				+ "'::DATE AND '"
				+ fechahasta
				+ "'::DATE AND cc.idempresa = "
				+ idempresa.toString()
				+

				// 20120410 - EJV - Mantis 702 - Forma menos decorosa, pero en
				// este caso mas pragmatica ;-) -->

				(idvendedor != null && idvendedor.longValue() > 0 ? "     AND pr.idvendedorasignado="
						+ idvendedor.toString()
						: " ")
				+ (idcliente != null && idcliente.longValue() > 0 ? "     AND cl.idcliente="
						+ idcliente.toString()
						: " ")

				// <--

				+ " ORDER BY  1 DESC    ;";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCteReportePuntos()  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefCtaCtePK(BigDecimal idctacte, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idctacte,idcliente,idoperacion,idreferido,puntos,fecha,"
				+ "            cc.observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "  FROM bacorefctacte WHERE idctacte=" + idctacte.toString()
				+ " AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCtePK( BigDecimal idctacte )  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getBacoRefCtaCtePuntosCliente(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {

		BigDecimal totalAcumulado = new BigDecimal(-9999);

		totalAcumulado = getBacoRefCtaCtePuntosCliente(idcliente, idempresa,
				dbconn);

		return totalAcumulado;
	}

	public BigDecimal getBacoRefCtaCtePuntosCliente(BigDecimal idcliente,
			BigDecimal idempresa, Connection conn) throws EJBException {
		BigDecimal totalAcumulado = new BigDecimal(-9999);
		String cQuery = ""
				+ "SELECT COALESCE(SUM(puntos), 0)    FROM bacorefctacte WHERE idempresa = "
				+ idempresa.toString() + "      AND idcliente="
				+ idcliente.toString();
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery, conn);

			if (vecSalida != null && !vecSalida.isEmpty()) {
				totalAcumulado = new BigDecimal(
						((String[]) vecSalida.get(0))[0]);
			} else {
				log
						.warn("No fue posible contabilizar los puntos disponibles por programa de referidos para el cliente: "
								+ idcliente);
			}

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCtePuntosCliente()  "
							+ ex);
		}
		return totalAcumulado;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefCtaCteDelete(BigDecimal idctacte, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFCTACTE WHERE idctacte="
				+ idctacte.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFCTACTE WHERE idctacte="
						+ idctacte.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefCtaCteDelete( BigDecimal idctacte, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefCtaCteDelete( BigDecimal idctacte, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	// 20120410 - EJV - Mantis 702 -->

	public String bacoRefCtaCteCreate(BigDecimal idcliente,
			BigDecimal idoperacion, BigDecimal idreferido, BigDecimal puntos,
			java.sql.Date fecha, String observaciones, BigDecimal idpedido,
			BigDecimal idempresa, String usuarioalt) throws EJBException {

		String salida = "";

		salida = bacoRefCtaCteCreate(idcliente, idoperacion, idreferido,
				puntos, fecha, observaciones, idpedido, idempresa, usuarioalt,
				dbconn);

		if (salida.equalsIgnoreCase("OK"))
			salida = "Alta correcta.";

		return salida;

	}

	// <--

	public String bacoRefCtaCteCreate(BigDecimal idcliente,
			BigDecimal idoperacion, BigDecimal idreferido, BigDecimal puntos,
			java.sql.Date fecha, String observaciones, BigDecimal idpedido,
			BigDecimal idempresa, String usuarioalt, Connection conn)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";
		if (puntos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntos ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO BACOREFCTACTE(idcliente, idoperacion, idreferido, puntos, fecha, observaciones, idpedido, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idcliente);
				insert.setBigDecimal(2, idoperacion);
				insert.setBigDecimal(3, idreferido);
				insert.setBigDecimal(4, puntos);
				insert.setDate(5, fecha);
				insert.setString(6, observaciones);
				insert.setBigDecimal(7, idpedido);
				insert.setBigDecimal(8, idempresa);
				insert.setString(9, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar registro en cuenta corriente ";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible generar registro en cuenta corriente ";
			log.error("Error SQL public String bacoRefCtaCteCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible generar registro en cuenta corriente ";
			log
					.error("Error excepcion public String bacoRefCtaCteCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefCtaCteCreateOrUpdate(BigDecimal idctacte,
			BigDecimal idcliente, BigDecimal idoperacion,
			BigDecimal idreferido, BigDecimal puntos, java.sql.Date fecha,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idctacte == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idctacte ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";
		if (puntos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntos ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCtaCte WHERE idctacte = "
					+ idctacte.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFCTACTE SET idcliente=?, idoperacion=?, idreferido=?, puntos=?, fecha=?, idempresa=?, usuarioact=?, fechaact=? WHERE idctacte=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idoperacion);
					insert.setBigDecimal(3, idreferido);
					insert.setBigDecimal(4, puntos);
					insert.setDate(5, fecha);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idctacte);
				} else {
					String ins = "INSERT INTO BACOREFCTACTE(idcliente, idoperacion, idreferido, puntos, fecha, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idoperacion);
					insert.setBigDecimal(3, idreferido);
					insert.setBigDecimal(4, puntos);
					insert.setDate(5, fecha);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefCtaCteCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefCtaCteCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefCtaCteUpdate(BigDecimal idctacte,
			BigDecimal idcliente, BigDecimal idoperacion,
			BigDecimal idreferido, BigDecimal puntos, java.sql.Date fecha,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idctacte == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idctacte ";
		if (idcliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idoperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idoperacion ";
		if (puntos == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: puntos ";
		if (fecha == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCtaCte WHERE idctacte = "
					+ idctacte.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFCTACTE SET idcliente=?, idoperacion=?, idreferido=?, puntos=?, fecha=?, idempresa=?, usuarioact=?, fechaact=? WHERE idctacte=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idcliente);
					insert.setBigDecimal(2, idoperacion);
					insert.setBigDecimal(3, idreferido);
					insert.setBigDecimal(4, puntos);
					insert.setDate(5, fecha);
					insert.setBigDecimal(6, idempresa);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idctacte);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefCtaCteUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefCtaCteUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefTipoOperaciones Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Jul 02 09:36:21 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefTipoOperacionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idtipooperacion,tipooperacion,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "    FROM bacoreftipooperaciones WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefTipoOperacionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefTipoOperacionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idtipooperacion,tipooperacion,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacoreftipooperaciones WHERE (UPPER(tipooperacion) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefTipoOperacionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefTipoOperacionesPK(BigDecimal idtipooperacion,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idtipooperacion,tipooperacion,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacoreftipooperaciones WHERE idtipooperacion="
				+ idtipooperacion.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefTipoOperacionesPK( BigDecimal idtipooperacion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefTipoOperacionesDelete(BigDecimal idtipooperacion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFTIPOOPERACIONES WHERE idtipooperacion="
				+ idtipooperacion.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFTIPOOPERACIONES WHERE idtipooperacion="
						+ idtipooperacion.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefTipoOperacionesDelete( BigDecimal idtipooperacion, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefTipoOperacionesDelete( BigDecimal idtipooperacion, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefTipoOperacionesCreate(String tipooperacion,
			String observaciones, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipooperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipooperacion ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipooperacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipooperacion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFTIPOOPERACIONES(tipooperacion, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipooperacion);
				insert.setString(2, observaciones);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefTipoOperacionesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefTipoOperacionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefTipoOperacionesCreateOrUpdate(
			BigDecimal idtipooperacion, String tipooperacion,
			String observaciones, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipooperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipooperacion ";
		if (tipooperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipooperacion ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipooperacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipooperacion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefTipoOperaciones WHERE idtipooperacion = "
					+ idtipooperacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFTIPOOPERACIONES SET tipooperacion=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipooperacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipooperacion);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idtipooperacion);
				} else {
					String ins = "INSERT INTO BACOREFTIPOOPERACIONES(tipooperacion, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, tipooperacion);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefTipoOperacionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefTipoOperacionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefTipoOperacionesUpdate(BigDecimal idtipooperacion,
			String tipooperacion, String observaciones, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipooperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipooperacion ";
		if (tipooperacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipooperacion ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipooperacion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipooperacion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefTipoOperaciones WHERE idtipooperacion = "
					+ idtipooperacion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFTIPOOPERACIONES SET tipooperacion=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idtipooperacion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipooperacion);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idtipooperacion);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoRefTipoOperacionesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefTipoOperacionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public List getClientesRemitosEstadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idestado,estado,observaciones,usuarioalt,usuarioact,fechaalt,fechaact FROM clientesremitosestados WHERE idempresa = "
				+ idempresa + "ORDER BY 2  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosEstadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * EJV - 20100806 - REASIGNACION DE PEDIDOS BEGIN
	 * 
	 * */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesPedidosReasignacionAll(long limit, long offset,
			BigDecimal idestado, String tipopedido, String orden,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fechapedido, sucursal, remitocliente, "
				+ "             idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "             zona, idexpreso, expreso, idlocalidad, localidad, "
				+ "             idprovincia, provincia,  nrosucursal, nroremitocliente, "
				+ "            idexpresozona,  idpedido_cabe, idprioridad, prioridad, cpostal, reasigna, cotizacion, idempresa "
				+ "  FROM vreasignacionpedidos " + " WHERE idempresa = "
				+ idempresa.toString() + " AND tipopedido = '" + tipopedido
				+ "'  ORDER BY " + orden + "  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPedidosReasignacionAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesPedidosReasignacionOcu(long limit, long offset,
			BigDecimal idestado, String tipopedido, String filtro,
			String orden, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idremitocliente, fechapedido, sucursal, remitocliente, "
				+ "             idcliente, razon, calle, nro, piso, depto, idzona, "
				+ "             zona, idexpreso, expreso, idlocalidad, localidad, "
				+ "             idprovincia, provincia,  nrosucursal, nroremitocliente, "
				+ "             idexpresozona,  idpedido_cabe, idprioridad, prioridad, cpostal, reasigna, cotizacion, idempresa "
				+ "  FROM vreasignacionpedidos " + filtro + " AND idempresa = "
				+ idempresa.toString() + " AND tipopedido = '" + tipopedido
				+ "' ORDER BY " + orden + "  LIMIT " + limit + " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPedidosReasignacionOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesAnexosLocalidades Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Mon Aug 09 15:06:36 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesAnexosLocalidadesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idanexolocalidad,idexpresozona,idexpreso,expreso,idzona,zona,idlocalidad,localidad,cpostal,idprovincia,provincia,idempresa"
				+ "   FROM vclientesanexoslocalidades" + " WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesAnexosLocalidadesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesAnexosLocalidadesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idanexolocalidad,idexpresozona,idexpreso,expreso,idzona,zona,idlocalidad,localidad,cpostal,idprovincia,provincia,idempresa"
				+ "   FROM vclientesanexoslocalidades WHERE (UPPER(expreso) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%' OR UPPER(zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'  OR UPPER(localidad) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'  OR UPPER(cpostal) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesAnexosLocalidadesOcu(String ocurrencia)  "
							+ ex);
		}

		return vecSalida;

	}

	/**
	 * Metodos para la entidad: vClientesExpresosZonasReasignacion Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Mon Aug 09 15:06:36 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesExpresosZonasReasignacionAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idanexolocalidad,idexpresozona,idexpreso,expreso,idzona,zona,idlocalidad,localidad,cpostal,idprovincia,provincia,idempresa"
				+ "   FROM vClientesExpresosZonasReasignacion"
				+ " WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesExpresosZonasReasignacionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesExpresosZonasReasignacionOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT  idanexolocalidad,idexpresozona,idexpreso,expreso,idzona,zona,idlocalidad,localidad,cpostal,idprovincia,provincia,idempresa"
				+ "   FROM vClientesExpresosZonasReasignacion WHERE (UPPER(expreso) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%' OR UPPER(zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'  OR UPPER(localidad) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%'  OR UPPER(cpostal) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesExpresosZonasReasignacionOcu(String ocurrencia)  "
							+ ex);
		}

		return vecSalida;

	}

	// 20101215 - EJV - Mantis 642 -->

	public String ejecutarReasignacionCtacte(BigDecimal idpedido,
			BigDecimal idzona, String tipopedido, String usuarioact,
			BigDecimal idempresa) throws EJBException {

		String salida = "OK";
		String cQuery = "";
		ResultSet rs = null;
		Statement st = null;
		String nuevactacte = "";

		try {

			// La QUERY tambin recupera la cuenta corriente que corresponde
			// para la nueva zona asignada
			if (tipopedido.equalsIgnoreCase("N")) {
				cQuery = ""
						+ "SELECT DISTINCT pd.idremitocliente, pc.idzona, zo.zona, pc.idexpreso, "
						+ "       CASE WHEN pd.idremitocliente IS NULL "
						+ "            THEN NULL  "
						+ "            ELSE LPAD(cr.nrosucursal::varchar, 4, '0') || '-' || LPAD(cr.nroremitocliente::varchar, 8, '0') "
						+ "       END AS comprobante,  "
						+ "       cr.nrosucursal, cr.nroremitocliente, "
						+ "       COALESCE( (SELECT ctacte_normal FROM clienteszonasctacte WHERE idzona = "
						+ idzona
						+ " AND idempresa = "
						+ idempresa
						+ "), '')  AS nuevactacte, pc.idpedido_cabe   "
						+ "  FROM pedidos_cabe pc "
						+ "       INNER JOIN pedidos_deta pd ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa "
						+ "       INNER JOIN clienteszonas zo ON pc.idzona = zo.idzona AND pc.idempresa = zo.idempresa "
						+ "        LEFT JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa "
						+ " WHERE pc.idpedido_cabe =  " + idpedido
						+ "   AND pc.idempresa =  " + idempresa;

			} else if (tipopedido.equalsIgnoreCase("R")) {
				cQuery = ""

						+ "SELECT DISTINCT pd.idremitocliente, pc.idzona, zo.zona, pc.idexpreso,  "
						+ "       CASE WHEN pd.idremitocliente IS NULL  "
						+ "            THEN NULL  "
						+ "            ELSE LPAD(cr.nrosucursal::varchar, 4, '0') || '-' || LPAD(cr.nroremitocliente::varchar, 8, '0')   "
						+ "       END AS comprobante,  "
						+ "      cr.nrosucursal, cr.nroremitocliente, "
						+ "      COALESCE((SELECT CASE WHEN  COALESCE(cr.bultos, 0) < 25 THEN ctacte_regalos ELSE ctacte_regalos_alto END  FROM clienteszonasctacte WHERE idzona = "
						+ idzona
						+ " AND idempresa = "
						+ idempresa
						+ "), '')   AS nuevactacte,  pc.idpedido_regalos_entrega_cabe "
						+ "  FROM pedidos_regalos_entregas_cabe pc "
						+ "       INNER JOIN pedidos_regalos_entregas_deta pd ON pd.idpedido_regalos_entrega_cabe = pc.idpedido_regalos_entrega_cabe AND pd.idempresa = pc.idempresa "
						+ "       INNER JOIN clienteszonas zo ON pc.idzona = zo.idzona AND pc.idempresa = zo.idempresa "
						+ "        LEFT JOIN clientesremitos cr ON pd.idremitocliente = cr.idremitocliente AND pd.idempresa = cr.idempresa "
						+ " WHERE pc.idpedido_regalos_entrega_cabe =   "
						+ idpedido + "   AND pc.idempresa =  " + idempresa;

			} else {
				salida = "Tipo de pedido incorrecto: " + tipopedido;
			}

			if (salida.equalsIgnoreCase("OK")) {

				st = dbconn.createStatement();
				rs = st.executeQuery(cQuery);
				if (rs != null) {

					if (rs.next()) {

						do {

							if (rs.getString("idremitocliente") != null) {

								nuevactacte = rs.getString("nuevactacte");

								// Verificar que la cuenta corriente tenga
								// cargado un valor
								if (nuevactacte.trim().equals("")) {
									salida = "Cuenta corriente no asociada para la zona "
											+ idzona;
									break;
								}

								// NO es posible reasignar remitos ANDREANI
								if (rs.getLong("idzona") == 28) {
									salida = "No se puede reasignar pedido/entrega "
											+ idpedido
											+ ", el mismo corresponde a remito "
											+ rs.getString("comprobante")
											+ " asignado a Zona 28-Andreani.";
									break;
								}

								// NO es posible reasignar remitos propios para
								// ANDREANI
								if (rs.getLong("idzona") != 28
										&& idzona.longValue() == 28) {
									salida = "No se puede reasignar pedido/entrega "
											+ idpedido
											+ " a Zona 28-Andreani, el mismo corresponde a remito "
											+ rs.getString("comprobante")
											+ " asignado a Zona "
											+ rs.getString("idzona")
											+ "-"
											+ rs.getString("zona");
									break;
								}

								salida = clientesRemitosUpdateCtaCte(rs
										.getBigDecimal("nrosucursal"), rs
										.getBigDecimal("nroremitocliente"),
										nuevactacte, idempresa, usuarioact);

							} else
								continue;

						} while (rs.next());

					} else
						salida = "(RSNX): Se produjo un error al verificar si es posible la reasignacion del pedido/entrega: "
								+ idpedido;

				} else
					salida = "(RSNL): Se produjo un error al verificar si es posible la reasignacion del pedido/entrega: "
							+ idpedido;

				st.close();

			}

		} catch (Exception e) {
			salida = "(EX): Se produjo un error al verificar si es posible la reasignacion del pedido: "
					+ idpedido;
			log.error("ejecutarReasignacionCtacte (): " + e);
		}

		return salida;
	}

	// <--

	public String pedidosCabeReasignarDistribucionUpdate(
			BigDecimal idpedido_cabe, BigDecimal idexpreso, BigDecimal idzona,
			BigDecimal idanexolocalidad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null || idpedido_cabe.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (idexpreso == null || idexpreso.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idzona == null || idzona.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idanexolocalidad == null || idanexolocalidad.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucuclie ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";

			if (salida.equalsIgnoreCase("OK")) {

				// 20101216 - EJV - MANTIS 642 -->
				salida = ejecutarReasignacionCtacte(idpedido_cabe, idzona, "N",
						usuarioact, idempresa);
				// <--
				if (salida.equalsIgnoreCase("OK")) {

					sql = "UPDATE PEDIDOS_CABE SET  idexpreso=?, idzona=?, idanexolocalidad=?, usuarioact=?, fechaact=? WHERE idpedido_cabe=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idzona);
					insert.setBigDecimal(3, idanexolocalidad);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idpedido_cabe);
					insert.setBigDecimal(7, idempresa);

					log.info("UPD - pedidosCabeReasignarDistribucionUpdate: "
							+ idpedido_cabe);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No fue posible reasignar pedido "
								+ idpedido_cabe + " para anexo-localidad "
								+ idanexolocalidad + ".";

				}

			}

		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosCabeReasignarDistribucionUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosCabeReasignarDistribucionUpdate(.....)"
							+ ex);
		}

		return salida;

	}

	public String pedidosCabeRegalosEntregasReasignarDistribucionUpdate(
			BigDecimal idpedido_cabe, BigDecimal idexpreso, BigDecimal idzona,
			BigDecimal idanexolocalidad, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpedido_cabe == null || idpedido_cabe.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpedido_cabe ";
		if (idexpreso == null || idexpreso.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (idzona == null || idzona.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcliente ";
		if (idanexolocalidad == null || idanexolocalidad.longValue() < 1)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idsucuclie ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";

			if (salida.equalsIgnoreCase("OK")) {

				// 20101216 - EJV - MANTIS 642 -->
				salida = ejecutarReasignacionCtacte(idpedido_cabe, idzona, "R",
						usuarioact, idempresa);
				// <--

				if (salida.equalsIgnoreCase("OK")) {

					sql = "UPDATE PEDIDOS_REGALOS_ENTREGAS_CABE SET  idexpreso=?, idzona=?, idanexolocalidad=?, usuarioact=?, fechaact=? WHERE idpedido_regalos_entrega_cabe=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, idexpreso);
					insert.setBigDecimal(2, idzona);
					insert.setBigDecimal(3, idanexolocalidad);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idpedido_cabe);
					insert.setBigDecimal(7, idempresa);

					int i = insert.executeUpdate();
					if (i != 1)
						salida = "No fue posible reasignar entrega "
								+ idpedido_cabe + " para anexo-localidad "
								+ idanexolocalidad + ".";

				}

			}

		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosCabeRegalosEntregasReasignarDistribucionUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosCabeRegalosEntregasReasignarDistribucionUpdate(.....)"
							+ ex);
		}

		return salida;

	}

	public String clientesPedidosNormalesReasignarDistribucion(
			String[] idpedidocabe, BigDecimal idanexolocalidaddestino,
			BigDecimal idexpresodestino, BigDecimal idzonadestino,
			String usuarioact, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		dbconn.setAutoCommit(false);

		try {

			for (int i = 0; idpedidocabe != null && i < idpedidocabe.length; i++) {

				salida = pedidosCabeReasignarDistribucionUpdate(new BigDecimal(
						idpedidocabe[i]), idexpresodestino, idzonadestino,
						idanexolocalidaddestino, idempresa, usuarioact);

				if (!salida.equalsIgnoreCase("OK"))
					break;

			}

		} catch (Exception e) {
			salida = "Error al reasignar pedidos. ";
			log.error("clientesPedidosNormalesReasignarDistribucion(): " + e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);
		return salida;

	}

	public String clientesPedidosRegalosEntregasReasignarDistribucion(
			String[] idpedidocabe, BigDecimal idanexolocalidaddestino,
			BigDecimal idexpresodestino, BigDecimal idzonadestino,
			String usuarioact, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		dbconn.setAutoCommit(false);

		try {

			for (int i = 0; idpedidocabe != null && i < idpedidocabe.length; i++) {

				salida = pedidosCabeRegalosEntregasReasignarDistribucionUpdate(
						new BigDecimal(idpedidocabe[i]), idexpresodestino,
						idzonadestino, idanexolocalidaddestino, idempresa,
						usuarioact);

				if (!salida.equalsIgnoreCase("OK"))
					break;

			}

		} catch (Exception e) {
			salida = "Error al reasignar entregas. ";
			log.error("clientesPedidosRegalosEntregasReasignarDistribucion(): "
					+ e);
		}

		if (salida.equalsIgnoreCase("OK")) {
			dbconn.commit();
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);
		return salida;

	}

	/**
	 * END - REASIGNACION DE PEDIDOS
	 * */

	/**
	 * Metodos para la entidad: vClientesRemitosDistribucion Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Mon Aug 23 13:37:09 ART 2010
	 */

	public List getVClientesRemitosDistribucionPK(BigDecimal idremitocliente,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idremitocliente,fecharemito,sucursal,remitocliente,idcliente,razon,idzona,zona,idexpreso,expreso,nroctacte,tipopedido,idexpresozona,"
				+ "            bultos,kilos,nrohojaarmado,fechahojaarmado,nrohojarutafinal,fechahojarutafinal,valorflete,idempresa FROM vclientesremitosdistribucion "
				+ "WHERE idremitocliente=" + idremitocliente.toString()
				+ "    AND idempresa = " + idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosDistribucionPK( BigDecimal idremitocliente )  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesRemitosConformacion Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Sep 07 10:05:56 ART 2010
	 */

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String clientesRemitosConformacionCreate(BigDecimal idremitocliente,
			BigDecimal idestado, String procesado, BigDecimal idempresa,
			String usuarioalt, Connection conn) throws EJBException {
		String salida = "OK";
		int idestadoActual = -1000;
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (procesado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (procesado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: procesado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		// 20120510 -- EJV -->

		idestadoActual = getConformacionRemitoEstadoActual(idremitocliente,
				idempresa, conn);

		if (idestadoActual < 0 && idestadoActual != -100)
			salida = "PCF - Error: No fue posible verificar estado actual - [ "
					+ idestadoActual + " ]";

		if (idestadoActual == idestado.intValue() && idestadoActual != 4)
			salida = "PCF - Error: Inconsistencia al crear nuevo estado, estado actual debe ser distinto del nuevo["
					+ idestadoActual + " - " + idestado + " ]";

		// <--

		try {

			if (salida.equalsIgnoreCase("OK")) {

				String ins = "INSERT INTO CLIENTESREMITOSCONFORMACION(idremitocliente, idestado, procesado, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idremitocliente);
				insert.setBigDecimal(2, idestado);
				insert.setString(3, procesado);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Imposible generar registro de conformacion para idremitocliente:"
							+ idremitocliente + ", para estado " + idestado;
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar registro de conformacion para idremitocliente:"
					+ idremitocliente + ", para estado " + idestado;
			log
					.error("Error SQL public String clientesRemitosConformacionCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar registro de conformacion para idremitocliente:"
					+ idremitocliente + ", para estado " + idestado;
			log
					.error("Error excepcion public String clientesRemitosConformacionCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String setClientesRemitosConformacionProcesado(
			BigDecimal idconformacion, String procesado, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idconformacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idconformacion ";
		if (procesado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: procesado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		// 2. sin nada desde la pagina
		if (procesado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: procesado ";
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "UPDATE clientesremitosconformacion SET procesado=?,  usuarioact=?, fechaact=? WHERE idconformacion=? AND idempresa=?;";
				insert = dbconn.prepareStatement(sql);
				insert.setString(1, procesado);
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, idconformacion);
				insert.setBigDecimal(5, idempresa);
				int i = insert.executeUpdate();

				if (i != 1)
					salida = "Imposible marcar como procesado remito para idconformacion "
							+ idconformacion;

			}
		} catch (SQLException sqlException) {

			salida = "(SQLE)Imposible marcar como procesado remito para idconformacion "
					+ idconformacion;
			log
					.error("Error SQL public String setClientesRemitosConformacionProcesado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible marcar como procesado remito para idconformacion "
					+ idconformacion;
			log
					.error("Error excepcion public String setClientesRemitosConformacionProcesado(.....)"
							+ ex);
		}

		return salida;

	}

	// 20101201 - EJV - Mantis 624

	public List getClientesRemitosConformacionXRemitoAll(long limit,
			long offset, BigDecimal idremitocliente, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT rc.idconformacion, rc.idremitocliente, rc.idestado, re.estado, rc.procesado, rc.idempresa, rc.usuarioalt, rc.usuarioact, rc.fechaalt, rc.fechaact"
				+ "   FROM clientesremitosconformacion rc "
				+ "             INNER JOIN clientesremitosestados re ON rc.idestado = re.idestado AND rc.idempresa = re.idempresa "
				+ "  WHERE idremitocliente =  " + idremitocliente
				+ " AND rc.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosConformacionXRemitoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesUsuarioZona Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Sep 07 16:01:29 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesUsuarioZonaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT uz.idusuario, gl.nombre, uz.idzona, zo.zona, uz.idempresa, uz.usuarioalt, uz.usuarioact, uz.fechaalt, uz.fechaact "
				+ "   FROM clientesusuariozona uz "
				+ "            INNER JOIN globalusuarios gl ON uz.idusuario  = gl.idusuario AND uz.idempresa = uz.idempresa "
				+ "            INNER JOIN clienteszonas zo ON uz.idzona  = zo.idzona AND uz.idempresa = zo.idempresa "
				+ " WHERE uz.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesUsuarioZonaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesUsuarioZonaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT uz.idusuario, gl.nombre, uz.idzona, zo.zona, uz.idempresa, uz.usuarioalt, uz.usuarioact, uz.fechaalt, uz.fechaact "
				+ "   FROM clientesusuariozona uz "
				+ "            INNER JOIN globalusuarios gl ON uz.idusuario  = gl.idusuario AND uz.idempresa = uz.idempresa "
				+ "            INNER JOIN clienteszonas zo ON uz.idzona  = zo.idzona AND uz.idempresa = zo.idempresa "
				+ " WHERE ( UPPER(gl.nombre) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(gl.usuario) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(zo.zona) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND uz.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesUsuarioZonaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesUsuarioZonaPK(BigDecimal idusuario,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT uz.idusuario, gu.usuario, gu.nombre, uz.idzona, zo.zona ,uz.idempresa,uz.usuarioalt,uz.usuarioact,uz.fechaalt,uz.fechaact "
				+ "  FROM clientesusuariozona uz "
				+ "            INNER JOIN globalusuarios gu ON uz.idusuario = gu.idusuario AND uz.idempresa = gu.idempresa "
				+ "            INNER JOIN clienteszonas zo ON uz.idzona = zo.idzona AND uz.idempresa = zo.idempresa "
				+ " WHERE uz.idusuario=" + idusuario.toString()
				+ "     AND  uz.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesUsuarioZonaPK( BigDecimal idusuario )  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getZonaXUsuario(BigDecimal idusuario, BigDecimal idempresa)
			throws EJBException {
		BigDecimal idzona = new BigDecimal(-1);
		String cQuery = "SELECT idzona  FROM clientesusuariozona uz  WHERE uz.idusuario="
				+ idusuario.toString()
				+ "     AND  uz.idempresa = "
				+ idempresa.toString() + ";";

		try {

			Statement stm = dbconn.createStatement();
			ResultSet rs = stm.executeQuery(cQuery);

			if (rs != null) {
				idzona = new BigDecimal(0);
				if (rs.next()) {
					idzona = rs.getBigDecimal(1);
				} else
					log.debug("getZonaXUsuario - NO NEXT !!");
			} else
				log.warn("getZonaXUsuario - VACIO !!");

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getCountUsuarioZona( BigDecimal idusuario )  "
							+ ex);
		}
		return idzona;
	}

	public List getClientesUsuarioZonaPendientes(BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT gl.idusuario, gl.nombre, gl.idempresa, gl.usuarioalt, gl.usuarioact, gl.fechaalt, gl.fechaact "
				+ "   FROM globalusuarios gl  "
				+ " WHERE gl.idempresa = "
				+ idempresa.toString()
				+ " AND gl.idusuario NOT IN (SELECT idusuario FROM clientesusuariozona WHERE idempresa = "
				+ idempresa + " )" + "  ORDER BY 2  ;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesUsuarioZonaPendientes()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesZonaUsuarioPendientes(BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT zo.idzona, zo.zona, zo.idempresa, zo.usuarioalt, zo.usuarioact, zo.fechaalt, zo.fechaact "
				+ "   FROM clienteszonas zo  "
				+ " WHERE zo.idempresa = "
				+ idempresa.toString()
				+ " AND zo.idzona NOT IN (SELECT idzona FROM clientesusuariozona WHERE idempresa = "
				+ idempresa + " )" + "  ORDER BY 2  ;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesZonaUsuarioPendientes()  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesUsuarioZonaDelete(BigDecimal idusuario,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESUSUARIOZONA WHERE idusuario="
				+ idusuario.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESUSUARIOZONA WHERE idusuario="
						+ idusuario.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesUsuarioZonaDelete( BigDecimal idusuario, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesUsuarioZonaDelete( BigDecimal idusuario, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesUsuarioZonaCreate(BigDecimal idusuario,
			BigDecimal idzona, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idzona == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: zona ";
		if (idusuario == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuario ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESUSUARIOZONA(idusuario, idzona, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idusuario);
				insert.setBigDecimal(2, idzona);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar relacion usuario - zona ("
							+ idusuario + "-" + idzona + ")";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesUsuarioZonaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesUsuarioZonaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosConformacionStatus Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Tue Sep 28 15:33:05 ART 2010
	 */

	public List getClientesRemitosPendientesValidarAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idconformacion,idremitocliente,nrosucursal,nroremitocliente,fecharemito,idzona,zona,idexpreso,expreso,idestado,estado,fechaestado,"
				+ "            procesado,nrohojaarmado,nrohojarutafinal,origenpedido,idcliente,razon,idempresa "
				+ "  FROM vclientesremitosconformacionstatus "
				+ "WHERE  idestado <> 1  AND procesado = 'N'  AND  idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosPendientesValidarAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRemitosPendientesValidarOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idconformacion,idremitocliente,nrosucursal,nroremitocliente,fecharemito,idzona,zona,idexpreso,expreso,idestado,estado,fechaestado,"
				+ "            procesado,nrohojaarmado,nrohojarutafinal,origenpedido,idcliente,razon,idempresa "
				+ "  FROM vclientesremitosconformacionstatus "
				+ " WHERE (UPPER(nroremitocliente::varchar) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idestado <> 1  AND procesado = 'N'  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosPendientesValidarOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// 20120510 - EJV - Movimientos stock x 2 - Sobrecarga -->

	public List getVClientesRemitosConformacionStatusPK(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal idzona, BigDecimal idempresa)
			throws EJBException {

		List vecSalida = new ArrayList();

		try {

			vecSalida = getVClientesRemitosConformacionStatusPK(nrosucursal,
					nroremitocliente, idzona, idempresa, dbconn);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosConformacionStatusPK( BigDecimal idremitocliente )  "
							+ ex);
		}

		return vecSalida;

	}

	// <--

	public List getVClientesRemitosConformacionStatusPK(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal idzona,
			BigDecimal idempresa, Connection conn) throws EJBException {
		String cQuery = ""
				+ "SELECT idremitocliente,nrosucursal,nroremitocliente,idzona,idestado,estado,"
				+ "             procesado,nrohojaarmado,nrohojarutafinal,origenpedido, idcliente, razon, fechaestado, idempresa "
				+ "   FROM vclientesremitosconformacionstatus "
				+ "WHERE nrosucursal=" + nrosucursal.toString()
				+ "    AND nroremitocliente=" + nroremitocliente.toString()
				+ "    AND idzona=" + idzona.toString()
				+ "    AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery, conn);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosConformacionStatusPK( BigDecimal idremitocliente ..., Connection conn)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getVClientesRemitosConformacionStatusXRemito(
			BigDecimal nrosucursal, BigDecimal nroremitocliente,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idconformacion, idremitocliente,nrosucursal,nroremitocliente,idzona,idestado,estado,"
				+ "             procesado,nrohojaarmado,nrohojarutafinal,origenpedido, idcliente, razon, idempresa "
				+ "   FROM vclientesremitosconformacionstatus "
				+ "WHERE nrosucursal=" + nrosucursal.toString()
				+ "    AND nroremitocliente=" + nroremitocliente.toString()
				+ "    AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosConformacionStatusXRemito( BigDecimal idremitocliente )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getVClientesRemitosConformacionStatusByHRF(
			BigDecimal nrohojarutafinal, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idremitocliente,nrosucursal,nroremitocliente,idzona,idestado,estado,"
				+ "             procesado,nrohojaarmado,nrohojarutafinal,origenpedido, idcliente, razon, idempresa "
				+ "   FROM vclientesremitosconformacionstatus "
				+ "WHERE nrohojarutafinal=" + nrohojarutafinal.toString()
				+ "    AND idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosConformacionStatusByHRF( BigDecimal nrohojarutafinal )  "
							+ ex);
		}
		return vecSalida;
	}

	// Conformacion normal
	public String clientesRemitosConformacion(int idestadoNuevo,
			BigDecimal nrosucursal, BigDecimal nroremitocliente,
			BigDecimal idzona, String origentransaccion, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {

		BigDecimal idusuario = new BigDecimal(-1);
		BigDecimal idpuesto = new BigDecimal(-1);
		String habilitado = "N";
		BigDecimal idcontadorcomprobante = new BigDecimal(-1);

		String salida = "OK";
		List listStatusRemito = new ArrayList();
		List listUser = new ArrayList();
		BigDecimal idremitocliente = new BigDecimal(-1);
		int idestadoActual = -1;
		String estadoActual = "";
		String procesado = "";
		long nrohojaarmado = 0;
		long nrohojarutafinal = 0;
		String origenpedido = "";
		String tipomovimiento = "";
		String query = "";
		String[] datos = null;
		boolean actualizastock = false;
		String vistaDeposito = " vclientesremitosarticulos ";

		// EJV - 20101114 - Mantis 639 -->

		java.sql.Date fechaActual = null;
		java.sql.Date fechaestado = null;
		Calendar cal = new GregorianCalendar();

		// <--

		// 20120510 -- EJV - Movimientos stock x 2 -->
		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		// dbconn.setAutoCommit(false);

		try {

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);
			// <--

			log.info("----------( CRC: " + nrosucursal + " - "
					+ nroremitocliente + ")----------");

			// EJV - 20101114 - Mantis 639 -->
			cal.set(Calendar.HOUR_OF_DAY, 0);
			cal.set(Calendar.MINUTE, 0);
			cal.set(Calendar.SECOND, 0);
			cal.set(Calendar.MILLISECOND, 0);
			// <--

			fechaActual = new java.sql.Date(cal.getTimeInMillis());

			query = ""
					+ "SELECT gu.idusuario, gu.idpuesto, gu.habilitado "
					+ "   FROM clientesusuariozona uz "
					+ "             INNER JOIN globalusuarios gu ON uz.idusuario = gu.idusuario AND uz.idempresa = gu.idempresa "
					+ " WHERE uz.idzona =  " + idzona + " AND uz.idempresa = "
					+ idempresa;

			listUser = getLista(query, conn);

			if (listUser != null && !listUser.isEmpty()) {

				datos = (String[]) listUser.get(0);
				idusuario = new BigDecimal(datos[0]);
				idpuesto = new BigDecimal(datos[1]);
				habilitado = datos[2];

				idcontadorcomprobante = gb.getContadorDocumentos(idpuesto,
						"idconta_remitos1");

				if (idcontadorcomprobante != null
						&& idcontadorcomprobante.longValue() > 0) {

					// idremitocliente,nrosucursal,nroremitocliente,idzona,idestado,estado,procesado,nrohojaarmado,nrohojarutafinal,origenpedido,fechaestado,idempresa
					listStatusRemito = getVClientesRemitosConformacionStatusPK(
							nrosucursal, nroremitocliente, idzona, idempresa,
							conn);

					if (listStatusRemito != null && !listStatusRemito.isEmpty()) {

						datos = (String[]) listStatusRemito.get(0);
						idremitocliente = new BigDecimal(datos[0]);
						idestadoActual = Integer.parseInt(datos[4]);
						estadoActual = datos[5];
						procesado = datos[6];
						nrohojaarmado = datos[7] != null
								&& !datos[7].trim().equals("") ? Long
								.parseLong(datos[7]) : 0;
						nrohojarutafinal = datos[8] != null
								&& !datos[8].trim().equals("") ? Long
								.parseLong(datos[8]) : 0;
						// log.info("antes de setear fecha estado : " +
						// datos[12]);
						fechaestado = java.sql.Date.valueOf(datos[12]);
						// log.info("despues de setear fecha estado : " +
						// datos[12]);
						/*
						 * ...................................1;"Pendiente (Limpio)"
						 * ...................................2;"Rechazado"
						 * ...................................3;"Cambio"
						 * ..........................4;"Visita - No Entregado"
						 * ...................................5;"Entregado" -
						 * ...................................6;"Preconformado"
						 * ...................................7;"Anulado"
						 */

						log.info("idestadoActual: " + idestadoActual);
						log.info("idestadoNuevo:" + idestadoNuevo);

						// Validaciones -->

						if (procesado.equalsIgnoreCase("S")) {
							salida = "No es posible conformar, el remito ya fue procesado.";
						} else if (nrohojarutafinal == 0
								&& (idestadoNuevo <= 6)) {
							salida = "No es posible conformar, el remito no tiene hoja de ruta final asignada.";
							// } else if (idestadoActual == idestadoNuevo ) {
						} else if (idestadoActual == idestadoNuevo
								&& idestadoNuevo != 4) {
							salida = "No es posible conformar, nuevo estado debe ser diferente del actual.";
							// } else if ( idestadoActual != 1 && idestadoNuevo
							// != 1) {
							// ----------------------------------------------------------------------------------------------------
							// EJV - 20101025 - MANTIS 600
							// } else if (idestadoActual != 1 && idestadoActual
							// != 4
							// && idestadoNuevo != 1) {
							// salida =
							// "No es posible conformar, nuevo estado solo puede ser Pendiente.";
						} else if (idestadoActual != 1 && idestadoActual != 4
								&& idestadoActual != 6 && idestadoNuevo != 1) {
							salida = "No es posible conformar, nuevo estado solo puede ser Pendiente.";
							// MANTIS 600
						} else if (idestadoActual == 6 && idestadoNuevo == 1) {
							salida = "IMPOSIBLE conformar, el estado actual es Preconformado.";
							// ----------------------------------------------------------------------------------------------------
							// EJV - 20101114 - Mantis 639 -->
						} else if (idestadoNuevo == 1
								&& fechaActual.compareTo(fechaestado) != 0
								&& (idestadoActual == 5 || idestadoActual == 6)) {
							salida = "IMPOSIBLE conformar (limpiar remito), fecha estado distinta de la del dia..";
							log.info("fechaActual : " + fechaActual);
							log.info("fechaestado: " + fechaestado);
							// <--
						} else if (idestadoActual == 7) {
							salida = "IMPOSIBLE conformar, el estado actual es: Canc. x Logstica (Ex Anulado).";
						} else if (idestadoNuevo == 7 && (nrohojaarmado != 0)) {
							// salida =
							// "No es posible anular, el remito tiene hoja de armado asignada.";
							salida = "No es posible cancelar, el remito tiene hoja de armado asignada.";

							// 20110328 - EJV - Mantis 687 -->
						} else if (idestadoNuevo == 9
								&& (nrohojarutafinal == 0 || (idestadoActual != 1 && idestadoActual != 4))) {
							salida = "IMPOSIBLE conformar, remito debe estar Pendiente - Visita y tener HRF asignada.";

						} else if (idestadoActual == 9) {
							salida = "IMPOSIBLE conformar, el estado actual es: No Entregado (Anulacion).";

							// <--
						} else {
							// Fin Validaciones <--

							// WORKFLOW de estados, segn el estado actual y el
							// nuevo, determinar accin.
							// -->
							if (idestadoNuevo == 1) {
								// PENDIENTE

								if (idestadoActual == 2) {
									// RECHAZO-Mueve de disponible a reserva
									actualizastock = true;
									tipomovimiento = "DAR";
								} else if (idestadoActual == 3) {
									// CAMBIO-Mueve de disponible a reserva
									actualizastock = true;
									tipomovimiento = "DAR";
								} else if (idestadoActual == 4) {
									// VISITA-NO Mueve Stock
									tipomovimiento = "NMS";
								} else if (idestadoActual == 5) {
									// ENTREGA-Movimiento de ENTRADA al
									// reservado
									actualizastock = true;
									tipomovimiento = "EAR";
								} else if (idestadoActual == 6) {
									// PRECONFORMADO-NO Mueve Stock
									tipomovimiento = "NMS";
								} else {
									salida = "(E1.0)Estado no contemplado en workflow de conformacion.";
								}

							} else if (idestadoNuevo == 2) {
								// RECHAZO-Mueve de reserva a disponible
								actualizastock = true;
								tipomovimiento = "RAD";
							} else if (idestadoNuevo == 3) {
								// CAMBIO-Mueve de reserva a disponible
								actualizastock = true;
								tipomovimiento = "RAD";
							} else if (idestadoNuevo == 4) {
								// VISITA-NO Mueve Stock
								tipomovimiento = "NMS";
							} else if (idestadoNuevo == 5) {
								// ENTREGA-Movimiento de SALIDA de reservado
								actualizastock = true;
								tipomovimiento = "SDR";
							} else if (idestadoNuevo == 6) {
								// PRECONFORMADO-NO Mueve Stock
								tipomovimiento = "NMS";
							} else if (idestadoNuevo == 7) {
								// ANULADO-DEBE MOVER AL DISPONIBLE DEL
								// DISTRIBUIDOR
								// ....? Ya tiene HRF.

								// 20110601 - Mantis 712 - EJV -->
								// Esto deberia estar aplicado anteriormente!!??
								// tipomovimiento = "DEFINICION-PENDIENTE";
								actualizastock = true;
								tipomovimiento = "RAD";
								// <--

								// 20110629 - Mantis 712 - EJV -->
								vistaDeposito = " vclientesremitosarticulosdepoped ";
								// <--

							} else if (idestadoNuevo == 9) {

								actualizastock = true;
								tipomovimiento = "RAD";

							} else {
								salida = "(E1.1)Estado no contemplado en workflow de conformacion.";
							}
							log.info("TpMv-->: " + tipomovimiento);
							// <--

							if (salida.equalsIgnoreCase("OK")) {

								// Recuperar productos y cantidades asociados al
								// remito. -->
								String queryArt = ""
										+ "SELECT codigo_st, alias_st, descrip_st, descri2_st, cost_re_st, cost_uc_st, cost_pp_st, precipp_st, ultcomp_st, "
										+ "             deposito, cantidad, total, cuencom_st, unimed_st, cuenven_st, cuenve2_st, cuencos_st "
										+ "   FROM  " + vistaDeposito
										+ "WHERE idremitocliente = "
										+ idremitocliente
										+ "    AND idempresa =  " + idempresa;
								// <--

								// Recuperar datos de cliente y el
								// correspondiente domicilio de entrega -->
								String queryCliente = ""
										+ "SELECT idcliente, razon, domicilio, cpostal, idlocalidad, idprovincia, nrodocumento, brutos,  "
										+ "             nroremitocliente, tipomov, sucursal, tipo, idremitocliente, idempresa"
										+ "  FROM vclientesremitosanexo WHERE idremitocliente = "
										+ idremitocliente + " AND idempresa = "
										+ idempresa;
								// <--

								BigDecimal codigo_anexo = null;
								String razon_social = null;
								String domicilio = null;
								String codigo_postal = null;
								BigDecimal idlocalidad = null;
								BigDecimal idprovincia = null;
								String cuit = null;
								String iibb = null;
								Timestamp fechamov = null;
								BigDecimal remito_ms = null;
								String tipomov = null;
								BigDecimal sucursal = null;
								String tipo = null;
								boolean remitopendiente = true;
								String observaciones = "";
								int ejercicioactivo = ContableBean
										.getEjercicioActivo(conn, idempresa);
								Hashtable htArticulos = new Hashtable();

								// Inicia actualizacion STOCK -->
								if (actualizastock) {

									// No se recuperan cuentas, actualmente
									// REMITO
									// PENDIENTE es TRUE, heredado para remitos
									// oficiales desde SUMA.
									Hashtable htCuentas = new Hashtable();

									// Recuperar y armar el hash correspondiente
									// a
									// los
									// articulos que mueven stock, que se
									// encuentran
									// asociados a los pedidos que componen el
									// remito.

									List listArticulos = getLista(queryArt,
											conn);

									if (listArticulos != null
											&& !listArticulos.isEmpty()) {

										Iterator it = listArticulos.iterator();
										log.info("Antes de llenar HTARTICULOS");

										while (it.hasNext()) {

											datos = (String[]) it.next();
											// 20110601 - EJV - Mantis 714 -->
											// htArticulos.put(datos[0], datos);
											htArticulos.put(datos[0] + "-"
													+ datos[9], datos);
											// <--

										}

										List listAnexo = getLista(queryCliente,
												conn);

										it = listAnexo.iterator();

										if (it.hasNext()) {

											datos = (String[]) it.next();

											codigo_anexo = new BigDecimal(
													datos[0]);
											razon_social = datos[1];
											domicilio = datos[2];
											codigo_postal = datos[3];
											idlocalidad = new BigDecimal(
													datos[4]);
											idprovincia = new BigDecimal(
													datos[5]);
											cuit = datos[6];
											iibb = datos[7];
											remito_ms = new BigDecimal(datos[8]);
											tipomov = datos[9];
											sucursal = new BigDecimal(datos[10]);
											tipo = datos[11];

											observaciones = "(ORIGEN:"
													+ origentransaccion
													+ " - CONFORMACION - "
													+ tipomovimiento + " {"
													+ idestadoActual + " --> "
													+ idestadoNuevo
													+ "}) - [IDREMITOCLIENTE:"
													+ idremitocliente
													+ "|SUCURSAL:" + sucursal
													+ "|COMPROBANTE:"
													+ nroremitocliente + "]";

											if (tipomovimiento
													.equalsIgnoreCase("SDR")) {

												// SALIDA DE RESERVA (Baja
												// Stock)

												salida = StockBean
														.stockMovSalidaWAPEntregadoCreate(
																codigo_anexo,
																razon_social,
																domicilio,
																codigo_postal,
																idlocalidad,
																idprovincia,
																cuit,
																iibb,
																fechamov,
																remito_ms,
																tipomov,
																sucursal,
																tipo,
																remitopendiente,
																ejercicioactivo,
																observaciones,
																htArticulos,
																htCuentas,
																idcontadorcomprobante,
																conn,
																usuarioalt,
																idempresa)[0];
											} else if (tipomovimiento
													.equalsIgnoreCase("EAR")) {

												// ENTRADA a Reserva (Incrementa
												// Stock)

												salida = StockBean
														.stockMovEntradaWAPLimpiaEntregaCreate(
																codigo_anexo,
																razon_social,
																domicilio,
																codigo_postal,
																idlocalidad,
																idprovincia,
																cuit,
																iibb,
																fechamov,
																remito_ms,
																tipomov,
																sucursal,
																tipo,
																remitopendiente,
																ejercicioactivo,
																observaciones,
																htArticulos,
																htCuentas,
																idcontadorcomprobante,
																conn,
																usuarioalt,
																idempresa)[0];

											} else if (tipomovimiento
													.equalsIgnoreCase("RAD")) {

												// MOVIMIENTO de Reserva a
												// Disponible
												salida = StockBean
														.stockMovStockRes2DispWAPRechazoCambioCreate(
																htArticulos,
																conn,
																usuarioalt,
																idempresa)[0];

											} else if (tipomovimiento
													.equalsIgnoreCase("DAR")) {

												// MOVIMIENTO de Disponible a
												// Reserva
												salida = StockBean
														.stockMovEntradaWAPLimpiaRechazoCambioCreate(
																htArticulos,
																conn,
																usuarioalt,
																idempresa)[0];

											}

										} else {

											salida = "No fue posible recuperar datos de cliente asociado al remito.";

										}

									} else {

										salida = "No fue posible recuperar los articulos asociados al remito seleccionado.";
									}

								}

								// FINALIZA Actualizcion de STOCK <---

								// Registrar conformacion -->
								if (salida.equalsIgnoreCase("OK")) {

									salida = clientesRemitosConformacionCreate(
											idremitocliente, new BigDecimal(
													idestadoNuevo), "N",
											idempresa, usuarioalt, conn);
									// Cambiar estado REMITO -->
									if (salida.equalsIgnoreCase("OK")) {
										salida = clientesRemitosUpdEstado(
												idremitocliente,
												new BigDecimal(idestadoNuevo),
												idempresa, usuarioalt, conn);
									}
									// <--

								}
								// <--
							}

						}

					} else {

						salida = "Remito inexistente u asociado a otra zona.";

					}

				} else {

					salida = "No fue posible recuperar contador para comprobante.";

				}

			} else {
				salida = "Zona sin usuario asignado, o error al recuperar datos del mismo.";
			}

		} catch (SQLException sqlException) {
			salida = "(SQL) No fue posible conformar remito .";
			log
					.error("Error SQL en el metodo : clientesRemitosConformacion( ... ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX) No fue posible conformar remito preconformado.";
			log
					.error("Salida por exception: en el metodo: clientesRemitosConformacion( ... )  "
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			conn.rollback();

		} else {
			conn.commit();
			salida = "Conformacion Exitosa.";
		}

		conn.setAutoCommit(true);
		conn.close();
		log
				.info("---------------------------- CRC ---------------------------------");

		return salida;
	}

	// PREConformacion Automatica x hoja de ruta final
	public String clientesRemitosPreconformarXHRF(String[] nrohojarutafinal,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		BigDecimal idremitocliente = new BigDecimal(-1);
		BigDecimal idestadoNuevo = new BigDecimal(6);
		List listRemitosStatus = new ArrayList();
		java.sql.Date fechapreconf = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());

		dbconn.setAutoCommit(false);
		try {

			for (int i = 0; i < nrohojarutafinal.length
					&& salida.equalsIgnoreCase("OK"); i++) {

				BigDecimal nroHRF = new BigDecimal(nrohojarutafinal[i]);
				listRemitosStatus = getVClientesRemitosConformacionStatusByHRF(
						nroHRF, idempresa);

				Iterator it = listRemitosStatus.iterator();

				while (it.hasNext() && salida.equalsIgnoreCase("OK")) {

					String[] datos = (String[]) it.next();
					idremitocliente = new BigDecimal(datos[0]);
					int idestadoActual = Integer.parseInt(datos[4]);
					String procesado = datos[6];

					if (idestadoActual == 7)
						continue;
					else if (idestadoActual != 1) {
						salida = "No es posible cambiar estado a preconformado para remito "
								+ datos[1]
								+ "-"
								+ datos[2]
								+ ", estado actual debe ser pendiente.";
						break;

					} else if (procesado.equalsIgnoreCase("S")) {
						salida = "No es posible cambiar estado a preconformado para remito "
								+ datos[1]
								+ "-"
								+ datos[2]
								+ ", el mismo ya fue procesado.";
						break;
					}

					// Registrar conformacion -->
					if (salida.equalsIgnoreCase("OK")) {

						// log.info("EJECUTA CAMBIO DE ESTDO PRECONFORMA");
						salida = clientesRemitosConformacionCreate(
								idremitocliente, idestadoNuevo, "N", idempresa,
								usuarioalt, dbconn);
						// Cambiar estado REMITO -->
						if (salida.equalsIgnoreCase("OK")) {
							// log.info("EJECUTA CAMBIO DE ESTDO REMITO");
							salida = clientesRemitosUpdEstado(idremitocliente,
									idestadoNuevo, idempresa, usuarioalt,
									dbconn);
						} else
							break;
						// <--

					} else
						break;
					// <--

				}

				if (salida.equalsIgnoreCase("OK")) {
					// log.info("EJECUTA UPD FECHA HRF");
					salida = pedidosHojaRutaFinalFPreconfUpdate(nroHRF,
							fechapreconf, idempresa, usuarioalt);
				}

			}

		} catch (Exception e) {
			salida = "Se detecto una excepcion al preconformar HRF: ";
			log.error("clientesRemitosPreconformarXHRF(): " + e);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();

		} else {
			dbconn.commit();
			salida = "Preconformacion Exitosa.";
		}
		dbconn.setAutoCommit(true);
		return salida;
	}

	// Conformacion con estado Preconformado
	public String clientesRemitosConformarPreconformados(int idestadoNuevo,
			BigDecimal nrosucursal, BigDecimal nroremitocliente,
			BigDecimal idzona, String origentransaccion, String tipoinput,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {

		BigDecimal idusuario = new BigDecimal(-1);
		BigDecimal idpuesto = new BigDecimal(-1);
		String habilitado = "N";
		BigDecimal idcontadorcomprobante = new BigDecimal(-1);

		String salida = "OK";
		List listStatusRemito = new ArrayList();
		List listUser = new ArrayList();
		BigDecimal idremitocliente = new BigDecimal(-1);
		int idestadoActual = -1;
		String estadoActual = "";
		String procesado = "";
		long nrohojaarmado = 0;
		long nrohojarutafinal = 0;
		String origenpedido = "";
		String tipomovimiento = "";
		String query = "";
		String[] datos = null;
		boolean actualizastock = false;

		String operacion = "CONF-PRECONFORMADOS";
		String resultado = "OK";

		// 20120510 -- EJV - Movimientos stock x 2 -->
		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		// dbconn.setAutoCommit(false);

		try {

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);
			// <--
			log.info("----------( CRCP:  " + nrosucursal + " - "
					+ nroremitocliente + ")----------");

			query = ""
					+ "SELECT gu.idusuario, gu.idpuesto, gu.habilitado"
					+ "   FROM clientesusuariozona uz "
					+ "             INNER JOIN globalusuarios gu ON uz.idusuario = gu.idusuario AND uz.idempresa = gu.idempresa "
					+ " WHERE uz.idzona =  " + idzona + " AND uz.idempresa = "
					+ idempresa;

			listUser = getLista(query, conn);

			if (listUser != null && !listUser.isEmpty()) {

				datos = (String[]) listUser.get(0);
				idusuario = new BigDecimal(datos[0]);
				idpuesto = new BigDecimal(datos[1]);
				habilitado = datos[2];

				idcontadorcomprobante = gb.getContadorDocumentos(idpuesto,
						"idconta_remitos1");

				if (idcontadorcomprobante != null
						&& idcontadorcomprobante.longValue() > 0) {

					// idremitocliente,nrosucursal,nroremitocliente,idzona,idestado,estado,procesado,nrohojaarmado,nrohojarutafinal,origenpedido,idempresa
					listStatusRemito = getVClientesRemitosConformacionStatusPK(
							nrosucursal, nroremitocliente, idzona, idempresa,
							conn);

					if (listStatusRemito != null && !listStatusRemito.isEmpty()) {

						datos = (String[]) listStatusRemito.get(0);
						idremitocliente = new BigDecimal(datos[0]);
						idestadoActual = Integer.parseInt(datos[4]);
						estadoActual = datos[5];
						procesado = datos[6];
						nrohojaarmado = datos[7] != null
								&& !datos[7].trim().equals("") ? Long
								.parseLong(datos[7]) : 0;
						nrohojarutafinal = datos[8] != null
								&& !datos[8].trim().equals("") ? Long
								.parseLong(datos[8]) : 0;
						/*
						 * ...................................1;"Pendiente (Limpio)"
						 * ...................................2;"Rechazado"
						 * ...................................3;"Cambio"
						 * ..........................4;"Visita - No Entregado"
						 * ...................................5;"Entregado" -
						 * ...................................6;"Preconformado"
						 * ...................................7;"Anulado"
						 */

						log.info("idestadoActual: " + idestadoActual);
						log.info("idestadoNuevo:" + idestadoNuevo);

						// Validaciones -->

						if (procesado.equalsIgnoreCase("S")) {
							salida = "No es posible conformar, el remito ya fue procesado.";
						} else if (idestadoActual != 6) {
							salida = "No es posible conformar, estado actual debe ser Preconformado.";
						} else if (nrohojarutafinal == 0
								&& (idestadoNuevo <= 6)) {
							salida = "No es posible conformar, el remito no tiene hoja de ruta final asignada.";
						} else if (idestadoActual == idestadoNuevo) {
							salida = "No es posible conformar, nuevo estado debe ser diferente del actual.";
						} else if (idestadoActual == 7) {
							salida = "IMPOSIBLE conformar, el estado actual es Anulado.";
						} else if (idestadoNuevo == 1) {
							salida = "No es posible conformar, estado nuevo no puede ser Pendiente.";
						} else if (idestadoNuevo == 4) {
							salida = "No es posible conformar, estado nuevo no puede ser Visita - No Entregado.";
						} else if (idestadoNuevo == 7) {
							salida = "No es posible conformar, estado nuevo no puede ser Anulado.";
							// 20110328 - EJV Mantis 689 -->
							// } else if (idestadoNuevo > 7) {
						} else if (idestadoNuevo == 10
								&& idzona.intValue() != 28) {

							salida = "No es posible conformar, estado solo puede ser asignado por Andreani.";

						} else if (idestadoNuevo > 10) {
							salida = "No es posible conformar, estado nuevo no contemplado.";
							// <--
						} else {
							// Fin Validaciones <--

							// WORKFLOW de estados, segn el estado actual y el
							// nuevo, determinar accin.
							// -->
							if (idestadoNuevo == 2) {
								// RECHAZO-Mueve de reserva a disponible
								actualizastock = true;
								tipomovimiento = "RAD";
							} else if (idestadoNuevo == 3) {
								// CAMBIO-Mueve de reserva a disponible
								actualizastock = true;
								tipomovimiento = "RAD";
								// 20110328 - EJV Mantis 689 -->
							} else if (idestadoNuevo == 10) {
								// SINIESTRO-Mueve de reserva a disponible
								actualizastock = true;
								tipomovimiento = "RAD";
								// <--
							} else if (idestadoNuevo == 5) {
								// ENTREGA-Movimiento de SALIDA de reservado
								actualizastock = true;
								tipomovimiento = "SDR";
								// 20110606 - EJV Mantis 706 -->
							} else if (idestadoNuevo == 9) {
								// No Entregado (Aulacion) - Mueve de reserva a
								// disponible
								actualizastock = true;
								tipomovimiento = "RAD";
								// <--

							} else {
								salida = "(E1.1)Estado no contemplado en workflow de conformacion de Remitos Preconformados.";
							}
							// <--

							if (salida.equalsIgnoreCase("OK")) {

								// Recuperar productos y cantidades asociados al
								// remito. -->
								String queryArt = ""
										+ "SELECT codigo_st, alias_st, descrip_st, descri2_st, cost_re_st, cost_uc_st, cost_pp_st, precipp_st, ultcomp_st, "
										+ "             deposito, cantidad, total, cuencom_st, unimed_st, cuenven_st, cuenve2_st, cuencos_st "
										+ "   FROM vclientesremitosarticulos "
										+ "WHERE idremitocliente = "
										+ idremitocliente
										+ "    AND idempresa =  " + idempresa;
								// <--

								// Recuperar datos de cliente y el
								// correspondiente domicilio de entrega -->
								String queryCliente = ""
										+ "SELECT idcliente, razon, domicilio, cpostal, idlocalidad, idprovincia, nrodocumento, brutos,  "
										+ "             nroremitocliente, tipomov, sucursal, tipo, idremitocliente, idempresa"
										+ "  FROM vclientesremitosanexo WHERE idremitocliente = "
										+ idremitocliente + " AND idempresa = "
										+ idempresa;
								// <--

								BigDecimal codigo_anexo = null;
								String razon_social = null;
								String domicilio = null;
								String codigo_postal = null;
								BigDecimal idlocalidad = null;
								BigDecimal idprovincia = null;
								String cuit = null;
								String iibb = null;
								Timestamp fechamov = null;
								BigDecimal remito_ms = null;
								String tipomov = null;
								BigDecimal sucursal = null;
								String tipo = null;
								boolean remitopendiente = true;
								String observaciones = "";
								int ejercicioactivo = ContableBean
										.getEjercicioActivo(conn, idempresa);
								Hashtable htArticulos = new Hashtable();

								// Inicia actualizacion STOCK -->
								if (actualizastock) {

									// No se recuperan cuentas, actualmente
									// REMITO
									// PENDIENTE es TRUE, heredado para remitos
									// oficiales desde SUMA.
									Hashtable htCuentas = new Hashtable();

									// Recuperar y armar el hash correspondiente
									// a
									// los
									// articulos que mueven stock, que se
									// encuentran
									// asociados a los pedidos que componen el
									// remito.

									List listArticulos = getLista(queryArt,
											conn);

									if (listArticulos != null
											&& !listArticulos.isEmpty()) {

										Iterator it = listArticulos.iterator();

										while (it.hasNext()) {

											datos = (String[]) it.next();
											// 20110601 - EJV - Mantis 714 -->
											// htArticulos.put(datos[0], datos);
											htArticulos.put(datos[0] + "-"
													+ datos[9], datos);
											// <--

										}

										List listAnexo = getLista(queryCliente,
												conn);

										it = listAnexo.iterator();

										if (it.hasNext()) {

											datos = (String[]) it.next();

											codigo_anexo = new BigDecimal(
													datos[0]);
											razon_social = datos[1];
											domicilio = datos[2];
											codigo_postal = datos[3];
											idlocalidad = new BigDecimal(
													datos[4]);
											idprovincia = new BigDecimal(
													datos[5]);
											cuit = datos[6];
											iibb = datos[7];
											remito_ms = new BigDecimal(datos[8]);
											tipomov = datos[9];
											sucursal = new BigDecimal(datos[10]);
											tipo = datos[11];

											observaciones = "(ORIGEN:"
													+ origentransaccion
													+ " - CONFORMACION - "
													+ tipomovimiento + " {"
													+ idestadoActual + " --> "
													+ idestadoNuevo
													+ "}) - [IDREMITOCLIENTE:"
													+ idremitocliente
													+ "|SUCURSAL:" + sucursal
													+ "|COMPROBANTE:"
													+ nroremitocliente + "]";

											if (tipomovimiento
													.equalsIgnoreCase("SDR")) {

												// SALIDA DE RESERVA (Baja
												// Stock)

												salida = StockBean
														.stockMovSalidaWAPEntregadoCreate(
																codigo_anexo,
																razon_social,
																domicilio,
																codigo_postal,
																idlocalidad,
																idprovincia,
																cuit,
																iibb,
																fechamov,
																remito_ms,
																tipomov,
																sucursal,
																tipo,
																remitopendiente,
																ejercicioactivo,
																observaciones,
																htArticulos,
																htCuentas,
																idcontadorcomprobante,
																conn,
																usuarioalt,
																idempresa)[0];

											} else if (tipomovimiento
													.equalsIgnoreCase("RAD")) {

												// MOVIMIENTO de Reserva a
												// Disponible

												salida = StockBean
														.stockMovStockRes2DispWAPRechazoCambioCreate(
																htArticulos,
																conn,
																usuarioalt,
																idempresa)[0];

											}

										} else {

											salida = "No fue posible recuperar datos de cliente asociado al remito.";

										}

									} else {

										salida = "No fue posible recuperar los articulos asociados al remito seleccionado.";
									}

								}

								// FINALIZA Actualizcion de STOCK <---

								// Registrar conformacion -->
								if (salida.equalsIgnoreCase("OK")) {

									salida = clientesRemitosConformacionCreate(
											idremitocliente, new BigDecimal(
													idestadoNuevo), "N",
											idempresa, usuarioalt, conn);
									// Cambiar estado REMITO -->
									if (salida.equalsIgnoreCase("OK")) {
										salida = clientesRemitosUpdEstado(
												idremitocliente,
												new BigDecimal(idestadoNuevo),
												idempresa, usuarioalt, conn);
									}
									// <--

								}
								// <--
							}

						}

					} else {

						salida = "Remito inexistente u asociado a otra zona.";

					}

				} else {

					salida = "No fue posible recuperar contador para comprobante.";

				}

			} else {
				salida = "Zona sin usuario asignado, o error al recuperar datos del mismo.";
			}

		} catch (SQLException sqlException) {
			salida = "(SQL) No fue posible conformar remito preconformado.";
			log
					.error("Error SQL en el metodo : clientesRemitosConformarPreconformados( ... ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX) No fue posible conformar remito preconformado.";
			log
					.error("Salida por exception: en el metodo: clientesRemitosConformarPreconformados( ... )  "
							+ ex);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			resultado = "ERROR";
			conn.rollback();

		} else {

			conn.commit();
			salida = "Conformacion Exitosa.";
		}

		if (idremitocliente.longValue() > 0)
			clientesRemitosValidarLogCreate(idremitocliente, new BigDecimal(
					idestadoNuevo), new BigDecimal(idestadoActual), resultado,
					salida, tipoinput, operacion, idempresa, usuarioalt);

		log
				.info("------------------------------ CRCP -------------------------------");

		// conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosHojaRutaFinalReimprime
	 * Copyrigth(r) sysWarp S.R.L. Fecha de creacion: Tue Sep 21 15:10:09 ART
	 * 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesRemitosHojaRutaFinalReimprimeAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal,nropallets,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,fechapreconf,fechabaja,tipo,filename,"
				+ "            idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM vclientesremitoshojarutafinalreimprime "
				+ "WHERE idempresa = " + idempresa.toString()
				+ "  ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalReimprimeAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesRemitosHojaRutaFinalReimprimeOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal,nropallets,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,fechapreconf,fechabaja,tipo,filename,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM vclientesremitoshojarutafinalreimprime"
				+ " WHERE (UPPER(nrohojarutafinal::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(descrip_dt_des) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%' )  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalReimprimeOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// 20101210 - EJV - Mantis 637 -->

	public List getVClientesRemitosHojaRutaFinalArchivoAndreaniAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal,nropallets,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,fechapreconf,"
				+ "            fechabaja,tipo,filename, fileandreani,idempresa,usuarioalt,usuarioact,fechaalt,fechaact, "
				+ "            CASE WHEN fileandreani IS NULL THEN 0 ELSE 1 END "
				+ "  FROM vclientesremitoshojarutafinalreimprime "
				+ "WHERE idzona = 28 AND idempresa = " + idempresa.toString()
				+ "  ORDER BY 19 , 1 DESC  LIMIT " + limit + " OFFSET  "
				+ offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalArchivoAnedreniAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesRemitosHojaRutaFinalArchivoAndreaniOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojarutafinal,nropallets,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,fechapreconf,"
				+ "            fechabaja,tipo,filename, fileandreani,idempresa,usuarioalt,usuarioact,fechaalt,fechaact, "
				+ "            CASE WHEN fileandreani IS NULL THEN 0 ELSE 1 END "
				+ "   FROM vclientesremitoshojarutafinalreimprime"
				+ " WHERE (   (nrohojarutafinal::VARCHAR) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER(descrip_dt_des) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' )  AND  idzona = 28 AND  idempresa = "
				+ idempresa.toString() + " ORDER BY 19, 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaRutaFinalArchivoAndreaniOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	/**
	 * Metodos para la entidad: clientesRemitosValidarLog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Sep 28 10:52:04 ART 2010
	 */

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public String clientesRemitosValidarLogCreate(BigDecimal idremitocliente,
			BigDecimal idestadoesperado, BigDecimal idestadoactual,
			String resultado, String observaciones, String tipoinput,
			String operacion, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";
		if (idestadoesperado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadoesperado ";
		if (idestadoactual == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestadoactual ";
		if (resultado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: resultado ";
		if (tipoinput == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoinput ";
		if (operacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipoinput ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (resultado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: resultado ";
		if (tipoinput.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipoinput ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESREMITOSVALIDARLOG"
						+ "                    (idremitocliente, idestadoesperado, idestadoactual, resultado, observaciones, tipoinput, operacion, idempresa, usuarioalt )"
						+ "       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idremitocliente);
				insert.setBigDecimal(2, idestadoesperado);
				insert.setBigDecimal(3, idestadoactual);
				insert.setString(4, resultado);
				insert.setString(5, observaciones);
				insert.setString(6, tipoinput);
				insert.setString(7, operacion);
				insert.setBigDecimal(8, idempresa);
				insert.setString(9, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "(I)No fue posible generar log de validacion de remitos.";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible generar log de validacion de remitos.";
			log
					.error("Error SQL public String clientesRemitosValidarLogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(E)No fue posible generar log de validacion de remitos.";
			log
					.error("Error excepcion public String clientesRemitosValidarLogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesRemitosValidarEstado(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal idestadoesperado,
			String tipoinput, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		String salida = "OK";
		String resultado = "OK";
		String observaciones = "Procesado correctamente.";
		BigDecimal idremitocliente = new BigDecimal(-1);
		BigDecimal idconformacion = new BigDecimal(-1);
		BigDecimal idestadoActual = new BigDecimal(-1);
		String operacion = "VAL-ESTADO";
		// BigDecimal idestadoNuevo = new BigDecimal(6);
		List listDataRemito = new ArrayList();
		java.sql.Date fechapreconf = new java.sql.Date(Calendar.getInstance()
				.getTimeInMillis());

		dbconn.setAutoCommit(false);
		try {

			listDataRemito = getVClientesRemitosConformacionStatusXRemito(
					nrosucursal, nroremitocliente, idempresa);

			Iterator it = listDataRemito.iterator();

			if (it.hasNext()) {

				String[] datos = (String[]) it.next();
				idconformacion = new BigDecimal(datos[0]);
				idremitocliente = new BigDecimal(datos[1]);
				idestadoActual = new BigDecimal(datos[5]);
				String procesado = datos[7];

				if (idestadoActual.intValue() == 7) {
					salida = "No es posible validar remito, estado actual es anulado "
							+ datos[2] + "-" + datos[3] + ".";
				} else if (procesado.equalsIgnoreCase("S")) {
					salida = "No es posible validar remito " + datos[2] + "-"
							+ datos[3] + ", el mismo ya fue procesado.";
				} else {

					if (idestadoesperado.intValue() != idestadoActual
							.intValue()) {
						resultado = "ERROR";
						observaciones = "El estado actual del remito ["
								+ idestadoActual + "], no es el esperado: "
								+ idestadoesperado;
					}

					if (resultado.equalsIgnoreCase("OK"))
						salida = setClientesRemitosConformacionProcesado(
								idconformacion, "S", idempresa, usuarioalt);

					if (salida.equalsIgnoreCase("OK"))
						salida = clientesRemitosValidarLogCreate(
								idremitocliente, idestadoesperado,
								idestadoActual, resultado, observaciones,
								tipoinput, operacion, idempresa, usuarioalt);

				}
				// <--

			} else
				salida = "Remito inexistente.";

		} catch (Exception e) {
			salida = "Se detecto una excepcion al validar estado de remito. ";
			log.error("clientesRemitosValidarEstado(): " + e);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			dbconn.rollback();

		} else {
			salida = resultado;
			dbconn.commit();
			// salida = "Validacion de remito correcta.";
		}
		dbconn.setAutoCommit(true);
		return salida;
	}

	public String clientesRemitosGeneraStickersAndreani(
			BigDecimal nrohojaarmado, BigDecimal idempresa, String usuarioalt)
			throws EJBException {

		String salida = "OK";

		try {

			List listRemitos = new ArrayList();
			Iterator it;
			String query = "";

			Statement st = dbconn.createStatement();
			ResultSet rs = null;

			query = "SELECT idremitocliente, bultos FROM clientesremitos WHERE nrohojaarmado = "
					+ nrohojaarmado
					+ " AND bultos > 0  AND idempresa = "
					+ idempresa + " ORDER BY idremitocliente ";
			PreparedStatement ps = dbconn.prepareStatement(query);
			rs = ps.executeQuery();

			if (rs != null) {

				if (rs.next()) {

					st.clearBatch();
					st
							.addBatch("DELETE FROM clientesremitosandreanistickers WHERE nrohojaarmado = "
									+ nrohojaarmado
									+ " AND idempresa = "
									+ idempresa + ";");

					do {

						BigDecimal idremitocliente = rs
								.getBigDecimal("idremitocliente");
						int totalBultos = rs.getInt("bultos");

						for (int i = 1; i <= totalBultos; i++) {
							st
									.addBatch("INSERT INTO clientesremitosandreanistickers VALUES(  "
											+ nrohojaarmado
											+ ", "
											+ idremitocliente
											+ ", "
											+ i
											+ ", "
											+ idempresa
											+ ",  '"
											+ usuarioalt.toUpperCase() + "');");

						}

					} while (rs.next());

					st.executeBatch();

				} else {
					salida = "No existen registros para la hoja ingresada.";
					log.warn("(NO NEXT) Stickers");
				}
			} else
				salida = "(NULL) Stickers";

		} catch (SQLException sqle) {

			salida = "(SQLE) Stickers";
			log.error("clientesRemitosGeneraStickersAndreani(): " + sqle);
			log.error("clientesRemitosGeneraStickersAndreani(): "
					+ sqle.getNextException());

		} catch (Exception e) {
			salida = "(EX) Stickers";
			log.error("clientesRemitosGeneraStickersAndreani(): " + e);
			log.error("clientesRemitosGeneraStickersAndreani(): " + e);

		}
		return salida;
	}

	// por primary key (primer campo por defecto)

	public BigDecimal getClientesRemitosBultos(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT bultos  FROM clientesremitos WHERE nrosucursal="
				+ nrosucursal.toString() + " AND nroremitocliente = "
				+ nroremitocliente.toString() + " AND idempresa="
				+ idempresa.toString();
		List vecSalida = new ArrayList();
		Iterator it;
		BigDecimal bultos = new BigDecimal(-1);
		try {

			vecSalida = getLista(cQuery);
			it = vecSalida.iterator();

			if (it.hasNext()) {
				String[] datos = (String[]) it.next();
				bultos = new BigDecimal(datos[0]);

			}

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosBultos(...)  "
							+ ex);
		}
		return bultos;
	}

	public String clientesRemitosModificarBulto(BigDecimal nrosucursal,
			BigDecimal nroremitocliente, BigDecimal totalbultos,
			BigDecimal idempresa, String usuarioalt) throws EJBException,
			SQLException {

		String salida = "OK";
		PreparedStatement pstatement = null;
		dbconn.setAutoCommit(false);
		int resultado = 0;
		Timestamp fechaalt = new Timestamp(Calendar.getInstance()
				.getTimeInMillis());

		if (nrosucursal == null || nrosucursal.longValue() < 0)
			salida = "Ingrese valores validos para sucursal";
		else if (nroremitocliente == null || nroremitocliente.longValue() < 0)
			salida = "Ingrese valores validos para remito";
		else if (totalbultos == null || totalbultos.longValue() < 0)
			salida = "Ingrese valores validos para total bultos";

		try {

			if (salida.equalsIgnoreCase("OK")) {

				pstatement = dbconn
						.prepareStatement(""
								+ "INSERT INTO  clientesremitosupdbultoslog (idremitocliente, bultosold, bultosnew, idempresa, usuarioalt, fechaalt) "
								+ " SELECT idremitocliente, bultos, ? , ?, ?, ? FROM clientesremitos WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;");

				pstatement.setBigDecimal(1, totalbultos);
				pstatement.setBigDecimal(2, idempresa);
				pstatement.setString(3, usuarioalt);
				pstatement.setTimestamp(4, fechaalt);
				pstatement.setBigDecimal(5, nrosucursal);
				pstatement.setBigDecimal(6, nroremitocliente);
				pstatement.setBigDecimal(7, idempresa);

				resultado = pstatement.executeUpdate();

				if (resultado == 1) {

					BigDecimal[] totalesFlete = new BigDecimal[] {
							new BigDecimal(0), new BigDecimal(0),
							new BigDecimal(0) };
					BigDecimal totalFlete = new BigDecimal(0);
					BigDecimal totalIvaFlete = new BigDecimal(0);
					BigDecimal porcIvaFlete = new BigDecimal(0);

					totalesFlete = getCalculoFlete(nrosucursal,
							nroremitocliente, totalbultos.intValue(),
							idempresa, dbconn);

					totalFlete = totalesFlete[0];
					totalIvaFlete = totalesFlete[1];
					porcIvaFlete = totalesFlete[2];

					if (totalFlete.signum() > -1) {

						pstatement = dbconn
								.prepareStatement("UPDATE clientesremitos SET bultos= ?, valorflete= ?, valordeclaradoflete= ?, valorivaflete= ?, porcivaflete= ?,  usuarioact=? , fechaact=?  WHERE nrosucursal=? AND nroremitocliente=? AND idempresa=?;");

						pstatement.setBigDecimal(1, totalbultos);
						pstatement.setBigDecimal(2, totalFlete);
						pstatement.setBigDecimal(3, totalFlete);

						pstatement.setBigDecimal(4, totalIvaFlete);
						pstatement.setBigDecimal(5, porcIvaFlete);

						pstatement.setString(6, usuarioalt);
						pstatement.setTimestamp(7, fechaalt);
						pstatement.setBigDecimal(8, nrosucursal);
						pstatement.setBigDecimal(9, nroremitocliente);
						pstatement.setBigDecimal(10, idempresa);

						resultado = pstatement.executeUpdate();

						if (resultado != 1)
							salida = "No fue posible actualizar cantidad de bultos-flete.";
					} else
						salida = "No fue posible recalcular flete.";

				} else
					salida = "No fue posible generar log de modificacion de bultos-flete.";

			}

		} catch (Exception e) {
			salida = "(EX)No fue posible generar log de modificacion de bultos-flete.";
			log.error("clientesRemitosModificarBulto():" + e);
		}

		dbconn.setAutoCommit(true);
		return salida;
	}

	public List getClientesRemitosHATotalesFamila(String idremitosIn,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ " SELECT sf.descrip_fm, COUNT(sf.codigo_fm) AS total, COALESCE(sm.descrip_md, 'NO-ASIGN') "
				+ "   FROM pedidos_deta pd "
				+ "        INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st AND pd.idempresa = st.idempresa "
				+ "        INNER JOIN stockgrupos sg ON st.grupo_st = sg.codigo_gr AND st.idempresa = sg.idempresa "
				+ "        INNER JOIN stockfamilias sf ON sg.codigo_fm = sf.codigo_fm AND sg.idempresa = sf.idempresa  "
				+ "         LEFT JOIN stockmedidas sm ON st.unialt2_st = sm.codigo_md AND st.idempresa = sm.idempresa "
				+ "  WHERE pd.idremitocliente IN(" + idremitosIn
				+ ") AND pd.idempresa =  " + idempresa
				+ "  GROUP BY sf.descrip_fm, sm.descrip_md	 ";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosHATotalesFamila(...)  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesRemitosControlDespachosAll(long limit, long offset,
			String orden, String tipopedido, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT nrohojaarmado, fechahojaarmado, nrohojarutafinal, fechahojarutafinal, nroctacte, idexpreso, expreso, total_bultos, tipo, idempresa "
				+ "  FROM vclientesremitoscontroldespachos "
				+ " WHERE tipo = '" + tipopedido.toUpperCase()
				+ "' AND idempresa = " + idempresa.toString() + "  ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosControlDespachosAll(..)  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesRemitosControlDespachosOcu(long limit, long offset,
			String filtro, String orden, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT nrohojaarmado, fechahojaarmado, nrohojarutafinal, fechahojarutafinal, nroctacte, idexpreso, expreso, total_bultos, tipo, idempresa "
				+ "  FROM vclientesremitoscontroldespachos " + filtro
				+ "    AND idempresa = " + idempresa.toString() + " ORDER BY "
				+ orden + "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesRemitosControlDespachosOcu(...)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosEstadoActual Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Wed Oct 20 14:22:33 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesRemitosEstadoActualAll(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idconformacion,idremitocliente,nrosucursal,nroremitocliente,fecharemito,idzona,zona,idexpreso,expreso,idexpresozona,"
				+ "            idestado,estado,fechaestado,procesado,nrohojaarmado,nrohojarutafinal,origenpedido,idcliente,razon,idsucuclie,calle,nro,"
				+ "            depto,piso,idclub, club, logo, idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM vclientesremitosestadoactual WHERE idempresa = "
				+ idempresa.toString() + filtro + "  ORDER BY 2 DESC  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();

		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosEstadoActualAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosHojaArmadoReimprime Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Thu Oct 21 11:29:27 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesRemitosHojaArmadoReimprimeAll(long limit,
			long offset, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT nrohojaarmado,fechahojaarmado,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,tipo,idempresa "
				+ "   FROM vclientesremitoshojaarmadoreimprime WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaArmadoReimprimeAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVClientesRemitosHojaArmadoReimprimeOcu(long limit,
			long offset, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT  nrohojaarmado,fechahojaarmado,idzona,zona,codigo_dt_ori,descrip_dt_ori,codigo_dt_des,descrip_dt_des,tipo,idempresa "
				+ "  FROM vclientesremitoshojaarmadoreimprime WHERE nrohojaarmado = "
				+ ocurrencia.toUpperCase().trim() + "  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosHojaArmadoReimprimeOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * 20101105 - EJV - Recuperar porcentaje de descuento de tarjetas segn el
	 * Nro. BIN - IIN
	 * 
	 * */

	public float getPorcentajeDescuentoIinBin(String iinBin)
			throws EJBException {

		boolean isIinBinBancofrances = false;
		float porcDescIiBin = 0;

		try {

			Properties props = new Properties();
			props.load(ClientesBean.class
					.getResourceAsStream("iinbin.properties"));

			if (props.containsKey(iinBin))
				porcDescIiBin = Float.parseFloat(props.getProperty(iinBin));

		} catch (IOException e) {
			log.error("getPorcentajeDescuentoIinBin(): " + e);
		}

		return porcDescIiBin;

	}

	/**
	 * Metodos para la entidad: pedidosRegalosEstados Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Nov 10 15:14:42 ART 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosRegalosEstadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM pedidosregalosestados WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosEstadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosRegalosEstadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM pedidosregalosestados"
				+ " WHERE (UPPER(ESTADO) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosEstadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosRegalosEstadosPK(BigDecimal idestado,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM pedidosregalosestados WHERE idestado="
				+ idestado.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosEstadosPK( BigDecimal idestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosRegalosEstadosDelete(BigDecimal idestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSREGALOSESTADOS WHERE idestado="
				+ idestado.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSREGALOSESTADOS WHERE idestado="
						+ idestado.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosRegalosEstadosDelete( BigDecimal idestado, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosRegalosEstadosDelete( BigDecimal idestado, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosRegalosEstadosCreate(String estado,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSREGALOSESTADOS(estado, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, estado);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosRegalosEstadosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosRegalosEstadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosRegalosEstadosCreateOrUpdate(BigDecimal idestado,
			String estado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosRegalosEstados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSREGALOSESTADOS SET estado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
				} else {
					String ins = "INSERT INTO PEDIDOSREGALOSESTADOS(estado, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosRegalosEstadosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosRegalosEstadosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosRegalosEstadosUpdate(BigDecimal idestado,
			String estado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idestado ";
		if (estado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (estado.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosRegalosEstados WHERE idestado = "
					+ idestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSREGALOSESTADOS SET estado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, estado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosRegalosEstadosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosRegalosEstadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: vPedidosRegalosEstado Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Nov 10 16:05:22 GYT 2010
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosRegalosEstadoAll(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT idpedido_cabe,idestado,estado,idcliente,razon, tipopedido, "
				+ "            origenpedido, fechapedido, prioridad, fechaalt, usuarioalt, idempresa,"
				// TODO:
				// Mantis 602 - EJV - 20101126 - Al final de la lista, mejorar.
				+ "            idpedido_regalos_padre, transformacion "
				+ "  FROM vpedidosregalosestado  " + filtro
				+ "    AND  idempresa = " + idempresa.toString()
				+ "  ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosRegalosEstadoAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosDetalleXPedido(
			BigDecimal idpedido_regalos_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT st.codigo_st,  "
				+ "            st.alias_st, "
				+ "            st.descrip_st, "
				+ "            st.descri2_st,  "
				+ "            COALESCE(st.bonific_st, 0)AS porcdesc,"
				+ "            lp.precio::numeric(18,2)  AS precio, "
				+ "             ((1 * pd.precio)  - ( (CASE WHEN pd.porcdesc_apli IS NULL THEN 0 ELSE pd.porcdesc_apli END) * (1 * pd.precio) / 100 )  )::numeric(18,2)  AS precioConDescuento, "
				+ "            COALESCE(sb.canti_sb::numeric(18), 0) AS existencia, "
				+ "            COALESCE(pedid_sb::numeric(18), 0) AS reserva , "
				+ "            de.codigo_dt as deposito, pd.cantidad::numeric(18)  AS cantidad, "
				// + "            0 AS total, "
				+ "             ((pd.cantidad * pd.precio)  - ( (CASE WHEN pd.porcdesc_apli IS NULL THEN 0 ELSE pd.porcdesc_apli END) * (pd.cantidad * pd.precio) / 100 )  )::numeric(18,2) AS total, "
				+ "            st.cuencom_st, st.unimed_st,  "
				+ "            st.cuenven_st, st.cuenve2_st, st.cuencos_st, "
				// +
				// "            --0 AS iddescuento_suge,0 AS iddescuento_apli,0 AS porcdesc_suge, "
				+ "            pd.iddescuento_suge,pd.iddescuento_apli,pd.porcdesc_suge,pd.porcdesc_apli, "
				+ "            pd.idmotivodescuento, de.descrip_dt,   "
				+ "            COALESCE(si.idstockiva, -1) AS idstockiva, COALESCE(si.porcentaje,0.00) AS porcentaje, "
				// +
				// "            --COALESCE(si.tipoexen_grav, 'G'), 0.00 AS porciva_st, 0.00 AS totaliva_st, "
				+ "           COALESCE(si.tipoexen_grav, 'G'), pd.porciva_st, pd.totaliva_st, "
				+ "           COALESCE(sb.canti_sb::NUMERIC(18, 2), 0.00) AS canti_sb,  "
				+ "           COALESCE(sb.pedid_sb::NUMERIC(18, 2), 0.00) AS pedid_sb, "
				+ "           st.inventa_st,  "
				+ "           COALESCE(fm.codigo_fm, -1) AS codigo_fm, "
				+ "           COALESCE(fm.descrip_fm, '') AS descrip_fm,  "
				+ "           'true' AS flagLoad   "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "           INNER JOIN pedidos_regalos_deta pd ON pc.idpedido_regalos_cabe = pd.idpedido_regalos_cabe AND pc.idempresa = pd.idempresa "
				+ "           INNER JOIN stockstock st ON pd.codigo_st = st.codigo_st AND pd.idempresa = st.idempresa "
				+ "           INNER JOIN clienteslistasdeprecios lp ON pd.codigo_st = lp.codigo_st  AND pd.idempresa = lp.idempresa "
				+ "                     AND pc.idlista = lp.idlista AND pc.idempresa = pd.idempresa "
				+ "           INNER JOIN stockdepositos de ON pd.codigo_dt = de.codigo_dt AND pd.idempresa = de.idempresa "
				// 20101203 - EJV - Se aplico junta debil, ya que es posible que
				// el articulo no exista aun en el deposito., motivo por el cual
				// no se recuperaba el detalle de los pedidos de forma correcta.
				// +
				// "           INNER JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb  "
				+ "            LEFT JOIN stockstockbis sb ON st.codigo_st = sb.articu_sb AND de.codigo_dt = sb.deposi_sb  "
				+ "                      AND st.idempresa = sb.idempresa  "
				+ "             LEFT JOIN stockiva si ON st.tipoiva_st = si.idstockiva AND st.idempresa = si.idempresa "
				+ "             LEFT JOIN stockgrupos gr ON st.grupo_st = gr.codigo_gr AND st.idempresa = gr.idempresa "
				+ "             LEFT JOIN stockfamilias fm ON gr.codigo_fm = fm.codigo_fm AND gr.idempresa = fm.idempresa "
				+ "WHERE pc.idpedido_regalos_cabe =  " + idpedido_regalos_cabe
				+ "     AND pc.idempresa =   " + idempresa;

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosDetalleXPedido( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosRegalosClienteXPedido(
			BigDecimal idpedido_regalos_cabe, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ " SELECT cl.idcliente, cl.razon,  pc.idpedido_regalos_padre, pc.idtipoiva, pc.idcondicion, pc.idmoneda, pc.idlista, COALESCE(pc.idvendedor, -1) AS idvendedor, "
				+ "             cl.idcredcate, cc.credcate, pf.idpreferencia, pf.preferencia,  "
				+ "             COALESCE(cs.idcategoriasocio, -1) AS idcategoriasocio, COALESCE(cs.categoriasocio, '') AS categoriasocio, adidesc, "
				+ "             pc.idsucuclie, pc.obsentrega, pc.obsarmado ,"
				+ "             pc.idexpreso, ex.expreso, pc.idzona, zo.zona, cd.idanexolocalidad,"
				+ "             cd.telefonos, cd.celular, cd.calle, cd.nro, cd.piso, cd.depto, pc.transformacion,"
				+ "             cl.idempresa,cl.usuarioalt,cl.usuarioact,cl.fechaalt,cl.fechaact  "
				+ "   FROM clientesclientes  cl "
				+ "             INNER JOIN pedidos_regalos_cabe pc ON cl.idcliente = pc.idcliente AND cl.idempresa = pc.idempresa "
				+ "             INNER JOIN clientesdomicilios cd ON pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa  "
				+ "             INNER JOIN clientesexpresos ex ON pc.idexpreso = ex.idexpreso AND pc.idempresa = ex.idempresa  "
				+ "             INNER JOIN clienteszonas zo ON pc.idzona = zo.idzona AND pc.idempresa = zo.idempresa  "
				+ "             INNER JOIN clientescredcate cc ON cl.idcredcate = cc.idcredcate AND cl.idempresa = cc.idempresa  "
				+ "              LEFT JOIN bacotmcategorizaciones ca ON cl.idcliente = ca.idcliente AND cl.idempresa = ca.idempresa  AND ca.fhasta IS NULL "
				+ "              LEFT JOIN bacotmcategoriassocios cs ON cs.idcategoriasocio = ca.idcategoria AND cs.idempresa = ca.idempresa "
				+ "              LEFT JOIN clientesprecargaclientes pre ON  cl.idcliente = pre.idcliente AND cl.idempresa = pre.idempresa  "
				+ "              LEFT JOIN clientespreferencias pf ON pre.idpreferencia = pf.idpreferencia AND pre.idempresa = pf.idempresa "
				+ "WHERE pc.idpedido_regalos_cabe =  " + idpedido_regalos_cabe
				+ "     AND pc.idempresa =   " + idempresa;

		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosClienteXPedido( ... )  "
							+ ex);
		}
		return vecSalida;
	}

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosRegalosHijosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_regalos_cabe, pc.idpedido_regalos_padre, es.idestado,es.estado,  td.invalido,  pd.cantidad::numeric(18) AS cantidad,"
				+ "            ec.idesquema, ec.esquema, ec.observaciones, pd.codigo_st, st.descrip_st, "
				+ "            pc.idcliente, cl.razon, pc.idsucursal,cd.calle || ' ' || cd.nro as direccion,  "
				+ "            pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "            recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "            CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "            pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "            INNER JOIN pedidos_regalos_deta pd ON pc.idpedido_regalos_cabe = pd.idpedido_regalos_cabe AND pc.idempresa = pd.idempresa  "
				+ "            INNER JOIN ( "
				+ "                                SELECT CASE WHEN COUNT(1) = 1 THEN 'N' ELSE 'S' END AS invalido, idpedido_regalos_cabe, idempresa "
				+ "                                   FROM pedidos_regalos_deta GROUP BY idpedido_regalos_cabe, idempresa "
				+ "                               ) td ON pc.idpedido_regalos_cabe = td.idpedido_regalos_cabe AND pc.idempresa = td.idempresa "
				+ "            INNER JOIN produccionesquemas_deta  ed ON pd.codigo_st = ed.codigo_st  AND pd.idempresa = ed.idempresa  AND entsal = 'P' "
				+ "            INNER JOIN produccionesquemas_cabe  ec ON ed.idesquema = ec.idesquema  AND ed.idempresa = ec.idempresa  "
				+ "            INNER JOIN stockstock  st ON ed.codigo_st = st.codigo_st  AND ed.idempresa = st.idempresa  "
				+ "            INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
				+ "            INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "                      AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "            INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "            INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "              LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "              LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE  pc.idempresa = "
				+ idempresa.toString()
				+ "    AND  pc.idpedido_regalos_padre IS NOT NULL  AND pc.idpedido_regalos_cabe <> pc.idpedido_regalos_padre  "
				+ "  ORDER BY fechapedido DESC  LIMIT " + limit + " OFFSET  "

				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosHijosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosRegalosHijosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				+ "SELECT pc.idpedido_regalos_cabe, pc.idpedido_regalos_padre, es.idestado,es.estado,  td.invalido, pd.cantidad::numeric(18) AS cantidad,"
				+ "            ec.idesquema, ec.esquema, ec.observaciones, pd.codigo_st, st.descrip_st, "
				+ "            pc.idcliente, cl.razon, pc.idsucursal,cd.calle || ' ' || cd.nro as direccion,  "
				+ "            pc.fechapedido,pc.idcondicion,pc.idvendedor,pc.idexpreso,pc.comision,pc.ordencompra,pc.obsarmado,pc.obsentrega,pc.recargo1,pc.recargo2,pc. "
				+ "            recargo3,pc.recargo4,pc.bonific1,pc.bonific2,pc.bonific3,pc.idlista,pc.idmoneda,pc.cotizacion,pc.idtipoiva,pc.totaliva,pc.idprioridad,pc.idzona,  "
				+ "            CASE WHEN pc.idtarjeta < 0 THEN co.condicion ELSE tm.tarjetacredito || '/' || tc.nrotarjeta  END AS condicion, "
				+ "            pc.cuotas,pc.origenpedido,'R' AS tipopedido,pc.idempresa,pc.usuarioalt,pc.usuarioact,pc.fechaalt,pc.fechaact "
				+ "  FROM pedidos_regalos_cabe pc "
				+ "            INNER JOIN pedidos_regalos_deta pd ON pc.idpedido_regalos_cabe = pd.idpedido_regalos_cabe AND pc.idempresa = pd.idempresa  "
				+ "            INNER JOIN ( "
				+ "                                SELECT CASE WHEN COUNT(1) = 1 THEN 'N' ELSE 'S' END AS invalido, idpedido_regalos_cabe, idempresa "
				+ "                                   FROM pedidos_regalos_deta GROUP BY idpedido_regalos_cabe, idempresa "
				+ "                               ) td ON pc.idpedido_regalos_cabe = td.idpedido_regalos_cabe AND pc.idempresa = td.idempresa "
				+ "            INNER JOIN produccionesquemas_deta  ed ON pd.codigo_st = ed.codigo_st  AND pd.idempresa = ed.idempresa  AND entsal = 'P' "
				+ "            INNER JOIN produccionesquemas_cabe  ec ON ed.idesquema = ec.idesquema  AND ed.idempresa = ec.idempresa  "
				+ "            INNER JOIN stockstock  st ON ed.codigo_st = st.codigo_st  AND ed.idempresa = st.idempresa  "
				+ "            INNER JOIN clientesclientes cl ON pc.idcliente = cl.idcliente AND pc.idempresa = cl.idempresa  "
				+ "            INNER JOIN clientesdomicilios cd ON pc.idcliente = cd.idcliente "
				+ "                      AND pc.idsucuclie = cd.iddomicilio AND pc.idempresa = cd.idempresa "
				+ "            INNER JOIN pedidosregalosestados es ON pc.idestado = es.idestado  AND pc.idempresa = es.idempresa "
				+ "            INNER JOIN clientescondicio co ON pc.idcondicion = co.idcondicion AND  pc.idempresa = co.idempresa "
				+ "              LEFT JOIN clientetarjetascredito tc ON pc.idtarjeta = tc.idtarjeta   AND pc.idempresa = tc.idempresa "
				+ "              LEFT JOIN clientetarjetascreditomarcas tm ON tc.idtarjetacredito = tm.idtarjetacredito    AND tc.idempresa = tm.idempresa "
				+ " WHERE  (pc.idpedido_regalos_cabe::VARCHAR LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR UPPER (es.estado) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%') AND pc.idempresa = "
				+ idempresa.toString()
				+ "    AND  pc.idpedido_regalos_padre IS NOT NULL  AND pc.idpedido_regalos_cabe <> pc.idpedido_regalos_padre  "
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosRegalosHijosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosRegalosEntregas Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Tue Dec 14 12:45:32 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesRemitosRegalosEntregasAll(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idpedido_regalos_cabe,idremitocliente,nrosucursal,nroremitocliente,fecharemito,idestado,estado,"
				+ "            nroctacte,idzona,zona,idexpreso,expreso,idcliente,razon,contacto,calle,nro,piso,depto,"
				+ "            localidad,provincia,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM vclientesremitosregalosentregas "
				+ "WHERE idempresa = " + idempresa.toString() + " " + filtro
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosRegalosEntregasAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vPedidosRegalosValorizacion Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Dec 22 10:55:24 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVPedidosRegalosValorizacionAll(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idpedido_regalos_cabe,idpedido_regalos_padre,idcliente,razon,totalsiniva,totaliva,totalivadetalle,idestado,estado,idempresa,fechaalt "
				+ "   FROM vpedidosregalosvalorizacion WHERE idempresa = "
				+ idempresa.toString() + filtro + "  ORDER BY  4, 1   LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosRegalosValorizacionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public BigDecimal getVPedidosRegalosValorizacionSumTotal(String filtro,
			String consiniva, BigDecimal idempresa) throws EJBException {
		BigDecimal total = new BigDecimal(0);
		String cQuery = ""
				+ "SELECT CASE WHEN UPPER('"
				+ consiniva
				+ "') = 'SIN' THEN  SUM(totalsiniva)  ELSE   SUM(totalivadetalle)  END AS total "
				+ "   FROM vpedidosregalosvalorizacion WHERE idempresa = "
				+ idempresa.toString() + filtro + ";";

		try {

			ResultSet rs = null;
			Statement st = dbconn.createStatement();
			rs = st.executeQuery(cQuery);

			if (rs != null) {
				if (rs.next()) {
					total = rs.getBigDecimal("total");
				} else
					log
							.warn("getVPedidosRegalosValorizacionSumTotal: rs no next");
			} else
				log.error("getVPedidosRegalosValorizacionSumTotal: rs null");

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosRegalosValorizacionSumTotal()  "
							+ ex);
		}
		return total;
	}

	/**
	 * Metodos para la entidad: vPedidosRegalosValorizacionHijos Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Thu Dec 23 09:59:27 ART 2010
	 */
	// para todo (ordena por el segundo campo por defecto)
	// por primary key (primer campo por defecto)
	public List getVPedidosRegalosValorizacionHijosPK(
			BigDecimal idpedido_regalos_padre, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idpedido_regalos_padre,idpedido_regalos_cabe,codigo_st,descrip_st,cantidad,precio,importe,importeiva,porcdesc_apli,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM vpedidosregalosvalorizacionhijos"
				+ " WHERE idpedido_regalos_padre="
				+ idpedido_regalos_padre.toString() + " AND idempresa = "
				+ idempresa.toString() + " AND idestado <> 99 ;";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVPedidosRegalosValorizacionHijosPK( BigDecimal idpedido_regalos_padre )  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesRemitosTotalCondicion Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Tue Jan 04 15:02:54 ART 2011
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesRemitosTotalCondicionFleteAll(long limit,
			long offset, int mes, int ano, int idestado, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idzona,zona,idcondicion,condicion,mes,ano,idestado,totalsinivadetalle,totalivadetalle, valorfleteconiva, total, idempresa "
				+ "   FROM vclientesremitostotalcondicionflete"
				+ " WHERE idempresa = " + idempresa.toString()
				+ "      AND mes = " + mes + "  AND ano =  " + ano
				+ "  AND idestado = " + idestado + " ORDER BY 2, 8 DESC;";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesRemitosTotalCondicionFleteAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesPromociones Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Jan 18 09:58:24 ART 2011
	 * 
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesPromocionesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cp.idpromocion, cp.promocion, cp.idtipoclie, ct.tipoclie, cp.fechadesde, cp.fechahasta, cp.convenio, cp.porc_desc_ci, cp.porc_desc_ci_react, cp.porc_liq, "
				// 20110907 - EJV - Mantis 777 -->
				+ "            cb.idclub, cb.club, cb.logo,  "
				// <--
				+ "             cp.idempresa, cp.usuarioalt, cp.usuarioact, cp.fechaalt, cp.fechaact "
				+ "   FROM clientespromociones cp "
				+ "             INNER JOIN clientestipoclie ct ON cp.idtipoclie = ct.idtipoclie AND cp.idempresa = ct.idempresa "
				// 20110907 - EJV - Mantis 777 -->
				+ "            INNER JOIN clientesclub cb  ON ct.idclub = cb.idclub AND ct.idempresa = cb.idempresa "
				// <--
				+ "WHERE cp.idempresa = " + idempresa.toString()
				+ "  ORDER BY cp.fechadesde DESC, ct.tipoclie   LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPromocionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesPromocionesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cp.idpromocion, cp.promocion, cp.idtipoclie, ct.tipoclie, cp.fechadesde, cp.fechahasta, cp.convenio, cp.porc_desc_ci,  cp.porc_desc_ci_react,cp.porc_liq, "
				// 20110907 - EJV - Mantis 777 -->
				+ "            cb.idclub, cb.club, cb.logo,  "
				// <--
				+ "             cp.idempresa, cp.usuarioalt, cp.usuarioact, cp.fechaalt, cp.fechaact "
				+ "   FROM clientespromociones cp "
				+ "            INNER JOIN clientestipoclie ct ON cp.idtipoclie = ct.idtipoclie AND cp.idempresa = ct.idempresa "
				// 20110907 - EJV - Mantis 777 -->
				+ "            INNER JOIN clientesclub cb  ON ct.idclub = cb.idclub AND ct.idempresa = cb.idempresa "
				// <--
				+ " WHERE (UPPER(cp.promocion) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY cp.fechadesde DESC, ct.tipoclie  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPromocionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesPromocionesPK(BigDecimal idpromocion,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cp.idpromocion, cp.promocion, cp.idtipoclie, cp.fechadesde, cp.fechahasta, cp.convenio, cp.porc_desc_ci, cp.porc_desc_ci_react, cp.porc_liq, "
				// 20110907 - EJV - Mantis 777 -->
				+ "            cb.idclub, cb.club, cb.logo,  "
				// <--
				+ "            cp.idempresa, cp.usuarioalt, cp.usuarioact, cp.fechaalt, cp.fechaact "
				+ "  FROM clientespromociones cp "
				// 20110907 - EJV - Mantis 777 -->
				+ "            INNER JOIN clientestipoclie tc  ON cp.idtipoclie = tc.idtipoclie AND cp.idempresa = tc.idempresa "
				+ "            INNER JOIN clientesclub cb  ON tc.idclub = cb.idclub AND tc.idempresa = cb.idempresa "
				// <--
				+ "WHERE cp.idpromocion=" + idpromocion.toString()
				+ "    AND cp.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesPromocionesPK( BigDecimal idpromocion )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesPromocionesDelete(BigDecimal idpromocion,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESPROMOCIONES WHERE idpromocion="
				+ idpromocion.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESPROMOCIONES WHERE idpromocion="
						+ idpromocion.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesPromocionesDelete( BigDecimal idpromocion, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesPromocionesDelete( BigDecimal idpromocion, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesPromocionesCreate(String promocion,
			BigDecimal idtipoclie, java.sql.Date fechadesde,
			java.sql.Date fechahasta, String convenio, BigDecimal porc_desc_ci,
			BigDecimal porc_desc_ci_react, BigDecimal porc_liq,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (promocion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: promocion ";
		if (idtipoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoclie ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (porc_desc_ci == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_desc_ci ";
		if (porc_desc_ci_react == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_desc_ci_react ";
		if (porc_liq == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_liq ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (promocion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: promocion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// 20110907 - EJV - Mantis 777 -->

		// int countPromo = getExistePromocionActivaEnPeriodo(null, idtipoclie,
		// fechadesde, fechahasta, idempresa);

		// if (countPromo > 0)
		// salida =
		// "Error: Existe promocion abierta para el periodo seleccionado.";
		// else if (countPromo < 0)
		// salida =
		// "Error: No fue posible verificar si existe promocion abierta para el periodo seleccionado.";

		// <--

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESPROMOCIONES(promocion, idtipoclie, fechadesde, fechahasta, convenio, porc_desc_ci, porc_desc_ci_react, porc_liq, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, promocion);
				insert.setBigDecimal(2, idtipoclie);
				insert.setDate(3, fechadesde);
				insert.setDate(4, fechahasta);
				insert.setString(5, convenio);
				insert.setBigDecimal(6, porc_desc_ci);
				insert.setBigDecimal(7, porc_desc_ci_react);
				insert.setBigDecimal(8, porc_liq);
				insert.setBigDecimal(9, idempresa);
				insert.setString(10, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesPromocionesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesPromocionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesPromocionesCreateOrUpdate(BigDecimal idpromocion,
			String promocion, BigDecimal idtipoclie, java.sql.Date fechadesde,
			java.sql.Date fechahasta, String convenio, BigDecimal porc_desc_ci,
			BigDecimal porc_desc_ci_react, BigDecimal porc_liq,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (promocion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: promocion ";
		if (idtipoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoclie ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (porc_desc_ci == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_desc_ci ";
		if (porc_liq == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_liq ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (promocion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: promocion ";

		int countPromo = getExistePromocionActivaEnPeriodo(idpromocion,
				idtipoclie, fechadesde, fechahasta, idempresa);
		if (countPromo > 0)
			salida = "Error: Existe promocion abierta para el periodo seleccionado.";
		else if (countPromo < 0)
			salida = "Error: No fue posible verificar si existe promocion abierta para el periodo seleccionado.";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPromociones WHERE idpromocion = "
					+ idpromocion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPROMOCIONES SET promocion=?, idtipoclie=?, fechadesde=?, fechahasta=?, convenio=?, porc_desc_ci=?, porc_liq=?, idempresa=?, usuarioact=?, fechaact=? WHERE idpromocion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, promocion);
					insert.setBigDecimal(2, idtipoclie);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setString(5, convenio);
					insert.setBigDecimal(6, porc_desc_ci);
					insert.setBigDecimal(7, porc_liq);
					insert.setBigDecimal(8, idempresa);
					insert.setString(9, usuarioact);
					insert.setTimestamp(10, fechaact);
					insert.setBigDecimal(11, idpromocion);
				} else {
					String ins = "INSERT INTO CLIENTESPROMOCIONES(promocion, idtipoclie, fechadesde, fechahasta, convenio, porc_desc_ci, porc_liq, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact; // esta variable va a
					// proposito
					insert.setString(1, promocion);
					insert.setBigDecimal(2, idtipoclie);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setString(5, convenio);
					insert.setBigDecimal(6, porc_desc_ci);
					insert.setBigDecimal(7, porc_liq);
					insert.setBigDecimal(8, idempresa);
					insert.setString(9, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesPromocionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesPromocionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesPromocionesUpdate(BigDecimal idpromocion,
			String promocion, BigDecimal idtipoclie, java.sql.Date fechadesde,
			java.sql.Date fechahasta, String convenio, BigDecimal porc_desc_ci,
			BigDecimal porc_desc_ci_react, BigDecimal porc_liq,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idpromocion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idpromocion ";
		if (promocion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: promocion ";
		if (idtipoclie == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipoclie ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";

		if (porc_desc_ci == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_desc_ci ";
		// 20110907 - EJV - Mantis 777 -->
		if (porc_desc_ci_react == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_desc_ci_react ";
		// <--

		if (porc_liq == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: porc_liq ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (promocion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: promocion ";

		// 20110907 - EJV - Mantis 777 -->
		// int countPromo = getExistePromocionActivaEnPeriodo(idpromocion,
		// idtipoclie, fechadesde, fechahasta, idempresa);
		// if (countPromo > 0)
		// salida =
		// "Error: Existe promocion abierta para el periodo seleccionado.";
		// else if (countPromo < 0)
		// salida =
		// "Error: No fue posible verificar si existe promocion abierta para el periodo seleccionado.";
		// <--

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesPromociones WHERE idpromocion = "
					+ idpromocion.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESPROMOCIONES "
							+ "   SET promocion=?, idtipoclie=?, fechadesde=?, fechahasta=?, convenio=?, porc_desc_ci=?,  porc_desc_ci_react=?,porc_liq=?, idempresa=?, usuarioact=?, fechaact=? "
							+ " WHERE idpromocion=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, promocion);
					insert.setBigDecimal(2, idtipoclie);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setString(5, convenio);
					insert.setBigDecimal(6, porc_desc_ci);
					insert.setBigDecimal(7, porc_desc_ci_react);
					insert.setBigDecimal(8, porc_liq);
					insert.setBigDecimal(9, idempresa);
					insert.setString(10, usuarioact);
					insert.setTimestamp(11, fechaact);
					insert.setBigDecimal(12, idpromocion);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesPromocionesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesPromocionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// 20110124 - EJV - Mantis 597 -->

	public List getPromocionesActivasXTipoClie(BigDecimal idtipoclie,
			BigDecimal idempresa) throws EJBException {

		String cQuery = ""
				// +
				// "SELECT   idpromocion,promocion,idtipoclie,fechadesde,fechahasta,convenio,porc_desc_ci,porc_liq,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				// + "   FROM clientespromociones "
				//				
				+ "SELECT cp.idpromocion, cp.promocion, cp.idtipoclie, ct.tipoclie, cp.fechadesde, cp.fechahasta, cp.convenio, cp.porc_desc_ci, cp.porc_desc_ci_react, cp.porc_liq, "
				// 20110907 - EJV - Mantis 777 -->
				+ "            cb.idclub, cb.club, cb.logo,  "
				// <--
				+ "             cp.idempresa, cp.usuarioalt, cp.usuarioact, cp.fechaalt, cp.fechaact "
				+ "   FROM clientespromociones cp "
				+ "             INNER JOIN clientestipoclie ct ON cp.idtipoclie = ct.idtipoclie AND cp.idempresa = ct.idempresa "
				// 20110907 - EJV - Mantis 777 -->
				+ "            INNER JOIN clientesclub cb  ON ct.idclub = cb.idclub AND ct.idempresa = cb.idempresa "
				// <--

				+ "             WHERE cp.idtipoclie="
				+ idtipoclie.toString()
				+ "     AND (CURRENT_DATE BETWEEN cp.fechadesde AND cp.fechahasta OR (CURRENT_DATE >= cp.fechadesde AND cp.fechahasta IS NULL )) AND cp.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY cp.idtipoclie, cp.fechadesde DESC;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPromocionesActivasXTipoClie( BigDecimal idpromocion )  "
							+ ex);
		}

		return vecSalida;
	}

	public int getExistePromocionActivaEnPeriodo(BigDecimal idpromocion,
			BigDecimal idtipoclie, java.sql.Date fechadesde,
			java.sql.Date fechahasta, BigDecimal idempresa) throws EJBException {

		int retorno = -99;
		try {

			String cQuery = ""
					+ "SELECT COUNT(1) "
					+ "  FROM clientespromociones "
					+ " WHERE ((? BETWEEN fechadesde AND fechahasta "
					+ "        OR  (? >= fechadesde AND fechahasta IS NULL)) "
					+ "        OR ?  BETWEEN fechadesde AND fechahasta) "
					+ (idpromocion != null ? " AND idpromocion <> "
							+ idpromocion : "") + "   AND idtipoclie =  ? "
					+ "   AND idempresa = ? ";

			ResultSet rs = null;
			PreparedStatement st = dbconn.prepareStatement(cQuery);

			st.setDate(1, fechadesde);
			st.setDate(2, fechadesde);
			st.setDate(3, fechahasta);
			st.setBigDecimal(4, idtipoclie);
			st.setBigDecimal(5, idempresa);
			rs = st.executeQuery();

			if (rs != null) {
				if (rs.next()) {
					retorno = rs.getInt(1);
				} else {
					retorno = -97;
					log.warn("getExistePromocionActivaEnPeriodo(): No next.");
				}
			} else {
				retorno = -98;
				log.warn("getExistePromocionActivaEnPeriodo(): Null.");
			}

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getExistePromocionActivaEnPeriodo( ... )  "
							+ ex);
		}

		return retorno;
	}

	// <--

	/**
	 * Metodos para la entidad: pedidosVentasEspeciales Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Jan 27 11:07:27 ART 2011
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosVentasEspecialesAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idventaespecial,ventaespecial,fechadesde,fechahasta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM pedidosventasespeciales WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosVentasEspecialesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosVentasEspecialesOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idventaespecial,ventaespecial,fechadesde,fechahasta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM pedidosventasespeciales WHERE (UPPER(VENTAESPECIAL) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosVentasEspecialesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosVentasEspecialesPK(BigDecimal idventaespecial,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idventaespecial,ventaespecial,fechadesde,fechahasta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM pedidosventasespeciales WHERE idventaespecial="
				+ idventaespecial.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosVentasEspecialesPK( BigDecimal idventaespecial )  "
							+ ex);
		}
		return vecSalida;
	}

	public List getPedidosVentasEspecialesActivas(BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idventaespecial,ventaespecial,fechadesde,fechahasta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM pedidosventasespeciales WHERE current_date BETWEEN fechadesde AND fechahasta AND idempresa = "
				+ idempresa.toString() + "  ORDER BY 2 ;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosVentasEspecialesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosVentasEspecialesDelete(BigDecimal idventaespecial,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM PEDIDOSVENTASESPECIALES WHERE idventaespecial="
				+ idventaespecial.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM PEDIDOSVENTASESPECIALES WHERE idventaespecial="
						+ idventaespecial.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosVentasEspecialesDelete( BigDecimal idventaespecial, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosVentasEspecialesDelete( BigDecimal idventaespecial, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosVentasEspecialesCreate(String ventaespecial,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (ventaespecial == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ventaespecial ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (ventaespecial.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ventaespecial ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO PEDIDOSVENTASESPECIALES(ventaespecial, fechadesde, fechahasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, ventaespecial);
				insert.setDate(2, fechadesde);
				insert.setDate(3, fechahasta);
				insert.setBigDecimal(4, idempresa);
				insert.setString(5, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosVentasEspecialesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosVentasEspecialesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosVentasEspecialesCreateOrUpdate(
			BigDecimal idventaespecial, String ventaespecial,
			java.sql.Date fechadesde, java.sql.Date fechahasta,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idventaespecial == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idventaespecial ";
		if (ventaespecial == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ventaespecial ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (ventaespecial.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ventaespecial ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosVentasEspeciales WHERE idventaespecial = "
					+ idventaespecial.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSVENTASESPECIALES SET ventaespecial=?, fechadesde=?, fechahasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idventaespecial=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, ventaespecial);
					insert.setDate(2, fechadesde);
					insert.setDate(3, fechahasta);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idventaespecial);
				} else {
					String ins = "INSERT INTO PEDIDOSVENTASESPECIALES(ventaespecial, fechadesde, fechahasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, ventaespecial);
					insert.setDate(2, fechadesde);
					insert.setDate(3, fechahasta);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosVentasEspecialesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosVentasEspecialesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosVentasEspecialesUpdate(BigDecimal idventaespecial,
			String ventaespecial, java.sql.Date fechadesde,
			java.sql.Date fechahasta, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idventaespecial == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idventaespecial ";
		if (ventaespecial == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: ventaespecial ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (ventaespecial.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: ventaespecial ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosVentasEspeciales WHERE idventaespecial = "
					+ idventaespecial.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSVENTASESPECIALES SET ventaespecial=?, fechadesde=?, fechahasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idventaespecial=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, ventaespecial);
					insert.setDate(2, fechadesde);
					insert.setDate(3, fechahasta);
					insert.setBigDecimal(4, idempresa);
					insert.setString(5, usuarioact);
					insert.setTimestamp(6, fechaact);
					insert.setBigDecimal(7, idventaespecial);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosVentasEspecialesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosVentasEspecialesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: pedidosReasignacionDespositos Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Fri Feb 04 13:46:54 ART 2011
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getPedidosReasignacionDespositosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT rd.idreasignaciondeposito, rd.codigo_dt, dt.descrip_dt, rd.tipo, rd.fechadesde, rd.fechahasta, "
				+ "            rd.idempresa, rd.usuarioalt, rd.usuarioact, rd.fechaalt, rd.fechaact "
				+ "   FROM pedidosreasignaciondespositos rd "
				+ "            INNER JOIN stockdepositos dt ON rd.codigo_dt = dt.codigo_dt AND rd.idempresa = dt.idempresa "
				+ " WHERE rd.idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosReasignacionDespositosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getPedidosReasignacionDespositosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT rd.idreasignaciondeposito, rd.codigo_dt, dt.descrip_dt, rd.tipo, rd.fechadesde, rd.fechahasta, "
				+ "            rd.idempresa, rd.usuarioalt, rd.usuarioact, rd.fechaalt, rd.fechaact "
				+ "   FROM pedidosreasignaciondespositos rd "
				+ "            INNER JOIN stockdepositos dt ON rd.codigo_dt = dt.codigo_dt AND rd.idempresa = dt.idempresa "
				+ "WHERE (UPPER(dt.descrip_dt) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND rd.idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosReasignacionDespositosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getPedidosReasignacionDespositosPK(
			BigDecimal idreasignaciondeposito, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT rd.idreasignaciondeposito, rd.codigo_dt, rd.tipo, rd.fechadesde, rd.fechahasta, "
				+ "            rd.idempresa, rd.usuarioalt, rd.usuarioact, rd.fechaalt, rd.fechaact "
				+ "   FROM pedidosreasignaciondespositos rd "
				+ "  WHERE rd.idreasignaciondeposito="
				+ idreasignaciondeposito.toString() + " AND rd.idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getPedidosReasignacionDespositosPK( Long idreasignaciondeposito )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String pedidosReasignacionDespositosDelete(
			BigDecimal idreasignaciondeposito, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM pedidosreasignaciondespositos WHERE idreasignaciondeposito="
				+ idreasignaciondeposito.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM pedidosreasignaciondespositos WHERE idreasignaciondeposito="
						+ idreasignaciondeposito.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : pedidosReasignacionDespositosDelete( Long idreasignaciondeposito, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: pedidosReasignacionDespositosDelete( Long idreasignaciondeposito, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String pedidosReasignacionDespositosCreate(BigDecimal codigo_dt,
			String tipo, java.sql.Date fechadesde, java.sql.Date fechahasta,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO pedidosreasignaciondespositos(codigo_dt, tipo, fechadesde, fechahasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, codigo_dt);
				insert.setString(2, tipo);
				insert.setDate(3, fechadesde);
				insert.setDate(4, fechahasta);
				insert.setBigDecimal(5, idempresa);
				insert.setString(6, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
				else
					salida = "No fue posible dar de alta el registro, posiblemente ya exista el rango para el deposito ingresado.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosReasignacionDespositosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosReasignacionDespositosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String pedidosReasignacionDespositosCreateOrUpdate(
			BigDecimal idreasignaciondeposito, BigDecimal codigo_dt,
			String tipo, java.sql.Date fechadesde, java.sql.Date fechahasta,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idreasignaciondeposito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreasignaciondeposito ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosReasignacionDespositos WHERE idreasignaciondeposito = "
					+ idreasignaciondeposito.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE pedidosreasignaciondespositos SET codigo_dt=?, tipo=?, fechadesde=?, fechahasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idreasignaciondeposito=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, codigo_dt);
					insert.setString(2, tipo);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idreasignaciondeposito);
				} else {
					String ins = "INSERT INTO pedidosreasignaciondespositos(codigo_dt, tipo, fechadesde, fechahasta, idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setBigDecimal(1, codigo_dt);
					insert.setString(2, tipo);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String pedidosReasignacionDespositosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String pedidosReasignacionDespositosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String pedidosReasignacionDespositosUpdate(
			BigDecimal idreasignaciondeposito, BigDecimal codigo_dt,
			String tipo, java.sql.Date fechadesde, java.sql.Date fechahasta,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idreasignaciondeposito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idreasignaciondeposito ";
		if (codigo_dt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: codigo_dt ";
		if (tipo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipo ";
		if (fechadesde == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechadesde ";
		if (fechahasta == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechahasta ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (tipo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipo ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM pedidosReasignacionDespositos WHERE idreasignaciondeposito = "
					+ idreasignaciondeposito.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE PEDIDOSREASIGNACIONDESPOSITOS SET codigo_dt=?, tipo=?, fechadesde=?, fechahasta=?, idempresa=?, usuarioact=?, fechaact=? WHERE idreasignaciondeposito=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setBigDecimal(1, codigo_dt);
					insert.setString(2, tipo);
					insert.setDate(3, fechadesde);
					insert.setDate(4, fechahasta);
					insert.setBigDecimal(5, idempresa);
					insert.setString(6, usuarioact);
					insert.setTimestamp(7, fechaact);
					insert.setBigDecimal(8, idreasignaciondeposito);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String pedidosReasignacionDespositosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String pedidosReasignacionDespositosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoClustersLogistica Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Mar 31 16:05:57 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoClustersLogisticaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idclusterlogistica,clusterlogistica,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacoclusterslogistica WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoClustersLogisticaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoClustersLogisticaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idclusterlogistica,clusterlogistica,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacoclusterslogistica WHERE (UPPER(CLUSTERLOGISTICA) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoClustersLogisticaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoClustersLogisticaPK(BigDecimal idclusterlogistica,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idclusterlogistica,clusterlogistica,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacoclusterslogistica WHERE idclusterlogistica="
				+ idclusterlogistica.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoClustersLogisticaPK( BigDecimal idclusterlogistica )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoClustersLogisticaDelete(BigDecimal idclusterlogistica,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOCLUSTERSLOGISTICA WHERE idclusterlogistica="
				+ idclusterlogistica.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOCLUSTERSLOGISTICA WHERE idclusterlogistica="
						+ idclusterlogistica.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoClustersLogisticaDelete( BigDecimal idclusterlogistica, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoClustersLogisticaDelete( BigDecimal idclusterlogistica, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoClustersLogisticaCreate(String clusterlogistica,
			BigDecimal idempresa, String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (clusterlogistica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clusterlogistica ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (clusterlogistica.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clusterlogistica ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOCLUSTERSLOGISTICA(clusterlogistica, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, clusterlogistica);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoClustersLogisticaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoClustersLogisticaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoClustersLogisticaCreateOrUpdate(
			BigDecimal idclusterlogistica, String clusterlogistica,
			BigDecimal idempresa, String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idclusterlogistica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclusterlogistica ";
		if (clusterlogistica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clusterlogistica ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (clusterlogistica.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clusterlogistica ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoClustersLogistica WHERE idclusterlogistica = "
					+ idclusterlogistica.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOCLUSTERSLOGISTICA SET clusterlogistica=?, idempresa=?, usuarioact=?, fechaact=? WHERE idclusterlogistica=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, clusterlogistica);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idclusterlogistica);
				} else {
					String ins = "INSERT INTO BACOCLUSTERSLOGISTICA(clusterlogistica, idempresa, usuarioalt ) VALUES (?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, clusterlogistica);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoClustersLogisticaCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoClustersLogisticaCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoClustersLogisticaUpdate(BigDecimal idclusterlogistica,
			String clusterlogistica, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idclusterlogistica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclusterlogistica ";
		if (clusterlogistica == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: clusterlogistica ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (clusterlogistica.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: clusterlogistica ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoClustersLogistica WHERE idclusterlogistica = "
					+ idclusterlogistica.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOCLUSTERSLOGISTICA SET clusterlogistica=?, idempresa=?, usuarioact=?, fechaact=? WHERE idclusterlogistica=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, clusterlogistica);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idclusterlogistica);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoClustersLogisticaUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoClustersLogisticaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/* 20110406 - EJV Mantis 696 */

	public List getClientesCambioFechaEstadoAll(long limit, long offset,
			BigDecimal idestado, java.sql.Date fechadesde, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT ce.idestadocliente, ce.idcliente, cl.razon, ce.fechadesde, COALESCE(fesm.total, 0) AS totalposterior, "
				+ "            ce.fechaalt, ce.fechaact, ce.usuarioalt, ce.usuarioact"
				+ "  FROM clientesestadosclientes ce "
				+ "            INNER JOIN clientesclientes cl ON ce.idcliente = cl.idcliente AND ce.idempresa = cl.idempresa "
				+ "              LEFT JOIN ( "
				+ "  		          SELECT COUNT(ce.idcliente)::NUMERIC AS total, ce.idcliente, ce.idempresa "
				+ "     		        FROM clientesestadosclientes ce "
				+ "        		 WHERE ce.fechadesde > '"
				+ fechadesde
				+ "'::DATE "
				+ "            	     AND ce.idempresa =  "
				+ idempresa.toString()
				+ "                GROUP BY ce.idcliente, ce.idempresa "
				+ "                ) fesm ON ce.idcliente = fesm.idcliente AND ce.idempresa = fesm.idempresa "
				+ " WHERE ce.idestado =  " + idestado
				+ "   AND ce.fechadesde = '" + fechadesde + "'::DATE "
				+ "   AND ce.idempresa =  " + idempresa.toString()
				+ " ORDER BY 3	 LIMIT " + limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesCambioFechaEstadoAll()  "
							+ ex);
		}

		return vecSalida;

	}

	public String clientesCambioFechaEstadoUpdate(
			String[] idestadoclienteVector, Date fechadesde, String usuarioact,
			BigDecimal idempresa) throws EJBException, SQLException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		// 2. sin nada desde la pagina
		// fin validaciones

		dbconn.setAutoCommit(false);

		try {
			ResultSet rsSalida = null;
			// String cQuery =
			// "SELECT COUNT(*) FROM clientesestadosclientes WHERE idestadocliente = "
			// + idestadocliente.toString()
			// + " AND idempresa = "
			// + idempresa;
			// Statement statement = dbconn.createStatement();
			// rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			// if (rsSalida != null && rsSalida.next())
			// total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				for (int j = 0; j < idestadoclienteVector.length; j++) {

					BigDecimal idestadocliente = new BigDecimal(
							idestadoclienteVector[j]);

					int i = 0;

					sql = "UPDATE clientesestadosclientes SET  fechadesde=?,  fechaact=?, usuarioact=? WHERE idestadocliente=? AND idempresa =?;";
					insert = dbconn.prepareStatement(sql);
					insert.setDate(1, fechadesde);
					insert.setTimestamp(2, fechaact);
					insert.setString(3, usuarioact);
					insert.setBigDecimal(4, idestadocliente);
					insert.setBigDecimal(5, idempresa);

					i = insert.executeUpdate();

					log.debug("fechadesde:" + fechadesde);
					log.debug("fechaact:" + fechaact);
					log.debug("usuarioact:" + usuarioact);
					log.debug("idestadocliente:" + idestadocliente);
					log.debug("idempresa:" + idempresa);

					if (i == 1) {

						sql = "UPDATE clientesestadoshoy SET  fechadesde=?,  fechaact=?, usuarioact=? WHERE idestadocliente=? AND idempresa =?;";
						insert = dbconn.prepareStatement(sql);
						insert.setDate(1, fechadesde);
						insert.setTimestamp(2, fechaact);
						insert.setString(3, usuarioact);
						insert.setBigDecimal(4, idestadocliente);
						insert.setBigDecimal(5, idempresa);

						i = insert.executeUpdate();
						// if (i != 1) {
						//
						// salida =
						// "(E2)No fue posible actualizar fecha para idestadocliente: "
						// + idestadoclienteVector[j] +
						// ", en la entidad clientes-estados-hoy.";
						// break;
						// }

					} else {
						salida = "(E1)No fue posible actualizar fecha para idestadocliente: "
								+ idestadoclienteVector[j]
								+ ", en la entidad clientes-estados-clientes.";
						break;
					}

				}
			}
		} catch (SQLException sqlException) {
			salida = "(SQL)-Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesCambioFechaEstadoUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)-Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesCambioFechaEstadoUpdate(.....)"
							+ ex);
		}

		if (salida.equals("OK")) {
			dbconn.commit();
		} else {
			dbconn.rollback();
		}

		dbconn.setAutoCommit(true);

		return salida;
	}

	/**
	 * Metodos para la entidad: sastiposcontactos Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri May 27 09:12:29 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getSastiposcontactosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT idtipocontacto,tipocontacto,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM SASTIPOSCONTACTOS WHERE idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSastiposcontactosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSastiposcontactosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idtipocontacto,tipocontacto,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM SASTIPOSCONTACTOS WHERE (UPPER(TIPOCONTACTO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSastiposcontactosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSastiposcontactosPK(BigDecimal idtipocontacto,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idtipocontacto,tipocontacto,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM SASTIPOSCONTACTOS WHERE idtipocontacto="
				+ idtipocontacto.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSastiposcontactosPK( BigDecimal idtipocontacto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String sastiposcontactosDelete(BigDecimal idtipocontacto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SASTIPOSCONTACTOS WHERE idtipocontacto="
				+ idtipocontacto.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SASTIPOSCONTACTOS WHERE idtipocontacto="
						+ idtipocontacto.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : sastiposcontactosDelete( BigDecimal idtipocontacto, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: sastiposcontactosDelete( BigDecimal idtipocontacto, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String sastiposcontactosCreate(String tipocontacto,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		// validaciones de datos:
		// 1. nulidad de campos
		if (tipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipocontacto ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (fechaalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechaalt ";
		// 2. sin nada desde la pagina
		if (tipocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipocontacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO SASTIPOSCONTACTOS(tipocontacto, usuarioalt, fechaalt, idempresa ) VALUES (?, ?, ? ,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, tipocontacto);
				insert.setString(2, usuarioalt);
				insert.setTimestamp(3, fechaalt);
				insert.setBigDecimal(4, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String sastiposcontactosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposaible dar de alta el registro.";
			log
					.error("Error excepcion public String sastiposcontactosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String sastiposcontactosCreateOrUpdate(BigDecimal idtipocontacto,
			String tipocontacto, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (tipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipocontacto ";

		// 2. sin nada desde la pagina
		if (tipocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipocontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sastiposcontactos WHERE idtipocontacto = "
					+ idtipocontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASTIPOSCONTACTOS SET tipocontacto=?, usuarioact=?, fechaact=?idempresa=? WHERE idtipocontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipocontacto);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idempresa);
					insert.setBigDecimal(5, idtipocontacto);
				} else {
					String ins = "INSERT INTO SASTIPOSCONTACTOS(tipocontacto, usuarioalt, fechaalt , idempresa) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, tipocontacto);
					insert.setString(2, usuarioalt);
					insert.setTimestamp(3, fechaalt);
					insert.setBigDecimal(4, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sastiposcontactosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sastiposcontactosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String sastiposcontactosUpdate(BigDecimal idtipocontacto,
			String tipocontacto, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (tipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: tipocontacto ";

		// 2. sin nada desde la pagina
		if (tipocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: tipocontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sastiposcontactos WHERE idtipocontacto = "
					+ idtipocontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASTIPOSCONTACTOS SET tipocontacto=?, usuarioact=?, fechaact=? , idempresa=? WHERE idtipocontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, tipocontacto);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, idempresa);
					insert.setBigDecimal(5, idtipocontacto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String sastiposcontactosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String sastiposcontactosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: sascanalescontactos Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri May 27 10:10:38 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getSascanalescontactosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT cc.idcanalcontacto,cc.canalcontacto,cc.idtipocontacto, tc.tipocontacto,cc.usuarioalt,cc.usuarioact,cc.fechaalt,cc.fechaact,cc.idempresa FROM SASCANALESCONTACTOS cc inner join sastiposcontactos tc on (cc.idtipocontacto = tc.idtipocontacto)  WHERE cc.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascanalescontactosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSascanalescontactosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT cc.idcanalcontacto,cc.canalcontacto,cc.idtipocontacto, tc.tipocontacto,cc.usuarioalt,cc.usuarioact,cc.fechaalt,cc.fechaact,cc.idempresa FROM SASCANALESCONTACTOS cc inner join sastiposcontactos tc on (cc.idtipocontacto = tc.idtipocontacto)  WHERE  (UPPER(cc.CANALCONTACTO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' or upper(tc.tipocontacto) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' )  AND cc.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascanalescontactosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSascanalescontactosPK(BigDecimal idcanalcontacto,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idcanalcontacto,canalcontacto,idtipocontacto,usuarioalt,usuarioact,fechaalt,fechaact,idempresa FROM SASCANALESCONTACTOS WHERE idcanalcontacto="
				+ idcanalcontacto.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascanalescontactosPK( BigDecimal idcanalcontacto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String sascanalescontactosDelete(BigDecimal idcanalcontacto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SASCANALESCONTACTOS WHERE idcanalcontacto="
				+ idcanalcontacto.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SASCANALESCONTACTOS WHERE idcanalcontacto="
						+ idcanalcontacto.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : sascanalescontactosDelete( BigDecimal idcanalcontacto, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: sascanalescontactosDelete( BigDecimal idcanalcontacto, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String sascanalescontactosCreate(String canalcontacto,
			BigDecimal idtipocontacto, String usuarioalt, BigDecimal idempresa)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		if (canalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canalcontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (fechaalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechaalt ";
		// 2. sin nada desde la pagina
		if (canalcontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canalcontacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO SASCANALESCONTACTOS(canalcontacto, idtipocontacto, usuarioalt, fechaalt, idempresa ) VALUES (?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, canalcontacto);
				insert.setBigDecimal(2, idtipocontacto);
				insert.setString(3, usuarioalt);
				insert.setTimestamp(4, fechaalt);
				insert.setBigDecimal(5, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sascanalescontactosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sascanalescontactosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String sascanalescontactosCreateOrUpdate(BigDecimal idcanalcontacto,
			String canalcontacto, BigDecimal idtipocontacto, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (canalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canalcontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";

		// 2. sin nada desde la pagina
		if (canalcontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canalcontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sascanalescontactos WHERE idcanalcontacto = "
					+ idcanalcontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASCANALESCONTACTOS SET canalcontacto=?, idtipocontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idcanalcontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, canalcontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idempresa);
					insert.setBigDecimal(6, idcanalcontacto);
				} else {
					String ins = "INSERT INTO SASCANALESCONTACTOS(canalcontacto, idtipocontacto, usuarioalt, fechaalt, idempresa ) VALUES (?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, canalcontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setString(3, usuarioalt);
					insert.setTimestamp(4, fechaalt);
					insert.setBigDecimal(5, idempresa);

				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sascanalescontactosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sascanalescontactosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String sascanalescontactosUpdate(BigDecimal idcanalcontacto,
			String canalcontacto, BigDecimal idtipocontacto, String usuarioact,
			BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (canalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: canalcontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";

		// 2. sin nada desde la pagina
		if (canalcontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: canalcontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sascanalescontactos WHERE idcanalcontacto = "
					+ idcanalcontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASCANALESCONTACTOS SET canalcontacto=?, idtipocontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idcanalcontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, canalcontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idempresa);
					insert.setBigDecimal(6, idcanalcontacto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String sascanalescontactosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String sascanalescontactosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: sasmotivoscontactos Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri May 27 10:58:35 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getSasmotivoscontactosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  mc.idmotivocontacto,mc.motivocontacto,mc.idtipocontacto, tc.tipocontacto,mc.idcanalcontacto,cc.canalcontacto,mc.usuarioalt,mc.usuarioact,mc.fechaalt,mc.fechaact,mc.idempresa FROM SASMOTIVOSCONTACTOS mc inner join sascanalescontactos cc on (mc.idcanalcontacto = cc.idcanalcontacto) inner join sastiposcontactos tc on (mc.idtipocontacto = tc.idtipocontacto) WHERE mc.idempresa = "
				+ idempresa.toString()
				+ "  ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasmotivoscontactosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSasmotivoscontactosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  mc.idmotivocontacto,mc.motivocontacto,mc.idtipocontacto, tc.tipocontacto,mc.idcanalcontacto,cc.canalcontacto,mc.usuarioalt,mc.usuarioact,mc.fechaalt,mc.fechaact,mc.idempresa FROM SASMOTIVOSCONTACTOS mc inner join sascanalescontactos cc on (mc.idcanalcontacto = cc.idcanalcontacto) inner join sastiposcontactos tc on (mc.idtipocontacto = tc.idtipocontacto) WHERE (UPPER(mc.MOTIVOCONTACTO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' or upper(tc.tipocontacto) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND mc.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasmotivoscontactosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSasmotivoscontactosPK(BigDecimal idmotivocontacto,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  mc.idmotivocontacto,mc.motivocontacto,mc.idtipocontacto, tc.tipocontacto,mc.idcanalcontacto,cc.canalcontacto,mc.usuarioalt,mc.usuarioact,mc.fechaalt,mc.fechaact,mc.idempresa FROM SASMOTIVOSCONTACTOS mc inner join sascanalescontactos cc on (mc.idcanalcontacto = cc.idcanalcontacto) inner join sastiposcontactos tc on (mc.idtipocontacto = tc.idtipocontacto) WHERE mc.idmotivocontacto="
				+ idmotivocontacto.toString()
				+ " AND mc.idempresa ="
				+ idempresa.toString() + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasmotivoscontactosPK( BigDecimal idmotivocontacto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String sasmotivoscontactosDelete(BigDecimal idmotivocontacto,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SASMOTIVOSCONTACTOS WHERE idmotivocontacto="
				+ idmotivocontacto.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SASMOTIVOSCONTACTOS WHERE idmotivocontacto="
						+ idmotivocontacto.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : sasmotivoscontactosDelete( BigDecimal idmotivocontacto, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: sasmotivoscontactosDelete( BigDecimal idmotivocontacto, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String sasmotivoscontactosCreate(String motivocontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			String usuarioalt, BigDecimal idempresa) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		if (motivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivocontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (fechaalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechaalt ";
		// 2. sin nada desde la pagina
		if (motivocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivocontacto ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO SASMOTIVOSCONTACTOS(motivocontacto, idtipocontacto, idcanalcontacto, usuarioalt, fechaalt, idempresa ) VALUES (?, ?, ?, ?, ?,?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, motivocontacto);
				insert.setBigDecimal(2, idtipocontacto);
				insert.setBigDecimal(3, idcanalcontacto);
				insert.setString(4, usuarioalt);
				insert.setTimestamp(5, fechaalt);
				insert.setBigDecimal(6, idempresa);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sasmotivoscontactosCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sasmotivoscontactosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String sasmotivoscontactosCreateOrUpdate(
			BigDecimal idmotivocontacto, String motivocontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			String usuarioact, BigDecimal idempresa) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivocontacto ";
		if (motivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivocontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";

		// 2. sin nada desde la pagina
		if (motivocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivocontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sasmotivoscontactos WHERE idmotivocontacto = "
					+ idmotivocontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASMOTIVOSCONTACTOS SET motivocontacto=?, idtipocontacto=?, idcanalcontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idmotivocontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivocontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idempresa);
					insert.setBigDecimal(7, idmotivocontacto);
				} else {
					String ins = "INSERT INTO SASMOTIVOSCONTACTOS(motivocontacto, idtipocontacto, idcanalcontacto, usuarioalt, fechaalt, iempresa ) VALUES (?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, motivocontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setString(4, usuarioalt);
					insert.setTimestamp(5, fechaalt);
					insert.setBigDecimal(6, idempresa);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sasmotivoscontactosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sasmotivoscontactosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String sasmotivoscontactosUpdate(BigDecimal idmotivocontacto,
			String motivocontacto, BigDecimal idtipocontacto,
			BigDecimal idcanalcontacto, String usuarioact, BigDecimal idempresa)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivocontacto ";
		if (motivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivocontacto ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";

		// 2. sin nada desde la pagina
		if (motivocontacto.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivocontacto ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sasmotivoscontactos WHERE idmotivocontacto = "
					+ idmotivocontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE SASMOTIVOSCONTACTOS SET motivocontacto=?, idtipocontacto=?, idcanalcontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idmotivocontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivocontacto);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idempresa);
					insert.setBigDecimal(7, idmotivocontacto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String sasmotivoscontactosUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String sasmotivoscontactosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: sascontactos Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Fri May 27 12:30:35 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getSascontactosAll(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ " SELECT     sc.idcontacto, sc.descripcion, sc.idtipocontacto, tc.tipocontacto, sc.idcanalcontacto, "
				+ "            cc.canalcontacto, sc.idmotivocontacto, mc.motivocontacto, sc.idcliente, cl.razon, "
				+ "            sc.usuarioalt, sc.usuarioact, sc.fechaalt, sc.fechaact, sc.idempresa, "
				+ "            sc.idaccioncontacto, ac.accioncontacto, sc.idresultadocontacto, rc.resultadocontacto "
				+ " FROM SASCONTACTOS sc "
				+ "            INNER JOIN sastiposcontactos tc on (sc.idtipocontacto = tc.idtipocontacto) "
				+ "            INNER JOIN sascanalescontactos cc on (sc.idcanalcontacto = cc.idcanalcontacto) "
				+ "            INNER JOIN sasmotivoscontactos mc on (sc.idmotivocontacto = mc.idmotivocontacto) "
				+ "            INNER JOIN sasaccionescontactos ac on (sc.idaccioncontacto = ac.idaccioncontacto) "
				+ "            INNER JOIN sasresultadoscontactos rc on (sc.idresultadocontacto = rc.idresultadocontacto) "				
				+ "            INNER JOIN clientesclientes cl on (sc.idcliente = cl.idcliente)  "
				+ " WHERE sc.idcliente = " + idcliente.toString()
				+ "     AND sc.idempresa = " + idempresa.toString()
				+ " ORDER BY 1 DESC  LIMIT  " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascontactosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getSascontactosOcu(long limit, long offset,
			BigDecimal idcliente, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ " SELECT "
				+ "		       sc.idcontacto, sc.descripcion, sc.idtipocontacto, tc.tipocontacto, sc.idcanalcontacto, "
				+ "            cc.canalcontacto, sc.idmotivocontacto, mc.motivocontacto, sc.idcliente, cl.razon, "
				+ "            sc.usuarioalt, sc.usuarioact, sc.fechaalt, sc.fechaact, sc.idempresa, "
				+ "            sc.idaccioncontacto, ac.accioncontacto, sc.idresultadocontacto, rc.resultadocontacto "
				+ " FROM SASCONTACTOS sc "
				+ "            INNER JOIN sastiposcontactos tc on (sc.idtipocontacto = tc.idtipocontacto) "
				+ "            INNER JOIN sascanalescontactos cc on (sc.idcanalcontacto = cc.idcanalcontacto) "
				+ "            INNER JOIN sasmotivoscontactos mc on (sc.idmotivocontacto = mc.idmotivocontacto)  "
				+ "            INNER JOIN sasaccionescontactos ac on (sc.idaccioncontacto = ac.idaccioncontacto) "
				+ "            INNER JOIN sasresultadoscontactos rc on (sc.idresultadocontacto = rc.idresultadocontacto) "
				+ "            INNER JOIN clientesclientes cl on (sc.idcliente = cl.idcliente)"
				+ " WHERE (UPPER(sc.DESCRIPCION) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' or  upper(tc.tipocontacto) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' or upper (cl.razon) like '%"
				+ ocurrencia.toUpperCase().trim() + "%' ) AND sc.idcliente = "
				+ idcliente + " AND sc.idempresa = " + idempresa.toString()
				+ " ORDER BY  1 DESC   LIMIT " + limit + " OFFSET  " + offset
				+ ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascontactosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getSascontactosPK(BigDecimal idcontacto, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ " SELECT "
				+ "            sc.idcontacto, sc.descripcion, sc.idtipocontacto, tc.tipocontacto, sc.idcanalcontacto, "
				+ "            cc.canalcontacto, sc.idmotivocontacto, mc.motivocontacto, sc.idcliente, cl.razon, "
				+ "            sc.usuarioalt, sc.usuarioact, sc.fechaalt, sc.fechaact, sc.idempresa, "
				+ "            sc.idaccioncontacto, ac.accioncontacto, sc.idresultadocontacto, rc.resultadocontacto "
				+ "  FROM SASCONTACTOS sc "
				+ "            INNER JOIN sastiposcontactos tc on (sc.idtipocontacto = tc.idtipocontacto) "
				+ "            INNER JOIN sascanalescontactos cc on (sc.idcanalcontacto = cc.idcanalcontacto) "
				+ "            INNER JOIN sasmotivoscontactos mc on (sc.idmotivocontacto = mc.idmotivocontacto) "
				+ "            INNER JOIN sasaccionescontactos ac on (sc.idaccioncontacto = ac.idaccioncontacto) "
				+ "            INNER JOIN sasresultadoscontactos rc on (sc.idresultadocontacto = rc.idresultadocontacto) "
				+ "            INNER JOIN clientesclientes cl on (sc.idcliente = cl.idcliente)"
				+ " WHERE sc.idcontacto=" + idcontacto.toString()
				+ " AND sc.idempresa = " + idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascontactosPK( BigDecimal idcontacto )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String sascontactosDelete(BigDecimal idcontacto, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM SASCONTACTOS WHERE idcontacto="
				+ idcontacto.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM SASCONTACTOS WHERE idcontacto="
						+ idcontacto.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : sascontactosDelete( BigDecimal idcontacto, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: sascontactosDelete( BigDecimal idcontacto, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String sascontactosCreate(String descripcion,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, BigDecimal idaccioncontacto,
			BigDecimal idresultadocontacto, String usuarioalt,
			BigDecimal idempresa, BigDecimal idcliente) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());

		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (idmotivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivocontacto ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (fechaalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechaalt ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		idaccioncontacto = idaccioncontacto != null && idaccioncontacto.longValue() <= 0 ? null : idaccioncontacto;
		idresultadocontacto = idresultadocontacto != null && idresultadocontacto.longValue() <= 0 ? null : idresultadocontacto;
		
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
//				String ins = "INSERT INTO SASCONTACTOS(descripcion, idtipocontacto, idcanalcontacto, idmotivocontacto, usuarioalt, fechaalt ,idempresa,idcliente) VALUES (?, ?, ?, ?, ?, ?,?,?)";
				String ins = "INSERT INTO SASCONTACTOS(descripcion, idtipocontacto, idcanalcontacto, idmotivocontacto, idaccioncontacto, idresultadocontacto, usuarioalt, fechaalt, idempresa, idcliente) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, descripcion);
				insert.setBigDecimal(2, idtipocontacto);
				insert.setBigDecimal(3, idcanalcontacto);
				insert.setBigDecimal(4, idmotivocontacto);
				insert.setBigDecimal(5, idaccioncontacto);
				insert.setBigDecimal(6, idresultadocontacto);
				insert.setString(7, usuarioalt);
				insert.setTimestamp(8, fechaalt);
				insert.setBigDecimal(9, idempresa);
				insert.setBigDecimal(10, idcliente);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String sascontactosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error excepcion public String sascontactosCreate(.....)"
					+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String sascontactosCreateOrUpdate(BigDecimal idcontacto,
			String descripcion, BigDecimal idtipocontacto,
			BigDecimal idcanalcontacto, BigDecimal idmotivocontacto,
			BigDecimal idaccioncontacto, BigDecimal idresultadocontacto,
			String usuarioact, BigDecimal idempresa, BigDecimal idcliente)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcontacto ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (idmotivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivocontacto ";
		if (idaccioncontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idaccioncontacto ";
		if (idresultadocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idresultadocontacto ";
		
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";

		idaccioncontacto = idaccioncontacto != null && idaccioncontacto.longValue() <= 0 ? null : idaccioncontacto;
		idresultadocontacto = idresultadocontacto != null && idresultadocontacto.longValue() <= 0 ? null : idresultadocontacto;
		
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sascontactos WHERE idcontacto = "
					+ idcontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
//					sql = "UPDATE SASCONTACTOS SET descripcion=?, idtipocontacto=?, idcanalcontacto=?, idmotivocontacto=?, usuarioact=?, fechaact=?, idempresa=?, idcliente =? WHERE idcontacto=?;";
					sql = "UPDATE SASCONTACTOS SET descripcion=?, idtipocontacto=?, idcanalcontacto=?, idmotivocontacto=?, idaccioncontacto=?, idresultadocontacto=?, usuarioact=?, fechaact=?, idempresa=?, idcliente =? WHERE idcontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setBigDecimal(4, idmotivocontacto);
					insert.setBigDecimal(5, idaccioncontacto);
					insert.setBigDecimal(6, idresultadocontacto);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idempresa);
					insert.setBigDecimal(10, idcliente);
					insert.setBigDecimal(11, idcontacto);
				} else {
//					String ins = "INSERT INTO SASCONTACTOS(descripcion, idtipocontacto, idcanalcontacto, idmotivocontacto, usuarioalt, fechaalt, idempresa, idcliente ) VALUES (?, ?, ?, ?, ?, ?, ?,?)";
					String ins = "INSERT INTO SASCONTACTOS(descripcion, idtipocontacto, idcanalcontacto, idmotivocontacto, idaccioncontacto, idresultadocontacto, usuarioalt, fechaalt, idempresa, idcliente ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, descripcion);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setBigDecimal(4, idmotivocontacto);
					insert.setBigDecimal(5, idaccioncontacto);
					insert.setBigDecimal(6, idresultadocontacto);
					insert.setString(7, usuarioalt);
					insert.setTimestamp(8, fechaalt);
					insert.setBigDecimal(9, idempresa);
					insert.setBigDecimal(10, idcliente);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String sascontactosCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String sascontactosCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String sascontactosUpdate(BigDecimal idcontacto, String descripcion,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, BigDecimal idaccioncontacto,
			BigDecimal idresultadocontacto, String usuarioact,
			BigDecimal idempresa, BigDecimal idcliente) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcontacto ";
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (idtipocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtipocontacto ";
		if (idcanalcontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcanalcontacto ";
		if (idmotivocontacto == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivocontacto ";

		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";

		idaccioncontacto = idaccioncontacto != null && idaccioncontacto.longValue() <= 0 ? null : idaccioncontacto;
		idresultadocontacto = idresultadocontacto != null && idresultadocontacto.longValue() <= 0 ? null : idresultadocontacto;
		
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM sascontactos WHERE idcontacto = "
					+ idcontacto.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
//					sql = "UPDATE SASCONTACTOS SET descripcion=?, idtipocontacto=?, idcanalcontacto=?, idmotivocontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idcontacto=?;";
					sql = "UPDATE SASCONTACTOS SET descripcion=?, idtipocontacto=?, idcanalcontacto=?, idmotivocontacto=?, idaccioncontacto=?, idresultadocontacto=?, usuarioact=?, fechaact=?, idempresa=? WHERE idcontacto=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setBigDecimal(2, idtipocontacto);
					insert.setBigDecimal(3, idcanalcontacto);
					insert.setBigDecimal(4, idmotivocontacto);
					insert.setBigDecimal(5, idaccioncontacto);
					insert.setBigDecimal(6, idresultadocontacto);
					insert.setString(7, usuarioact);
					insert.setTimestamp(8, fechaact);
					insert.setBigDecimal(9, idempresa);
					insert.setBigDecimal(10, idcontacto);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String sascontactosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log.error("Error excepcion public String sascontactosUpdate(.....)"
					+ ex);
		}
		return salida;
	}

	public List getSascanalescontactosLista(
	// String tipo,
			BigDecimal id, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT cc.idcanalcontacto,cc.canalcontacto,cc.idtipocontacto, tc.tipocontacto,cc.usuarioalt,cc.usuarioact,cc.fechaalt,cc.fechaact,cc.idempresa "
				+ "   FROM SASCANALESCONTACTOS cc inner join sastiposcontactos tc on (cc.idtipocontacto = tc.idtipocontacto)  "
				+ " WHERE cc.idtipocontacto = "
				+ id.toString()
				// + " (" + " UPPER(tc.TIPOCONTACTO) LIKE '%" +
				// tipo.toUpperCase().trim() +
				// "%' or cc.idtipocontacto = '" + id.toString()
				// + "')  " +
				+ "  AND cc.idempresa = " + idempresa.toString()
				+ " order by 2";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSascanalescontactosLista(String tipo, BigDecimal id,  BigDecimal idempresa) "
							+ ex);
		}
		return vecSalida;
	}

	public List getSasmotivoscontactosLista(BigDecimal idcanal,
			BigDecimal idtipo, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  mc.idmotivocontacto,mc.motivocontacto,mc.idtipocontacto, tc.tipocontacto,mc.idcanalcontacto,cc.canalcontacto,mc.usuarioalt,mc.usuarioact,mc.fechaalt,mc.fechaact,mc.idempresa FROM SASMOTIVOSCONTACTOS mc inner join sascanalescontactos cc on (mc.idcanalcontacto = cc.idcanalcontacto) inner join sastiposcontactos tc on (mc.idtipocontacto = tc.idtipocontacto) WHERE (mc.idcanalcontacto ='"
				+ idcanal.toString()
				+ "' and mc.idtipocontacto = '"
				+ idtipo.toString()
				+ "' )  AND mc.idempresa = "
				+ idempresa.toString() + " order by 2";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasmotivoscontactosLista(BigDecimal idcanal, BigDecimal idtipo, BigDecimal idempresa)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getSasHistorialcontactos(long limit, long offset,
			BigDecimal idempresa, Timestamp fechaDesde, Timestamp fechaHasta)
			throws EJBException {
		String cQuery = "SELECT sc.idcontacto,sc.descripcion,sc.idtipocontacto,tc.tipocontacto,sc.idcanalcontacto,cc.canalcontacto,sc.idmotivocontacto,mc.motivocontacto,sc.usuarioalt,sc.usuarioact,sc.fechaalt,sc.fechaact,sc.idempresa FROM SASCONTACTOS sc inner join sastiposcontactos tc on (sc.idtipocontacto = tc.idtipocontacto) inner join sascanalescontactos cc on (sc.idcanalcontacto = cc.idcanalcontacto) inner join sasmotivoscontactos mc on (sc.idmotivocontacto = mc.idmotivocontacto)  WHERE sc.idempresa = "
				+ idempresa.toString()
				+ " and sc.fechaalt between '"
				+ fechaDesde
				+ "' and '"
				+ fechaHasta
				+ "'  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasHistorialcontactos()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getSasHistorialcontactosOcu(long limit, long offset,
			BigDecimal idempresa, Timestamp fechaDesde, Timestamp fechaHasta,
			String ocurrencia) throws EJBException {
		String cQuery = "SELECT sc.idcontacto,sc.descripcion,sc.idtipocontacto,tc.tipocontacto,sc.idcanalcontacto,cc.canalcontacto,sc.idmotivocontacto,mc.motivocontacto,sc.usuarioalt,sc.usuarioact,sc.fechaalt,sc.fechaact,sc.idempresa FROM SASCONTACTOS sc inner join sastiposcontactos tc on (sc.idtipocontacto = tc.idtipocontacto) inner join sascanalescontactos cc on (sc.idcanalcontacto = cc.idcanalcontacto) inner join sasmotivoscontactos mc on (sc.idmotivocontacto = mc.idmotivocontacto)  WHERE sc.idempresa = "
				+ idempresa.toString()
				+ " and sc.fechaalt between '"
				+ fechaDesde
				+ "' and '"
				+ fechaHasta
				+ "' and  upper(sc.descripcion) like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getSasHistorialcontactos()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vclientesRemitosFacturar Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Mon Jul 04 14:04:27 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVclientesRemitosFacturarAll(long limit, long offset,
			String filtro, String orden, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT totalfacturar,idremitocliente,nrosucursal,nroremitocliente,sucursalfactura,idcliente,razon,"
				+ "            idzona,zona,idexpreso,expreso, idexpresozona, idanexolocalidad, idtarjetacredito, tarjetacredito, letra,"
				+ "            idcondicion, condicion, "
				+ "            fecharemito, "
				+ "            idempresa,fechaalt,fechaact,usuarioalt,usuarioact "
				+ "  FROM vclientesremitosfacturar " + " WHERE idempresa = "
				+ idempresa.toString() + filtro + " ORDER BY " + orden
				+ "  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesRemitosFacturarAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getVclientesRemitosFacturarPK(BigDecimal totalfacturar,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT totalfacturar,idremitocliente,nrosucursal,nroremitocliente,sucursalfactura,idcliente,razon,"
				+ "            idzona,zona,idexpreso,expreso, idexpresozona, idanexolocalidad, tarjetacredito,"
				+ "            idempresa,fechaalt,fechaact,usuarioalt,usuarioact "
				+ "  FROM vclientesremitosfacturar " + " WHERE totalfacturar="
				+ totalfacturar.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVclientesRemitosFacturarPK( BigDecimal totalfacturar )  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * EJV - 20110706 INICIA GENERACION DE MOVIMIENTOS DE CLIENTES A PARTIR DE
	 * REMITOS. -- >
	 * */
	// 20110909 - EJV - Mantis 777 REPLICADO EN GENERAL
	public String getPorPerIIBB(String cuit) throws EJBException {

		String cQuery = "SELECT por_per FROM padroniibb WHERE cuit = '" + cuit
				+ "'";

		String por_per = "0";
		Iterator it;
		try {

			it = getLista(cQuery).iterator();
			if (it.hasNext()) {
				por_per = ((String[]) it.next())[0];
			}

		} catch (Exception ex) {
			por_per = "-1";
			log
					.error("Salida por exception: en el metodo: getPorPerIIBB( BigDecimal idtipoiva )  "
							+ ex);
		}
		return por_per;
	}

	// <--

	private static int getMaxCuotaRemitos(BigDecimal idcliente,
			BigDecimal idcondicion, BigDecimal idtarjeta, BigDecimal idempresa,
			Connection conn) throws EJBException {
		ResultSet rsSalida = null;
		boolean isExisteImputable = false;
		int maxCuota = -99;
		String cQuery = ""
				+ "SELECT MAX(cuotas) AS cuota "
				+ "  FROM pedidos_cabe "
				+ "WHERE idpedido_cabe IN ( "
				+ "                                     SELECT idpedido_cabe "
				+ "                                        FROM tmp_remitos_facturar "
				+ "                                      WHERE idcliente = "
				+ idcliente + " AND idcondicion = " + idcondicion
				+ " AND idtarjeta = " + idtarjeta + "  " + ""
				+ "                                        ) AND idempresa="
				+ idempresa.toString();

		try {
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null) {
				if (rsSalida.next()) {
					maxCuota = rsSalida.getInt("cuota");
				} else
					maxCuota = -100;
			} else
				maxCuota = -200;

		} catch (SQLException sqlException) {
			maxCuota = -300;
			log.error("Error SQL en el metodo : getMaxCuotaRemitos( ...  ) "
					+ sqlException);
		} catch (Exception ex) {
			maxCuota = -400;
			log
					.error("Salida por exception: en el metodo: getMaxCuotaRemitos( ... )  "
							+ ex);
		}

		return maxCuota;

	}

	/**
	 * Metodos para la entidad: clientesMovcuota Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Thu Jul 14 11:47:45 ART 2011
	 */

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt
	public static String clientesMovcuotaCreate(BigDecimal numero_cuo,
			BigDecimal ninter_cuo, BigDecimal import_cuo, Date venci_cuo,
			BigDecimal saldo_cuo, BigDecimal idcondicion_cuo,
			BigDecimal idtarjeta_cuo, int periodo_cuo, Date fecha_envio_cuo,
			Date fecha_ctrl_cuo, BigDecimal idclub, BigDecimal idempresa,
			String usuarioalt, Connection conn) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		// 2. sin nada desde la pagina

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO CLIENTESMOVCUOTA"
						+ "                   (numero_cuo, ninter_cuo, import_cuo, venci_cuo, saldo_cuo, idcondicion_cuo, idtarjeta_cuo, periodo_cuo, fecha_envio_cuo, fecha_ctrl_cuo, idclub, idempresa, usuarioalt ) "
						+ "      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, numero_cuo);
				insert.setBigDecimal(2, ninter_cuo);
				insert.setBigDecimal(3, import_cuo);
				insert.setDate(4, venci_cuo);
				insert.setBigDecimal(5, saldo_cuo);
				insert.setBigDecimal(6, idcondicion_cuo);
				insert.setBigDecimal(7, idtarjeta_cuo);
				insert.setInt(8, periodo_cuo);
				insert.setDate(9, fecha_envio_cuo);
				insert.setDate(10, fecha_ctrl_cuo);
				insert.setBigDecimal(11, idclub);
				insert.setBigDecimal(12, idempresa);
				insert.setString(13, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "Error al generar cuota " + numero_cuo;
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Error al generar cuota " + numero_cuo;
			log.error("Error SQL public String clientesMovcuotaCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Error al generar cuota " + numero_cuo;
			log
					.error("Error excepcion public String clientesMovcuotaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesMovCuotaSetEnviado(BigDecimal idtarjeta_cuo,
			BigDecimal periodo_cuo, Date fecha_envio_cuo, String estado_cuo,
			BigDecimal idclub_cuo,
			// 20121031 - EJV - Mantis 889 -->
			BigDecimal idgeneracion,
			// <--
			BigDecimal idempresa, String usuarioact, Connection conn)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (estado_cuo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado_cuo ";

		if (fecha_envio_cuo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha envio cuota ";

		// 2. sin nada desde la pagina
		if (estado_cuo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado_cuo ";
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE clientesmovcuota "
						+ "      SET fecha_envio_cuo=?, estado_cuo=? , idgeneracion = ? , idmotivorechazo = null, usuarioact=?, fechaact=?  "
						+ " WHERE idempresa=?  "
						// TODO: MEJORAR ESTE FILTRO, REMODELAR LA ENTIDAD
						// clientesmovcuota AGREGAR ATRIBUTO idtarjetacredito
						// -->
						// 20120823 - EJV - Mantis 878 -- >
						// TODO: Se agrega filtro para estados que no se deben
						// contemplar en el envio, es necesario modificar esta
						// consulta, la misma se deja para un futuro RELEASE
						// +
						// "     AND idtarjeta_cuo IN ( SELECT idtarjeta FROM clientetarjetascredito WHERE idtarjetacredito = ? AND idempresa = ? )  "
						+ "     AND idtarjeta_cuo IN (  "
						+ "     	                                SELECT tj.idtarjeta  "
						+ "     	                                  FROM clientetarjetascredito tj "
						+ "     	                                    LEFT JOIN (  "
						+ "     			                                  SELECT idestadocliente, idcliente, idempresa  "
						+ "     			                                    FROM clientesestadoshoy "
						+ "     			                                   WHERE (  "
						+ "     				                                   (idestado = 2 AND idmotivo = 60) OR "
						+ "     				                                   (idestado = 4 AND idmotivo = 64) OR "
						+ "     				                                   (idestado = 4 AND idmotivo = 66) OR "
						+ "     				                                   (idestado = 6 AND idmotivo = 41) "
						+ "     				                                 )  "
						+ "     			                                 ) eout ON tj.idcliente = eout.idcliente AND tj.idempresa = eout.idempresa "
						+ "     	                                 WHERE tj.idtarjetacredito = ?  "
						+ "     	                                   AND tj.idempresa = ? "
						+ "     	                                   AND eout.idcliente IS NULL "
						+ "                                   ) "
						// <--
						+ "     AND idclub=? "
						// 20120810 - EJV - Mantis 871 -->
						+ "     AND periodo_cuo <=  ?   AND  estado_cuo IN ('P', 'R')   ";
				// +
				// "     AND  ( (  periodo_cuo=? AND estado_cuo='P' )   OR  (  periodo_cuo < ? AND estado_cuo='R' )  );";
				// <--
				insert = conn.prepareStatement(sql);

				insert.setDate(1, fecha_envio_cuo);
				insert.setString(2, estado_cuo);
				// 20121031 - EJV - Mantis 889 -->
				insert.setBigDecimal(3, idgeneracion);
				// <--
				insert.setString(4, usuarioact);
				insert.setTimestamp(5, fechaact);
				insert.setBigDecimal(6, idempresa);
				insert.setBigDecimal(7, idtarjeta_cuo);
				insert.setBigDecimal(8, idempresa);
				insert.setBigDecimal(9, idclub_cuo);
				insert.setBigDecimal(10, periodo_cuo);
				// insert.setBigDecimal(10, periodo_cuo);

				int i = insert.executeUpdate();
				if (i == 0)
					salida = "No fue posible asignar fecha de envio de presentacion para ningun registro";

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar fecha de envio de presentacion.";
			log
					.error("Error SQL public String clientesMovCuotaSetEnviado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar fecha de envio de presentacion.";
			log
					.error("Error excepcion public String clientesMovCuotaSetEnviado(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesMovCuotaSetAceptado(BigDecimal idmovcuo,
			String estado_cuo, BigDecimal saldo_cuo, BigDecimal idempresa,
			String usuarioact, Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (estado_cuo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado_cuo ";

		// 2. sin nada desde la pagina
		if (estado_cuo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado_cuo ";
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE clientesmovcuota "
						+ "      SET  estado_cuo=? , saldo_cuo=(saldo_cuo+(?)), fecha_ctrl_cuo=?, usuarioact=?, fechaact=?  "
						+ " WHERE idempresa=?  "
						+ "   AND idmovcuo =?  AND estado_cuo='E' ;";
				insert = conn.prepareStatement(sql);

				insert.setString(1, estado_cuo);
				insert.setBigDecimal(2, saldo_cuo);
				insert.setDate(3, new java.sql.Date(fechaact.getTime()));
				insert.setString(4, usuarioact);
				insert.setTimestamp(5, fechaact);
				insert.setBigDecimal(6, idempresa);
				insert.setBigDecimal(7, idmovcuo);

				int i = insert.executeUpdate();
				if (i == 0)
					salida = "No fue posible aceptar cuota:  " + idmovcuo;

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar estado aceptadp.";
			log
					.error("Error SQL public String clientesMovCuotaSetAceptado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar estado aceptado .";
			log
					.error("Error excepcion public String clientesMovCuotaSetAceptado(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesMovCuotaSetRechazo(BigDecimal idmovcuo,
			String estado_cuo, BigDecimal idmotivorechazo,
			BigDecimal idempresa, String usuarioact, Connection conn)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (estado_cuo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: estado_cuo ";

		// 2. sin nada desde la pagina
		if (estado_cuo.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: estado_cuo ";
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE clientesmovcuota "
						+ "      SET  estado_cuo=? , idmotivorechazo=?, usuarioact=?, fechaact=?  "
						+ " WHERE idempresa=?  "
						+ "     AND idmovcuo =?  AND estado_cuo='E' ;";
				insert = conn.prepareStatement(sql);

				insert.setString(1, estado_cuo);
				insert.setBigDecimal(2, idmotivorechazo);
				insert.setString(3, usuarioact);
				insert.setTimestamp(4, fechaact);
				insert.setBigDecimal(5, idempresa);
				insert.setBigDecimal(6, idmovcuo);

				int i = insert.executeUpdate();
				if (i == 0)
					salida = "No fue generar rechazo para cuota:  " + idmovcuo;

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar estado rechazado.";
			log
					.error("Error SQL public String clientesMovCuotaSetRechazo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar estado rechazado.";
			log
					.error("Error excepcion public String clientesMovCuotaSetRechazo(.....)"
							+ ex);
		}
		return salida;
	}

	// 20121114 - EJV - Mantis 889-->

	public String clientesMovCuotaCanelaPendientesXNCTotal(
			BigDecimal ninter_cuo, BigDecimal idempresa, String usuarioact,
			Connection conn) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (ninter_cuo == null)
			salida = "Error: Al cancelar cuotas pendientes no se puede dejar sin datos (nulo) el campo: ninter_cuo ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = ""
						+ "UPDATE clientesmovcuota "
						+ "      SET  estado_cuo='C' , saldo_cuo=0, fecha_ctrl_cuo=?, usuarioact=?, fechaact=?  "
						+ " WHERE idempresa=?  AND ninter_cuo=?  "
						+ "      AND estado_cuo IN ('P', 'R');  ";

				insert = conn.prepareStatement(sql);

				insert.setDate(1, new java.sql.Date(fechaact.getTime()));
				insert.setString(2, usuarioact);
				insert.setTimestamp(3, fechaact);
				insert.setBigDecimal(4, idempresa);
				insert.setBigDecimal(5, ninter_cuo);

				int i = insert.executeUpdate();
				if (i == 0)
					salida = "No fue posible cancelar cuotas para movimiento interno:  "
							+ ninter_cuo;

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar estado canelado.";
			log
					.error("Error SQL public String clientesMovCuotaCanelaPendientesXNCTotal(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar estado canelado .";
			log
					.error("Error excepcion public String clientesMovCuotaCanelaPendientesXNCTotal(.....)"
							+ ex);
		}

		return salida;
	}

	// <--

	// 20121115 - EJV - Mantis 889-->

	public String setClientesMovCuotaCaneladasAPendientes(
			BigDecimal ninter_cuo, BigDecimal importeAplicacion,
			BigDecimal idempresa, String usuarioact, Connection conn)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (ninter_cuo == null)
			salida = "Error: Al modificar estado a pendiente para cuotas canceladas, no se puede dejar sin datos (nulo) el campo: ninter_cuo ";

		// fin validaciones

		try {

			String filtro = " WHERE ninter_cuo = " + ninter_cuo
					+ " AND estado_cuo = 'E' ";
			long cantCuotasTransito = getTotalEntidadFiltro("clientesmovcuota",
					filtro, idempresa);

			if (cantCuotasTransito > 0)
				salida = "No es posible cambiar estado de cuotas, existen cuotas en transito, pendientes de Aceptar/Rechazar (estado Enviado), para movimiento interno: "
						+ ninter_cuo;

			PreparedStatement insert = null;
			String sql = "";

			if (salida.equalsIgnoreCase("OK")) {

				sql = "SELECT TRUNC(importe) importeInt, TRUNC("
						+ importeAplicacion
						+ ") aplicadoInt, importe FROM clientesmovcli WHERE nrointerno = "
						+ ninter_cuo + " AND idempresa = " + idempresa;

				Iterator iterImporte = getLista(sql, conn).iterator();

				if (iterImporte.hasNext()) {

					String[] datos = (String[]) iterImporte.next();

					long auxImporteComprob = Long.parseLong(datos[0]);
					long auxImporteAplicado = Long.parseLong(datos[1]);
					BigDecimal importeComprob = new BigDecimal(datos[2]);

					if (auxImporteComprob == auxImporteAplicado) {

						sql = ""
								+ "UPDATE clientesmovcuota "
								+ "      SET  estado_cuo='P' , saldo_cuo=import_cuo, fecha_ctrl_cuo=?, usuarioact=?, fechaact=?  "
								+ " WHERE idempresa=?  AND ninter_cuo=?  ";

						insert = conn.prepareStatement(sql);

						insert
								.setDate(1, new java.sql.Date(fechaact
										.getTime()));
						insert.setString(2, usuarioact);
						insert.setTimestamp(3, fechaact);
						insert.setBigDecimal(4, idempresa);
						insert.setBigDecimal(5, ninter_cuo);

					} else {

						filtro = " WHERE ninter_cuo = " + ninter_cuo;
						long totalCuotas = getTotalEntidadFiltro(
								"clientesmovcuota", filtro, idempresa);

						BigDecimal nuevoSaldoCuota = importeAplicacion.divide(
								new BigDecimal(totalCuotas), 4,
								BigDecimal.ROUND_HALF_UP);

						sql = ""
								+ "UPDATE clientesmovcuota "
								+ "      SET  estado_cuo='P' , saldo_cuo=(saldo_cuo+?), fecha_ctrl_cuo=?, usuarioact=?, fechaact=?  "
								+ " WHERE idempresa=?  AND ninter_cuo=?  ";

						insert = conn.prepareStatement(sql);

						insert.setBigDecimal(1, nuevoSaldoCuota);
						insert
								.setDate(2, new java.sql.Date(fechaact
										.getTime()));
						insert.setString(3, usuarioact);
						insert.setTimestamp(4, fechaact);
						insert.setBigDecimal(5, idempresa);
						insert.setBigDecimal(6, ninter_cuo);

					}

					int i = insert.executeUpdate();
					if (i == 0)
						salida = "No fue posible pasar estado a pendiente de cuotas canceladas para movimiento interno :  "
								+ ninter_cuo
								+ ", posiblemente modificadas desde otra sesion o inexistentes.  ";

				} else {

					salida = "No fue posible recuperar importe de comprobante .....";
				}

			}

		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar estado de canelado a pendiente.";
			log
					.error("Error SQL public String setClientesMovCuotaCaneladasAPendientes(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar estado de canelado a pendiente.";
			log
					.error("Error excepcion public String setClientesMovCuotaCaneladasAPendientes(.....)"
							+ ex);
		}

		return salida;
	}

	// <--

	// 20121116 - EJV - Mantis 889-->

	public String clientesMovCuotaCanelaPendientesParcial(
			BigDecimal ninter_cuo, BigDecimal importeAplica,
			BigDecimal idempresa, String usuarioact, Connection conn)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (ninter_cuo == null)
			salida = "Error: Al cancelar cuotas pendientes no se puede dejar sin datos (nulo) el campo: ninter_cuo ";

		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "SELECT idmovcuo,  saldo_cuo, estado_cuo, numero_cuo FROM clientesmovcuota WHERE estado_cuo IN ('P', 'R', 'E' ) AND ninter_cuo =  "
						+ ninter_cuo + " AND idempresa = " + idempresa;

				Iterator iterCuotas = getLista(sql, conn).iterator();

				if (iterCuotas.hasNext()) {

					BigDecimal nuevo_saldo = new BigDecimal(0);
					String nuevo_estado = "C";
					BigDecimal auxDescuentaAplica = new BigDecimal(
							importeAplica.toString());
					BigDecimal auxSaldoTotalCuotas = new BigDecimal(
							importeAplica.toString());

					while (iterCuotas.hasNext()) {

						String[] datosCuota = (String[]) iterCuotas.next();

						BigDecimal idmovcuo = new BigDecimal(datosCuota[0]);
						BigDecimal saldo_cuo = new BigDecimal(datosCuota[1]);
						String estado_cuo = datosCuota[2];
						int numero_cuo = Integer.parseInt(datosCuota[3]);

						auxSaldoTotalCuotas = auxSaldoTotalCuotas
								.add(saldo_cuo);

						if (estado_cuo.equalsIgnoreCase("E")) {
							salida = "No es posible cancelar existen cuotas en espera de respuesta de marca (Aceptar/Rechazar), para nro. interno  "
									+ ninter_cuo + ", cuota nro  " + numero_cuo;
							break;
						}

						if ((saldo_cuo.doubleValue() <= auxDescuentaAplica
								.doubleValue() || (auxDescuentaAplica.abs()
								.subtract(saldo_cuo.abs())).abs().doubleValue() < 0.01)) {

							nuevo_saldo = new BigDecimal(0);
							nuevo_estado = "C";

						} else {

							if (auxDescuentaAplica.doubleValue() > 0)
								nuevo_saldo = saldo_cuo
										.subtract(auxDescuentaAplica);
							else
								nuevo_saldo = saldo_cuo;

							nuevo_estado = "P";
						}

						auxDescuentaAplica = auxDescuentaAplica
								.subtract(saldo_cuo);

						sql = ""
								+ "UPDATE clientesmovcuota "
								+ "      SET  estado_cuo=? , saldo_cuo=?, fecha_ctrl_cuo=?, usuarioact=?, fechaact=?  "
								+ " WHERE idempresa=?  AND idmovcuo=?  "
								+ "      AND estado_cuo IN ('P', 'R');  ";

						insert = conn.prepareStatement(sql);

						insert.setString(1, nuevo_estado);
						insert.setBigDecimal(2, nuevo_saldo);
						insert
								.setDate(3, new java.sql.Date(fechaact
										.getTime()));
						insert.setString(4, usuarioact);
						insert.setTimestamp(5, fechaact);
						insert.setBigDecimal(6, idempresa);
						insert.setBigDecimal(7, idmovcuo);

						int i = insert.executeUpdate();
						if (i == 0)
							salida = "No fue posible cancelar cuotas para movimiento interno:  "
									+ ninter_cuo + ", cuota nro  " + numero_cuo;
					}

					if (salida.equalsIgnoreCase("OK")) {
						if (auxDescuentaAplica.doubleValue() > 0.01D) {
							salida = "El total aplicado ("
									+ importeAplica
									+ ") no coicide con el saldo total de cuotas pendientes ("
									+ auxSaldoTotalCuotas + ")";
						}
					}

				} else {

					salida = "No fue posible consultar cuotas pendientes para movimiento interno: "
							+ ninter_cuo;

				}

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE) No fue posible asignar estado canelado.";
			log
					.error("Error SQL public String clientesMovCuotaCanelaPendientesParcial(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar estado canelado .";
			log
					.error("Error excepcion public String clientesMovCuotaCanelaPendientesParcial(.....)"
							+ ex);
		}

		return salida;
	}

	// <--

	public String clientesRemitosUpdateComprob(BigDecimal idremitocliente,
			BigDecimal nrointerno_mc, BigDecimal idciclofact,
			BigDecimal idempresa, String usuarioact, Connection conn)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idremitocliente == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idremitocliente ";

		if (nrointerno_mc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: nrointerno_mc ";

		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones

		try {

			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {

				sql = "UPDATE clientesremitos SET nrointerno_mc=?, idciclofact=?, usuarioact=?, fechaact=?"
						+ " WHERE idremitocliente=? AND idempresa=? AND nrointerno_mc IS NULL;";
				insert = conn.prepareStatement(sql);

				insert.setBigDecimal(1, nrointerno_mc);
				insert.setBigDecimal(2, idciclofact);
				insert.setString(3, usuarioact);
				insert.setTimestamp(4, fechaact);
				insert.setBigDecimal(5, idremitocliente);
				insert.setBigDecimal(6, idempresa);

				int i = insert.executeUpdate();
				if (i != 1)
					salida = "No se pudo actualizar nro. interno comprobante id-remito:  "
							+ idremitocliente;

			}

		} catch (SQLException sqlException) {
			salida = "SQLE: No se pudo actualizar numero interno de comprobante id-remito:  "
					+ idremitocliente;
			log
					.error("Error SQL public String clientesRemitosUpdateGrupoArmado(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "EX: No se pudo actualizar numero interno de comprobante id-remito:  "
					+ idremitocliente;
			log
					.error("Error excepcion public String clientesRemitosUpdateGrupoArmado(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: clientesmovcliremitoslog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Jul 15 14:16:42 ART 2011
	 */

	public String clientesmovcliremitoslogCreate(BigDecimal idciclofact,
			String descripcion, String remitossel, BigDecimal idcliente,
			BigDecimal idcondicion, BigDecimal idtarjeta, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = ""
						+ "INSERT INTO clientesmovcliremitoslog(idciclofact, descripcion, remitossel, idcliente, idcondicion, idtarjeta, idempresa, usuarioalt ) "
						+ "VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idciclofact);
				insert.setString(2, descripcion);
				insert.setString(3, remitossel);
				insert.setBigDecimal(4, idcliente);
				insert.setBigDecimal(5, idcondicion);
				insert.setBigDecimal(6, idtarjeta);
				insert.setBigDecimal(7, idempresa);
				insert.setString(8, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "(E0)Imposible generar log de facturacion.";

			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible generar log de facturacion.";
			log
					.error("Error SQL public String clientesmovcliremitoslogCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible generar log de facturacion.";
			log
					.error("Error excepcion public String clientesmovcliremitoslogCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesMovCliDesdeRemitosCreate(String[] vecIdremitocliente,
			BigDecimal idclub, BigDecimal sucursal,
			java.sql.Timestamp fechamov, BigDecimal tipomov, String tipomovs,
			String condicionletra, String letracontador, BigDecimal cambio,
			BigDecimal moneda, int ejercicioactivo, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {

		String salida = "OK";
		BigDecimal nrointernomovcliente = null;
		Enumeration en;
		Connection conn = null;
		/**/
		BigDecimal idcliente = null;
		BigDecimal comprob = null;
		BigDecimal comprob_has = null;
		BigDecimal saldo = null;
		BigDecimal importe = null;
		String unamode = null;
		String tipocomp = "1";
		BigDecimal idcondicion = null;
		BigDecimal com_venta = null;
		BigDecimal com_cobra = null;
		BigDecimal com_vende = null;
		String anulada = null;
		BigDecimal retoque = null;
		BigDecimal expreso = null;
		BigDecimal sucucli = null;
		BigDecimal remito = null;
		BigDecimal credito = null;
		String observaciones = null;
		BigDecimal por_per = new BigDecimal(0);
		Hashtable htCuentasContCli = new Hashtable();
		String remitosSeleccion = "";
		boolean confirmaTransaccion = true;
		String keyenum = "";
		BigDecimal idciclofact = new BigDecimal(Calendar.getInstance()
				.getTimeInMillis());

		int totalSeleccion = -1;
		int totalProcesados = 0;
		int auxTotalProcesados = 0;

		/**/

		try {

			conn = GeneralBean.getTransaccionConn(this.clase, this.url,
					this.usuario, this.clave);
			// <--

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			if (vecIdremitocliente == null || vecIdremitocliente.length == 0)
				salida = "No existen remitos a procesar.";

			if (salida.equalsIgnoreCase("OK")) {// AA

				totalSeleccion = vecIdremitocliente.length;
				idciclofact = GeneralBean.getNextValorSequencia(
						"seq_clientesciclofacturacion", conn);

				GeneralBean.setLockedTable("cajasucursalescontadores",
						"ACCESS EXCLUSIVE", conn);

				String cQuery = ""
						+ " CREATE TEMPORARY TABLE tmp_remitos_facturar  "
						// + " CREATE TABLE tmp_remitos_facturar  "
						+ "    ( idcliente numeric(18,0),  idcondicion numeric(18,0),  idtarjeta numeric(18,0),  idremitocliente numeric(18,0),  total numeric(18,4),  totalgravado numeric(18,4), "
						+ "       iva numeric(18,4),  valorflete numeric(18,4),  "
						//
						+ "       valorivaflete numeric(18, 4),  porcivaflete numeric(18, 2),  "
						//
						+ "       idpedido_cabe numeric(18,0),  totalivapedido numeric(18,4),  preciounidesc numeric(18, 4),  precio numeric(18, 4),  "
						+ "       cantidad numeric(18,3),  iva_unidad numeric,  porciva_st numeric(18,3),  porcdesc_apli numeric(18 ,3),"
						+ "       idtipocomp numeric(18,0),  idctaneto numeric(18,0),  ctaiva_tc numeric(18,0),  ctivani_tc numeric(18,0),  ctgrava_tc numeric(18,0),  ctexent_tc  numeric(18,0),  "
						+ "       ctare1_tc numeric(18,0),  ctare2_tc  numeric(18,0),  "
						+ "       idtipodocumento numeric(18,0),  tipodocumento varchar(50), nrodocumento  numeric(18,0)  "
						+ "     ) ; ";

				Statement statement = conn.createStatement();
				Statement stsavepoint = conn.createStatement();
				statement.execute(cQuery);
				statement.clearBatch();

				for (int j = 0; j < totalSeleccion; j++) {

					remitosSeleccion += "[" + vecIdremitocliente[j] + "], ";

					cQuery = ""
							+ "INSERT INTO tmp_remitos_facturar  "
							+ "SELECT cr.idcliente,pc.idcondicion, pc.idtarjeta, cr.idremitocliente, "
							+ "            (((pd.precio - ((pd.precio*pd.porcdesc_apli)/100) + (pd.totaliva_st/pd.cantidad))* pd.cantidad ))::NUMERIC(18, 4) AS total,"
							+ "            ((pd.precio - ((pd.precio*pd.porcdesc_apli)/100))* pd.cantidad)::NUMERIC(18, 4) AS totalgravado,"
							+ "            pd.totaliva_st AS iva,"
							+ "            cr.valorflete,"

							+ "            cr.valorivaflete,"
							+ "            cr.porcivaflete,"

							+ "            pd.idpedido_cabe,pc.totaliva AS totalivapedido,"
							+ "            (pd.precio - ((pd.precio*pd.porcdesc_apli)/100))::NUMERIC(18, 4) AS preciounidesc,"
							+ "            pd.precio, pd.cantidad,"
							+ "            pd.totaliva_st/pd.cantidad AS iva_unidad, pd.porciva_st, pd.porcdesc_apli,"
							+ "            ctc.idtipocomp, COALESCE(cl.idctaneto, 0) AS idctaneto, COALESCE(ctc.ctaiva_tc, 0) AS ctaiva_tc, "
							+ "            COALESCE(ctc.ctivani_tc, 0) AS ctivani_tc , COALESCE(ctc.ctgrava_tc, 0) AS ctgrava_tc, COALESCE(ctc.ctexent_tc, 0) AS ctexent_tc,  "
							+ "            COALESCE(ctc.ctare1_tc, 0) AS ctare1_tc, COALESCE(ctc.ctare2_tc, 0) AS ctare2_tc, "
							+ "            td.idtipodocumento, td.tipodocumento, cl.nrodocumento "
							+ "  FROM clientesremitos cr "
							+ "            INNER JOIN clientesclientes cl ON cr.idcliente = cl.idcliente AND cr.idempresa = cl.idempresa "
							+ "            INNER JOIN clientestipocomp ctc ON cl.idtipocomp = ctc.idtipocomp AND cl.idempresa = ctc.idempresa "
							+ "            INNER JOIN globaltiposdocumentos td ON cl.idtipodocumento = td.idtipodocumento AND cl.idempresa = td.idempresa "
							+ "            INNER JOIN pedidos_deta pd ON cr.idremitocliente = pd.idremitocliente AND cr.idempresa = pd.idempresa "
							+ "            INNER JOIN pedidos_cabe pc ON pd.idpedido_cabe = pc.idpedido_cabe AND pd.idempresa = pc.idempresa  "
							+ "                      AND pd.idremitocliente = "
							+ vecIdremitocliente[j]
							+ " WHERE pd.idempresa = "
							+ idempresa
							+ "  ORDER BY idcliente, pc.idcondicion, pc.idtarjeta, pd.idremitocliente, pc.idpedido_cabe  ; ";

					statement.addBatch(cQuery);

				}

				statement.executeBatch();

				if (salida.equalsIgnoreCase("OK")) {// BB

					// Todas las FC a generar para un cliente
					cQuery = ""
							+ "SELECT DISTINCT idcliente, idcondicion, idtarjeta, idctaneto, ctaiva_tc, ctivani_tc, ctgrava_tc, ctexent_tc, ctare1_tc, ctare2_tc, "
							+ "             tipodocumento, nrodocumento, idtipocomp "
							+ "  FROM tmp_remitos_facturar "
							+ " ORDER BY idcliente, idcondicion, idtarjeta ";

					Iterator iterComprobantes = getLista(cQuery, conn)
							.iterator();

					if (iterComprobantes.hasNext()) {// X1

						while (iterComprobantes.hasNext()) { // X2

							String[] data = (String[]) iterComprobantes.next();

							idcliente = new BigDecimal(data[0]);
							idcondicion = new BigDecimal(data[1]);
							BigDecimal idtarjeta = new BigDecimal(data[2]);
							BigDecimal cuentatotal = new BigDecimal(data[3]);
							BigDecimal cuentaivaresponsablei = new BigDecimal(
									data[4]);
							BigDecimal cuentanoinscripto = new BigDecimal(
									data[5]);
							BigDecimal cuentagravado = new BigDecimal(data[6]);
							BigDecimal cuentaexento = new BigDecimal(data[7]);
							BigDecimal cuentaflete = new BigDecimal(data[8]);
							BigDecimal cuentaiibb = new BigDecimal(data[9]);
							String tipodocumento = data[10] == null ? ""
									: data[10].trim();
							String nrodocumento = data[11];
							tipocomp = data[12];

							BigDecimal totalCalculado = new BigDecimal(0);
							BigDecimal total = new BigDecimal(0);
							BigDecimal totalgravado = new BigDecimal(0);

							BigDecimal totalIvaCalculado = new BigDecimal(0);

							BigDecimal iva = new BigDecimal(0);
							BigDecimal ivaFlete = new BigDecimal(0);
							BigDecimal totalflete = new BigDecimal(0);
							BigDecimal percepcioniibb = new BigDecimal(0);
							int cuotas = 0;

							cQuery = ""
									+ "SELECT DISTINCT idremitocliente       "
									+ "  FROM tmp_remitos_facturar  "
									+ "WHERE idcliente = "
									+ idcliente
									+ "    AND idcondicion = "
									+ idcondicion
									+ "    AND idtarjeta =  "
									+ idtarjeta
									+ "    AND idremitocliente IN ( "
									+ "	   	             SELECT idremitocliente  "
									+ "		               FROM tmp_remitos_facturar  "
									+ "		            WHERE idcliente = "
									+ idcliente
									+ "                       AND (idcondicion <> "
									+ idcondicion
									+ "                                OR idtarjeta <> "
									+ idtarjeta + ") " + "		) ";

							Iterator iterValidaRemito = getLista(cQuery, conn)
									.iterator();

							if (!iterValidaRemito.hasNext()) {// X3

								// Totales por cada una de las FC a generar
								cQuery = ""
										+ "SELECT  SUM(total) AS total, SUM(totalgravado) AS totalgravado,  SUM(iva) AS iva, "
										+ "             idcliente, idcondicion, idtarjeta "
										+ "  FROM tmp_remitos_facturar "
										+ " WHERE idcliente = "
										+ idcliente
										+ " AND idcondicion ="
										+ idcondicion
										+ " AND idtarjeta =  "
										+ idtarjeta
										+ " GROUP BY idcliente, idcondicion, idtarjeta ";

								Iterator iterTotales = getLista(cQuery, conn)
										.iterator();

								if (iterTotales.hasNext()) {// X4

									data = (String[]) iterTotales.next();
									total = new BigDecimal(data[0]);
									totalCalculado = new BigDecimal(total
											.toString());
									totalgravado = new BigDecimal(data[1]);
									iva = new BigDecimal(data[2]);

									// Verificar si documento cliente es
									// CUIT-CUIL
									if (tipodocumento.toUpperCase()
											.equalsIgnoreCase("CUIT")
											|| tipodocumento.toUpperCase()
													.equalsIgnoreCase("CUIL")) {
										GeneralBean g = new GeneralBean();
										if (!g
												.validarClaveIdentificacionUnica(nrodocumento)) {

											salida = tipodocumento
													+ " invalido.";

										} else {

											por_per = new BigDecimal(
													getPorPerIIBB(nrodocumento));

											if (por_per.floatValue() < 0) {
												salida = "E[10902]No fue posible capturar porcentaje de percepcion IIBB.";
											} else {

												BigDecimal factorIIBBBA = new BigDecimal(
														por_per.floatValue() / 100)
														.setScale(
																6,
																BigDecimal.ROUND_HALF_UP);
												percepcioniibb = totalgravado
														.multiply(factorIIBBBA)
														.setScale(
																6,
																BigDecimal.ROUND_HALF_UP);
												percepcioniibb = percepcioniibb
														.setScale(
																4,
																BigDecimal.ROUND_HALF_UP);

												totalCalculado = totalCalculado
														.add(percepcioniibb);

											}
										}
									}

									if (salida.equalsIgnoreCase("OK")) {// Z1
										// Totales de FLETE por cada una de las
										// FC
										cQuery = ""
												+ "SELECT (SUM(valorflete))::NUMERIC(18, 4) AS totalflete, "
												+ "            (SUM(valorivaflete))::NUMERIC(18, 4) AS totalivaflete "
												+ "  FROM ( "
												+ "	SELECT DISTINCT idcliente, idcondicion, idtarjeta, idremitocliente, valorflete, valorivaflete, porcivaflete  "
												+ "	  FROM tmp_remitos_facturar "
												+ "  WHERE idcliente = "
												+ idcliente
												+ " AND idcondicion ="
												+ idcondicion
												+ " AND idtarjeta =  "
												+ idtarjeta + "       ) tf ";

										Iterator iterTotalFlete = getLista(
												cQuery, conn).iterator();
										// SAVEPOINT
										stsavepoint
												.execute(" SAVEPOINT sp_comprobante; ");

										if (iterTotalFlete.hasNext()) {// X4

											data = (String[]) iterTotalFlete
													.next();
											totalflete = new BigDecimal(data[0]);
											ivaFlete = new BigDecimal(data[1]);
											totalCalculado = totalCalculado
													.add(totalflete);
											//
											totalCalculado = totalCalculado
													.add(ivaFlete);
											totalIvaCalculado = iva
													.add(ivaFlete);
											//

											importe = totalCalculado;
											saldo = importe;

											htCuentasContCli
													.put(
															"T",
															new String[] {
																	cuentatotal
																			.toString(),
																	totalCalculado
																			.toString() });
											htCuentasContCli
													.put(
															"G",
															new String[] {
																	cuentagravado
																			.toString(),
																	totalgravado
																			.toString() });
											htCuentasContCli
													.put(
															"I",
															new String[] {
																	cuentaivaresponsablei
																			.toString(),
																	totalIvaCalculado
																			.toString() });

											// TODO: 20110714 - EJV
											// Momentaneamente
											// todo
											// el
											// IVA va a la cuenta de
											// Responsables
											// Inscriptos (I), por eso se
											// comenta la
											// asignacion para la cuenta de NO
											// INSCRIPTOS
											// (N).
											/*
											 * htCuentasContCli.put("N", new
											 * String[] {
											 * cuentanoinscripto.toString(),
											 * iva.toString() });
											 */

											htCuentasContCli
													.put(
															"E",
															new String[] {
																	cuentaexento
																			.toString(),
																	"0" });
											htCuentasContCli
													.put(
															"PIB",
															new String[] {
																	cuentaiibb
																			.toString(),
																	percepcioniibb
																			.toString() });
											htCuentasContCli
													.put(
															"FLE",
															new String[] {
																	cuentaflete
																			.toString(),
																	totalflete
																			.toString() });

											// 20120615 - EJV - Mantis 810 -->
											// Si es comprobante de exportacion,
											// el flete se toma como un item.

											int facturaExportacion = esFacturaExportacion(
													idcliente, idempresa, conn);

											if (facturaExportacion == 1) {

												htCuentasContCli
														.put(
																"G",
																new String[] {
																		cuentagravado
																				.toString(),
																		totalCalculado
																				.toString() });

												htCuentasContCli
														.put(
																"FLE",
																new String[] {
																		cuentaflete
																				.toString(),
																		"0" });

											} else if (facturaExportacion < 0) {

												salida = "E[6020] No fue posible verificar si es comprobante exportacion( "
														+ facturaExportacion
														+ ") - Cliente: "
														+ idcliente;

											}

											if (salida.equalsIgnoreCase("OK")) {// X5
												// <--

												comprob = GeneralBean
														.getCajaSucursalesContadoresProximo(
																sucursal,
																letracontador,
																tipomov,
																idempresa, conn);
												if (comprob.longValue() > -1) {// 0.1

													if (!isExisteComprobanteMovCli(
															sucursal, comprob,
															tipomovs, idempresa)) {// 0.2

														nrointernomovcliente = GeneralBean
																.getContador(
																		new BigDecimal(
																				8),
																		idempresa,
																		conn);
														if (nrointernomovcliente
																.longValue() > -1) {// A

															// Generar cuotas
															// siempre y cuando
															// la
															// condicion sea
															// TARJETA
															// y el importe sea
															// mayor a cero (0)
															if (idtarjeta
																	.longValue() > 0
																	&& totalCalculado
																			.signum() == 1) {
																// 
																cuotas = getMaxCuotaRemitos(
																		idcliente,
																		idcondicion,
																		idtarjeta,
																		idempresa,
																		conn);

																if (cuotas < 0) {
																	salida = "E[10901]Error al recuperar cuotas.";
																} else {
																	// GENERAR
																	// CUOTAS

																	// 20110818
																	// -
																	// EJV - Es
																	// posible
																	// manejar
																	// este
																	// error, se
																	// charlo
																	// con
																	// Ame y se
																	// definio
																	// que
																	// momentaneamente
																	// se asigne
																	// una
																	// cuota por
																	// default
																	// -->
																	if (cuotas == 0)
																		cuotas = 1;
																	// <--
																	BigDecimal import_cuo = totalCalculado
																			.divide(
																					new BigDecimal(
																							cuotas),
																					6,
																					BigDecimal.ROUND_HALF_UP);

																	BigDecimal totalCuotas = import_cuo
																			.multiply(new BigDecimal(
																					cuotas));

																	Calendar cal = new GregorianCalendar();
																	cal
																			.setTime(fechamov);
																	java.sql.Date venci_cuo = new java.sql.Date(
																			cal
																					.getTimeInMillis());
																	int periodo_cuo = 0;
																	for (int c = 1; c <= cuotas; c++) {

																		if (c == cuotas) {
																			import_cuo = import_cuo
																					.add(totalCalculado
																							.subtract(totalCuotas));
																		}

																		periodo_cuo = Integer
																				.parseInt(cal
																						.get(Calendar.YEAR)
																						+ GeneralBean
																								.strZero(
																										""
																												+ (cal
																														.get(Calendar.MONTH) + 1),
																										2));

																		// CUOTAS
																		salida = clientesMovcuotaCreate(
																				new BigDecimal(
																						c),
																				nrointernomovcliente,
																				import_cuo,
																				venci_cuo,
																				import_cuo,
																				idcondicion,
																				idtarjeta,
																				periodo_cuo,
																				null,
																				null,
																				idclub,
																				idempresa,
																				usuarioalt,
																				conn);

																		if (!salida
																				.equalsIgnoreCase("OK"))
																			break;

																		cal
																				.add(
																						Calendar.MONTH,
																						1);
																		venci_cuo = new java.sql.Date(
																				cal
																						.getTimeInMillis());

																	}
																}
															}

															if (idcliente != null
																	&& idcliente
																			.longValue() > 0) {// A.0
																// MOVIMIENTO DE
																// CLIENTE
																salida = clientesMovCliCreate(
																		idcliente,
																		fechamov,
																		sucursal,
																		comprob,
																		comprob_has,
																		tipomov,
																		tipomovs,
																		saldo,
																		importe,
																		cambio,
																		moneda,
																		unamode,
																		tipocomp,
																		idcondicion,
																		nrointernomovcliente,
																		com_venta,
																		com_cobra,
																		com_vende,
																		anulada,
																		retoque,
																		expreso,
																		sucucli,
																		remito,
																		credito,
																		observaciones,
																		condicionletra,
																		// 20121005
																		// - EJV
																		// -
																		// Mantis
																		// 882
																		// -->
																		null,
																		// <--
																		usuarioalt,
																		idempresa,
																		conn);
															}

															if (salida
																	.equalsIgnoreCase("OK")) {// B
																en = htCuentasContCli
																		.keys();

																while (en
																		.hasMoreElements()) {// B.0
																	keyenum = en
																			.nextElement()
																			.toString();
																	String[] datos = (String[]) htCuentasContCli
																			.get(keyenum);

																	if (Double
																			.parseDouble(datos[1]) > 0) {

																		if (!GeneralBean
																				.isExisteCtaImputable(
																						new BigDecimal(
																								datos[0]),
																						ejercicioactivo,
																						idempresa,
																						conn)) {
																			salida = "E[10900]La cuenta : "
																					+ datos[0]
																					+ " no existe o no es imputable. ["
																					+ keyenum
																					+ "]";
																		}

																		if (!salida
																				.equalsIgnoreCase("OK"))
																			break;

																		BigDecimal porcentaje_percepcion = new BigDecimal(
																				0);
																		if (keyenum
																				.equalsIgnoreCase("PIB"))
																			porcentaje_percepcion = por_per;
																		// CONTABILIDAD
																		// DE
																		// MOVIMIENTO
																		salida = clientesContCliCreate(
																				new BigDecimal(
																						datos[0]),
																				new BigDecimal(
																						datos[1]),
																				keyenum,
																				nrointernomovcliente,
																				null,
																				null,
																				porcentaje_percepcion,
																				usuarioalt,
																				idempresa,
																				conn);

																	}

																	if (!salida
																			.equalsIgnoreCase("OK"))
																		break;

																}// B.0

																// ASIGNAR
																// COMPROBANTE A
																// REMITOS

																if (salida
																		.equalsIgnoreCase("OK")) {

																	// Recuperar
																	// los
																	// remitos
																	// que
																	// corresponden
																	// al
																	// comprobante
																	// generado
																	// en
																	// este
																	// ciclo.
																	cQuery = ""
																			+ " SELECT DISTINCT idremitocliente "
																			+ "    FROM tmp_remitos_facturar "
																			+ "  WHERE idcliente = "
																			+ idcliente
																			+ "       AND idcondicion ="
																			+ idcondicion
																			+ "       AND idtarjeta =  "
																			+ idtarjeta;
																	Iterator iterRemitos = getLista(
																			cQuery,
																			conn)
																			.iterator();

																	auxTotalProcesados = 0;

																	if (iterRemitos
																			.hasNext()) {// M

																		while (iterRemitos
																				.hasNext()) {

																			String[] dataRemito = (String[]) iterRemitos
																					.next();
																			BigDecimal idremitocliente = new BigDecimal(
																					dataRemito[0]);

																			salida = clientesRemitosUpdateComprob(
																					idremitocliente,
																					nrointernomovcliente,
																					idciclofact,
																					idempresa,
																					usuarioalt,
																					conn);

																			if (!salida
																					.equalsIgnoreCase("OK"))
																				break;

																			++auxTotalProcesados;
																		}

																		if (salida
																				.equalsIgnoreCase("OK"))
																			totalProcesados += auxTotalProcesados;

																	}// M
																	else {
																		salida = "E[8000]No se recuperaron remitos asociados al comprobante generado.";
																	}// M

																}
															}// B
														}// A
														else {
															salida = "E[7000]Imposible recuperar Nro. Interno de Movimiento de Cliente.";
														}
													}// 0.2
													else {

														salida = "E[6000]El comprobante "
																+ GeneralBean
																		.strZero(
																				sucursal
																						.toString(),
																				4)
																+ " - "
																+ GeneralBean
																		.strZero(
																				comprob
																						.toString(),
																				8)
																+ " ya fue emitido. Es necesario verificar contadores.";
														// Ante un comprobante
														// ya existente o
														// emitido
														// previamente, se
														// aborta la
														// generacion y se
														// deshace
														// toda la transaccion.
														confirmaTransaccion = false;
														break;
													}
												}// 0.1
												else {
													salida = "E[5000]No se recupero Nro. Comprobante para Sucursal "
															+ sucursal
															+ " - TM: "
															+ tipomovs
															+ " - "
															+ letracontador
															+ ", posiblemente no se haya definido contador.";
													// Ante un contador
													// inexistente,
													// se aborta la generacion y
													// se
													// deshace toda la
													// transaccion.
													confirmaTransaccion = false;
													break;
												}

											}// X5

										}// X4

										if (!salida.equalsIgnoreCase("OK")) {
											stsavepoint
													.execute(" ROLLBACK TO SAVEPOINT sp_comprobante; ");
										} else
											stsavepoint
													.execute(" RELEASE SAVEPOINT sp_comprobante; ");

									}// Z1

								} // X4
								else {
									salida = "E[4000] - Totales por comprobante.";
								}// X4

							}// X3
							else {

								data = (String[]) iterValidaRemito.next();
								salida = " E[3000] Se detecto  IDremito: "
										+ data[0]
										+ " con mas de una condicion-tarjeta.";

								// log.info(salida);

							}// X3
							String msjLog = "OK";
							// EN CASO DE ALGUN TIPO DE ERROR REGISTRA EL MISMO.
							if (!salida.equalsIgnoreCase("OK"))
								msjLog = clientesmovcliremitoslogCreate(
										idciclofact, salida, remitosSeleccion,
										idcliente, idcondicion, idtarjeta,
										idempresa, usuarioalt);

							if (!msjLog.equalsIgnoreCase("OK"))
								log.warn("NO SE GENERO LOG FACTURACION:  "
										+ msjLog);

							salida = "OK";

						} // X2

					}// X1
					else {

						salida = "E[2000] - Comprobantes recuperados. ";

					}// X1

				}// BB

			}// AA

		} catch (SQLException sqle) {
			confirmaTransaccion = false;
			salida = "E[1001](SQL)Imposible generar movimiento de cliente.";
			log.error("clientesMovCliDesdeRemitosCreate:" + sqle);
			log.error("clientesMovimientoClienteCreate:"
					+ sqle.getNextException());
		} catch (Exception e) {
			confirmaTransaccion = false;
			salida = "E[1002](EX)Imposible generar movimiento de cliente.";
			log.error("clientesMovCliDesdeRemitosCreate:" + e);
		}

		if (!salida.equalsIgnoreCase("OK"))
			clientesmovcliremitoslogCreate(idciclofact, salida,
					remitosSeleccion, idciclofact, idciclofact, idciclofact,
					idempresa, usuarioalt);

		if (confirmaTransaccion) {

			if (totalSeleccion != totalProcesados) {
				salida = "Se proceso un total de "
						+ totalProcesados
						+ " registros, sobre "
						+ totalSeleccion
						+ " seleccionados. El ciclo de control asignado es el nro: "
						+ idciclofact;
			} else {

				salida = "Todos los registros seleccionados fueron procesados satisfactoriamente, el ciclo de control asignado es el nro.: "
						+ idciclofact;

			}

			conn.commit();

		} else {

			conn.rollback();

		}

		conn.setAutoCommit(true);
		conn.close();

		return salida;

	}

	/**
	 * EJV - 20110706 FINAL GENERACION DE MOVIMIENTOS DE CLIENTES A PARTIR DE
	 * REMITOS. <--
	 * */

	/**
	 * EJV - 20110727 INICA PRESENTACION DE TARJETAS . -->
	 * */

	public String clientesTarjetasGeneracionCreate(BigDecimal idgeneracion,
			BigDecimal idtarjetacredito, BigDecimal idclub, BigDecimal periodo,
			String regenerar, java.sql.Date fecha_presentacion,
			BigDecimal idempresa, String usuarioalt, Connection conn)
			throws EJBException {
		String salida = "OK";
		// validaciones de datos:
		// 1. nulidad de campos

		if (idgeneracion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idgeneracion ";
		if (idtarjetacredito == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idtarjetacredito ";
		if (idclub == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idclub ";
		if (periodo == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: periodo ";
		if (regenerar == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: regenerar ";
		if (fecha_presentacion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fecha_presentacion ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (regenerar.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: regenerar ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		try {

			if (salida.equalsIgnoreCase("OK")) {
				String ins = "INSERT INTO CLIENTESTARJETASGENERACION(idgeneracion, idtarjetacredito, idclub, periodo, regenerar, fecha_presentacion,  idempresa, usuarioalt ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
				PreparedStatement insert = conn.prepareStatement(ins);
				// seteo de campos:
				insert.setBigDecimal(1, idgeneracion);
				insert.setBigDecimal(2, idtarjetacredito);
				insert.setBigDecimal(3, idclub);
				insert.setBigDecimal(4, periodo);
				insert.setString(5, regenerar);
				insert.setDate(6, fecha_presentacion);
				insert.setBigDecimal(7, idempresa);
				insert.setString(8, usuarioalt);
				int n = insert.executeUpdate();
				if (n != 1)
					salida = "No fue posible generar registro presentacion tarjeta-periodo.";
			}
		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible generar registro presentacion tarjeta-periodo.";
			log
					.error("Error SQL public String clientesTarjetasGeneracionCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible generar registro presentacion tarjeta-periodo.";
			log
					.error("Error excepcion public String clientesTarjetasGeneracionCreate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * INICIA --> GENERACION DE PRESENTACION DE ARCHIVOS PARA TARJETAS DE
	 * CREDITO
	 * */

	private boolean setPresentacionArchivoTotales(String cQuery, String path,
			String archivo, Connection conn) {

		boolean control = false;

		try {

			Iterator iterTotales = getLista(cQuery, conn).iterator();
			if (iterTotales.hasNext()) {
				String[] sourceTotaliza = (String[]) iterTotales.next();
				String archivoTotaliza = archivo
						.replace(".txt", "-TOTALES.txt");
				control = GeneralBean.generaArchivo(sourceTotaliza[0],
						archivoTotaliza, path);
				// --
				if (control) {
					File fileZip = new File(path + archivoTotaliza);
					control = GeneralBean.zipFile(fileZip, fileZip
							.getAbsolutePath()
							+ ".zip");
				} else
					log
							.warn("setPresentacionArchivoTotales: No fue posible comprimir: "
									+ archivoTotaliza);
			} else
				log
						.warn("setPresentacionArchivoTotales: No fue posible recuperar datos para totalizar: "
								+ archivo);

		} catch (Exception e) {
			log.error("setPresentacionArchivoTotales(): " + e);
		}
		return control;
	}

	/*
	 * VISA
	 */

	public String setPresentacionVISA(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivo, String path, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		String retorno = "OK";
		boolean control = false;
		Statement statement = null;
		String cQuery = "";
		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));
		Connection conn = null;

		int cantidadComprobantes = 0;
		final int CANTIDAD_LOTE = 99;
		int modulo = 0;
		int totalLotes = 0;
		String source = "";
		String entidad = "";
		int generacion = -1;

		try {

			conn = GeneralBean.getTransaccionConn(this.clase, this.url,
					this.usuario, this.clave);
			// <--

			if (conn == null)
				return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito ) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				statement = conn.createStatement();
				// Generar Registros de detalle
				cQuery = ""
						+ "CREATE TEMPORARY TABLE tmp_visa_comprobante AS "
						// + "CREATE TABLE tmp_visa_comprobante AS "

						+ "SELECT cmp1_tipo_registro, cmp2_uso_reservado, cmp3_nrotarjeta, cmp4_uso_reservado, cmp5_nro_cupon, cmp6_fecha_transaccion, cmp7_uso_reservado, cmp8_uso_reservado,  "
						+ "            cmp9_importe, cmp10_uso_reservado, cmp11_identifica_debito, cmp12_codigo_alta, importe, row_number() OVER() AS registro, lote, idcliente, idempresa "
						+ "   FROM ("

						+ "              SELECT LPAD('', 1, ' ')::varchar(1) AS cmp1_tipo_registro, LPAD('', 2, ' ')::varchar(2) AS cmp2_uso_reservado, tj.nrotarjeta::varchar(16) AS cmp3_nrotarjeta, LPAD('', 1, ' ')::varchar(1) AS cmp4_uso_reservado, "
						+ "                           LPAD(tj.idcliente::varchar, 8, '0')::varchar(8) AS cmp5_nro_cupon, to_char(current_date, 'ddmmyy')::varchar(6) AS cmp6_fecha_transaccion, LPAD('', 3, ' ')::varchar(3) AS cmp7_uso_reservado, "
						// 20120825 - EJV-->
						// +
						// "             LPAD('', 5, ' ')::varchar(5) AS cmp8_uso_reservado, LPAD(replace(import_cuo::varchar, '.', ''), 15, '0')::varchar(15) AS cmp9_importe, LPAD('', 7, ' ')::varchar(7) AS cmp10_uso_reservado, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "                           LPAD('', 5, ' ')::varchar(5) AS cmp8_uso_reservado, LPAD(replace((import_cuo::NUMERIC(18, 2))::varchar, '.', ''), 15, '0')::varchar(15) AS cmp9_importe, LPAD('', 7, ' ')::varchar(7) AS cmp10_uso_reservado, "
						+ "                           LPAD('', 5, ' ')::varchar(5) AS cmp8_uso_reservado, LPAD(replace((saldo_cuo::NUMERIC(18, 2))::varchar, '.', ''), 15, '0')::varchar(15) AS cmp9_importe, LPAD('', 7, ' ')::varchar(7) AS cmp10_uso_reservado, "
						// <--
						// <--
						// 20120813 - EJV - Mantis 871 -->
						// +
						// "             LPAD(mc.comprob::varchar, 15, '0')::varchar(15) AS cmp11_identifica_debito, LPAD('', 1, ' ')::varchar(1) AS cmp12_codigo_alta, "
						+ "                           LPAD(ABS(mc.comprob)::varchar, 15, '0')::varchar(15) AS cmp11_identifica_debito, LPAD('', 1, ' ')::varchar(1) AS cmp12_codigo_alta, "
						// <--
						// 20121030 - EJV - Mantis 889 -->
						// +
						// "             cu.import_cuo::NUMERIC(18, 2) AS importe, row_number() OVER() AS  registro, 0 AS lote,  cl.idcliente, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "                           cu.import_cuo::NUMERIC(18, 2) AS importe, row_number() OVER() AS  registro, 0 AS lote,  cl.idcliente, "
						+ "                           cu.saldo_cuo::NUMERIC(18, 2) AS importe, row_number() OVER() AS  registro, 0 AS lote,  cl.idcliente, "
						// <--
						// <--
						+ idempresa
						+ "               AS idempresa "
						+ "                 FROM clientesmovcuota cu "
						+ "                           INNER JOIN clientetarjetascredito tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa  AND cu.estado_cuo <> 'A' "
						// 20120810 - EJV - Mantis 871 -->
						// +
						// "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov =1 "
						+ "                          INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						// <--
						+ "                          INNER JOIN clientesclientes cl ON tj.idcliente = cl.idcliente AND tj.idempresa = cl.idempresa "
						// 20120810 - EJV - Mantis 871 -->
						+ "                           INNER JOIN clientesestadoshoy eh ON cl.idcliente = eh.idcliente AND cl.idempresa = eh.idempresa "
						//
						+ "                           INNER JOIN clientestipoclie ti ON cl.idtipoclie = ti.idtipoclie  AND cl.idempresa = ti.idempresa"
						// 20120810 - EJV - Mantis 871 -->
						+ "                           LEFT JOIN ( "
						+ "                                           SELECT idestadocliente, idcliente, idempresa "
						+ "                                              FROM clientesestadoshoy  "
						+ "                                            WHERE ( "
						+ "                                                         (idestado = 2 AND idmotivo = 60) OR "
						+ "                                                         (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                                         (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                                         (idestado = 6 AND idmotivo = 41) "
						+ "                                                         )  "
						+ "                                              ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// <--
						+ "               WHERE cu.idclub =  "
						+ idclub
						+ "                   AND tj.idempresa = "
						+ idempresa
						+ "                   AND  tj.idtarjetacredito  ="
						+ idtarjetacredito
						// 20120810 - EJV - Mantis 871 -->
						+ "                   AND eout.idestadocliente IS NULL"
						+ "                   AND cu.periodo_cuo <= "
						+ periodo
						+ "                   AND  cu.estado_cuo IN ('P', 'R')"
						// 20121030 - EJV - Mantis 889 -->
						+ "               ORDER BY cl.idcliente ASC   "
						+ " ) vresumenvisa  ;  "
				// <--
				// + "     AND (  ( cu.periodo_cuo = "
				// + periodo
				// +
				// "               AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
				// + periodo
				// + "               AND  cu.estado_cuo='R' )  );"
				// <--
				;

				statement.execute(cQuery);

				cantidadComprobantes = (int) getTotalEntidad(
						"tmp_visa_comprobante", idempresa, conn);

				if (cantidadComprobantes > 0) {// B

					modulo = cantidadComprobantes % CANTIDAD_LOTE;
					totalLotes = cantidadComprobantes / CANTIDAD_LOTE;
					if (modulo > 0 && cantidadComprobantes != 0)
						totalLotes++;

					// Generar registros resumen (cabecera)
					cQuery = ""
							+ "CREATE TEMPORARY TABLE tmp_visa_resumen AS "
							// + "CREATE TABLE tmp_visa_resumen AS "
							+ "SELECT '0'::varchar(1)  AS cmp1_tipo_registro,   "
							+ "       'DB'::varchar(2)  AS cmp2_db, "
							+ "       to_char(current_date, 'ddmmyy')::varchar(6)  AS cmp3_fecha_transaccion, "
							+ "       '016'::varchar(3)  AS cmp4_codigo_banco_estab, "
							+ "       '023'::varchar(3)  AS cmp5_codigo_sucursal, "
							+ "       LPAD(lt.nrolote::varchar, 4, '0')::varchar(4)  AS cmp6_nro_lote, "
							+ "       LPAD('', 7, ' ')::varchar(7)  AS cmp7_uso_reservado, "
							+ "       '0005'::varchar(4)  AS cmp8_codigo_transaccion, "
							+ "       LPAD(nrocomercio::varchar(10), 10, '0')::varchar(10) AS cmp9_nro_comercio, "
							+ "       '"
							+ CANTIDAD_LOTE
							+ "'::varchar(2)  AS cmp10_cant_comprob_lote, "
							+ "       '000000000000000'::varchar(15)  AS cmp11_total_comp_lote, "
							+ "       LPAD('', 1, ' ')::varchar(1)  AS cmp12_uso_reservado, "
							+ "       '9786'::varchar(4)  AS cmp13__nro_caja,  "
							+ "       LPAD('', 18, ' ')::varchar(18)  AS cmp14_uso_reservado, lt.nrolote "
							+ "  FROM clientesclubcomerciotarjeta "
							+ "       INNER JOIN (SELECT generate_series(1, CASE WHEN "
							+ totalLotes + " < 1 THEN 1 ELSE " + totalLotes
							+ " END) AS nrolote) AS lt ON TRUE "
							+ " WHERE idclub = " + idclub + " AND idtarjeta = "
							+ idtarjetacredito;

					control = statement.execute(cQuery);

					statement.clearBatch();

					for (int j = 0, lote = 1; j < totalLotes; j++, lote++) {
						int max = CANTIDAD_LOTE * lote;
						int min = (max - CANTIDAD_LOTE) + 1;
						// Asignar lote al que corresponde grupo de
						// registros
						// comprobante
						cQuery = "UPDATE tmp_visa_comprobante SET lote = "
								+ lote + " WHERE registro BETWEEN " + min
								+ " AND " + max;
						statement.addBatch(cQuery);
						// Sumarizar total para el lote
						// 20120825 - EJV-->
						// cQuery =
						// "UPDATE tmp_visa_resumen SET cmp11_total_comp_lote = (SELECT   LPAD(  REPLACE(SUBSTRING((SUM ( importe   )  )::varchar, 1 , LENGTH((SUM ( importe   )  )::varchar)-2), '.', ''    ), 15, '0') FROM tmp_visa_comprobante WHERE registro BETWEEN "
						cQuery = "UPDATE tmp_visa_resumen SET cmp11_total_comp_lote = (SELECT   LPAD(  REPLACE(SUBSTRING((SUM ( importe   )::NUMERIC(18, 2)  )::varchar, 1 , LENGTH((SUM ( importe   )::NUMERIC(18, 2) )::varchar)), '.', ''    ), 15, '0') FROM tmp_visa_comprobante WHERE registro BETWEEN "
								// <--
								+ min
								+ " AND "
								+ max
								+ " )   WHERE cmp6_nro_lote::numeric = " + lote;
						statement.addBatch(cQuery);
						// Actualizar cantidad de comprobantes para el
						// ultimo
						// lote, en general < CANTIDAD_LOTE
						if (lote == totalLotes) {
							cQuery = "UPDATE tmp_visa_resumen SET cmp10_cant_comprob_lote = (SELECT   LPAD( (COUNT ( 1 )  )::varchar, 2, '0') FROM tmp_visa_comprobante WHERE registro BETWEEN "
									+ min
									+ " AND "
									+ max
									+ " )   WHERE cmp6_nro_lote::numeric = "
									+ lote;
							statement.addBatch(cQuery);
						}
					}

					statement.executeBatch();

					// Recuperar datos de resumen + detalle con el formato
					// esperado para generar archivo.
					cQuery = ""
							+ " SELECT (cmp1_tipo_registro || cmp2_db || cmp3_fecha_transaccion || cmp4_codigo_banco_estab || cmp5_codigo_sucursal || cmp6_nro_lote || cmp7_uso_reservado || "
							+ "             cmp8_codigo_transaccion || cmp9_nro_comercio || cmp10_cant_comprob_lote || cmp11_total_comp_lote || cmp12_uso_reservado || cmp13__nro_caja || cmp14_uso_reservado) AS resumen_detalle , nrolote   , 0 AS registro "
							+ "    FROM tmp_visa_resumen "
							+ " UNION ALL "
							+ " SELECT (cmp1_tipo_registro || cmp2_uso_reservado || cmp3_nrotarjeta || cmp4_uso_reservado || cmp5_nro_cupon || cmp6_fecha_transaccion ||  "
							+ "              cmp7_uso_reservado || cmp8_uso_reservado || cmp9_importe || cmp10_uso_reservado || cmp11_identifica_debito || cmp12_codigo_alta) AS resumen_detalle, lote , registro "
							+ "   FROM tmp_visa_comprobante "
							+ " ORDER BY 2, 3 ";

					Iterator iterRegistros = getLista(cQuery, conn).iterator();

					if (iterRegistros.hasNext()) {

						while (iterRegistros.hasNext()) {
							String[] datos = (String[]) iterRegistros.next();
							source += datos[0] + "\r\n";
						}

						control = GeneralBean.generaArchivo(source, archivo,
								path);

						if (control) {// D

							BigDecimal idgeneracion = GeneralBean
									.getNextValorSequencia(
											"seq_clientestarjetasgeneracion",
											conn);

							if (idgeneracion != null) {

								// retorno = clientesMovCuotaSetEnviado(
								// idtarjetacredito, new BigDecimal(periodo),
								// fechaPresentacion, "E", idclub, idgeneracion,
								// idempresa,
								// usuarioalt, conn);

								retorno = clientesTarjetasGeneracionCreate(
										idgeneracion, idtarjetacredito, idclub,
										new BigDecimal(periodo), "N",
										fechaPresentacion, idempresa,
										usuarioalt, conn);

								if (retorno.equalsIgnoreCase("OK"))

									// retorno =
									// clientesTarjetasGeneracionCreate(
									// idtarjetacredito, idclub,
									// new BigDecimal(periodo), "N",
									// idempresa, usuarioalt, conn);

									retorno = clientesMovCuotaSetEnviado(
											idtarjetacredito, new BigDecimal(
													periodo),
											fechaPresentacion, "E", idclub,
											idgeneracion, idempresa,
											usuarioalt, conn);

								try {

									File fileZip = new File(path + archivo);
									GeneralBean.zipFile(fileZip, fileZip
											.getAbsolutePath()
											+ ".zip");

								} catch (Exception io) {
									log.warn("Falla al comrpimir   " + archivo
											+ ": " + io);
								}

								// Archivo de resumen -->
								cQuery = ""
								// 20120825 - EJV -->
										// +
										// "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( importe   )  )::varchar, 1 , LENGTH((SUM ( importe   )  )::varchar)-2)::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
										+ "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( importe::NUMERIC(18, 2)   )  )::varchar, 1 , LENGTH( (SUM ( importe   )::NUMERIC(18, 2)  )::varchar))::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
										// <--
										+ "   FROM tmp_visa_comprobante";

								setPresentacionArchivoTotales(cQuery, path,
										archivo, conn);
								// <--

							} else {

								retorno = "Imposible capturar/asignar ID generacion.";
							}

						}// D
						else {

							retorno = "[E4]-No fue posible generar escribir archivo.";

						}// D

					} else {
						retorno = "[E3]-No fue posible recuperar lineas para escribir en archivo";
					}

				}// B
				else {

					retorno = "[E1]-No existen registros que cumplan con el criterio de busqueda, para generar archivo";
				}// B

			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (SQLException e) {
			retorno = "[SQLE]-No fue posible procesar registros para generar archivo.";
			log.error("setPresentacionVISA():" + e);
			log.error("setPresentacionVISA():" + e.getNextException());
		} catch (Exception e) {
			retorno = "[EX]-No fue posible procesar registros para generar archivo.";
			log.error("setPresentacionVISA():" + e);
		}

		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return retorno;

	}

	/*
	 * AMEX
	 */

	public String setPresentacionAMEX(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivo, String path, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));

		String cQuery = "";
		String entidad = "";
		String source = "";
		boolean control = false;
		String retorno = "OK";
		Connection conn = null;
		int generacion = -1;

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		conn.setAutoCommit(false);

		try {

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				cQuery = ""
						+ "CREATE TEMPORARY TABLE tmp_registros_amex AS "
						// + "CREATE  TABLE tmp_registros_amex AS "
						+ "	         SELECT nrocomercio::varchar(10) AS cmp1_nrocomercio, nrotarjeta::varchar(15) AS cmp2_nrotarjeta, LPAD(numero_cuo::varchar, 5, '0')::varchar(5) AS cmp3_codservicio,  "
						// 20120829 - EJV - Mantis 880 -->
						// +
						// "	                      LPAD(idcliente::varchar, 10, '0')::varchar(10) AS cmp4_nroservicio , '01'::varchar(2) as cmp5_frecuencia, substring(periodo_cuo::varchar, 3)::varchar(4) AS cmp6_periodo_fact, "
						+ "	                      LPAD(idcliente::varchar, 10, '0')::varchar(10) AS cmp4_nroservicio , '01'::varchar(2) as cmp5_frecuencia, TO_CHAR(TO_DATE('"
						+ fechaPresentacion
						+ "', 'YYYY-MM-DD') + INTERVAL '1 MONTH', 'YYMM')::varchar(4) AS cmp6_periodo_fact, "
						// <--
						// +
						// "	                      LPAD(REPLACE(import_cuo::varchar, '.', ''), 11, '0')::varchar(11) cmp7_importe, "
						// 20121105 - EJV - Mantis 889 -->
						// +
						// "	                      LPAD(REPLACE(SUBSTRING((  ( import_cuo   )  )::varchar, 1 , LENGTH((  ( import_cuo   )  )::varchar)-2), '.', ''    ), 11, '0')::varchar(11) cmp7_importe, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "	                      LPAD(REPLACE(   (  ( import_cuo::NUMERIC(18, 2)   )  )::varchar , '.', ''     ), 11, '0')::varchar(11) cmp7_importe, "
						+ "	                      LPAD(REPLACE(   (  ( saldo_cuo::NUMERIC(18, 2)   )  )::varchar , '.', ''     ), 11, '0')::varchar(11) cmp7_importe, "
						// <--
						// <--
						+ "                         fechamov::varchar(5) AS cmp8_fechafactura, "

						// 20121119 - EJV - Mantis 889 -->
						// +
						// "          	              filler AS cmp9_filler, import_cuo,  idcliente,  "
						+ "          	              filler AS cmp9_filler, saldo_cuo,  idcliente,  "
						// <--

						// 20121030 - EJV - Mantis 889 -->
						+ "                         row_number() OVER() AS  tupla "
						// <--
						+ "	           FROM ( "

						// 20121030 - EJV - Mantis 889 -->
						// +
						// "		                 SELECT co.nrocomercio, tj.nrotarjeta, cu.numero_cuo ,  "
						// +
						// "		                              tj.idcliente, '01'::varchar(2) AS frecuencia, cu.periodo_cuo, "
						+ "		                 SELECT co.nrocomercio, tj.nrotarjeta, 1 numero_cuo ,  "
						+ "		                              tj.idcliente, LPAD(per.periodicidad::varchar, 2, '0 ')::varchar(2) AS frecuencia, 1 periodo_cuo, "
						// <--
						// 20121105 - EJV - Mantis 889 -->
						// +
						// "		                              SUM(cu.import_cuo) AS import_cuo, to_char(mc.fechamov, 'mm/yy') AS fechamov, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "		                              SUM(cu.import_cuo::NUMERIC(18, 2)) AS import_cuo, to_char(mc.fechamov, 'mm/yy') AS fechamov, "
						+ "		                              SUM(cu.saldo_cuo::NUMERIC(18, 2)) AS saldo_cuo, to_char(mc.fechamov, 'mm/yy') AS fechamov, "
						// <--
						// <--
						+ "		                              LPAD('', 38, ' ')::varchar(38) AS filler "
						+ "		                     FROM clientesmovcuota cu "
						// 20120810 - EJV - Mantis 871 -->
						// +
						// "                                  INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov = 1 "
						+ "                                     INNER JOIN clientesmovcli mc ON cu.ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						+ "                                     INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						// <--
						+ "		                              INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						+ "		                              INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "

						// 20121030 - EJV - Mantis 889 -->
						+ "                                     INNER JOIN vclientesperiodicidad per ON mc.cliente = per.idcliente AND mc.idempresa = per.idempresa "
						// <--

						// 20120810 - EJV - Mantis 871 -->
						+ "                                       LEFT JOIN ( "
						+ "                                                       SELECT idestadocliente, idcliente, idempresa "
						+ "                                                          FROM clientesestadoshoy  "
						+ "                                                        WHERE ( "
						+ "                                                                     (idestado = 2 AND idmotivo = 60) OR "
						+ "                                                                     (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                                                     (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                                                     (idestado = 6 AND idmotivo = 41) "
						+ "                                                                     )  "
						+ "                                                          ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// <--
						+ "		                  WHERE cu.idclub =  "
						+ idclub
						+ "		                      AND tj.idtarjetacredito = "
						+ idtarjetacredito
						+ "		                      AND tj.idempresa = "
						+ idempresa

						// 20120810 - EJV - Mantis 871 -->
						+ "     AND eout.idestadocliente IS NULL"
						+ "     AND cu.periodo_cuo <= "
						+ periodo
						+ "     AND  cu.estado_cuo IN ('P', 'R')  "
						// +
						// "                             AND (  ( cu.periodo_cuo = "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='R' )  ) "

						// 20121030 - EJV - Mantis 889 -->
						// +
						// "		                  GROUP BY co.nrocomercio, tj.nrotarjeta, cu.numero_cuo , "
						// +
						// "			                              tj.idcliente, cu.periodo_cuo, "
						+ "		                  GROUP BY co.nrocomercio, tj.nrotarjeta, "
						+ "			                              tj.idcliente,  per.periodicidad, "
						// <--
						+ "			                              to_char(mc.fechamov, 'mm/yy') "
						// 20121030 - EJV - Mantis 889 -->
						+ "                          ORDER BY tj.idcliente ASC "
						// <--
						+ "		                  )  vresumen ";

				Statement statement = conn.createStatement();
				control = statement.execute(cQuery);

				// 20120822 - EJV - Mantis 878 -->

				cQuery = ""
						+ " UPDATE tmp_registros_amex  "
						+ "    SET cmp3_codservicio =  ref "
						+ "   FROM ( "
						+ "         SELECT row_number()  OVER() AS registro, ref, referencia  "
						+ "            FROM ( "
						+ " 	                  SELECT (LPAD( GENERATE_SERIES(1, COUNT(idcliente))::VARCHAR, 5, '0' )) AS ref, idcliente  AS referencia  "
						+ " 	                     FROM tmp_registros_amex  "
						+ " 	                   GROUP BY idcliente   "
						+ " 	                   ORDER BY idcliente, ref  "
						+ " 	         ) sub "
						+ "        ) entidad  WHERE tupla = registro AND idcliente = referencia;  ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);
				// <--

				cQuery = ""
						+ "SELECT (cmp1_nrocomercio || cmp2_nrotarjeta   || cmp3_codservicio || cmp4_nroservicio  ||  "
						+ "             cmp5_frecuencia || cmp6_periodo_fact || cmp7_importe  || cmp8_fechafactura ||  cmp9_filler)::varchar AS registro "
						+ "   FROM tmp_registros_amex "
						// 20120810 - EJV - Mantis 871 -->
						+ "  ORDER BY idcliente, cmp3_codservicio "
				// <--
				// + "  FROM ( "
				// +
				// "	         SELECT nrocomercio::varchar(10) AS cmp1_nrocomercio, nrotarjeta::varchar(15) AS cmp2_nrotarjeta, LPAD(numero_cuo::varchar, 5, '0')::varchar(5) AS cmp3_codservicio,  "
				// +
				// "	                      LPAD(idcliente::varchar, 10, '0')::varchar(10) AS cmp4_nroservicio , '01'::varchar(2) as cmp5_frecuencia, substring(periodo_cuo::varchar, 3)::varchar(4) AS cmp6_periodo_fact, "
				// +
				// "	                      LPAD(REPLACE(import_cuo::varchar, '.', ''), 11, '0')::varchar(11) cmp7_importe, fechamov::varchar(5) AS cmp8_fechafactura, "
				// + "          	              filler AS cmp9_filler  "
				// + "	           FROM ( "
				// +
				// "		                 SELECT co.nrocomercio, tj.nrotarjeta, cu.numero_cuo ,  "
				// +
				// "		                              tj.idcliente, '01'::varchar(2) AS frecuencia, cu.periodo_cuo, "
				// +
				// "		                              SUM(cu.import_cuo) AS import_cuo, to_char(mc.fechamov, 'mm/yy') AS fechamov, "
				// +
				// "		                              LPAD('', 38, ' ')::varchar(38) AS filler "
				// + "		                     FROM clientesmovcuota cu "
				// +
				// "		                              INNER JOIN clientesmovcli mc ON cu.ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  "
				// +
				// "		                              INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
				// +
				// "		                              INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
				// + "		                  WHERE cu.idclub =  "
				// + idclub
				// + "		                      AND tj.idtarjetacredito = "
				// + idtarjetacredito
				// + "		                      AND tj.idempresa = "
				// + idempresa
				// + "                             AND (  ( cu.periodo_cuo = "
				// + periodo
				// +
				// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
				// + periodo
				// +
				// "                                          AND  cu.estado_cuo='R' )  ) "
				// +
				// "		                  GROUP BY co.nrocomercio, tj.nrotarjeta, cu.numero_cuo , "
				// +
				// "			                              tj.idcliente, cu.periodo_cuo, "
				// +
				// "			                              to_char(mc.fechamov, 'mm/yy') "
				// + "		                  )  vresumen "
				// + "       ) vregistro; "
				;

				Iterator iterRegistros = getLista(cQuery, conn).iterator();

				if (iterRegistros.hasNext()) {

					while (iterRegistros.hasNext()) {
						String[] datos = (String[]) iterRegistros.next();
						source += datos[0] + "\r\n";
					}

					control = GeneralBean.generaArchivo(source, archivo, path);

					if (control) {// B

						BigDecimal idgeneracion = GeneralBean
								.getNextValorSequencia(
										"seq_clientestarjetasgeneracion", conn);

						if (idgeneracion != null) {

							// retorno =
							// clientesMovCuotaSetEnviado(idtarjetacredito,
							// new BigDecimal(periodo), fechaPresentacion,
							// "E", idclub, idgeneracion, idempresa, usuarioalt,
							// conn);

							retorno = clientesTarjetasGeneracionCreate(
									idgeneracion, idtarjetacredito, idclub,
									new BigDecimal(periodo), "N",
									fechaPresentacion, idempresa, usuarioalt,
									conn);

							if (retorno.equalsIgnoreCase("OK"))
								// retorno = clientesTarjetasGeneracionCreate(
								// idtarjetacredito, idclub, new BigDecimal(
								// periodo), "N", idempresa,
								// usuarioalt, conn);

								retorno = clientesMovCuotaSetEnviado(
										idtarjetacredito, new BigDecimal(
												periodo), fechaPresentacion,
										"E", idclub, idgeneracion, idempresa,
										usuarioalt, conn);

							try {

								File fileZip = new File(path + archivo);
								GeneralBean.zipFile(fileZip, fileZip
										.getAbsolutePath()
										+ ".zip");

							} catch (Exception io) {
								log.warn("Falla al comrpimir   " + archivo
										+ ": " + io);
							}

							// Archivo de totalizacion -->
							cQuery = ""
									// +
									// "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2)::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									+ "SELECT  'IMPORTE TOTAL: ' ||  ( SUM (   saldo_cuo   )  )::varchar  || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									+ "   FROM tmp_registros_amex ";

							setPresentacionArchivoTotales(cQuery, path,
									archivo, conn);
							// <--

						} else {

							retorno = "Imposible capturar/asignar ID generacion";

						}

					}// B
					else {

						retorno = "[E2]-No fue posible generar escribir archivo.";

					}// B

				} else {
					retorno = "[E1]-No fue posible recuperar lineas para escribir en archivo";
				}
			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (Exception e) {
			retorno = "[E100]-Se produjo un error al procesar generacion AMEX.";
			log.error("(EX)setPresentacionAMEX: " + e);
		}

		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return retorno;
	}

	/*
	 * MASTERCARD
	 */

	public String setPresentacionMASTERCARD(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivo, String path, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));

		Statement statement = null;
		String cQuery = "";
		String entidad = "";
		String source = "";
		boolean control = false;
		String retorno = "OK";
		Connection conn = null;
		int generacion = -1;

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		conn.setAutoCommit(false);

		try {

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				cQuery = ""
						// + "CREATE TEMPORARY TABLE tmp_registros_master AS "
						// +
						// " SELECT LPAD(co.nrocomercio::varchar, 8, '0')::varchar(8) cmp1_nrocomercio, '2'::varchar(1) AS cmp2_tipo, tj.nrotarjeta::varchar(16) cmp3_nrotarjeta, "
						// // 20120813 - EJV - Mantis 871 -->
						// // +
						// //
						// "             (LPAD(mc.sucursal::varchar, 4, '0') || LPAD(mc.comprob::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						// +
						// "             (LPAD(ABS(mc.sucursal)::varchar, 4, '0') || LPAD(ABS(mc.comprob)::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						// // <--
						// +
						// "             '001'::varchar(3) cmp5_cuotas, '999'::varchar(3) cmp6_cuotas_plan, "
						// +
						// "             '01'::varchar(2) cmp7_frecuancia_debito, "
						// // 20120813 - EJV - mantis 871 - Redondeo -->
						// // +
						// //
						// "             LPAD(REPLACE(cu.import_cuo::varchar, '.', ''), 11,'0')::varchar(11) cmp8_importe, "
						// +
						// "             LPAD(REPLACE(SUBSTRING( (  ( import_cuo::numeric(18,2)::numeric(18,4)   )  )::varchar, 1 , LENGTH((  ( import_cuo   )  )::varchar)-2), '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						// // <--
						// +
						// "             TO_CHAR(mc.fechamov, 'mm/yy')::varchar(5) cmp9_periodo_factura,  "
						// +
						// "             LPAD('', 1, ' ' )::varchar(1) cmp10_filler, lpad('', 6, ' ' )::varchar(6) cmp11_fecha_vto_pago, "
						// +
						// "             LPAD('', 40, ' ' )::varchar(40) cmp12_datos_auxiliare, LPAD('', 20, ' ' )::varchar(20) cmp13_filler2, "
						// // 20120813 - EJV - mantis 871 - Redondeo -->
						// // + "             cu.import_cuo, to_char('"
						// +
						// "             cu.import_cuo::NUMERIC(18, 2)::NUMERIC(18, 4) import_cuo, to_char('"
						// // <--
						// + fechaPresentacion
						// + "'::DATE, 'ddmmyy') fpresentacion "
						// + "   FROM clientesmovcuota cu "
						// // 20120810 - EJV - Mantis 871 -->
						// // +
						// //
						// "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov =1 "
						// +
						// "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						// +
						// "             INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						// // <--
						// +
						// "	          INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						// +
						// "	          INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
						// // 20120810 - EJV - Mantis 871 -->
						// + "             LEFT JOIN ( "
						// +
						// "                             SELECT idestadocliente, idcliente, idempresa "
						// +
						// "                                FROM clientesestadoshoy  "
						// + "                              WHERE ( "
						// +
						// "                                           (idestado = 2 AND idmotivo = 60) OR "
						// +
						// "                                           (idestado = 4 AND idmotivo = 64) OR  "
						// +
						// "                                           (idestado = 4 AND idmotivo = 66) OR  "
						// +
						// "                                           (idestado = 6 AND idmotivo = 41) "
						// + "                                           )  "
						// +
						// "                                ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// // <--
						// + " WHERE cu.idclub =  "
						// + idclub
						// +
						// "		                      AND tj.idtarjetacredito = "
						// + idtarjetacredito
						// + "		                      AND tj.idempresa = "
						// + idempresa
						// // 20120810 - EJV - Mantis 871 -->
						// + "     AND eout.idestadocliente IS NULL"
						// + "     AND cu.periodo_cuo <= "
						// + periodo
						// + "     AND  cu.estado_cuo IN ('P', 'R')  "
						// // +
						// //
						// "                             AND (  ( cu.periodo_cuo = "
						// // + periodo
						// // +
						// //
						// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
						// // + periodo
						// // +
						// //
						// "                                          AND  cu.estado_cuo='R' )  ) "
						// // <--
						// + "  ORDER BY 4; 	 ";

						+ "CREATE TEMPORARY TABLE tmp_registros_master AS "
						+ " SELECT LPAD(co.nrocomercio::varchar, 8, '0')::varchar(8) cmp1_nrocomercio, '2'::varchar(1) AS cmp2_tipo, tj.nrotarjeta::varchar(16) cmp3_nrotarjeta, "
						// 20120813 - EJV - Mantis 871 -->
						// +
						// "             (LPAD(mc.sucursal::varchar, 4, '0') || LPAD(mc.comprob::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						// 20120822 - EJV - Mantis 878 -->
						// +
						// "             (LPAD(ABS(mc.sucursal)::varchar, 4, '0') || LPAD(ABS(mc.comprob)::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						// 20121029 - EJV - Mantis 889 -->
						// +
						// "             (LPAD((mc.cliente)::varchar, 10, '0'))::varchar(12) cmp4_referencia,  "
						+ "             (LPAD((mc.cliente)::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						// <--
						// <--
						// <--
						+ "             '001'::varchar(3) cmp5_cuotas, '999'::varchar(3) cmp6_cuotas_plan, "
						+ "             '01'::varchar(2) cmp7_frecuancia_debito, "
						// 20120813 - EJV - mantis 871 - Redondeo -->
						// +
						// "             LPAD(REPLACE(cu.import_cuo::varchar, '.', ''), 11,'0')::varchar(11) cmp8_importe, "
						// 20120822 - EJV - Mantis 878 -->
						// +
						// "             LPAD(REPLACE(SUBSTRING( (  ( import_cuo::numeric(18,2)::numeric(18,4)   )  )::varchar, 1 , LENGTH((  ( import_cuo   )  )::varchar)-2), '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						// 20121105 - EJV - Mantis 889 -->
						// +
						// "             LPAD(REPLACE(SUBSTRING( (  ( SUM(import_cuo)::numeric(18,2)::numeric(18,4)   )  )::varchar, 1 , LENGTH((  ( SUM(import_cuo )  )  )::varchar)-2), '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "             LPAD(REPLACE(  (  ( SUM(import_cuo::numeric(18,2) )::numeric(18,2)  )  )::varchar, '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						+ "             LPAD(REPLACE(  (  ( SUM(saldo_cuo::numeric(18,2) )::numeric(18,2)  )  )::varchar, '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						// <--
						// <--
						// <--
						// <--
						+ "             TO_CHAR(mc.fechamov, 'mm/yy')::varchar(5) cmp9_periodo_factura,  "
						+ "             LPAD('', 1, ' ' )::varchar(1) cmp10_filler, lpad('', 6, ' ' )::varchar(6) cmp11_fecha_vto_pago, "
						+ "             LPAD('', 40, ' ' )::varchar(40) cmp12_datos_auxiliare, LPAD('', 20, ' ' )::varchar(20) cmp13_filler2, "
						// 20120813 - EJV - mantis 871 - Redondeo -->
						// + "             cu.import_cuo, to_char('"
						// 20120822 - EJV - Mantis 878 -->
						// +
						// "             cu.import_cuo::NUMERIC(18, 2)::NUMERIC(18, 4) import_cuo , to_char('"
						// 20121105 - EJV - Mantis 889 -->
						// +
						// "             SUM(cu.import_cuo)::NUMERIC(18, 2)::NUMERIC(18, 4) import_cuo , to_char('"
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "             SUM(cu.import_cuo::NUMERIC(18, 2))::NUMERIC(18, 2) import_cuo , to_char('"
						+ "             SUM(cu.saldo_cuo::NUMERIC(18, 2))::NUMERIC(18, 2) import_cuo , to_char('"
						// <--
						// <--
						// <--
						// <--
						+ fechaPresentacion
						+ "'::DATE, 'ddmmyy') fpresentacion, "
						// 20120822 - EJV - Mantis 878 -->
						+ "             mc.cliente, row_number()  OVER() tupla "
						// <--
						+ "   FROM clientesmovcuota cu "
						// 20120810 - EJV - Mantis 871 -->
						// +
						// "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov =1 "
						+ "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						+ "             INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						// <--
						+ "	          INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						+ "	          INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
						// 20120810 - EJV - Mantis 871 -->
						+ "             LEFT JOIN ( "
						+ "                             SELECT idestadocliente, idcliente, idempresa "
						+ "                                FROM clientesestadoshoy  "
						+ "                              WHERE ( "
						+ "                                           (idestado = 2 AND idmotivo = 60) OR "
						+ "                                           (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                           (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                           (idestado = 6 AND idmotivo = 41) "
						+ "                                           )  "
						+ "                                ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// <--
						+ " WHERE cu.idclub =  "
						+ idclub
						+ "		                      AND tj.idtarjetacredito = "
						+ idtarjetacredito
						+ "		                      AND tj.idempresa = "
						+ idempresa
						// 20120810 - EJV - Mantis 871 -->
						+ "     AND eout.idestadocliente IS NULL"
						+ "     AND cu.periodo_cuo <= "
						+ periodo
						+ "     AND  cu.estado_cuo IN ('P', 'R')  "
						// +
						// "                             AND (  ( cu.periodo_cuo = "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='R' )  ) "
						// <--
						// 20120822 - EJV - Mantis 878 -->
						+ "  GROUP BY co.nrocomercio, tj.nrotarjeta, mc.cliente, TO_CHAR(mc.fechamov, 'mm/yy') "
						// <--
						+ "  ORDER BY mc.cliente; 	 ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);

				// 20120822 - EJV - Mantis 878 -->

				cQuery = ""
						+ " UPDATE tmp_registros_master "
						+ "    SET cmp4_referencia =  ref || cmp4_referencia "
						+ "   FROM ( "
						+ "         SELECT row_number()  OVER() AS registro, ref, referencia  "
						+ "            FROM ( "
						// 20121029 - EJV - Mantis 889 -->
						// +
						// " 	        SELECT (LPAD( GENERATE_SERIES(1, COUNT(cmp4_referencia))::VARCHAR, 2, '0' )) AS ref, cmp4_referencia  AS referencia "
						+ " 	        SELECT (LPAD( GENERATE_SERIES(1, COUNT(cmp4_referencia))::VARCHAR, 4, '0' )) AS ref, cmp4_referencia  AS referencia "
						// <--
						+ " 	          FROM tmp_registros_master  "
						+ " 	         GROUP BY cmp4_referencia, cliente   "
						+ " 	         ORDER BY cliente " + " 	         ) sub "
						+ "        ) entidad " + "  WHERE tupla = registro;  ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);
				// <--

				cQuery = ""
						+ "SELECT (cmp1_nrocomercio || '1'::varchar(1) || fpresentacion ||  "
						+ "       LPAD(COUNT(1)::varchar, 7,'0')::varchar(7) || '0'::varchar(1) || "
						//
						// +
						// "       LPAD(REPLACE(SUM(import_cuo)::varchar, '.', ''), 14, '0') ||  "
						// 20121105 - EJV - Mantis 889 -->
						// +
						// "       LPAD(  REPLACE(SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2), '.', ''    ), 14, '0') ||  "
						+ "       LPAD(  REPLACE(  (SUM ( import_cuo   )::numeric(18, 2)  )::varchar , '.', ''    ), 14, '0') ||  "
						// <--
						//
						+ "       LPAD('', 91, ' '))::varchar(128) registro_header, 1 orden, 0::numeric(18), 0::numeric(18) "
						+ "  FROM tmp_registros_master  "
						+ " GROUP BY cmp1_nrocomercio, fpresentacion "
						+ "       UNION ALL "
						+ "SELECT (cmp1_nrocomercio || cmp2_tipo || cmp3_nrotarjeta || cmp4_referencia || "
						+ "        cmp5_cuotas || cmp6_cuotas_plan || cmp7_frecuancia_debito || cmp8_importe || "
						+ "        cmp9_periodo_factura || cmp10_filler || cmp11_fecha_vto_pago || cmp12_datos_auxiliare ||cmp13_filler2 )registro_detalle, 2 orden, cliente, cmp4_referencia::numeric(18) "
						+ "  FROM tmp_registros_master "
						+ " ORDER BY 2, 3, 4; ";

				Iterator iterRegistros = getLista(cQuery, conn).iterator();

				if (iterRegistros.hasNext()) {

					while (iterRegistros.hasNext()) {
						String[] datos = (String[]) iterRegistros.next();
						source += datos[0] + "\r\n";
					}

					control = GeneralBean.generaArchivo(source, archivo, path);

					if (control) {// B

						BigDecimal idgeneracion = GeneralBean
								.getNextValorSequencia(
										"seq_clientestarjetasgeneracion", conn);

						if (idgeneracion != null) {

							// retorno = clientesMovCuotaSetEnviado(
							// idtarjetacredito, new BigDecimal(periodo),
							// fechaPresentacion, "E", idclub,
							// idgeneracion, idempresa, usuarioalt, conn);

							retorno = clientesTarjetasGeneracionCreate(
									idgeneracion, idtarjetacredito, idclub,
									new BigDecimal(periodo), "N",
									fechaPresentacion, idempresa, usuarioalt,
									conn);

							if (retorno.equalsIgnoreCase("OK"))
								// retorno = clientesTarjetasGeneracionCreate(
								// idtarjetacredito, idclub,
								// new BigDecimal(periodo), "N",
								// idempresa, usuarioalt, conn);

								retorno = clientesMovCuotaSetEnviado(
										idtarjetacredito, new BigDecimal(
												periodo), fechaPresentacion,
										"E", idclub, idgeneracion, idempresa,
										usuarioalt, conn);

							try {

								File fileZip = new File(path + archivo);
								GeneralBean.zipFile(fileZip, fileZip
										.getAbsolutePath()
										+ ".zip");

							} catch (Exception io) {
								log.warn("Falla al comrpimir   " + archivo
										+ ": " + io);
							}

							// Archivo de totalizacion -->
							cQuery = ""
							// 20121105 - EJV - Mantis 889 -->
									// +
									// "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2)::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									+ "SELECT  'IMPORTE TOTAL: ' ||     (   SUM (  import_cuo   )::numeric(18, 2)  )::varchar   || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									// <--
									+ "   FROM tmp_registros_master";

							setPresentacionArchivoTotales(cQuery, path,
									archivo, conn);
							// <--

						} else {

							retorno = "Imposible capturar/asignar ID generacion.";

						}

					}// B
					else {

						retorno = "[E2]-No fue posible generar escribir archivo.";

					}// B

				} else {
					retorno = "[E1]-No fue posible recuperar lineas para escribir en archivo";
				}
			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (Exception e) {
			retorno = "[E100]-Se produjo un error al procesar generacion MASTERCARD.";
			log.error("(EX)setPresentacionMASTERCARD: " + e);
		}

		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return retorno;
	}

	/*
	 * DINERS
	 */
	// Mantis 923 se reemplaza por el de Mastercard
	public String setPresentacionDINERS(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivo, String path, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));

		Statement statement = null;
		String cQuery = "";
		String entidad = "";
		String source = "";
		boolean control = false;
		String retorno = "OK";
		Connection conn = null;
		int generacion = -1;

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		conn.setAutoCommit(false);

		try {

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				cQuery = ""

						+ "CREATE TEMPORARY TABLE tmp_registros_diners AS "
						+ " SELECT LPAD(co.nrocomercio::varchar, 8, '0')::varchar(8) cmp1_nrocomercio, '2'::varchar(1) AS cmp2_tipo,  LPAD(   tj.nrotarjeta::varchar(16), 16, '0'   )::varchar(16)     cmp3_nrotarjeta, "
						+ "             (LPAD((mc.cliente)::varchar, 8, '0'))::varchar(12) cmp4_referencia,  "
						+ "             '001'::varchar(3) cmp5_cuotas, '999'::varchar(3) cmp6_cuotas_plan, "
						+ "             '01'::varchar(2) cmp7_frecuancia_debito, "
						+ "             LPAD(REPLACE(  (  ( SUM(saldo_cuo::numeric(18,2) )::numeric(18,2)  )  )::varchar, '.', ''    ), 11, '0')::varchar(11) cmp8_importe, "
						+ "             TO_CHAR(mc.fechamov, 'mm/yy')::varchar(5) cmp9_periodo_factura,  "
						+ "             LPAD('', 1, ' ' )::varchar(1) cmp10_filler, lpad('', 6, ' ' )::varchar(6) cmp11_fecha_vto_pago, "
						+ "             LPAD('', 40, ' ' )::varchar(40) cmp12_datos_auxiliare, LPAD('', 20, ' ' )::varchar(20) cmp13_filler2, "
						+ "             SUM(cu.saldo_cuo::NUMERIC(18, 2))::NUMERIC(18, 2) import_cuo , to_char('"
						+ fechaPresentacion
						+ "'::DATE, 'ddmmyy') fpresentacion, "
						+ "             mc.cliente, row_number()  OVER() tupla "
						+ "   FROM clientesmovcuota cu "
						+ "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						+ "             INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						+ "	          INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						+ "	          INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
						+ "             LEFT JOIN ( "
						+ "                             SELECT idestadocliente, idcliente, idempresa "
						+ "                                FROM clientesestadoshoy  "
						+ "                              WHERE ( "
						+ "                                           (idestado = 2 AND idmotivo = 60) OR "
						+ "                                           (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                           (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                           (idestado = 6 AND idmotivo = 41) "
						+ "                                           )  "
						+ "                                ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						+ " WHERE cu.idclub =  "
						+ idclub
						+ "		                      AND tj.idtarjetacredito = "
						+ idtarjetacredito
						+ "		                      AND tj.idempresa = "
						+ idempresa
						+ "     AND eout.idestadocliente IS NULL"
						+ "     AND cu.periodo_cuo <= "
						+ periodo
						+ "     AND  cu.estado_cuo IN ('P', 'R')  "
						+ "  GROUP BY co.nrocomercio, tj.nrotarjeta, mc.cliente, TO_CHAR(mc.fechamov, 'mm/yy') "
						+ "  ORDER BY mc.cliente; 	 ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);

				cQuery = ""
						+ " UPDATE tmp_registros_diners "
						+ "    SET cmp4_referencia =  ref || cmp4_referencia "
						+ "   FROM ( "
						+ "         SELECT row_number()  OVER() AS registro, ref, referencia  "
						+ "            FROM ( "
						+ " 	        SELECT (LPAD( GENERATE_SERIES(1, COUNT(cmp4_referencia))::VARCHAR, 4, '0' )) AS ref, cmp4_referencia  AS referencia "
						+ " 	          FROM tmp_registros_diners  "
						+ " 	         GROUP BY cmp4_referencia, cliente   "
						+ " 	         ORDER BY cliente " + " 	         ) sub "
						+ "        ) entidad " + "  WHERE tupla = registro;  ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);

				cQuery = ""
						+ "SELECT (cmp1_nrocomercio || '1'::varchar(1) || fpresentacion ||  "
						+ "       LPAD(COUNT(1)::varchar, 7,'0')::varchar(7) || '0'::varchar(1) || "
						+ "       LPAD(  REPLACE(  (SUM ( import_cuo   )::numeric(18, 2)  )::varchar , '.', ''    ), 14, '0') ||  "
						+ "       LPAD('', 91, ' '))::varchar(128) registro_header, 1 orden, 0::numeric(18), 0::numeric(18) "
						+ "  FROM tmp_registros_diners  "
						+ " GROUP BY cmp1_nrocomercio, fpresentacion "
						+ "       UNION ALL "
						+ "SELECT (cmp1_nrocomercio || cmp2_tipo || cmp3_nrotarjeta || cmp4_referencia || "
						+ "        cmp5_cuotas || cmp6_cuotas_plan || cmp7_frecuancia_debito || cmp8_importe || "
						+ "        cmp9_periodo_factura || cmp10_filler || cmp11_fecha_vto_pago || cmp12_datos_auxiliare ||cmp13_filler2 )registro_detalle, 2 orden, cliente, cmp4_referencia::numeric(18) "
						+ "  FROM tmp_registros_diners "
						+ " ORDER BY 2, 3, 4; ";

				Iterator iterRegistros = getLista(cQuery, conn).iterator();

				if (iterRegistros.hasNext()) {

					while (iterRegistros.hasNext()) {
						String[] datos = (String[]) iterRegistros.next();
						source += datos[0] + "\r\n";
					}

					control = GeneralBean.generaArchivo(source, archivo, path);

					if (control) {// B

						BigDecimal idgeneracion = GeneralBean
								.getNextValorSequencia(
										"seq_clientestarjetasgeneracion", conn);

						if (idgeneracion != null) {

							// retorno = clientesMovCuotaSetEnviado(
							// idtarjetacredito, new BigDecimal(periodo),
							// fechaPresentacion, "E", idclub,
							// idgeneracion, idempresa, usuarioalt, conn);

							retorno = clientesTarjetasGeneracionCreate(
									idgeneracion, idtarjetacredito, idclub,
									new BigDecimal(periodo), "N",
									fechaPresentacion, idempresa, usuarioalt,
									conn);

							if (retorno.equalsIgnoreCase("OK"))
								// retorno = clientesTarjetasGeneracionCreate(
								// idtarjetacredito, idclub,
								// new BigDecimal(periodo), "N",
								// idempresa, usuarioalt, conn);

								retorno = clientesMovCuotaSetEnviado(
										idtarjetacredito, new BigDecimal(
												periodo), fechaPresentacion,
										"E", idclub, idgeneracion, idempresa,
										usuarioalt, conn);

							try {

								File fileZip = new File(path + archivo);
								GeneralBean.zipFile(fileZip, fileZip
										.getAbsolutePath()
										+ ".zip");

							} catch (Exception io) {
								log.warn("Falla al comrpimir   " + archivo
										+ ": " + io);
							}

							// Archivo de totalizacion -->
							cQuery = ""
									// 20121105 - EJV - Mantis 889 -->
									+ "SELECT  'IMPORTE TOTAL: ' ||     (   SUM (  import_cuo   )::numeric(18, 2)  )::varchar   || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									+ "   FROM tmp_registros_diners";

							setPresentacionArchivoTotales(cQuery, path,
									archivo, conn);

						} else {

							retorno = "Imposible capturar/asignar ID generacion.";

						}

					}// B
					else {

						retorno = "[E2]-No fue posible generar escribir archivo.";

					}// B

				} else {
					retorno = "[E1]-No fue posible recuperar lineas para escribir en archivo";
				}
			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (Exception e) {
			retorno = "[E100]-Se produjo un error al procesar generacion DINERS.";
			log.error("(EX)setPresentacionDINERS: " + e);
		}

		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return retorno;
	}

	public String setEXPresentacionDINERS(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivoCtrl, String archivConsumo, String path,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {

		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));

		Statement statement = null;
		String cQuery = "";
		String entidad = "";
		String source = "";
		boolean control = false;
		String retorno = "OK";
		Connection conn = null;
		int generacion = -1;
		String auxArchivoConsumo = "";

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		conn.setAutoCommit(false);

		try {

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				if (idclub.intValue() == 1) {
					auxArchivoConsumo = "BACOCLUB";
				} else if (idclub.intValue() == 2) {
					auxArchivoConsumo = "KosherWineClub";
				} else {
					auxArchivoConsumo = "ERROR";
				}

				cQuery = ""
						+ "CREATE TEMPORARY TABLE tmp_registros_diners AS "
						// + "CREATE  TABLE tmp_registros_diners AS "

						// 20121029 - EJV - Mantis 889 -->
						+ " SELECT cmp1_dia_consumo, cmp2_mes_consumo, cmp3_ano_consumo, cmp4_cod_autorizacion, cmp5_codigo_movimiento,  "
						+ "             cmp6_filler_13_24, cmp7_socio_diners, cmp8_filler_39_48, cmp9_version, cmp10_cliente_factura, cmp11_filler_89_96,  "
						+ "             cmp12_nrocomercio, cmp13_importe, cmp14_debito_credito, cmp15_filler_119_121, cmp16_nrocuota, cmp17_filler_126,  "
						+ "             cmp17_127_128, import_cuo, cmp_archivo_ctrl, cliente, row_number()  OVER()  tupla "

						+ "   FROM ( "
						// <--

						+ " SELECT to_char(mc.fechamov, 'dd')::varchar(2) cmp1_dia_consumo, "
						+ "             to_char(mc.fechamov, 'mm')::varchar(2) cmp2_mes_consumo, to_char(mc.fechamov, 'yy')::varchar(2) cmp3_ano_consumo, "
						+ "             '0000'::varchar(4) cmp4_cod_autorizacion,  '20'::varchar(2) cmp5_codigo_movimiento, LPAD('', 12, ' ' )::varchar(12) cmp6_filler_13_24, "
						+ "             tj.nrotarjeta::varchar(14) cmp7_socio_diners, LPAD('', 10, '0' )::varchar(10) cmp8_filler_39_48, "
						+ "             (CASE WHEN cu.idclub  = 1 THEN 'BACO'   WHEN cu.idclub = 2 THEN 'KWC0' ELSE 'ERRO' END || to_char('"
						+ fechaPresentacion
						+ "'::DATE, 'ddmmyy'))::varchar(10) cmp9_version, "
						// 20120813 - EJV - Mantis 871 -->
						// +
						// "             LPAD((LPAD(mc.sucursal::varchar, 4, '0') || LPAD(mc.comprob::varchar, 8, '0')), 30, ' ')::varchar(30) cmp10_cliente_factura, "
						// 20121029 - EJV - Mantis 889 -->
						// +
						// "             LPAD((LPAD(ABS(mc.sucursal)::varchar, 4, '0') || LPAD( ABS(mc.comprob)::varchar, 8, '0')), 30, ' ')::varchar(30) cmp10_cliente_factura, "
						+ "              mc.cliente::varchar(30) cmp10_cliente_factura,"
						// <--
						// <--
						+ "             LPAD('', 8, ' ' )::varchar(8) cmp11_filler_89_96, LPAD(co.nrocomercio::varchar, 11,'0')::varchar(11) cmp12_nrocomercio, "
						//
						// +
						// "             LPAD(REPLACE(cu.import_cuo::varchar, '.', ''), 10,'0')::varchar(10) cmp13_importe, "
						// 20121106 - EJV - Mantis 889 -->
						// +
						// "             LPAD(REPLACE(SUBSTRING( (  ( import_cuo   )  )::varchar, 1 , LENGTH((  ( import_cuo   )  )::varchar)-2), '.', ''    ), 10, '0')::VARCHAR(10) cmp13_importe, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "             LPAD( REPLACE(       (  ( import_cuo::numeric(18, 2)   )  )::varchar   , '.', ''    ), 10, '0')::VARCHAR(10) cmp13_importe, "
						+ "             LPAD( REPLACE(       (  ( saldo_cuo::numeric(18, 2)   )  )::varchar   , '.', ''    ), 10, '0')::VARCHAR(10) cmp13_importe, "
						// <-
						// <-
						//
						+ "             'D'::varchar(1) cmp14_debito_credito, LPAD('', 3, ' ' )::varchar(3) cmp15_filler_119_121, "
						+ "             LPAD('', 4, ' ' )::varchar(4) cmp16_nrocuota, LPAD('', 1, ' ' )::varchar(3) cmp17_filler_126, "
						// 20121106 - EJV - Mantis 889 -->
						// +
						// "             '00'::varchar(2) cmp17_127_128, cu.import_cuo,  "

						// 20121119 - EJV - Mantis 889 -->
						// +
						// "             '00'::varchar(2) cmp17_127_128, cu.import_cuo::numeric(18, 2) import_cuo,  "
						+ "             '00'::varchar(2) cmp17_127_128, cu.saldo_cuo::numeric(18, 2) import_cuo,  "
						// <--

						// <--
						+ "            RPAD( '"
						+ auxArchivoConsumo
						+ "' , 20, ' ')::varchar(20) cmp_archivo_ctrl,  "

						// 20121029 - EJV - Mantis 889 -->
						+ "             mc.cliente  "
						// <--

						+ "   FROM clientesmovcuota cu "
						// 20120813 - EJV - Mantis 871 -->
						// +
						// "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa "
						+ "             INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						+ "             INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						// <--
						+ "             INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						+ "             INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
						// 20120810 - EJV - Mantis 871 -->
						+ "             LEFT JOIN ( "
						+ "                             SELECT idestadocliente, idcliente, idempresa "
						+ "                                FROM clientesestadoshoy  "
						+ "                              WHERE ( "
						+ "                                           (idestado = 2 AND idmotivo = 60) OR "
						+ "                                           (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                           (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                           (idestado = 6 AND idmotivo = 41) "
						+ "                                           )  "
						+ "                                ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// <--
						+ " WHERE cu.idclub =  "
						+ idclub
						+ "		                      AND tj.idtarjetacredito = "
						+ idtarjetacredito
						+ "		                      AND tj.idempresa = "
						+ idempresa
						// 20120810 - EJV - Mantis 871 -->
						+ "     AND eout.idestadocliente IS NULL"
						+ "     AND cu.periodo_cuo <= "
						+ periodo
						+ "     AND  cu.estado_cuo IN ('P', 'R')   "
						// +
						// "                             AND (  ( cu.periodo_cuo = "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
						// + periodo
						// +
						// "                                          AND  cu.estado_cuo='R' )  ) "
						// <--
						+ "  ORDER BY mc.cliente 	 " + "  ) dinners 	 ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);

				// 20120822 - EJV - Mantis 878 -->

				cQuery = ""
						+ " UPDATE tmp_registros_diners "
						+ "    SET cmp10_cliente_factura =  LPAD(ref || LPAD(entidad.cliente::varchar, 8, '0' ), 30, ' ' )  "
						+ "   FROM ( "
						+ "         SELECT row_number()  OVER() AS registro, ref, cliente    "
						+ "            FROM ( "
						+ " 	                   SELECT (LPAD( GENERATE_SERIES(1, COUNT(cliente))::VARCHAR, 4, '0' )) AS ref, cliente  "
						+ " 	                      FROM tmp_registros_diners  "
						+ " 	                   GROUP BY cliente   "
						+ " 	                   ORDER BY cliente "
						+ " 	         ) sub "
						+ "        ) entidad "
						+ " WHERE tmp_registros_diners.tupla = entidad.registro AND tmp_registros_diners.cliente =  entidad.cliente;  ";

				statement = conn.createStatement();
				control = statement.execute(cQuery);
				// <--

				cQuery = ""
						+ "SELECT ('*CTL' || cmp_archivo_ctrl ||  cmp9_version ||  LPAD(COUNT(1)::varchar, 7,'0')::varchar(7) || "
						// +
						// "              LPAD(REPLACE(SUM(import_cuo)::varchar, '.', ''), 15, '0')  "
						// 20121106 - EJV - Mantis 889 -->
						// +
						// "              LPAD(  REPLACE(SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2), '.', ''    ), 15, '0')   "
						+ "              LPAD(  REPLACE(  (SUM ( import_cuo::numeric(18,2)   )::numeric(18, 2 )  )::varchar, '.', ''    ), 15, '0')   "
						// <--
						// 
						+ "   )::varchar(56) registro_ctrl "
						+ "  FROM tmp_registros_diners "
						+ " GROUP BY cmp_archivo_ctrl, cmp9_version; ";

				Iterator iterRegistros = getLista(cQuery, conn).iterator();

				if (iterRegistros.hasNext()) {

					while (iterRegistros.hasNext()) {
						String[] datos = (String[]) iterRegistros.next();
						source += datos[0] + "\r\n";
					}

					control = GeneralBean.generaArchivo(source, archivoCtrl,
							path);

					if (control) {// B

						control = false;
						source = "";

						cQuery = ""

								+ "SELECT (cmp1_dia_consumo || cmp2_mes_consumo || cmp3_ano_consumo || cmp4_cod_autorizacion || cmp5_codigo_movimiento || cmp6_filler_13_24 ||  "
								+ "           cmp7_socio_diners || cmp8_filler_39_48 || cmp9_version || cmp10_cliente_factura || cmp11_filler_89_96 || cmp12_nrocomercio ||  "
								+ "           cmp13_importe || cmp14_debito_credito || cmp15_filler_119_121 || cmp16_nrocuota || cmp17_filler_126 || cmp17_127_128 )::varchar AS registro_consumo "
								+ " FROM tmp_registros_diners ORDER BY cliente ASC, cmp10_cliente_factura	  ";

						iterRegistros = getLista(cQuery, conn).iterator();

						while (iterRegistros.hasNext()) {
							String[] datos = (String[]) iterRegistros.next();
							source += datos[0] + "\r\n";
						}

						archivConsumo = archivConsumo.replace("#ARCHIVO#",
								auxArchivoConsumo);
						control = GeneralBean.generaArchivo(source,
								archivConsumo, path);

						if (control) {// C

							BigDecimal idgeneracion = GeneralBean
									.getNextValorSequencia(
											"seq_clientestarjetasgeneracion",
											conn);

							if (idgeneracion != null) {

								// retorno = clientesMovCuotaSetEnviado(
								// idtarjetacredito, new BigDecimal(
								// periodo), fechaPresentacion,
								// "E", idclub, idgeneracion, idempresa,
								// usuarioalt,
								// conn);

								retorno = clientesTarjetasGeneracionCreate(
										idgeneracion, idtarjetacredito, idclub,
										new BigDecimal(periodo), "N",
										fechaPresentacion, idempresa,
										usuarioalt, conn);

								if (retorno.equalsIgnoreCase("OK"))
									// retorno =
									// clientesTarjetasGeneracionCreate(
									// idtarjetacredito, idclub,
									// new BigDecimal(periodo), "N",
									// idempresa, usuarioalt, conn);

									retorno = clientesMovCuotaSetEnviado(
											idtarjetacredito, new BigDecimal(
													periodo),
											fechaPresentacion, "E", idclub,
											idgeneracion, idempresa,
											usuarioalt, conn);

								try {

									File fileZip = new File(path + archivoCtrl);
									GeneralBean.zipFile(fileZip, fileZip
											.getAbsolutePath()
											+ ".zip");

									fileZip = new File(path + archivConsumo);
									GeneralBean.zipFile(fileZip, fileZip
											.getAbsolutePath()
											+ ".zip");
								} catch (Exception io) {
									log.warn("Falla al comrpimir   "
											+ archivoCtrl + " /  "
											+ archivoCtrl + ": " + io);
								}

								// Archivo de totalizacion -->
								cQuery = ""
								// 20121106 - EJV - Mantis 889 -->
										// +
										// "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2)::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
										+ "SELECT  'IMPORTE TOTAL: ' ||     (  ( SUM ( import_cuo::numeric(18, 2)   )::numeric(18, 2)  )::varchar  )::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
										// <--
										+ "   FROM tmp_registros_diners";

								setPresentacionArchivoTotales(cQuery, path,
										archivConsumo, conn);
								// <--

							} else {

								retorno = "Imposible capturar/asignar ID generacion.";
							}

						}// C
						else {
							retorno = "[E3]-No fue posible generar escribir archivo de consumo Diners.";
						}// C

					}// B
					else {

						retorno = "[E2]-No fue posible generar escribir archivo de control Diners.";

					}// B

				} else {
					retorno = "[E1]-No fue posible recuperar lineas para escribir en archivo";
				}
			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (Exception e) {
			retorno = "[E100]-Se produjo un error al procesar generacion DINERS.";
			log.error("(EX)setPresentacionDINERS: " + e);
		}

		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return retorno;
	}

	/*
	 * CABAL
	 */

	public String setPresentacionCABAL(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaPresentacion,
			String archivo, String path, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		Calendar cal = new GregorianCalendar();
		cal.setTimeInMillis(fechaPresentacion.getTime());
		String periodo = (cal.get(Calendar.YEAR) + GeneralBean.strZero((cal
				.get(Calendar.MONTH) + 1)
				+ "", 2));

		Statement statement = null;
		String cQuery = "";
		String entidad = "";
		String source = "";
		boolean control = false;
		String retorno = "OK";
		Connection conn = null;
		int generacion = -1;

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "[E1000]-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		conn.setAutoCommit(false);

		try {

			entidad = ""
					+ "( "
					+ "  SELECT DISTINCT ON ( idtarjetacredito) * FROM clientestarjetasgeneracion  "
					+ "   WHERE idtarjetacredito = " + idtarjetacredito
					+ "        AND idclub =  " + idclub + " AND periodo =    "
					+ periodo + " AND idempresa =    " + idempresa
					+ "   ORDER BY idtarjetacredito, idgeneracion DESC "
					+ ")		entidad	 ";

			generacion = (int) getTotalEntidadFiltro(entidad,
					"  WHERE regenerar = 'N'  ", idempresa);

			// Si no existe generacion o la misma esta marcada para regenerar.
			if (generacion == 0) {// A

				cQuery = ""
						+ " CREATE TEMPORARY TABLE tmp_registros_cabal AS "
						+ "   SELECT LPAD(mc.cliente::varchar, 9, '0' )::varchar(9) cmp1_socio_cliente, "
						+ "                tj.nrotarjeta::varchar(16) cmp2_nrotarjeta, "
						//
						// +
						// "                LPAD(REPLACE(cu.import_cuo::varchar, '.', ''), 11,'0')::varchar(11) cmp3_importe, "
						// 20121106 - EJV - Mantis 889 -->
						// +
						// "               LPAD(REPLACE(SUBSTRING( (  ( import_cuo   )  )::varchar, 1 , LENGTH((  ( import_cuo   )  )::varchar)-2), '.', ''    ), 11, '0')::varchar(11) cmp3_importe, "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "               LPAD(REPLACE(    (  ( import_cuo::numeric(18, 2)   )  )::varchar , '.', ''    ), 11, '0')::varchar(11) cmp3_importe, "
						+ "               LPAD(REPLACE(    (  ( saldo_cuo::numeric(18, 2)   )  )::varchar , '.', ''    ), 11, '0')::varchar(11) cmp3_importe, "
						// <--

						// <--
						//
						+ "                LPAD('', 82, ' ' )::varchar(82) cmp4_filler_37_118, "
						+ "                RPAD((CASE WHEN cu.idclub  = 1 THEN 'Bacoclub '   WHEN cu.idclub = 2 THEN 'KosherWineClub ' ELSE 'ERROR' END) || to_char(mc.fechamov, 'mm/yyyy') , 25, ' ')::varchar(25) cmp5_leyenda_resumen, "
						+ "                to_char(current_date, 'ddmmyy')::varchar(6) cmp6_fecha_presentacion, "
						+ "                LPAD('', 27, ' ' )::varchar(27) cmp7_filler_150_176, "
						+ "                LPAD(co.nrocomercio::varchar, 11,'0')::varchar(11) cmp8_nrocomercio, "
						+ "                'P'::varchar(1) cmp9_codigo_moneda, "
						+ "                LPAD('', 21, ' ' )::varchar(21) cmp10_filler_189_209, "
						+ "                LPAD((row_number() OVER() )::varchar, 4, '0' )::varchar(4) cmp11_nrocupon, "
						+ "                LPAD('', 10, ' ' )::varchar(10) cmp12_filler, "
						+ "                '01'::varchar(2) cmp13_codigo_operacion, "
						+ "                LPAD('', 15, '0' )::varchar(15) cmp14_reservado_nrocontribuyente, "
						// 20121106 - EJV - Mantis 889 -->
						// + "                cu.import_cuo , mc.cliente  "
						// 20121119 - EJV - Mantis 889 -->
						// +
						// "                cu.import_cuo::numeric(18, 2) import_cuo , mc.cliente  "
						+ "                cu.saldo_cuo::numeric(18, 2) import_cuo , mc.cliente  "
						// <--
						+ "      FROM clientesmovcuota cu "
						// 20120813 - EJV - Mantis 871 -->
						// +
						// "                INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa "
						+ "                INNER JOIN clientesmovcli mc ON ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa  AND mc.tipomov <=2 "
						+ "                INNER JOIN clientesestadoshoy eh ON mc.cliente = eh.idcliente AND mc.idempresa = eh.idempresa "
						// <--
						+ " 	             INNER JOIN clientetarjetascredito  tj ON cu.idtarjeta_cuo = tj.idtarjeta AND cu.idempresa = tj.idempresa "
						+ " 	             INNER JOIN clientesclubcomerciotarjeta co ON cu.idclub = co.idclub AND cu.idempresa = co.idempresa  "
						+ " 	                        AND tj.idtarjetacredito =  co.idtarjeta AND tj.idempresa = co.idempresa "
						// 20120810 - EJV - Mantis 871 -->
						+ "                   LEFT JOIN ( "
						+ "                                      SELECT idestadocliente, idcliente, idempresa "
						+ "                                         FROM clientesestadoshoy  "
						+ "                                       WHERE ( "
						+ "                                                    (idestado = 2 AND idmotivo = 60) OR "
						+ "                                                    (idestado = 4 AND idmotivo = 64) OR  "
						+ "                                                    (idestado = 4 AND idmotivo = 66) OR  "
						+ "                                                    (idestado = 6 AND idmotivo = 41) "
						+ "                                                   )  "
						+ "                                     ) eout ON eh.idestadocliente = eout.idestadocliente AND eh.idempresa = eout.idempresa "
						// <--
						+ "    WHERE cu.idclub =  "
						+ idclub
						+ "		                      AND tj.idtarjetacredito = "
						+ idtarjetacredito
						+ "		                      AND tj.idempresa = "
						+ idempresa
						// <--

						// 20120810 - EJV - Mantis 871 -->
						+ "     AND eout.idestadocliente IS NULL"
						+ "     AND cu.periodo_cuo <= " + periodo
						+ "     AND  cu.estado_cuo IN ('P', 'R')   "
						// 20121030 - EJV - Mantis 889 -->
						+ " ORDER BY mc.cliente ASC "
				// <--
				// + "                             AND (  ( cu.periodo_cuo = "
				// + periodo
				// +
				// "                                          AND  cu.estado_cuo='P' )   OR ( cu.periodo_cuo < "
				// + periodo
				// +
				// "                                          AND  cu.estado_cuo='R' )  )  "
				// <--
				;

				statement = conn.createStatement();
				control = statement.execute(cQuery);

				cQuery = ""
						+ " SELECT cmp1_socio_cliente || cmp2_nrotarjeta || cmp3_importe || cmp4_filler_37_118 ||  "
						+ "              cmp5_leyenda_resumen || cmp6_fecha_presentacion || cmp7_filler_150_176 || cmp8_nrocomercio || "
						+ "              cmp9_codigo_moneda || cmp10_filler_189_209 || cmp11_nrocupon ||  "
						+ "              cmp12_filler || cmp13_codigo_operacion || cmp14_reservado_nrocontribuyente "
						+ "   FROM tmp_registros_cabal "
						// 20121030 - EJV - Mantis 889 -->
						+ " ORDER BY cliente ASC ";
				// <--
				Iterator iterRegistros = getLista(cQuery, conn).iterator();

				if (iterRegistros.hasNext()) {

					while (iterRegistros.hasNext()) {
						String[] datos = (String[]) iterRegistros.next();
						source += datos[0] + "\r\n";
					}

					control = GeneralBean.generaArchivo(source, archivo, path);

					if (control) {// B

						BigDecimal idgeneracion = GeneralBean
								.getNextValorSequencia(
										"seq_clientestarjetasgeneracion", conn);

						if (idgeneracion != null) {
							// retorno =
							// clientesMovCuotaSetEnviado(idtarjetacredito,
							// new BigDecimal(periodo), fechaPresentacion,
							// "E", idclub, idgeneracion, idempresa, usuarioalt,
							// conn);

							retorno = clientesTarjetasGeneracionCreate(
									idgeneracion, idtarjetacredito, idclub,
									new BigDecimal(periodo), "N",
									fechaPresentacion, idempresa, usuarioalt,
									conn);

							if (retorno.equalsIgnoreCase("OK"))

								// retorno = clientesTarjetasGeneracionCreate(
								// idtarjetacredito, idclub, new BigDecimal(
								// periodo), "N", idempresa,
								// usuarioalt, conn);

								retorno = clientesMovCuotaSetEnviado(
										idtarjetacredito, new BigDecimal(
												periodo), fechaPresentacion,
										"E", idclub, idgeneracion, idempresa,
										usuarioalt, conn);

							try {

								File fileZip = new File(path + archivo);
								GeneralBean.zipFile(fileZip, fileZip
										.getAbsolutePath()
										+ ".zip");
							} catch (Exception io) {
								log.warn("Falla al comrpimir   " + archivo
										+ ": " + io);
							}

							// Archivo de totalizacion -->
							cQuery = ""
							// 20121106 - EJV - Mantis 889 -->
									// +
									// "SELECT  'IMPORTE TOTAL: ' || SUBSTRING((SUM ( import_cuo   )  )::varchar, 1 , LENGTH((SUM ( import_cuo   )  )::varchar)-2)::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									+ "SELECT  'IMPORTE TOTAL: ' || (  (SUM ( import_cuo::numeric(18, 2)   )  )::numeric(18, 2) )::varchar || CHR(13) || CHR(10) ||'CANTIDAD DE REGISTROS: ' || COUNT(1)::varchar "
									// <--
									+ "   FROM tmp_registros_cabal ";

							setPresentacionArchivoTotales(cQuery, path,
									archivo, conn);
							// <--

						} else {
							retorno = "Imposible capturar/asignar ID generacion";
						}

					}// B
					else {

						retorno = "[E2]-No fue posible generar escribir archivo.";

					}// B

				} else {
					retorno = "[E1]-No fue posible recuperar lineas para escribir en archivo";
				}
			}// A
			else {
				retorno = "[E0]-La generacion para la tarjeta/periodo ya fue ejecutada con anterioridad. Avise a sistemas.";
			}// A

		} catch (Exception e) {
			retorno = "[E100]-Se produjo un error al procesar generacion CABAL.";
			log.error("(EX)setPresentacionCABAL: " + e);
		}

		// --
		if (retorno.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();
		// --

		conn.close();

		return retorno;

	}

	/**
	 * Metodos para la entidad: clientesMovcliRemitosLog Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Tue Aug 23 14:12:37 ART 2011
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesMovcliRemitosLogAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idlog,idciclofact,descripcion,remitossel,idcliente,idcondicion,idtarjeta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM clientesmovcliremitoslog WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovcliRemitosLogAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesMovcliRemitosLogOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idlog,idciclofact,descripcion,remitossel,idcliente,idcondicion,idtarjeta,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM clientesmovcliremitoslog WHERE (UPPER(idcliente::varchar) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  DESC LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovcliRemitosLogOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// 20110914 - EJV - Mantis 776 -- >

	public List getClientesTarjetasPresentacionRecepcionXClie(
			BigDecimal idcliente, BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechaenvio,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				// 20121119 - EJV - Mantis 889 -->
				// +
				// "SELECT idmovcuo, numero_cuo, import_cuo, idcliente, razon, nrotarjeta, comprobante, importe, saldo, -1 idmotivorechazo "
				+ "SELECT idmovcuo, numero_cuo, saldo_cuo, idcliente, razon, nrotarjeta, comprobante, importe, saldo, -1 idmotivorechazo "
				// <--
				+ "  FROM vclientesmovcuorecepcion "
				+ "WHERE fecha_envio_cuo = '" + fechaenvio + "'::date "
				+ "  AND estado_cuo = 'E' " + "  AND idtarjetacredito =  "
				+ idtarjetacredito + "  AND idcliente =  " + idcliente
				+ "  AND idclub =   " + idclub + "  AND idempresa =   "
				+ idempresa;

		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasPresentacionRecepcionXClie(...)  "
							+ ex);
		}
		return vecSalida;
	}

	public List getClientesTarjetasPresentacionRecepcionPK(BigDecimal idmovcuo,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				// 20121119 - EJV - Mantis 889 -->
				// +
				// "SELECT idmovcuo, numero_cuo, import_cuo, idcliente, razon, nrotarjeta, comprobante, importe, saldo, -1 idmotivorechazo "
				+ "SELECT idmovcuo, numero_cuo, saldo_cuo, idcliente, razon, nrotarjeta, comprobante, importe, saldo, -1 idmotivorechazo "
				// <--
				+ "   FROM vclientesmovcuorecepcion " + "WHERE idmovcuo =  "
				+ idmovcuo + "  AND idempresa =   " + idempresa;

		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasPresentacionRecepcionPK(...)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: clientesTarjetasMotivos Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Sep 15 09:13:55 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesTarjetasMotivosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idmotivorechazo,motivorechazo,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM clientestarjetasmotivos WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasMotivosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public String clientesPresentacionGenerarRechazos(Hashtable htRechazos,
			BigDecimal idempresa, String usuarioact) throws EJBException,
			SQLException {

		String salida = "OK";
		Enumeration en;
		// --
		String estado_cuo = "R";
		BigDecimal idestadoinactivo = new BigDecimal(4);
		BigDecimal idmotivoestadocobranza = new BigDecimal(15);
		// --
		BigDecimal idmovcuo = null;
		BigDecimal idmotivorechazo = null;
		BigDecimal idcliente = null;
		java.sql.Date fechadesde = null;
		java.sql.Timestamp fechabaja = null;
		String observaciones = "";
		String comprobante = "";

		Connection conn = null;

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		// <--

		if (conn == null)
			return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		try {

			conn.setAutoCommit(false);
			fechadesde = new java.sql.Date(Calendar.getInstance()
					.getTimeInMillis());

			fechabaja = new java.sql.Timestamp(fechadesde.getTime());

			if (htRechazos != null && !htRechazos.isEmpty()) {

				en = htRechazos.keys();

				while (en.hasMoreElements()) {

					// idmovcuo, numero_cuo, import_cuo, idcliente, razon,
					// nrotarjeta, comprobante, importe, saldo, -1
					// idmotivorechazo
					String key = en.nextElement().toString();
					String[] rechazo = (String[]) htRechazos.get(key);

					idmovcuo = new BigDecimal(rechazo[0]);
					idcliente = new BigDecimal(rechazo[3]);
					idmotivorechazo = new BigDecimal(rechazo[9]);
					comprobante = rechazo[6];

					for (int g = 0; g < rechazo.length; g++) {
						log.info(" rechazo[" + g + "]: " + rechazo[g]);
					}

					salida = clientesMovCuotaSetRechazo(idmovcuo, estado_cuo,
							idmotivorechazo, idempresa, usuarioact, conn);

					if (salida.equalsIgnoreCase("OK")) {

						observaciones = "RECHAZO DE PRESENTACION: "
								+ comprobante + "[" + idmovcuo + "]";

						salida = setEstadoClienteCreate(new BigDecimal(-1),
								idcliente, idestadoinactivo,
								idmotivoestadocobranza, fechadesde, null,
								fechabaja, observaciones, usuarioact,
								idempresa, conn);

						log.info("ANTES DE GENERAR TK");

						if (salida.equalsIgnoreCase("OK")) {

							// TODO: GENERAR TIKET WORKFLOW

							log.info("GENERANDO TK");

							String cQuery = ""
									+ "SELECT ' * CUOTA: ' || LPAD(numero_cuo::varchar, 2, '0') || CHR(13)  ||   ' * CLIENTE: ' || cl.idcliente ::varchar || ' - ' || cl.razon || CHR(13)  || "
									+ "            ' * MOTIVO RECHAZO: ' ||  mr.motivorechazo  || CHR(13)  || "
									// 20121119 - EJV - Mantis 889 -->
									// +
									// "            ' * IMPORTE CUOTA: ' ||  cu.import_cuo::varchar  || CHR(13)  || "
									+ "            ' * IMPORTE CUOTA: ' ||  cu.saldo_cuo::varchar  || CHR(13)  || "
									// <--
									+ "            ' * COMPROBANTE: ' ||  mc.tipomovs || '-' || LPAD(mc.sucursal::varchar, 4, '0000') || '-' ||  LPAD(mc.comprob::varchar, 8, '0000')  || CHR(13)  || "
									+ "            ' * IMPORTE COMPROBANTE: ' ||  mc.importe::varchar  || CHR(13)  || "
									+ "            ' * TARJETA: ' || ta.nrotarjeta::varchar || ' - ' || tm.tarjetacredito || CHR(13)  || "
									+ "            ' * TELEFONOS: ' ||  fu_telefonos(mc.cliente, mc.idempresa)  || CHR(13)  "
									+ "  FROM clientesmovcuota  cu  "
									+ "            INNER JOIN clientesmovcli mc ON cu.ninter_cuo = mc.nrointerno AND cu.idempresa = mc.idempresa "
									+ "            INNER JOIN clientestarjetasmotivos mr  ON cu.idmotivorechazo = mr.idmotivorechazo AND cu.idempresa = mr.idempresa "
									+ "            INNER JOIN clientetarjetascredito ta ON cu.idtarjeta_cuo = ta.idtarjeta AND cu.idempresa = ta.idempresa "
									+ "            INNER JOIN clientetarjetascreditomarcas tm ON ta.idtarjetacredito = tm.idtarjetacredito AND tm.idempresa = tm.idempresa "
									+ "            INNER JOIN clientesclientes cl ON mc.cliente = cl.idcliente AND mc.idempresa = cl.idempresa "
									+ " WHERE cu.idmovcuo =  " + idmovcuo
									// + "     AND  cu.estado_cuo = 'E'  "
									+ "     AND cu.idempresa =   " + idempresa;

							Iterator iterDatosRechazo = getLista(cQuery, conn)
									.iterator();

							if (iterDatosRechazo != null) {

								if (iterDatosRechazo.hasNext()) {

									String[] datosRechazo = (String[]) iterDatosRechazo
											.next();

									salida = GeneralBean.ticketsCreate(
											new BigDecimal(19), null,
											idcliente,
											"RECHAZO DE TARJETA CLIENTE: "
													+ idcliente + " - ["
													+ idmovcuo + "]",
											datosRechazo[0], new BigDecimal(2),
											idempresa, usuarioact, true, conn);

								} else {
									salida = "No fue posible recuperar datos para rechazo de comprobante: "
											+ comprobante
											+ "["
											+ idmovcuo
											+ "]";
									break;
								}
							} else {
								salida = "Error al recuperar datos para rechazo de comprobante: "
										+ comprobante + "[" + idmovcuo + "]";
								break;
							}

						} else
							break;

					} else
						break;

				}

			} else
				salida = "No existen rechazos cargados.";

		} catch (SQLException e) {

			salida = "(SQLE) No fue posible generar rechazos.";
			log.error("clientesPresentacionGenerarRechazos: " + e);

		} catch (Exception e) {

			salida = "(EX) No fue posible generar rechazos.";
			log.error("clientesPresentacionGenerarRechazos: " + e);

		}

		if (salida.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.setAutoCommit(true);
		conn.close();
		return salida;
	}

	// Aceptaciones

	public BigDecimal getClientesTarjetasPresentacionTotalAceptar(
			BigDecimal idclub, BigDecimal idtarjetacredito,
			java.sql.Date fechaenvio, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				// 20121119 - EJV - Mantis 889 -->
				// +
				// "SELECT COALESCE(SUM(import_cuo), 0.00 )  FROM vclientesmovcuorecepcion "
				+ "SELECT COALESCE(SUM(saldo_cuo), 0.00 )  FROM vclientesmovcuorecepcion "
				// <--
				+ "WHERE fecha_envio_cuo = '" + fechaenvio + "'::date "
				+ "    AND estado_cuo = 'E'   AND idtarjetacredito =  "
				+ idtarjetacredito + "  AND idclub =   " + idclub
				+ "  AND idempresa =   " + idempresa;

		BigDecimal totalPendienteAceptar = new BigDecimal(0);
		List vecSalida = new ArrayList();

		try {

			vecSalida = getLista(cQuery);

			if (!vecSalida.isEmpty()) {

				String[] totales = (String[]) vecSalida.get(0);
				totalPendienteAceptar = new BigDecimal(totales[0]);

			} else
				totalPendienteAceptar = new BigDecimal(-1);

		} catch (Exception ex) {
			totalPendienteAceptar = new BigDecimal(-10);
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasPresentacionTotalAceptar(...)  "
							+ ex);
		}
		return totalPendienteAceptar;
	}

	// 20110920 - EJV - Mantis 776 -->

	public String cobranzasMovClientePresentacionTarjeta(BigDecimal idclub,
			BigDecimal idtarjetacredito, java.sql.Date fechapresentacion,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		String[] datosCliente = null;
		BigDecimal nrointernomovcliente = null;
		BigDecimal nrocobranza = null;
		BigDecimal nroint_mt = null;
		BigDecimal com_cobra = new BigDecimal(0);
		// 20100427 - EJV -->

		// ACTUAL
		BigDecimal idcliente = null;
		BigDecimal idmovcuo = null;
		BigDecimal idcobrador = null;
		BigDecimal importe_cuo_cobranza = null;
		BigDecimal nrointerno_cuo = null;
		BigDecimal condicion = null;
		String comprobante = null;
		int numero_cuo = 0;
		// 2012112 - EJV - Mantis 889 -->
		BigDecimal saldo_comprobante = new BigDecimal(0);
		BigDecimal saldo_cobranza = new BigDecimal(0);
		BigDecimal auxSaldoCobranza = new BigDecimal(0);
		BigDecimal importeCancela = new BigDecimal(0);
		boolean cobranzaCancelaComprob = true;
		// <--

		java.sql.Date fechamov = null;
		String observaciones = "";
		java.sql.Date fecha_mt = fechamov;
		java.sql.Date fclear_mt = fechamov;
		BigDecimal nrodoc_mt = null;
		// --
		String cartera_mt = "";
		String tipocart_mt = "";
		BigDecimal cuenta_mt = null;
		BigDecimal idcencosto = null;
		BigDecimal idcencosto1 = null;
		// --

		String cQuery = "";

		Iterator iter = null;

		// 20110622 - EJV - Factuaracion FE-CF-MA -->
		String condicionletra = "";
		// <--
		// <--

		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);

		if (conn == null)
			return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		log.info("INICIA MOV. POR PRESNTACION -->.");
		try {

			conn.setAutoCommit(false);

			Calendar cal = new GregorianCalendar();

			cal.set(Calendar.MILLISECOND, 0);
			cal.set(Calendar.SECOND, 0);
			cal.set(Calendar.MINUTE, 0);
			cal.set(Calendar.HOUR_OF_DAY, 0);

			fechamov = new java.sql.Date(cal.getTime().getTime());

			cQuery = ""
					+ "	SELECT cif.identificador AS cartera_mt, cti.tipomov AS tipcart_mt, cif.cuenta AS cuenta_mt, cif.idcencosto, cif.idcencosto1 "
					+ " 	   FROM clientetarjetascreditomarcas tjm   "
					+ "	             INNER JOIN cajaidentificadores cif ON tjm.ididentificador = cif.ididentificador AND tjm.idempresa = cif.idempresa "
					+ "  	             INNER JOIN cajatipoidentificadores cti ON cif.idtipoidentificador = cti.idtipoidentificador AND cif.idempresa = cti.idempresa "
					+ "	 WHERE tjm.idtarjetacredito = " + idtarjetacredito
					+ " 	      AND tjm.idempresa = " + idempresa;

			iter = getLista(cQuery, conn).iterator();

			if (iter != null && iter.hasNext()) {// 0

				String[] datosIngreso = (String[]) iter.next();

				cartera_mt = datosIngreso[0];
				tipocart_mt = datosIngreso[1];
				cuenta_mt = new BigDecimal(datosIngreso[2]);
				idcencosto = new BigDecimal(datosIngreso[3]);
				idcencosto1 = new BigDecimal(datosIngreso[4]);

				cQuery = ""
						+ "SELECT idcliente, razon, nrointerno, fecha_envio_cuo, idmovcuo, numero_cuo, import_cuo, saldo_cuo, idtarjetacredito, nrotarjeta, comprobante, idcondicion_cuo, "
						// 20121102 - EJV - Mantis 889 -->
						+ "             saldo  saldo_comprobante "
						// <--
						+ "   FROM vclientesmovcuorecepcion "
						+ " WHERE idclub = " + idclub
						+ "     AND estado_cuo = 'E' "
						+ "     AND idtarjetacredito = " + idtarjetacredito
						+ "     AND fecha_envio_cuo = '" + fechapresentacion
						+ "'::DATE" + "     AND idempresa = " + idempresa
						+ " ORDER BY nrointerno ASC "
				// --> SOLO TEST
				// + " LIMIT 3"
				// <--
				;

				GeneralBean.setLockedTable("globalcontadores",
						"ACCESS EXCLUSIVE", conn);

				iter = getLista(cQuery, conn).iterator();

				while (iter != null && iter.hasNext()) {// 1

					String[] datosAceptacion = (String[]) iter.next();

					idcliente = new BigDecimal(datosAceptacion[0]);
					nrointerno_cuo = new BigDecimal(datosAceptacion[2]);
					idmovcuo = new BigDecimal(datosAceptacion[4]);
					numero_cuo = Integer.parseInt(datosAceptacion[5]);
					// 20121119 - EJV - Mantis 889 -->
					// importe_cuo_cobranza = new
					// BigDecimal(datosAceptacion[6]);
					importe_cuo_cobranza = new BigDecimal(datosAceptacion[7]);
					// <--
					comprobante = datosAceptacion[10];
					condicion = new BigDecimal(datosAceptacion[11]);

					condicionletra = getClienteLetraIva(idcliente, idempresa);
					datosCliente = (String[]) getClientesClientesPK(idcliente,
							idempresa).get(0);
					nrocobranza = GeneralBean.getContador("nrointernocobranza",
							idempresa, conn);

					nrointernomovcliente = GeneralBean.getContador(
							"nrointernomovcliente", idempresa, conn);

					// 20121102 - EJV - Mantis 889 -->
					cobranzaCancelaComprob = true;
					saldo_cobranza = new BigDecimal(0);
					importeCancela = importe_cuo_cobranza;
					// --
					saldo_comprobante = new BigDecimal(datosAceptacion[12]);
					auxSaldoCobranza = saldo_comprobante
							.subtract(importe_cuo_cobranza);

					if (auxSaldoCobranza.signum() < 0) {
						saldo_cobranza = auxSaldoCobranza.abs();
						importeCancela = importeCancela
								.subtract(saldo_cobranza);
						if (saldo_comprobante.doubleValue() < 0.009)
							cobranzaCancelaComprob = false;
					}

					log
							.info("****************************************************");
					log.info("nrointerno_cuo: " + nrointerno_cuo);
					log.info("idmovcuo: " + idmovcuo);
					log.info("comprobante: " + comprobante);
					log.info("saldo_comprobante: " + saldo_comprobante);
					log.info("importe_cuo_cobranza: " + importe_cuo_cobranza);
					log.info("saldo_cobranza: " + saldo_cobranza);
					log.info("importeCancela: " + importeCancela);
					log.info("importeCancela.add(saldo_cobranza): "
							+ importeCancela.add(saldo_cobranza));
					log.info("aplicaCobranza: " + cobranzaCancelaComprob);
					log
							.info("-----------------------------------------------------------------------------");

					// <--

					// COMPROBANTES PARA APLICAR
					log.info("PRESENTACION SALDO: ");
					observaciones = comprobante + " / CUOTA: " + numero_cuo;

					if (cobranzaCancelaComprob) {

						salida = clientesMovCliUpdateSaldo(nrointerno_cuo,
						// 20121102 - EJV - Mantis 889 -->
								// importe_cuo_cobranza.negate(),
								importeCancela.negate(),
								// <--
								usuarioalt, idempresa, conn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

						// CANCELACION DE COMPROBANTES
						log.info("PRESENTACION CAN: ");
						salida = clientesCancClieCreate(
								nrointerno_cuo,
								nrointernomovcliente,
								// 20121102 - EJV - Mantis 889 -->
								// importe_cuo_cobranza,
								importeCancela,
								// <--
								new Timestamp(fechamov.getTime()), usuarioalt,
								idempresa, conn);

						if (!salida.equalsIgnoreCase("OK"))
							break;
					} else {
						observaciones += " (No se aplico, comprobante no presenta saldo.)";
					}

					// MOVIENTO DE CLIENTE
					log.info("PRESENTACION MC:  ");

					salida = clientesMovCliCreate(
							idcliente,
							new Timestamp(fechamov.getTime()),
							new BigDecimal(0),
							nrocobranza,
							null,
							new BigDecimal(4),
							"COB",
							// 20121102 - EJV - Mantis 889 -->
							// new BigDecimal(0),
							saldo_cobranza,
							// <--
							importe_cuo_cobranza, new BigDecimal(1),
							new BigDecimal(1), null, null, condicion,
							nrointernomovcliente, null, com_cobra, idcobrador,
							null, null, null, null, null, null, observaciones,
							condicionletra,
							// 20121005 - EJV - Mantis 882 -->
							null,
							// <--
							usuarioalt, idempresa, conn);

					if (!salida.equalsIgnoreCase("OK"))
						break;
					// { // B

					// APLICACIONES
					log.info("PRESENTACION AP: ");
					salida = cajaAplicaciCreate("COB", nrocobranza,
							nrointernomovcliente, "", new BigDecimal(0),
							usuarioalt, idempresa, conn);

					if (!salida.equalsIgnoreCase("OK"))
						break;

					// ========== DETALLE DE INGRESOS ==========
					// MOVIMIENTO DE TESORERIA
					log.info("PRESENTACION MT: ING");
					salida = cajaMovTesoCreate("CLI", nrocobranza,
							new Timestamp(fechamov.getTime()), "COB", "O",
							new BigDecimal(0), null, null, new Timestamp(
									fechamov.getTime()), null, new Timestamp(
									fechamov.getTime()), importe_cuo_cobranza,
							importe_cuo_cobranza, null, new BigDecimal(1),
							null, new BigDecimal(1), null, null, null,
							new BigDecimal(datosCliente[13]), idcliente,
							new BigDecimal(2), "S", null, null, null,
							usuarioalt, idempresa, conn);

					if (!salida.equalsIgnoreCase("OK"))
						break;

					// 20100427 - EJV -->
					fecha_mt = fechamov;
					fclear_mt = fechamov;
					// <--

					nroint_mt = new BigDecimal(0);
					// MOVIMIENTO DE TESORERIA

					log.info("2-PRESENTACION MT: ING");

					salida = cajaMovTesoCreate(cartera_mt, nrocobranza,
							new Timestamp(fechamov.getTime()), "COB",
							tipocart_mt, nroint_mt, observaciones, nrodoc_mt,
							new Timestamp(fecha_mt.getTime()),
							new BigDecimal(0), new Timestamp(fclear_mt
									.getTime()), importe_cuo_cobranza,
							importe_cuo_cobranza, null, new BigDecimal(1),
							null, new BigDecimal(1), null, null, null,
							cuenta_mt, idcliente, new BigDecimal(1), null,
							null, idcencosto, idcencosto1, usuarioalt,
							idempresa, conn);

					if (!salida.equalsIgnoreCase("OK"))
						break;

					log.info("PRESENTACION MCU: A");
					salida = clientesMovCuotaSetAceptado(idmovcuo, "A",
							importe_cuo_cobranza.negate(), idempresa,
							usuarioalt, conn);

					if (!salida.equalsIgnoreCase("OK"))
						break;

				}// 1

			}// 0
			else {
				salida = "(E0)No fue posible recuperar identificador y tipo asociado a tarjeta.";
			}

		} catch (SQLException sqle) {
			salida = "(SQLE)No fue posible aceptar presentacion.";
			log.error("cobranzasMovClientePresentacionTarjeta(...): " + sqle);
		} catch (Exception e) {
			salida = "(EX)No fue posible aceptar presentacion.";
			log.error("cobranzasMovClientePresentacionTarjeta(...): " + e);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			log
					.warn("cobranzasMovClientePresentacionTarjeta() - Transaccion cancelada: "
							+ salida);
			conn.rollback();
		} else {
			conn.commit();
			// conn.rollback();
		}

		log.info("FINAL MOV. POR PRESNTACION -->");
		conn.close();
		return salida;
	}

	// 20110921 - EJV - Replicado en Tesoreria
	public String getClienteLetraIva(BigDecimal idcliente, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""
				+ "SELECT ti.letra "
				+ "  FROM clientestablaiva ti "
				+ "       INNER JOIN clientesclientes cl ON ti.idtipoiva = cl.idtipoiva AND ti.idempresa = cl.idempresa AND cl.idcliente = "
				+ idcliente.toString() + "and cl.idempresa="
				+ idempresa.toString();

		String letra = "";
		Iterator it;
		try {

			it = getLista(cQuery).iterator();
			if (it.hasNext()) {
				letra = ((String[]) it.next())[0];
			}

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClienteLetraIva( BigDecimal idtipoiva )  "
							+ ex);
		}
		return letra;
	}

	// <--

	// 20110926 - EJV - Mantis 779 -->

	/**
	 * Metodos para la entidad: vClientesMovCliCancelar Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Mon Sep 26 14:21:57 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesMovCliCancelarAll(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT nrointerno,idcliente,razon,comprobante,tipomov,tipomovs,sucursal,comprob,fechamov,importe,saldo,idclub,club,logo, cancelar,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM vclientesmovclicancelar " + filtro
				+ " AND idempresa= " + idempresa.toString()
				+ "  ORDER BY idcliente, fechamov DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesMovCliCancelarAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public String clientesMovimientoClienteNC(BigDecimal nrointerno_cancelar,
			int ejercicioactivo, BigDecimal idmotivonc, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {

		String salida = "OK";
		BigDecimal nrointerno_nc = null;
		String[] resultado = new String[2];
		// 20110617 - EJV - Factuaracion FE-CF-MA -->
		Connection conn = null;
		// <--
		BigDecimal idcliente = null;
		Timestamp fechamov = null;
		BigDecimal sucursal_cancelar = null;
		BigDecimal comprob = null;
		BigDecimal comprob_has = null;
		BigDecimal tipomov = new BigDecimal(3);
		String tipomovs = "NC";
		String condicionletra_cancelar = null;
		BigDecimal saldo_cancelar = new BigDecimal(0);
		BigDecimal importe_cancelar = null;
		BigDecimal cambio = new BigDecimal(1);
		BigDecimal moneda = new BigDecimal(1);
		String unamode = null;
		String tipocomp = "3";
		BigDecimal condicion = new BigDecimal(4);
		BigDecimal com_venta = null;
		BigDecimal com_cobra = null;
		BigDecimal com_vende = null;
		String anulada = null;
		BigDecimal retoque = null;
		BigDecimal expreso = null;
		BigDecimal sucucli = null;
		BigDecimal remito = null;
		BigDecimal credito = null;
		String observaciones = null;

		String comprobante_cancelar = "";
		String tipomovs_cancelar = "";
		String cQuery = "";

		//
		BigDecimal totalDesaplica = new BigDecimal(0);

		try {

			conn = GeneralBean.getTransaccionConn(this.clase, this.url,
					this.usuario, this.clave);
			// <--

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			GeneralBean.setLockedTable("cajasucursalescontadores",
					"ACCESS EXCLUSIVE", conn);

			// if (salida.equalsIgnoreCase("OK")) {// 0.0

			// 20120914 -->

			cQuery = ""
					+ " SELECT cc.comp_canc, cc.comp_q_can, SUM(cc.importe) importe "
					+ "    FROM clientescancclie cc  "
					+ "              INNER JOIN clientesmovcli mc ON cc.comp_q_can = mc.nrointerno AND cc.idempresa = mc.idempresa AND mc.tipomovs = 'COB' "
					+ "  WHERE cc.comp_canc  = " + nrointerno_cancelar
					+ "     AND cc.idempresa = " + idempresa
					+ "  GROUP BY cc.comp_canc, cc.comp_q_can ";

			Iterator iterCobranzas = getLista(cQuery, conn).iterator();

			if (iterCobranzas != null) {

				if (iterCobranzas.hasNext()) {

					while (iterCobranzas.hasNext()) {

						String[] datosCobranza = (String[]) iterCobranzas
								.next();

						BigDecimal importeSaldo = new BigDecimal(
								datosCobranza[2]);
						BigDecimal compCobranza = new BigDecimal(
								datosCobranza[1]);

						totalDesaplica = totalDesaplica.add(importeSaldo);

						salida = clientesMovCliUpdateSaldo(compCobranza,
								importeSaldo, usuarioalt, idempresa, conn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

						salida = clientesCancClieDelete(nrointerno_cancelar,
								compCobranza, idempresa, conn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

						salida = clientesCancClie_log_delUpdate(
								nrointerno_cancelar, compCobranza, usuarioalt,
								idempresa, conn);

						if (!salida.equalsIgnoreCase("OK"))
							break;

					}

				}

			}

			if (salida.equalsIgnoreCase("OK")) {// 0.0
				// <--

				long totalCuotasPendientes = getTotalEntidadFiltro(
						"clientesmovcuota",
						" WHERE estado_cuo IN ('P', 'R') AND ninter_cuo  =  "
								+ nrointerno_cancelar, idempresa);

				if (totalCuotasPendientes > 0) {

					salida = clientesMovCuotaCanelaPendientesXNCTotal(
							nrointerno_cancelar, idempresa, usuarioalt, conn);

				}

				if (salida.equalsIgnoreCase("OK")) {

					cQuery = ""
							+ "SELECT mc.cliente, mc.sucursal, mc.saldo, mc.importe,  mc.letraiva, "
							+ "            (((mc.tipomovs::text || '-'::text) || lpad(mc.sucursal::character varying::text, 4, '0'::text)) || '-'::text) || lpad(mc.comprob::character varying::text, 8, '0'::text) AS comprobante, "
							+ "            mc.tipomovs, cl.sucursalfactura, ti.letra  "
							+ "  FROM clientesmovcli mc  "
							+ "           INNER JOIN clientesclientes cl ON mc.cliente = cl.idcliente AND mc.idempresa = cl.idempresa "
							+ "           INNER JOIN clientestablaiva ti ON cl.idtipoiva = ti.idtipoiva AND cl.idempresa = ti.idempresa "
							+ " WHERE mc.nrointerno = " + nrointerno_cancelar
							+ "     AND mc.idempresa = " + idempresa;

					Iterator itcomprob = getLista(cQuery, conn).iterator();

					if (itcomprob.hasNext()) {

						String[] datosComprob = (String[]) itcomprob.next();
						// -- >
						idcliente = new BigDecimal(datosComprob[0]);
						sucursal_cancelar = new BigDecimal(datosComprob[1]);
						saldo_cancelar = new BigDecimal(datosComprob[2]);
						importe_cancelar = new BigDecimal(datosComprob[3]);
						condicionletra_cancelar = datosComprob[4];
						comprobante_cancelar = datosComprob[5];
						tipomovs_cancelar = datosComprob[6];
						// 20120917 - EJV --> ...
						if (tipomovs_cancelar.equalsIgnoreCase("INI")) {
							sucursal_cancelar = new BigDecimal(datosComprob[7]);
							condicionletra_cancelar = datosComprob[8];
						}
						// ... < --
						// < --

						comprob = GeneralBean
								.getCajaSucursalesContadoresProximo(
										sucursal_cancelar,
										condicionletra_cancelar, tipomov,
										idempresa, conn);

						if (comprob.longValue() > -1) {// 0.1

							tipomovs += condicionletra_cancelar;

							if (!isExisteComprobanteMovCli(sucursal_cancelar,
									comprob, tipomovs, idempresa)) {// 0.2
								// <--
								nrointerno_nc = GeneralBean.getContador(
										new BigDecimal(8), idempresa, conn);

								if (nrointerno_nc.longValue() > -1) {// A

									BigDecimal saldo_nc = new BigDecimal(0);
									// 20120917 - EJV -->
									// BigDecimal importe_nc = saldo_cancelar;
									BigDecimal importe_nc = saldo_cancelar
											.add(totalDesaplica);
									// <--
									Calendar cal = new GregorianCalendar();
									cal.set(Calendar.MILLISECOND, 0);
									cal.set(Calendar.SECOND, 0);
									cal.set(Calendar.MINUTE, 0);
									cal.set(Calendar.HOUR_OF_DAY, 0);
									fechamov = new Timestamp(cal
											.getTimeInMillis());

									// CLIENTE
									observaciones = "En concepto de cancelar/saldar comprobante: "
											+ comprobante_cancelar;
									salida = clientesMovCliCreate(idcliente,
											fechamov, sucursal_cancelar,
											comprob, comprob_has, tipomov,
											tipomovs, saldo_nc, importe_nc,
											cambio, moneda, unamode, tipocomp,
											condicion, nrointerno_nc,
											com_venta, com_cobra, com_vende,
											anulada, retoque, expreso, sucucli,
											remito, credito, observaciones,
											condicionletra_cancelar,
											// 20121005 - EJV - Mantis 882 -->
											idmotivonc,
											// <--
											usuarioalt, idempresa, conn);

									if (salida.equalsIgnoreCase("OK")) {// B
										cQuery = ""
												+ " SELECT mc.sucursal, mc.saldo, mc.importe, cc.cuenta_con, cc.impor_con, "
												// +
												// "             ((cc.impor_con) * (mc.saldo / mc.importe))::numeric(18,4)  importe_con_real, cc.nroiva_con, cc.por_per "
												+ "             ((cc.impor_con) * ("
												+ importe_nc
												+ " / mc.importe))::numeric(18,4)  importe_con_real, cc.nroiva_con, cc.por_per "
												+ "   FROM clientesmovcli mc "
												+ "             INNER JOIN clientescontcli cc ON mc.nrointerno = cc.nroint_con "
												+ " WHERE mc.tipomov < 3 "
												+ "    AND mc.nrointerno =   "
												+ nrointerno_cancelar
												+ "    AND mc.idempresa =   "
												+ idempresa;

										Iterator itcont = getLista(cQuery, conn)
												.iterator();

										if (itcont.hasNext()) {
											while (itcont.hasNext()) {// B.0

												String[] datos = (String[]) itcont
														.next();
												BigDecimal cuenta_con = new BigDecimal(
														datos[3]);
												BigDecimal importe_con_real = new BigDecimal(
														datos[5]);
												String nroiva_con = datos[6];
												BigDecimal porcentaje_percepcion = new BigDecimal(
														datos[7]);

												if (!GeneralBean
														.isExisteCtaImputable(
																cuenta_con,
																ejercicioactivo,
																idempresa, conn)) {
													salida = "La cuenta : "
															+ datos[0]
															+ " no existe o no es imputable. ["
															+ nroiva_con + "]";
													break;

												}

												salida = clientesContCliCreate(
														cuenta_con,
														importe_con_real,
														nroiva_con,
														nrointerno_nc, null,
														null,
														porcentaje_percepcion,
														usuarioalt, idempresa,
														conn);

												if (!salida
														.equalsIgnoreCase("OK"))
													break;

											}// B.0

											if (salida.equalsIgnoreCase("OK")) {

												salida = clientesMovCliUpdateSaldo(
														nrointerno_cancelar,
														saldo_cancelar.negate(),
														usuarioalt, idempresa,
														conn);

												if (salida
														.equalsIgnoreCase("OK")) {

													salida = clientesCancClieCreate(
															nrointerno_cancelar,
															nrointerno_nc,
															importe_nc,
															fechamov,
															usuarioalt,
															idempresa, conn);

												}

											}

										} else {

											salida = "No fue posible recuperar datos contables par nc.";
										}

									}// B

								}// A
								else {
									salida = "Imposible recuperar Nro. Interno de Movimiento de Cliente.";
								}

							}// 0.2
							else {

								salida = "El comprobante "
										+ GeneralBean.strZero(sucursal_cancelar
												.toString(), 4)
										+ " - "
										+ GeneralBean.strZero(comprob
												.toString(), 8)
										+ " ya fue emitido.";
							}

						}// 0.1
						else {
							salida = "No se recupero Nro. Comprobante para Sucursal "
									+ sucursal_cancelar
									+ ", posiblemente no se haya definido contador.";
						}

					} else {

						salida = "No fue posible recuperar datos del comprobante a saldar/anular.";

					}

				}

			}// 0.0

			resultado[0] = salida;
			resultado[1] = resultado[1] != null ? resultado[1] + "-"
					+ nrointerno_cancelar.toString() : nrointerno_cancelar
					.toString();

		} catch (Exception e) {
			salida = "Imposible generar movimiento de cliente.";
			log.error("clientesMovimientoClienteNC:" + e);
		}

		if (!salida.equalsIgnoreCase("OK")) {
			conn.rollback();
		} else {

			conn.commit();

			salida = "Comprobante emitido correctamenta: " + tipomovs + "-"
					+ GeneralBean.strZero(sucursal_cancelar + "", 4) + " - "
					+ GeneralBean.strZero(comprob + "", 8);

		}

		conn.setAutoCommit(true);
		conn.close();

		return salida;
	}

	// <--

	// --> 20110928 - EJV - Mantis 782

	/**
	 * Metodos para la entidad: vClientesAplicaciones Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Sep 28 17:28:54 ART 2011
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesAplicacionesXCliente(long limit, long offset,
			BigDecimal idcliente, String filtro, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,nrointerno,comprobante,accion,fecha,importe_ap,nrointerno_ap,comprob,idempresa "
				+ "   FROM vclientesaplicaciones" + " WHERE idcliente = "
				+ idcliente + filtro + " AND idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesAplicacionesXCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getVClientesMovCuotaXCliente(long limit, long offset,
			BigDecimal idcliente, String filtro, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT nrointerno, idmovcuo, numero_cuo, import_cuo, saldo_cuo, estado_cuo, "
				+ "       CASE estado_cuo  "
				+ "            WHEN 'P' THEN 'PENDIENTE' "
				+ "            WHEN 'E' THEN 'ENVIADO' "
				+ "            WHEN 'A' THEN 'APROBADO' "
				+ "            WHEN 'R' THEN 'RECHAZADO' "
				+ "            WHEN 'C' THEN 'APLICADO' "
				+ "            ELSE 'DESCONOCIDO'  "
				+ "       END desc_estado_cuo, "
				+ "       fecha_envio_cuo, comprobante, saldo, idtarjetacredito, nrotarjeta "
				+ "  FROM vclientesmovcuorecepcion " + " WHERE idcliente = "
				+ idcliente + filtro + " AND idempresa = "
				+ idempresa.toString() + "  ORDER BY 1, 3  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesMovCuotaXCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	// --> 20110929 - EJV - Mantis 771
	public List getVClientesTarjetasXCliente(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idtarjeta,idcliente,tarjetacredito,razon,tipotarjeta,nrotarjeta,nrocontrol,fecha_emision,fecha_vencimiento,titular,orden,activa,"
				+ "            usuarioalt,usuarioact,fechaalt,fechaact,idempresa"
				+ "   FROM vclientestarjetas WHERE idcliente = " + idcliente
				+ " AND idempresa = " + idempresa.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesTarjetasXCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	/**
	 * Metodos para la entidad: vClientesMovCli Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri Mar 09 09:42:36 ART 2012
	 */

	public List getVClientesMovCliEtiquetas(long limit, long offset,
			String filtro, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,fechamov::DATE,sucursal,comprob,tipomovs,idtipomov,tipomov,importe,saldo,"
				+ "             idcondicion,condicion,idtipocomp,tipocomp,sucucli,nrointerno,idexpreso,expreso,idempresa "
				+ "   FROM VCLIENTESMOVCLI WHERE idempresa = "
				+ idempresa.toString() + filtro
				+ "  ORDER BY nrointerno DESC  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesMovCliEtiquetas()  "
							+ ex);
		}
		return vecSalida;
	}

	// 20120313 - EJV - Mantis 702 -->

	/**
	 * Metodos para la entidad: bacoRefEstados Copyrigth(r) sysWarp S.R.L. Fecha
	 * de creacion: Tue Mar 13 15:00:43 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefEstadosAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idrefestado,refestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacorefestados WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefEstadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefEstadosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idrefestado,refestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOREFESTADOS WHERE (UPPER(REFESTADO) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idempresa = "
				+ idempresa.toString()
				+ " ORDER BY 2  LIMIT "
				+ limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefEstadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefEstadosPK(BigDecimal idrefestado, BigDecimal idempresa)
			throws EJBException {
		String cQuery = "SELECT  idrefestado,refestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOREFESTADOS WHERE idrefestado="
				+ idrefestado.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefEstadosPK( BigDecimal idrefestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefEstadosDelete(BigDecimal idrefestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFESTADOS WHERE idrefestado="
				+ idrefestado.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFESTADOS WHERE idrefestado="
						+ idrefestado.toString().toString() + " AND idempresa="
						+ idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefEstadosDelete( BigDecimal idrefestado, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefEstadosDelete( BigDecimal idrefestado, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefEstadosCreate(String refestado, BigDecimal idempresa,
			String usuarioalt) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFESTADOS(refestado, idempresa, usuarioalt ) VALUES (?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, refestado);
				insert.setBigDecimal(2, idempresa);
				insert.setString(3, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefEstadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefEstadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefEstadosUpdate(BigDecimal idrefestado,
			String refestado, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idrefestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefEstados WHERE idrefestado = "
					+ idrefestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFESTADOS SET refestado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idrefestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, refestado);
					insert.setBigDecimal(2, idempresa);
					insert.setString(3, usuarioact);
					insert.setTimestamp(4, fechaact);
					insert.setBigDecimal(5, idrefestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefEstadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefEstadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefSubEstados Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Tue Mar 13 15:00:55 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefSubEstadosAll(long limit, long offset,
			BigDecimal idrefestado, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idrefsubestado,refsubestado,idrefestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacorefsubestados WHERE idempresa = "
				+ idempresa.toString() + " AND idrefestado = " + idrefestado
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefSubEstadosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefSubEstadosOcu(long limit, long offset,
			BigDecimal idrefestado, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT  idrefsubestado,refsubestado,idrefestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM bacorefsubestados WHERE (UPPER(REFSUBESTADO) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idrefestado = "
				+ idrefestado + "  AND idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefSubEstadosOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefSubEstadosPK(BigDecimal idrefsubestado,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idrefsubestado,refsubestado,idrefestado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOREFSUBESTADOS WHERE idrefsubestado="
				+ idrefsubestado.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefSubEstadosPK( BigDecimal idrefsubestado )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefSubEstadosDelete(BigDecimal idrefsubestado,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFSUBESTADOS WHERE idrefsubestado="
				+ idrefsubestado.toString() + " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFSUBESTADOS WHERE idrefsubestado="
						+ idrefsubestado.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefSubEstadosDelete( BigDecimal idrefsubestado, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefSubEstadosDelete( BigDecimal idrefsubestado, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefSubEstadosCreate(String refsubestado,
			BigDecimal idrefestado, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idrefestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFSUBESTADOS(refsubestado, idrefestado, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, refsubestado);
				insert.setBigDecimal(2, idrefestado);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String bacoRefSubEstadosCreate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefSubEstadosCreate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefSubEstadosUpdate(BigDecimal idrefsubestado,
			String refsubestado, BigDecimal idrefestado, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idrefsubestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefsubestado ";
		if (idrefestado == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idrefestado ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefSubEstados WHERE idrefsubestado = "
					+ idrefsubestado.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFSUBESTADOS SET refsubestado=?, idrefestado=?, idempresa=?, usuarioact=?, fechaact=? WHERE idrefsubestado=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, refsubestado);
					insert.setBigDecimal(2, idrefestado);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idrefsubestado);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log.error("Error SQL public String bacoRefSubEstadosUpdate(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefSubEstadosUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: bacoRefCatalogoCategoria Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Mar 15 09:25:38 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getBacoRefCatalogoCategoriaAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcatalogocategoria,catalogocategoria,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacorefcatalogocategoria WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoCategoriaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getBacoRefCatalogoCategoriaOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idcatalogocategoria,catalogocategoria,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM bacorefcatalogocategoria "
				+ "WHERE (UPPER(CATALOGOCATEGORIA) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoCategoriaOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getBacoRefCatalogoCategoriaPK(BigDecimal idcatalogocategoria,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "SELECT  idcatalogocategoria,catalogocategoria,observaciones,idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM BACOREFCATALOGOCATEGORIA WHERE idcatalogocategoria="
				+ idcatalogocategoria.toString()
				+ " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCatalogoCategoriaPK( BigDecimal idcatalogocategoria )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String bacoRefCatalogoCategoriaDelete(
			BigDecimal idcatalogocategoria, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM BACOREFCATALOGOCATEGORIA WHERE idcatalogocategoria="
				+ idcatalogocategoria.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM BACOREFCATALOGOCATEGORIA WHERE idcatalogocategoria="
						+ idcatalogocategoria.toString().toString()
						+ " AND idempresa=" + idempresa.toString();
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : bacoRefCatalogoCategoriaDelete( BigDecimal idcatalogocategoria, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: bacoRefCatalogoCategoriaDelete( BigDecimal idcatalogocategoria, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String bacoRefCatalogoCategoriaCreate(String catalogocategoria,
			String observaciones, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (catalogocategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: catalogocategoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (catalogocategoria.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: catalogocategoria ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO BACOREFCATALOGOCATEGORIA(catalogocategoria, observaciones, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, catalogocategoria);
				insert.setString(2, observaciones);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String bacoRefCatalogoCategoriaCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String bacoRefCatalogoCategoriaCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String bacoRefCatalogoCategoriaUpdate(
			BigDecimal idcatalogocategoria, String catalogocategoria,
			String observaciones, BigDecimal idempresa, String usuarioact)
			throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idcatalogocategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idcatalogocategoria ";
		if (catalogocategoria == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: catalogocategoria ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (catalogocategoria.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: catalogocategoria ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM bacoRefCatalogoCategoria WHERE idcatalogocategoria = "
					+ idcatalogocategoria.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE BACOREFCATALOGOCATEGORIA SET catalogocategoria=?, observaciones=?, idempresa=?, usuarioact=?, fechaact=? WHERE idcatalogocategoria=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, catalogocategoria);
					insert.setString(2, observaciones);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idcatalogocategoria);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String bacoRefCatalogoCategoriaUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String bacoRefCatalogoCategoriaUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String bacoRefCtaCtePuntosFromFile(BufferedReader input,
			String table, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		String line = null;
		int totalLineas = 0;
		Pattern patron;
		Matcher compara;
		Statement st = null;

		try {

			long countTabla = getTotalEntidadFiltro(
					"(SELECT table_name, 1 idempresa FROM information_schema.tables ) entidad",
					" WHERE table_name = '" + table + "' ", new BigDecimal(1));
			st = dbconn.createStatement();

			if (countTabla == 0) {

				st
						.addBatch("CREATE TEMPORARY TABLE "
								+ table
								+ "_aux( idcliente NUMERIC(18), operacion VARCHAR(15), puntos numeric(18));");
				st
						.addBatch("CREATE TEMPORARY  TABLE "
								+ table
								+ "( idcliefile NUMERIC(18), idcliente NUMERIC(18), razon VARCHAR(100), idoperacion NUMERIC(18), operacion VARCHAR(75), puntos numeric(18), idempresa NUMERIC(18));");
			}

			st.addBatch("TRUNCATE TABLE " + table + "_aux;");
			st.addBatch("TRUNCATE TABLE " + table + ";");

			while ((line = input.readLine()) != null) {
				// --
				// salida = "";
				++totalLineas;
				String linea = line;
				log.info("--------------------- " + totalLineas
						+ " --------------------");
				log.info("-------------------> " + linea + " ");

				patron = Pattern.compile("[^A-Za-z0-9\r\n;]");
				compara = patron.matcher(linea);

				// log.info("LINEA - " + totalLineas + " fuera de patron: "
				// + compara.find());
				if (compara.find()) {
					salida = "Linea nro  " + totalLineas
							+ " contiene caracteres invalidos: " + linea;
					break;
				}

				patron = Pattern.compile(";");
				compara = patron.matcher(linea);
				int totalSeparador = 0;
				// --
				while (compara.find())
					++totalSeparador;
				// log.info("LINEA - " + totalLineas + " total separador: "
				// + totalSeparador);
				if (totalSeparador < 2 || totalSeparador > 3) {
					salida = "Linea nro "
							+ totalLineas
							+ " no contiene el separador punto y coma (;) en la cantidad esperada.";
					break;
				}

				String[] colsSplit = linea.split(";");
				// log.info("LINEA - " + totalLineas + " campos: "
				// + colsSplit.length);

				if (colsSplit == null || colsSplit.length != 3) {
					salida = "Cantidad de columnas definidas en linea nro "
							+ totalLineas + " no es la esperada.";
					break;
				}

				patron = Pattern.compile("[^0-9]");
				compara = patron.matcher(colsSplit[0]);
				if (compara.find()) {
					salida = "Cliente incorrecto en linea  " + totalLineas
							+ ": " + linea;
					break;
				}

				compara = patron.matcher(colsSplit[2]);
				if (compara.find()) {
					salida = "Puntos incorrectos en linea  " + totalLineas
							+ ": " + linea;
					break;
				}

				patron = Pattern.compile("[^A-Za-z0-9]");
				compara = patron.matcher(colsSplit[1]);

				if (compara.find()) {
					salida = "Operacion incorrecta en linea  " + totalLineas
							+ ": " + linea;
					break;
				}

				st.addBatch(" INSERT INTO " + table + "_aux VALUES("
						+ colsSplit[0] + ", '" + colsSplit[1].toUpperCase()
						+ "', " + colsSplit[2] + ");");

			}

			String sql = "INSERT INTO "
					+ table
					+ " SELECT aux.idcliente idcliefile, COALESCE(cl.idcliente, -1) idcliente, "
					+ "             COALESCE(cl.razon, 'Cliente Inexistente') razon, COALESCE(op.idoperacion, -1) idoperacion, COALESCE(op.operacion, 'Oeracion no reconocida: ' || aux.operacion ) operacion, aux.puntos, "
					+ idempresa
					+ "   FROM "
					+ table
					+ "_aux aux "
					+ "              LEFT JOIN clientesclientes cl ON aux.idcliente = cl.idcliente AND cl.idempresa =  "
					+ idempresa
					+ "              LEFT JOIN bacorefoperaciones op ON aux.operacion = op.operacion AND op.idempresa = "
					+ idempresa;

			st.addBatch(sql);

			if (salida.equalsIgnoreCase("OK")) {
				st.executeBatch();
			}
		} catch (SQLException sqle) {

			log.error("bacoRefCtaCtePuntosFromFile(): " + sqle);
			log.error("bacoRefCtaCtePuntosFromFile(): "
					+ sqle.getNextException());

		} catch (Exception e) {
			salida = "(EX)No fue posible procesar archivo.";
			log.error("bacoRefCtaCtePuntosFromFile(): " + e);
		}

		st.clearBatch();

		return salida;

	}

	public String bacoRefCtaCteCargarPuntosFromFile(String table, String file,
			String usuarioalt, BigDecimal idempresa) throws EJBException,
			SQLException {

		String salida = "OK";
		Statement st = null;
		String sql = "";

		try {

			st = dbconn.createStatement();
			sql = ""
					+ "INSERT INTO bacorefctacte "
					+ "                    (idcliente, idoperacion, idreferido, puntos, fecha ,  observaciones,  idempresa, usuarioalt) "
					+ "        SELECT idcliente,  idoperacion, 0            , puntos,  current_date, 'PROCESO ARCHIVO "
					+ file + ":' || CURRENT_DATE  , idempresa, '" + usuarioalt
					+ "' FROM " + table + " WHERE idempresa = " + idempresa
					+ "  AND idoperacion > 0 AND idcliente > 0 ";

			st.addBatch(sql);
			st.addBatch("DELETE FROM " + table + "_aux; ");
			st
					.addBatch("DELETE FROM "
							+ table
							+ " WHERE idoperacion > 0 AND idcliente > 0 AND idempresa = "
							+ idempresa);

			st.executeBatch();

		} catch (SQLException sqle) {

			log.error("bacoRefCtaCtePuntosFromFile(): " + sqle);
			log.error("bacoRefCtaCtePuntosFromFile(): "
					+ sqle.getNextException());

		} catch (Exception e) {
			salida = "(EX)No fue posible procesar archivo.";
			log.error("bacoRefCtaCtePuntosFromFile(): " + e);
		}

		return salida;

	}

	public List getBacoRefCtaCteFromFileAll(long limit, long offset,
			String tablename, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliefile, idcliente, razon, idoperacion, operacion, puntos , idempresa "
				+ "   FROM " + tablename + " WHERE idempresa = " + idempresa
				+ "   ORDER BY 3  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCteFromFileAll()  "
							+ ex);
		}

		return vecSalida;
	}

	public List getBacoRefCtaCteFromFileOcu(long limit, long offset,
			String tablename, String ocurrencia, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idcliefile, idcliente, razon, idoperacion, operacion, puntos, idempresa "
				+ "   FROM " + tablename + " WHERE idempresa = " + idempresa
				+ " AND ( razon ILIKE  '%" + ocurrencia
				+ "%' OR  idcliente::varchar ILIKE  '%" + ocurrencia
				+ "%'  OR  idcliefile::varchar  ILIKE  '%" + ocurrencia
				+ "%' ) " + "   ORDER BY 3  LIMIT " + limit + " OFFSET  "
				+ offset + ";";
		List vecSalida = new ArrayList();
		try {

			vecSalida = getLista(cQuery);

		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getBacoRefCtaCteFromFileAll()  "
							+ ex);
		}

		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vBacoReferidosEvolucion Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Fri Apr 13 14:42:13 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVBacoReferidosEvolucionAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idctacte,idcliente,operacion,fecha,detalle,idpedido_cabe,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "    FROM vbacoreferidosevolucion WHERE idempresa = "
				+ idempresa.toString() + "  ORDER BY 4 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVBacoReferidosEvolucionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getVBacoReferidosEvolucionOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idctacte,idcliente,operacion,fecha,detalle,idpedido_cabe,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM vbacoreferidosevolucion WHERE (UPPER(IDCLIENTE) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 4 DESC LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVBacoReferidosEvolucionOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	// 20120426 - EJV - Mantis 708 -->

	/**
	 * Metodos para la entidad: clientesLCSASVentasRevisar Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Apr 26 12:07:59 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasRevisarAll(long limit, long offset,
			int anio, int mes, BigDecimal idtipoclie, BigDecimal idestado,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,idestado,estado,fechadesde,idmotivo,motivo,idcategoriasocio,categoriasocio,fechapedido, "
				+ "             origenpedido, idpedido_cabe, obsarmado, obsentrega, idtipoclie,"
				+ "             usuarioalt,usuarioact,fechaalt,fechaact,idempresa "
				+ "   FROM vclienteslcsasventasrevisar WHERE idestadopedido = 1 AND idempresa = "
				+ idempresa.toString()
				+ " AND  DATE_PART('YEAR', fechapedido) = " + anio
				+ " AND  DATE_PART('MONTH', fechapedido) = " + mes
				+ " AND idtipoclie = " + idtipoclie.toString()
				+ " AND  idestado = " + idestado.toString()
				+ "    ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasRevisarAll()  "
							+ ex);
		}
		return vecSalida;
	}

	public List getVClientesLCSASVentasRevisarXCliente(long limit, long offset,
			int anio, int mes, BigDecimal idtipoclie, BigDecimal idestado,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,idestado,estado,fechadesde,idmotivo,motivo,idcategoriasocio,categoriasocio,fechapedido, "
				+ "             origenpedido, idpedido_cabe, obsarmado, obsentrega, idtipoclie,"
				+ "             usuarioalt,usuarioact,fechaalt,fechaact,idempresa "
				+ "   FROM vclienteslcsasventasrevisar WHERE idestadopedido = 1 AND idempresa = "
				+ idempresa.toString()
				+ " AND  DATE_PART('YEAR', fechapedido) = " + anio
				+ " AND  DATE_PART('MONTH', fechapedido) = " + mes
				+ " AND idtipoclie = " + idtipoclie.toString()
				+ " AND  idestado = " + idestado.toString()
				+ " AND  idcliente = " + idcliente.toString()
				+ "    ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasRevisarXCliente()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesLCSASVentasDescuentoCero Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Thu May 03 09:08:59 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasDescuentoCeroAll(long limit,
			long offset, int anio, int mes, BigDecimal idtipoclie,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,cantidad,idestado,estado,anio,mes,idtipoclie,idempresa "
				+ "   FROM vclienteslcsasventasdescuentocero "
				+ "WHERE idempresa = " + idempresa.toString()
				+ "     AND anio = " + anio + " AND mes = " + mes
				+ "     AND idtipoclie = " + idtipoclie.toString()
				+ "     AND idestado = " + idestado.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasDescuentoCeroAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesLCSASVentasDescuentoAplicadoTotal
	 * Copyrigth(r) sysWarp S.R.L. Fecha de creacion: Thu May 03 14:13:51 ART
	 * 2012
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasDescuentoAplicadoTotalAll(long limit,
			long offset, int anio, int mes, BigDecimal idtipoclie,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT porcdesc_apli,total_socios,idtipoclie,anio,mes,idempresa "
				+ "   FROM vclienteslcsasventasdescuentoaplicadototal "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "     AND anio = " + anio + " AND mes = " + mes
				+ "     AND idtipoclie = " + idtipoclie.toString()
				+ "     AND idestado = " + idestado.toString()
				+ "  ORDER BY 1  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasDescuentoAplicadoTotalAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesLCSASVentasDescuentoAplicadoDeta
	 * Copyrigth(r) sysWarp S.R.L. Fecha de creacion: Fri May 04 10:47:59 ART
	 * 2012
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasDescuentoAplicadoDetaAll(long limit,
			long offset, int anio, int mes, BigDecimal idtipoclie,
			BigDecimal idestado, BigDecimal porcdesc_apli, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,idcategoriasocio,categoriasocio,idtipoclie,codigo_st,descrip_st,cantidad,porcdesc_apli,idmotivodescuento,motivodescuento, "
				+ "             importe,fechapedido,origenpedido,obsentrega,idpedido_cabe,idestado,estado,idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM vclienteslcsasventasdescuentoaplicadodeta "
				+ " WHERE idempresa = " + idempresa.toString()

				+ "     AND  DATE_PART('YEAR', fechapedido) = " + anio
				+ "     AND  DATE_PART('MONTH', fechapedido) = " + mes
				+ "     AND idtipoclie = " + idtipoclie.toString()
				+ "     AND  idestado = " + idestado.toString()
				+ "     AND  porcdesc_apli = " + porcdesc_apli.toString()

				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();

		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasDescuentoAplicadoDetaAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesLCSASVentasSuspensionEr Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Tue May 08 10:04:48 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasSuspensionErAll(long limit, long offset,
			int anio, int mes, BigDecimal idtipoclie, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,idpedido_cabe,idmotsusp,motsusp,anio,mes,idtipoclie,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM vclienteslcsasventassuspensioner "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "     AND anio = " + anio + " AND mes = " + mes
				+ "     AND idtipoclie = " + idtipoclie.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasSuspensionErAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesLCSASVentasSociosActivos Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Tue May 08 16:28:58 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesLCSASVentasSociosActivosAll(long limit,
			long offset, int anio, int mes, BigDecimal idtipoclie,
			BigDecimal idestado, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,idpedido_cabe,anio,mes,idtipoclie,idestado,estado,fechadesde,idmotivo,motivo,idestadopedido,"
				+ "          idempresa,usuarioalt,usuarioact,fechaalt,fechaact"
				+ "   FROM vclienteslcsasventassociosactivos "
				// + "WHERE idestadopedido = 1" + "    AND idempresa = "
				+ "WHERE idempresa = " + idempresa.toString()
				+ "    AND anio = " + anio + "    AND mes = " + mes
				+ "     AND idtipoclie = " + idtipoclie.toString()
				+ "     AND  idestado = " + idestado.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesLCSASVentasSociosActivosAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	// 20120510 - EJV - Movimientos de Stock duplicados -- >

	private static int getConformacionRemitoEstadoActual(
			BigDecimal idremitocliente, BigDecimal idempresa, Connection conn)
			throws EJBException {
		ResultSet rsSalida = null;
		boolean isExisteImputable = false;
		int estadoActual = -99;
		String cQuery = "                     "
				+ "SELECT DISTINCT ON (idremitocliente) idestado "
				+ "   FROM clientesremitosconformacion  "
				+ " WHERE idremitocliente =  " + idremitocliente
				+ "     AND idempresa = " + idempresa.toString()
				+ " ORDER BY idremitocliente, idconformacion DESC ";

		try {
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null) {
				if (rsSalida.next()) {
					estadoActual = rsSalida.getInt("idestado");
				} else
					estadoActual = -100;
			} else
				estadoActual = -200;

		} catch (SQLException sqlException) {
			estadoActual = -300;
			log
					.error("Error SQL en el metodo : getConformacionRemitoEstadoActual( ...  ) "
							+ sqlException);
		} catch (Exception ex) {
			estadoActual = -400;
			log
					.error("Salida por exception: en el metodo: getConformacionRemitoEstadoActual( ... )  "
							+ ex);
		}

		return estadoActual;

	}

	private static int getClientesRemitoEstadoActual(
			BigDecimal idremitocliente, BigDecimal idempresa, Connection conn)
			throws EJBException {
		ResultSet rsSalida = null;
		boolean isExisteImputable = false;
		int estadoActual = -99;
		String cQuery = "                     "
				+ "SELECT idestado  FROM clientesremitos  "
				+ " WHERE idremitocliente =  " + idremitocliente
				+ "     AND idempresa = " + idempresa.toString();

		try {
			Statement statement = conn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida != null) {
				if (rsSalida.next()) {
					estadoActual = rsSalida.getInt("idestado");
				} else
					estadoActual = -100;
			} else
				estadoActual = -200;

		} catch (SQLException sqlException) {
			estadoActual = -300;
			log
					.error("Error SQL en el metodo : getClientesRemitoEstadoActual( ...  ) "
							+ sqlException);
		} catch (Exception ex) {
			estadoActual = -400;
			log
					.error("Salida por exception: en el metodo: getClientesRemitoEstadoActual( ... )  "
							+ ex);
		}

		return estadoActual;

	}

	// <--

	// 20120621 -->
	/**
	 * Metodos para la entidad: vClientesMovCliImprime Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Jun 21 13:36:40 ART 2012
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesMovCliImprimeAll(long limit, long offset,
			String filtro, String orden, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT nrointerno,cliente,razon,fechamov,sucursal,comprob,tipomov,tipomovs,saldo,importe,cambio,moneda,unamode,tipocomp,condicion, "
				+ "            anulada,observaciones,afipcae,afipcaea,impreso,letraiva,afipcaevence,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM vclientesmovcliimprime WHERE idempresa = "
				+ idempresa.toString() + filtro + orden + "    LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesMovCliImprimeAll()  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: ClientesMov Copyrigth(r) sysWarp S.R.L. Fecha de
	 * creacion: Fri Jan Thu Jun 21 13:36:40 ART 2012
	 */

	public List getClientesTipoMovAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idtipomov, tipomov, factor, usuarioalt, usuarioact, fechaalt, fechaact, idempresa "
				+ "   FROM clientestipomov WHERE idempresa = "
				+ idempresa.toString() + " ORDER BY 2   LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTipoMovAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// <-- 20120621 - EJV
	// 20120702 - CAMI - Facturas por Articulo vendido --->
	public List ObtenerFacturasXArticulo(String codigo_st, BigDecimal idempresa)
			throws EJBException {

		String cQuery = ""

				+ "SELECT DISTINCT mov.comprob,mov.tipomovs, de.cantidad, mov.fechamov, mov.cliente, cl.razon,mon.moneda"
				+ " FROM clientesmovcli mov "
				+ " INNER JOIN clientesclientes  cl on (mov.cliente = cl.idcliente AND mov.idempresa = cl.idempresa)"
				+ " INNER JOIN clientesremitos re on (mov.nrointerno = re.nrointerno_mc AND mov.idempresa = re.idempresa)"
				// +
				// " INNER JOIN pedidosrotuloslote ro on (re.idremitocliente = ro.idremitocliente AND re.idempresa = ro.idempresa)"
				// +
				// " INNER JOIN pedidos_deta de on (ro.idpedido_deta = de.idpedido_deta AND ro.idempresa = de.idempresa)"
				+ " INNER JOIN pedidos_deta de on (re.idremitocliente = de.idremitocliente AND re.idempresa = de.idempresa)"
				+ " INNER JOIN globalmonedas mon on (mon.idmoneda = mov.moneda)"
				+ "	where de.codigo_st = '" + codigo_st
				+ "' AND de.idempresa= " + idempresa.toString()
				+ " ORDER BY mov.fechamov asc";
		log.info("cQuery: " + cQuery);
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: ObtenerFacturasXArticulo(String codarticulo)  "
							+ ex);
		}
		return vecSalida;
	}

	public long ObtenerFacturasXArticuloTotal(String codigo_st,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		long cantidad = 0l;
		String cQuery = "SELECT count (1) as cant from (Select DISTINCT de.codigo_st,mov.comprob,mov.tipomovs, de.cantidad, mov.fechamov, mov.cliente, cl.razon  , mon.moneda"
				+ " FROM clientesmovcli mov"
				+ "	INNER JOIN clientesclientes  cl on (mov.cliente = cl.idcliente AND mov.idempresa = cl.idempresa)"
				+ "      INNER JOIN clientesremitos re on (mov.nrointerno = re.nrointerno_mc AND mov.idempresa = re.idempresa)"
				// +
				// "INNER JOIN pedidosrotuloslote ro on (re.idremitocliente = ro.idremitocliente AND re.idempresa = ro.idempresa)"
				// +
				// "INNER JOIN pedidos_deta de on (ro.idpedido_deta = de.idpedido_deta AND ro.idempresa = de.idempresa)"
				+ " INNER JOIN pedidos_deta de on (re.idremitocliente = de.idremitocliente AND re.idempresa = de.idempresa)"
				+ "INNER JOIN globalmonedas mon on (mon.idmoneda = mov.moneda)"
				+ "WHERE de.codigo_st = '"
				+ codigo_st
				+ "' AND"
				+ " de.idempresa = "
				+ idempresa.toString()
				+ " ORDER BY mov.fechamov asc ) as entidad";
		try {
			Statement stat = dbconn.createStatement();
			rsSalida = stat.executeQuery(cQuery);
			if (rsSalida.next()) {
				cantidad = rsSalida.getLong("cant");
			}
		} catch (Exception e) {
			log
					.error("ObtenerFacturasXArticuloTotal(String codigo_st,BigDecimal idempresa)"
							+ e);
		}
		return cantidad;

	}

	// <----------------------------------------------------------
	// 20120703 -CAMI- Agregado de clientes para el menu del sas
	public List getClientesClientesObtenerUno(BigDecimal idcliente,
			BigDecimal idempresa) throws EJBException {
		String cQuery = "Select  pre.idcliente,pre.razon, pre.nrodocumento, pre.idtipodocumento, doc.tipodocumento, pre.idtipoclie,tipo.tipoclie,"
				+ "		 COALESCE(cs.idcategoriasocio) as idcategoria,cs.categoriasocio,pre.fechadenacimiento, pre.idpreferencia, pref.preferencia, pre.idpromocion,pro.promocion,"
				+ "		 pre.idorigen, origen.origen, pre.idsuborigen,sub.suborigen,pre.idcondicion,cond.condicion,pre.idtipoiva,iva.tipoiva,"
				+ "		 estados.estado, estados.motivo,estados.imagen,pre.idprecarga "
				+ "		 from clientesprecargaclientes pre"
				+ "		 inner join globaltiposdocumentos  doc on (doc.idtipodocumento = pre.idtipodocumento and doc.idempresa = pre.idempresa)"
				+ "		 inner join clientestipoclie tipo on (tipo.idtipoclie = pre.idtipoclie and tipo.idempresa = pre.idempresa)"
				+ "		 inner join clientespreferencias pref on (pref.idpreferencia = pre.idpreferencia and pref.idempresa = pre.idempresa)"
				+ "		 left join clientespromociones pro on (pro.idpromocion = pre.idpromocion and pro.idempresa = pre.idempresa)"
				+ "		 inner join origenprospecto  origen on (origen.idorigen= pre.idorigen and origen.idempresa = pre.idempresa)"
				+ "	 	 inner join suborigenprospecto sub on (sub.idsuborigen = pre.idsuborigen and sub.idempresa = pre.idempresa)"
				+ "		 inner join clientescondicio cond on (cond.idcondicion = pre.idcondicion and cond.idempresa = pre.idempresa)"
				+ "		 inner join clientestablaiva iva on (iva.idtipoiva = pre.idtipoiva and iva.idempresa = pre.idempresa)"
				+ "		 inner join vclientesestadoshoy estados on (estados.idcliente = pre.idcliente and estados.idempresa = pre.idempresa)"
				+ "		 left join bacotmcategorizaciones ca ON (ca.idcliente = pre.idcliente AND ca.idempresa = pre.idempresa  AND ca.fhasta IS NULL)"
				+ "		 left join bacotmcategoriassocios cs ON (cs.idcategoriasocio = ca.idcategoria AND cs.idempresa = ca.idempresa)"
				+ "Where pre.idcliente ="
				+ idcliente.toString()
				+ " and pre.idempresa = " + idempresa.toString();
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesClientesObtenerUno (BigDecimal idcliente, BigDecimal idempresa)"
							+ ex);
		}
		return vecSalida;
	}

	// <-------------------------------------------------

	// 20120911 - EJV -->

	public List getLovClientesMovClieXCliente(long limit, long offset,
			BigDecimal idcliente, String tipomovIN, BigDecimal idempresa)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT nrointerno,cliente,fechamov,sucursal,comprob,tipomov,tipomovs,"
				+ "       importe::numeric(18,2),saldo::numeric(18,2),condicion,fechamov,retoque,fechamov,"
				// 20130716 - EJV -->
				+ "       anulada,"
				// <--
				+ "       usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM clientesmovcli  WHERE cliente = " + idcliente
				+ " AND saldo > 0 AND tipomov IN (" + tipomovIN
				+ ") AND idempresa=" + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = getLista(cQuery);
		return vecSalida;
	}

	public List getLovClientesMovClieXClienteOcu(long limit, long offset,
			BigDecimal idcliente, String tipomovIN, String ocurrencia,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = ""
				+ "SELECT nrointerno,cliente,fechamov,sucursal,comprob,tipomov,tipomovs,"
				+ "       importe::numeric(18,2),saldo::numeric(18,2),condicion,fechamov,retoque,fechamov,"
				// 20130716 - EJV -->
				+ "       anulada,"
				// <--
				+ "       usuarioalt,usuarioact,fechaalt,fechaact "
				+ "  FROM clientesmovcli  " + " WHERE cliente = " + idcliente
				+ " AND saldo > 0  and tipomov IN (" + tipomovIN
				+ ") AND comprob::VARCHAR LIKE '" + ocurrencia
				+ "%'  AND idempresa = " + idempresa.toString()
				+ " ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = getLista(cQuery);
		return vecSalida;
	}

	public String clientesAplicarComprobante(BigDecimal comp_canc,
			BigDecimal comp_q_canc, BigDecimal importe, String usuarioalt,
			BigDecimal idempresa) throws EJBException, SQLException {
		String salida = "OK";
		Connection conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		java.sql.Timestamp fechamov = new java.sql.Timestamp(Calendar
				.getInstance().getTimeInMillis());

		try {

			if (conn == null)
				return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

			conn.setAutoCommit(false);

			salida = clientesMovCliUpdateSaldo(comp_canc, importe.negate(),
					usuarioalt, idempresa, conn);

			if (salida.equalsIgnoreCase("OK")) {

				salida = clientesMovCliUpdateSaldo(comp_q_canc, importe
						.negate(), usuarioalt, idempresa, conn);

				if (salida.equalsIgnoreCase("OK")) {

					salida = clientesCancClieCreate(comp_canc, comp_q_canc,
							importe, fechamov, usuarioalt, idempresa, conn);

					// 20130715 - EJV (Correccion por no verificar si existen
					// cuotas a cancelar, fallaba aplicacion en movimientos sin
					// cuotas por ingreso manual de comprobantes ) -->
					if (salida.equalsIgnoreCase("OK")) {
						long cantCuotas = getTotalEntidadFiltro(
								"clientesmovcuota", "WHERE ninter_cuo ="
										+ comp_canc, idempresa);
						if (cantCuotas > 0) {

							// 20121116 - EJV - Mantis 889 -->

							salida = clientesMovCuotaCanelaPendientesParcial(
									comp_canc, importe, idempresa, usuarioalt,
									conn);

							// <--
						}
					}
					// <--

				}

			}

		} catch (Exception e) {
			salida = "(EX) No fue posible aplicar documentos.";
		}

		if (salida.equalsIgnoreCase("OK"))
			conn.commit();
		else
			conn.rollback();

		conn.close();

		return salida;
	}

	public List getClientesMovCliPK(BigDecimal nrointerno, BigDecimal idempresa)
			throws EJBException {
		String cQuery = ""
				+ "SELECT cliente, fechamov, sucursal, comprob,"
				+ "             LPAD(sucursal::VARCHAR, 4, '0')  || '-' || LPAD(comprob::VARCHAR, 8, '0') comprobante, "
				+ "             comprob_has, tipomov, tipomovs, saldo, importe, cambio, moneda,"
				+ "             unamode, tipocomp, condicion, nrointerno, com_venta, com_cobra, com_vende, anulada, retoque, expreso,"
				+ "             sucucli, remito, credito, observaciones,"
				+ "             afipcae, afipcaea, impreso, letraiva, afipcaevence, "
				+ "             idempresa, usuarioalt, usuarioact, fechaalt, fechaact "
				+ "   FROM clientesmovcli WHERE nrointerno ="
				+ nrointerno.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovCliPK( BigDecimal cliente )  "
							+ ex);
		}
		return vecSalida;
	}

	// <--

	public String clientesCancClieDelete(BigDecimal comp_canc,
			BigDecimal comp_q_can, BigDecimal idempresa, Connection conn)
			throws EJBException {
		ResultSet rsSalida = null;

		String salida = "OK";
		try {
			Statement statement = conn.createStatement();

			String cQuery = "DELETE FROM clientescancclie WHERE comp_canc="
					+ comp_canc.toString().toString() + " AND comp_q_can="
					+ comp_q_can.toString() + " AND idempresa="
					+ idempresa.toString();

			int i = statement.executeUpdate(cQuery);
			if (i < 1)
				salida = "No existe cancelacion de documento: " + comp_canc
						+ ", aplicado por:  " + comp_q_can;

		} catch (SQLException sqlException) {
			salida = "(SQLE)Imposible eliminar aplicacion  de documento: "
					+ comp_canc + ", aplicado por:  " + comp_q_can;
			log
					.error("Error SQL en el metodo : clientesCancClieDelete( BigDecimal comp_canc, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)Imposible eliminar aplicacion  de documento: "
					+ comp_canc + ", aplicado por:  " + comp_q_can;
			log
					.error("Salida por exception: en el metodo: clientesCancClieDelete( BigDecimal comp_canc, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	public String clientesCancClie_log_delUpdate(BigDecimal comp_canc,
			BigDecimal comp_q_can, String usuaridel, BigDecimal idempresa,
			Connection conn) throws EJBException {

		String salida = "OK";

		try {

			PreparedStatement insert = null;
			String sql = "";

			sql = "UPDATE clientescancclie_log_del SET tupla=( tupla * (-1) ), usuaridel=? WHERE tupla < 0 AND comp_canc=? AND comp_q_can=? AND idempresa = ?;";

			insert = conn.prepareStatement(sql);
			insert.setString(1, usuaridel);
			insert.setBigDecimal(2, comp_canc);
			insert.setBigDecimal(3, comp_q_can);
			insert.setBigDecimal(4, idempresa);

			int i = insert.executeUpdate();
			if (i == 0)
				salida = "No fue posible asignar usuario borrado aplicacion documentos en log ("
						+ comp_canc + ", " + comp_q_can + ").";

		} catch (SQLException sqlException) {
			salida = "(SQLE)No fue posible asignar usuario borrado aplicacion documentos en log ("
					+ comp_canc + ", " + comp_q_can + ").";
			log
					.error("Error SQL public String clientesCancClie_log_delUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "(EX)No fue posible asignar usuario borrado aplicacion documentos en log ("
					+ comp_canc + ", " + comp_q_can + ").";
			log
					.error("Error excepcion public String clientesCancClie_log_delUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Metodos para la entidad: vClientesAplicacionesFull Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Wed Sep 19 10:35:58 ART 2012
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getVClientesAplicacionesFullXClie(long limit, long offset,
			BigDecimal idcliente, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idcliente,razon,nrointerno_ap,tipomov_ap,tipomovs_ap,sucursal_ap,comprob_ap,saldo_ap,importe_ap,comprobante_ap,"
				+ "             nrointerno_qc,tipomov_qc,tipomovs_qc,sucursal_qc,comprob_qc,saldo_qc,importe_qc,comprobante_qc,importe_can,fecha_can,"
				+ "             idempresa,usuarioalt,usuarioact,fechaalt,fechaact, tienecuotascomp, tienecuotascompqc FROM vclientesaplicacionesfull "
				+ " WHERE idempresa = " + idempresa.toString()
				+ "     AND idcliente = " + idcliente.toString()
				+ "  ORDER BY 2  LIMIT " + limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesAplicacionesFullXClie()  "
							+ ex);
		}
		return vecSalida;
	}

	public String clientesMovCliDesaplicar(BigDecimal nrointerno_canc,
			BigDecimal nrointerno_qcan, String usuarioalt, BigDecimal idempresa)
			throws EJBException, SQLException {

		String salida = "OK";
		Connection conn = null;
		String cQuery = "";

		conn = GeneralBean.getTransaccionConn(this.clase, this.url,
				this.usuario, this.clave);
		// <--

		if (conn == null)
			return "E1000-No fue posible generar vinculo a base de datos, intente nuevamente o avise a sistemas.";

		try {

			conn.setAutoCommit(false);

			// ------

			// 20120914 -->

			cQuery = " SELECT  SUM(cc.importe) importe "
					+ "       FROM clientescancclie cc  "
					+ "     WHERE cc.comp_canc  = " + nrointerno_canc
					+ "         AND cc.comp_q_can = " + nrointerno_qcan
					+ "         AND cc.idempresa = " + idempresa;

			Iterator iterDesaplicar = getLista(cQuery, conn).iterator();

			if (iterDesaplicar != null) {

				if (iterDesaplicar.hasNext()) {

					String[] datosDesaplicar = (String[]) iterDesaplicar.next();
					BigDecimal importeDesaplica = new BigDecimal(
							datosDesaplicar[0]);

					salida = clientesMovCliUpdateSaldo(nrointerno_canc,
							importeDesaplica, usuarioalt, idempresa, conn);

					if (salida.equalsIgnoreCase("OK")) {
						salida = clientesMovCliUpdateSaldo(nrointerno_qcan,
								importeDesaplica, usuarioalt, idempresa, conn);

						if (salida.equalsIgnoreCase("OK")) {
							salida = clientesCancClieDelete(nrointerno_canc,
									nrointerno_qcan, idempresa, conn);

							if (salida.equalsIgnoreCase("OK")) {
								salida = clientesCancClie_log_delUpdate(
										nrointerno_canc, nrointerno_qcan,
										usuarioalt, idempresa, conn);

								// 20121115 - EJV - Mantis 889 -->
								if (salida.equalsIgnoreCase("OK")) {

									String filtro = " WHERE ninter_cuo = "
											+ nrointerno_canc
											+ " AND (estado_cuo = 'C' "
											// 20121122 - EJV -->
											+ " OR  saldo_cuo < import_cuo ) "
									// <--
									;
									long nrolCuotasCanceladas = getTotalEntidadFiltro(
											"clientesmovcuota", filtro,
											idempresa);

									if (nrolCuotasCanceladas > 0) {

										salida = setClientesMovCuotaCaneladasAPendientes(
												nrointerno_canc,
												importeDesaplica, idempresa,
												usuarioalt, conn);

									}

								}

								// <--

							}

						}

					}

				} else {

					salida = "No existe aplicacion entre comprobantes. Posiblemente desaplicado desde otra sesion.";

				}

			} else {

				salida = "No fue posible comprobar existencia de aplicacion entre comprobantes, intente mas tarde o consulte a sistemas.";

			}

			// -----

		} catch (SQLException e) {

			salida = "(SQLE)Se produjo un error al desaplicar  documentos";
			log.error("clientesMovCliDesaplicar(" + nrointerno_canc + ", "
					+ nrointerno_qcan + "): " + e);

		} catch (Exception e) {

			salida = "(EX)Se produjo un error al desaplicar  documentos";
			log.error("clientesMovCliDesaplicar(" + nrointerno_canc + ", "
					+ nrointerno_qcan + "): " + e);

		}

		if (salida.equalsIgnoreCase("OK")) {
			conn.commit();
		} else {
			conn.rollback();
		}

		conn.close();

		return salida;

	}

	// 20121004 - EJV - Mantis 882 -->

	/**
	 * Metodos para la entidad: clientesMovCliMotivosNc Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Oct 04 11:49:25 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesMovCliMotivosNcAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT idmotivonc,motivonc,afectastock,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM clientesmovclimotivosnc WHERE idempresa = "
				+ idempresa.toString()
				+ " AND idmotivonc > 0  ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovCliMotivosNcAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesMovCliMotivosNcOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idmotivonc,motivonc,afectastock,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM clientesmovclimotivosnc WHERE (UPPER(MOTIVONC) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  AND idmotivonc > 0  AND idempresa = "
				+ idempresa.toString() + " ORDER BY 2  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovCliMotivosNcOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesMovCliMotivosNcPK(BigDecimal idmotivonc,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idmotivonc,motivonc,afectastock,idempresa,usuarioalt,usuarioact,fechaalt,fechaact "
				+ "   FROM clientesmovclimotivosnc WHERE idmotivonc="
				+ idmotivonc.toString() + " AND idempresa = "
				+ idempresa.toString() + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesMovCliMotivosNcPK( BigDecimal idmotivonc )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesMovCliMotivosNcDelete(BigDecimal idmotivonc,
			BigDecimal idempresa) throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM clientesmovclimotivosnc WHERE idmotivonc="
				+ idmotivonc.toString()
				+ " AND idempresa="
				+ idempresa.toString();
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM clientesmovclimotivosnc WHERE idmotivonc="
						+ idmotivonc.toString().toString()
						+ " AND idempresa="
						+ idempresa.toString() + " AND idmotivonc > 0 ";
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesMovCliMotivosNcDelete( BigDecimal idmotivonc, BigDecimal idempresa ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesMovCliMotivosNcDelete( BigDecimal idmotivonc, BigDecimal idempresa )  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesMovCliMotivosNcCreate(String motivonc,
			String afectastock, BigDecimal idempresa, String usuarioalt)
			throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (motivonc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivonc ";
		if (afectastock == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: afectastock ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		// 2. sin nada desde la pagina
		if (motivonc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivonc ";
		if (afectastock.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: afectastock ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO clientesmovclimotivosnc(motivonc, afectastock, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, motivonc);
				insert.setString(2, afectastock);
				insert.setBigDecimal(3, idempresa);
				insert.setString(4, usuarioalt);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesMovCliMotivosNcCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesMovCliMotivosNcCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesMovCliMotivosNcCreateOrUpdate(BigDecimal idmotivonc,
			String motivonc, String afectastock, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivonc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivonc ";
		if (motivonc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivonc ";
		if (afectastock == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: afectastock ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (motivonc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivonc ";
		if (afectastock.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: afectastock ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesMovCliMotivosNc WHERE idmotivonc = "
					+ idmotivonc.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESMOVCLIMOTIVOSNC SET motivonc=?, afectastock=?, idempresa=?, usuarioact=?, fechaact=? WHERE idmotivonc=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivonc);
					insert.setString(2, afectastock);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivonc);
				} else {
					String ins = "INSERT INTO CLIENTESMOVCLIMOTIVOSNC(motivonc, afectastock, idempresa, usuarioalt ) VALUES (?, ?, ?, ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, motivonc);
					insert.setString(2, afectastock);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesMovCliMotivosNcCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesMovCliMotivosNcCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesMovCliMotivosNcUpdate(BigDecimal idmotivonc,
			String motivonc, String afectastock, BigDecimal idempresa,
			String usuarioact) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (idmotivonc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idmotivonc ";
		if (motivonc == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: motivonc ";
		if (afectastock == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: afectastock ";
		if (idempresa == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: idempresa ";

		// 2. sin nada desde la pagina
		if (motivonc.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: motivonc ";
		if (afectastock.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: afectastock ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesMovCliMotivosNc WHERE idmotivonc = "
					+ idmotivonc.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE clientesmovclimotivosnc SET motivonc=?, afectastock=?, idempresa=?, usuarioact=?, fechaact=? WHERE idmotivonc=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, motivonc);
					insert.setString(2, afectastock);
					insert.setBigDecimal(3, idempresa);
					insert.setString(4, usuarioact);
					insert.setTimestamp(5, fechaact);
					insert.setBigDecimal(6, idmotivonc);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesMovCliMotivosNcUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesMovCliMotivosNcUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	// <--

	/**
	 * Metodos para la entidad: clientesTarjetasGeneracion Copyrigth(r) sysWarp
	 * S.R.L. Fecha de creacion: Thu Nov 01 14:12:16 ART 2012
	 */
	// para todo (ordena por el segundo campo por defecto)
	public List getClientesTarjetasGeneracionAll(long limit, long offset,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT ge.idgeneracion, ge.idtarjetacredito, tm.tarjetacredito, ge.idclub, cb.club,  ge.periodo, ge.regenerar, ge.fecha_presentacion, "
				+ "             ge.idempresa, ge.usuarioalt, ge.usuarioact, ge.fechaalt, ge.fechaact "
				+ "   FROM clientestarjetasgeneracion ge "
				+ "             INNER JOIN clientetarjetascreditomarcas  tm ON ge.idtarjetacredito = tm.idtarjetacredito AND ge.idempresa = tm.idempresa "
				+ "             INNER JOIN clientesclub  cb ON ge.idclub = cb.idclub AND ge.idempresa = cb.idempresa "
				+ " WHERE ge.idempresa = " + idempresa.toString()
				+ "  ORDER BY 1 DESC  LIMIT " + limit + " OFFSET  " + offset
				+ ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasGeneracionAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesTarjetasGeneracionOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT ge.idgeneracion, ge.idtarjetacredito, tm.tarjetacredito, ge.idclub, cb.club,  ge.periodo, ge.regenerar, ge.fecha_presentacion, "
				+ "             ge.idempresa, ge.usuarioalt, ge.usuarioact, ge.fechaalt, ge.fechaact "
				+ "   FROM clientestarjetasgeneracion ge "
				+ "             INNER JOIN clientetarjetascreditomarcas  tm ON ge.idtarjetacredito = tm.idtarjetacredito AND ge.idempresa = tm.idempresa "
				+ "             INNER JOIN clientesclub  cb ON ge.idclub = cb.idclub AND ge.idempresa = cb.idempresa "
				+ " WHERE (UPPER(tm.tarjetacredito) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' OR  to_char( ge.fecha_presentacion, 'dd-mm-yyyy' ) LIKE '%"
				+ ocurrencia.toUpperCase().trim() + "%')  AND ge.idempresa = "
				+ idempresa.toString() + " ORDER BY 1 DESC  LIMIT " + limit
				+ " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesTarjetasGeneracionOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	/**
	 * Metodos para la entidad: vClientesMovCuoHist Copyrigth(r) sysWarp S.R.L.
	 * Fecha de creacion: Fri Nov 02 15:06:49 ART 2012
	 */

	// por primary key (primer campo por defecto)
	public List getVClientesMovCuoHistPK(BigDecimal idmovcuo,
			BigDecimal idempresa) throws EJBException {
		String cQuery = ""
				+ "SELECT  idlog,idmomentoproceso,momentoproceso,idmovcuo,numero_cuo,ninter_cuo,import_cuo,venci_cuo,saldo_cuo,idcondicion_cuo, "
				+ "              idtarjeta_cuo,tarjetacredito,nrotarjeta,periodo_cuo,fecha_envio_cuo,fecha_ctrl_cuo,estado_cuo,idclub,idmotivorechazo,motivorechazo,idgeneracion,fecha_trigger,"
				+ "              idempresa,usuarioalt,usuarioact,fechaalt,fechaact FROM vclientesmovcuohist"
				+ " WHERE idmovcuo=" + idmovcuo.toString()
				+ " AND idempresa = " + idempresa.toString()
				+ " ORDER BY idlog ASC;";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getVClientesMovCuoHistPK( Long idlog )  "
							+ ex);
		}
		return vecSalida;
	}

	/*
	 * Metodos para la entidad: clientesvendedorescomisiones Copyrigth(r)
	 * sysWarp S.R.L. Fecha de creacion: Fri Oct 26 10:25:12 ART 2012
	 */

	// para todo (ordena por el segundo campo por defecto)
	public List getClientesvendedorescomisionesAll(long limit, long offset)
			throws EJBException {
		String cQuery = "SELECT idcomision,descripcion,cantsociodesde,cantsociohasta,porcdeserdesde,porcdeserhasta,valorasociacion,porccartera,usuarioalt,usuarioact,fechaalt,fechaact,tipo FROM CLIENTESVENDEDORESCOMISIONES  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorescomisionesAll()  "
							+ ex);
		}
		return vecSalida;
	}

	// para una ocurrencia (ordena por el segundo campo por defecto)

	public List getClientesvendedorescomisionesOcu(long limit, long offset,
			String ocurrencia) throws EJBException {
		String cQuery = "SELECT  idcomision,descripcion,cantsociodesde,cantsociohasta,porcdeserdesde,porcdeserhasta,valorasociacion,porccartera,usuarioalt,usuarioact,fechaalt,fechaact,tipo FROM CLIENTESVENDEDORESCOMISIONES WHERE (UPPER(DESCRIPCION) LIKE '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%' or idcomision::varchar like '%"
				+ ocurrencia.toUpperCase().trim()
				+ "%')  ORDER BY 2  LIMIT "
				+ limit + " OFFSET  " + offset + ";";

		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorescomisionesOcu(String ocurrencia)  "
							+ ex);
		}
		return vecSalida;
	}

	// por primary key (primer campo por defecto)

	public List getClientesvendedorescomisionesPK(int idcomision)
			throws EJBException {
		String cQuery = "SELECT  idcomision,descripcion,cantsociodesde,cantsociohasta,porcdeserdesde,porcdeserhasta,valorasociacion,porccartera,usuarioalt,usuarioact,fechaalt,fechaact,tipo FROM CLIENTESVENDEDORESCOMISIONES WHERE idcomision="
				+ idcomision + ";";
		List vecSalida = new ArrayList();
		try {
			vecSalida = getLista(cQuery);
		} catch (Exception ex) {
			log
					.error("Salida por exception: en el metodo: getClientesvendedorescomisionesPK( Integer idcomision )  "
							+ ex);
		}
		return vecSalida;
	}

	// ELIMINACION DE UN REGISTRO por primary key (primer campo por defecto)

	public String clientesvendedorescomisionesDelete(int idcomision)
			throws EJBException {
		ResultSet rsSalida = null;
		String cQuery = "SELECT * FROM CLIENTESVENDEDORESCOMISIONES WHERE idcomision="
				+ idcomision;
		String salida = "NOOK";
		try {
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				cQuery = "DELETE FROM CLIENTESVENDEDORESCOMISIONES WHERE idcomision="
						+ idcomision;
				statement.execute(cQuery);
				salida = "Baja Correcta.";
			} else {
				salida = "Error: Registro inexistente";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Error SQL en el metodo : clientesvendedorescomisionesDelete( int idcomision ) "
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible eliminar el registro.";
			log
					.error("Salida por exception: en el metodo: clientesvendedorescomisionesDelete( int idcomision)  "
							+ ex);
		}
		return salida;
	}

	// grabacion de un nuevo registro NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria solo usuarioalt

	public String clientesvendedorescomisionesCreate(String descripcion,
			double cantsociodesde, double cantsociohasta,
			double porcdeserdesde, double porcdeserhasta,
			double valorasociacion, double porccartera, String usuarioalt,
			String tipo) throws EJBException {
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		if (usuarioalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: usuarioalt ";
		if (fechaalt == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: fechaalt ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		if (usuarioalt.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: usuarioalt ";

		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			if (!bError) {
				String ins = "INSERT INTO CLIENTESVENDEDORESCOMISIONES(descripcion, cantsociodesde, cantsociohasta, porcdeserdesde, porcdeserhasta, valorasociacion, porccartera, usuarioalt, fechaalt, tipo ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ? , ?)";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				// seteo de campos:
				insert.setString(1, descripcion);
				insert.setDouble(2, cantsociodesde);
				insert.setDouble(3, cantsociohasta);
				insert.setDouble(4, porcdeserdesde);
				insert.setDouble(5, porcdeserhasta);
				insert.setDouble(6, valorasociacion);
				insert.setDouble(7, porccartera);
				insert.setString(8, usuarioalt);
				insert.setTimestamp(9, fechaalt);
				insert.setString(10, tipo);
				int n = insert.executeUpdate();
				if (n == 1)
					salida = "Alta Correcta";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesvendedorescomisionesCreate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesvendedorescomisionesCreate(.....)"
							+ ex);
		}
		return salida;
	}

	// actualizacion de un registro por PK NOTA: no se tiene en cuenta el primer
	// registro por PK y los datos de auditoria

	public String clientesvendedorescomisionesCreateOrUpdate(int idcomision,
			String descripcion, double cantsociodesde, double cantsociohasta,
			double porcdeserdesde, double porcdeserhasta,
			double valorasociacion, double porccartera, String usuarioact,
			String tipo) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesvendedorescomisiones WHERE idcomision = "
					+ idcomision;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESVENDEDORESCOMISIONES SET descripcion=?, cantsociodesde=?, cantsociohasta=?, porcdeserdesde=?, porcdeserhasta=?, valorasociacion=?, porccartera=?, usuarioact=?, fechaact=?, tipo=? WHERE idcomision=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setDouble(2, cantsociodesde);
					insert.setDouble(3, cantsociohasta);
					insert.setDouble(4, porcdeserdesde);
					insert.setDouble(5, porcdeserhasta);
					insert.setDouble(6, valorasociacion);
					insert.setDouble(7, porccartera);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaalt);
					insert.setString(10, tipo);
					insert.setInt(11, idcomision);
				} else {
					String ins = "INSERT INTO CLIENTESVENDEDORESCOMISIONES(descripcion, cantsociodesde, cantsociohasta, porcdeserdesde, porcdeserhasta, valorasociacion, porccartera, usuarioalt, fechaalt, tipo ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ? , ?)";
					insert = dbconn.prepareStatement(ins);
					// seteo de campos:
					String usuarioalt = usuarioact;
					insert.setString(1, descripcion);
					insert.setDouble(2, cantsociodesde);
					insert.setDouble(3, cantsociohasta);
					insert.setDouble(4, porcdeserdesde);
					insert.setDouble(5, porcdeserhasta);
					insert.setDouble(6, valorasociacion);
					insert.setDouble(7, porccartera);
					insert.setString(8, usuarioalt);
					insert.setTimestamp(9, fechaalt);
				}
				insert.executeUpdate();
				salida = "Alta Correcta.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error SQL public String clientesvendedorescomisionesCreateOrUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String clientesvendedorescomisionesCreateOrUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	public String clientesvendedorescomisionesUpdate(int idcomision,
			String descripcion, double cantsociodesde, double cantsociohasta,
			double porcdeserdesde, double porcdeserhasta,
			double valorasociacion, double porccartera, String usuarioact,
			String tipo) throws EJBException {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaalt = new Timestamp(hoy.getTime().getTime());
		String salida = "NOOK";
		// validaciones de datos:
		// 1. nulidad de campos
		if (descripcion == null)
			salida = "Error: No se puede dejar sin datos (nulo) el campo: descripcion ";
		// 2. sin nada desde la pagina
		if (descripcion.equalsIgnoreCase(""))
			salida = "Error: No se puede dejar vacio el campo: descripcion ";
		// fin validaciones
		boolean bError = true;
		if (salida.equalsIgnoreCase("NOOK"))
			bError = false;
		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesvendedorescomisiones WHERE idcomision = "
					+ idcomision;
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next())
				total = rsSalida.getInt(1);
			PreparedStatement insert = null;
			String sql = "";
			if (!bError) {
				if (total > 0) { // si existe hago update
					sql = "UPDATE CLIENTESVENDEDORESCOMISIONES SET descripcion=?, cantsociodesde=?, cantsociohasta=?, porcdeserdesde=?, porcdeserhasta=?, valorasociacion=?, porccartera=?, usuarioact=?, fechaact=?, tipo=? WHERE idcomision=?;";
					insert = dbconn.prepareStatement(sql);
					insert.setString(1, descripcion);
					insert.setDouble(2, cantsociodesde);
					insert.setDouble(3, cantsociohasta);
					insert.setDouble(4, porcdeserdesde);
					insert.setDouble(5, porcdeserhasta);
					insert.setDouble(6, valorasociacion);
					insert.setDouble(7, porccartera);
					insert.setString(8, usuarioact);
					insert.setTimestamp(9, fechaalt);
					insert.setString(10, tipo);
					insert.setInt(11, idcomision);
				}

				int i = insert.executeUpdate();
				if (i > 0)
					salida = "Actualizacion Correcta";
				else
					salida = "Imposible actualizar el registro.";
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesvendedorescomisionesUpdate(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesvendedorescomisionesUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	/**
	 * Aplicacin automtica - pasaje de netbeans a my eclipse
	 * */

	public String AplicacionAutomaticaCobranzas(String[] args) {
		java.sql.ResultSet rsDeuda = null;
		java.sql.ResultSet rsCobranzas = null;
		String salida = "OK";
		// if (hasClientesDeudaConSaldo(new BigDecimal(894)) ||
		// hasClientesCobranzasConSaldo(new BigDecimal(894))) {
		log.info("Inicio de Aplicacion Automatica");
		if (hasClientesCobranzasConSaldo()) {
			ResultSet rsClientes = getClientesConSaldoAFavor();
			try {
				while (rsClientes.next()) {
					BigDecimal idcliente = rsClientes
							.getBigDecimal("idcliente");
					log.info("Procesando Cliente: " + idcliente);
					setAplicadorCobros(idcliente, "APLICADOR-AUTOMATICO",
							new BigDecimal(1));
				}
			} catch (SQLException ex) {
				// Logger.getLogger(AplicacionPagos.class.getName()).log(Level.SEVERE,
				// null, ex);
				salida = "NOOK";
				log
						.error("Error excepcion public String AplicacionAutomaticaCobranzas(String[] args)"
								+ ex);
			}
		}
		log.info("Fin del Aplicador.");
		return salida;
		// ahora cobro y me fijo si tengo facturas con saldo previo y se los
		// aplico.

	}

	private void setAplicadorCobros(BigDecimal idcliente, String usuarioact,
			BigDecimal idempresa) {
		BigDecimal nroInternoOrigen;
		BigDecimal nroInternoDestino;
		float saldoOrigen;

		Calendar calendar = Calendar.getInstance();
		java.util.Date now = calendar.getTime();
		java.sql.Timestamp currentTimestamp = new java.sql.Timestamp(now
				.getTime());

		try {
			java.sql.ResultSet rsOrigen = getClientesDeudaConSaldo(idcliente);
			while (rsOrigen.next()) {
				nroInternoOrigen = rsOrigen.getBigDecimal("nrointerno");
				saldoOrigen = rsOrigen.getFloat("saldo");
				float saldoDestino;
				float importeAplicado = 0;
				log.info("Nro Interno origen (FC/ND): " + nroInternoOrigen);

				java.sql.ResultSet rsDestino = getClientesCobranzasConSaldo(idcliente);
				while (rsDestino.next() && saldoOrigen > 0) {
					nroInternoDestino = rsDestino.getBigDecimal("nrointerno");
					saldoDestino = rsDestino.getFloat("saldo");
					log.info("Nro Interno destino (NC/COB/SALDO INICIAL): "
							+ nroInternoDestino);
					if (saldoOrigen - saldoDestino >= 0) {
						importeAplicado = saldoDestino;
						saldoOrigen -= saldoDestino;
						saldoDestino -= saldoDestino;
					} else {
						importeAplicado = saldoOrigen;
						saldoDestino = saldoDestino - saldoOrigen;
						saldoOrigen -= saldoOrigen;
					}

					// aca resta grabar, origen, destino y aplicacion. (caja
					// aplicaci).

					// ACTUALIZO SALDO ORIGEN
					String salidaMovcliOrigen = clientesMovCliUpdateSaldoAp(
							nroInternoOrigen, new BigDecimal(saldoOrigen),
							usuarioact, idempresa);
					// ACTUALIZO SALDO DESTINO
					String salidaMovcliDestino = clientesMovCliUpdateSaldoAp(
							nroInternoDestino, new BigDecimal(saldoDestino),
							usuarioact, idempresa);
					// GRABO CANCCLIE
					String salidaCancClie = clientesCancClieCreate(
							nroInternoOrigen, nroInternoDestino,
							new BigDecimal(importeAplicado), currentTimestamp,
							usuarioact, idempresa, dbconn);

					// 2012-09-11 : trabajo con las cuotas (utilizo importe
					// aplicado)

					java.sql.ResultSet rsCuotas = getMovCuotasPK(nroInternoOrigen);
					while (rsCuotas.next()) {
						BigDecimal curIdCuota = rsCuotas
								.getBigDecimal("idmovcuo");
						String curEstadoCuota = "P";
						float saldo_cuo = rsCuotas.getFloat("saldo_cuo");
						if (importeAplicado > 0) {
							if (importeAplicado < rsCuotas
									.getFloat("saldo_cuo")) {
								saldo_cuo = rsCuotas.getFloat("saldo_cuo")
										- importeAplicado;
								importeAplicado -= saldo_cuo;
							} else {
								saldo_cuo = 0;
								curEstadoCuota = "C";
								importeAplicado -= rsCuotas
										.getFloat("saldo_cuo");
							}
						}
						// 2013-05-10 solo debe cancelar la cuota si el saldo
						// queda en cero
						setCanceCuota(curIdCuota, new BigDecimal(saldo_cuo),
								curEstadoCuota, "APLICADOR-AUTOMATICO");
					}

				}

			}
		} catch (SQLException ex) {
			log.error("setAplicadorCobros " + ex);
		}
	}

	private ResultSet getClientesDeudaConSaldo(BigDecimal idCliente) {
		ResultSet rsSalida = null;
		String cQuery = "select nrointerno,cliente,fechamov,sucursal,comprob,tipomov,tipomovs,saldo,importe ";
		cQuery += "from clientesmovcli ";
		cQuery += "where saldo <> 0  and cliente = " + idCliente;
		cQuery += "and (tipomov = 1 or tipomov = 2) and anulada is null ";
		cQuery += "order by cliente, fechamov;";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return rsSalida;
	}

	private ResultSet getMovCuotasPK(BigDecimal nrointerno) {
		ResultSet rsSalida = null;
		String cQuery = " select idmovcuo, numero_cuo import_cuo, saldo_cuo ";
		cQuery += " from clientesmovcuota  ";
		cQuery += " where ninter_cuo = " + nrointerno;
		cQuery += " and estado_cuo in ('P','R') ";
		cQuery += " order by numero_cuo ";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("getMovCuotasPK Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("getMovCuotasPK Salida por exception: " + ex);
		}
		return rsSalida;
	}

	private ResultSet getClientesConSaldoAFavor() {
		ResultSet rsSalida = null;
		String cQuery = "select distinct cliente as idcliente   ";
		cQuery += " from clientesmovcli ";
		cQuery += " where saldo <> 0 and (tipomov=3 or tipomov=4) and anulada is null ";
		cQuery += " order by idcliente; ";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return rsSalida;
	}

	private boolean hasClientesDeudaConSaldo(BigDecimal idCliente) {
		ResultSet rsSalida = null;
		boolean salida = false;
		String cQuery = "select cliente ";
		cQuery += "from clientesmovcli ";
		cQuery += "where saldo <> 0  and cliente = " + idCliente;
		cQuery += "and (tipomov = 1 or tipomov = 2) and anulada is null ";
		cQuery += "order by cliente, fechamov;";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = true;
			}

		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return salida;
	}

	private boolean hasClientesCobranzasConSaldo() {
		ResultSet rsSalida = null;
		boolean salida = false;
		String cQuery = "select cliente ";
		cQuery += "from clientesmovcli ";
		cQuery += "where saldo > 0  ";
		cQuery += "and (tipomov = 3 or tipomov = 4) and anulada is null ";
		cQuery += "order by cliente, fechamov;";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = true;
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return salida;
	}

	private boolean hasClientesCobranzasConSaldo(BigDecimal idCliente) {
		ResultSet rsSalida = null;
		boolean salida = false;
		String cQuery = "select cliente ";
		cQuery += "from clientesmovcli ";
		cQuery += "where saldo <> 0  and cliente = " + idCliente;
		cQuery += "and (tipomov = 3 or tipomov = 4) and anulada is null ";
		cQuery += "order by cliente, fechamov;";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			if (rsSalida.next()) {
				salida = true;
			}
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return salida;
	}

	private ResultSet getClientesCobranzasConSaldo(BigDecimal idCliente) {
		ResultSet rsSalida = null;
		String cQuery = "select nrointerno,cliente,fechamov,sucursal,comprob,tipomov,tipomovs,saldo,importe ";
		cQuery += "from clientesmovcli ";
		cQuery += "where saldo <> 0  and cliente = " + idCliente;
		cQuery += "and (tipomov = 3 or tipomov = 4) and anulada is null ";
		cQuery += "order by cliente, fechamov;";
		try {
			java.sql.Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
		} catch (SQLException sqlException) {
			log.error("Error SQL: " + sqlException);
		} catch (Exception ex) {
			log.error("Salida por exception: " + ex);
		}
		return rsSalida;
	}

	// atencion que lo cambie!!!, el original es clientesMovCliUpdateSaldoAp
	private String clientesMovCliUpdateSaldoAp(BigDecimal nrointerno,
			BigDecimal saldo, String usuarioact, BigDecimal idempresa) {
		Calendar hoy = new GregorianCalendar();
		Timestamp fechaact = new Timestamp(hoy.getTime().getTime());
		String salida = "OK";

		try {
			ResultSet rsSalida = null;
			String cQuery = "SELECT COUNT(*) FROM clientesMovCli WHERE nrointerno = "
					+ nrointerno.toString()
					+ " AND idempresa="
					+ idempresa.toString();
			Statement statement = dbconn.createStatement();
			rsSalida = statement.executeQuery(cQuery);
			int total = 0;
			if (rsSalida != null && rsSalida.next()) {
				total = rsSalida.getInt(1);
			}
			PreparedStatement insert = null;
			String sql = "";
			if (salida.equalsIgnoreCase("OK")) {
				if (total > 0) { // si existe hago update

					sql = "UPDATE CLIENTESMOVCLI SET saldo=?, usuarioact=?, fechaact=? WHERE nrointerno=? AND idempresa=?;";
					insert = dbconn.prepareStatement(sql);

					// TODO: EJV 20090513
					// La condicion siguiente no tiene logica valida, reveer
					// porque
					// esta o que se pretendio hacer en el momento de crear el
					// metodo.
					// En el caso que se NC
					/*
					 * CEP : lo saque para este metodo. if (saldo.signum() !=
					 * -1) { saldo = saldo.negate(); }
					 */
					insert.setBigDecimal(1, saldo);
					insert.setString(2, usuarioact);
					insert.setTimestamp(3, fechaact);
					insert.setBigDecimal(4, nrointerno);
					insert.setBigDecimal(5, idempresa);
				}

				int i = insert.executeUpdate();
				if (i < 1) {
					salida = "Imposible actualizar saldo documento clientes.";
				}
			}
		} catch (SQLException sqlException) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error SQL public String clientesMovCliUpdateSaldo(.....)"
							+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible actualizar el registro.";
			log
					.error("Error excepcion public String clientesMovCliUpdate(.....)"
							+ ex);
		}
		return salida;
	}

	private String setCanceCuota(BigDecimal idmovcuo, BigDecimal saldo_cuo,
			String estadoCuota, String usuarioact) {
		String salida = "OK";

		try {
			if (salida.equalsIgnoreCase("OK")) {
				String ins = "UPDATE clientesmovcuota SET saldo_cuo = ?, estado_cuo = ?, usuarioact=?  WHERE idmovcuo = ? ";
				PreparedStatement insert = dbconn.prepareStatement(ins);
				insert.setBigDecimal(1, saldo_cuo);
				insert.setString(2, estadoCuota);
				insert.setString(3, usuarioact);
				insert.setBigDecimal(4, idmovcuo);
				int n = insert.executeUpdate();
				if (estadoCuota.equalsIgnoreCase("C"))
					log.error("CANCELANDO CUOTA: " + idmovcuo);
				else
					log.error("APLICANDO CUOTA EN FORMA PARCIAL: " + idmovcuo);
				if (n != 1) {
					salida = "Imposible crear cancelacion cuota";
				}

			}

		} catch (SQLException sqlException) {
			salida = "Imposible dar de alta el registro.";
			log.error("Error SQL public String setCanceCuota(.....)"
					+ sqlException);
		} catch (Exception ex) {
			salida = "Imposible dar de alta el registro.";
			log
					.error("Error excepcion public String setCanceCuota(.....)"
							+ ex);
		}
		return salida;

	}

	/**
	 * Metodos para la entidad: sasaccionescontactos Copyrigth(r) Juan Manuel
	 * Furattini Fecha de creacion: Sat Mar 08 09:30:00 ART 2013
	 */
	@Override
	public List<String[]> getSasAccionesContactosAll(long limit, long offset,
			BigDecimal idempresa) throws RemoteException {

		return accionContactoManager.getAll(dbconn, new AccionContacto(null,
				idempresa), limit, offset);
	}

	@Override
	public List<String[]> getSasAccionesContactosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws RemoteException {

		return accionContactoManager.getByOcurrence(dbconn, new AccionContacto(
				null, idempresa), ocurrencia, limit, offset);
	}

	@Override
	public List<String[]> getSasAccionesContactosPK(BigDecimal idaccioncontacto,
			BigDecimal idempresa) throws RemoteException {

		return accionContactoManager.getByPK(dbconn, new AccionContacto(
				idaccioncontacto, idempresa));
	}

	@Override
	public List<String[]> getSasAccionesContactosLista(BigDecimal idtipo,
			BigDecimal idcanal, BigDecimal idmotivo, BigDecimal idempresa)
			throws RemoteException {

			return accionContactoManager.getList(dbconn, 
					new AccionContacto(null, idtipo, idcanal, idmotivo, idempresa));
	}

	@Override
	public String sasAccionesContactosCreate(String accioncontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, String usuarioalt, BigDecimal idempresa)
			throws RemoteException {

		return accionContactoManager.create(dbconn, new AccionContacto(null,
				accioncontacto, idtipocontacto, idcanalcontacto,
				idmotivocontacto, usuarioalt, null, 
				DateAndTimeUtils.getCurrentDateAsTimestamp(), null, idempresa));
	}

	/*@Override
	public String sasAccionesContactosCreateOrUpdate(
			BigDecimal idaccioncontacto, String accioncontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, String usuario, BigDecimal idempresa)
			throws RemoteException {

		return accionContactoManager.createOrUpdate(dbconn, new AccionContacto(
				idaccioncontacto, accioncontacto, idtipocontacto, 
				idcanalcontacto, idmotivocontacto, usuario, usuario, 
				DateAndTimeUtils.getCurrentDateAsTimestamp(), 
				DateAndTimeUtils.getCurrentDateAsTimestamp(), idempresa));
	}*/

	@Override
	public String sasAccionesContactosDelete(BigDecimal idaccioncontacto,
			BigDecimal idempresa) throws RemoteException {

		return accionContactoManager.delete(dbconn, new AccionContacto(idaccioncontacto, idempresa));
	}

	@Override
	public String sasAccionesContactosUpdate(BigDecimal idaccioncontacto,
			String accioncontacto, BigDecimal idtipocontacto,
			BigDecimal idcanalcontacto, BigDecimal idmotivocontacto,
			String usuarioact, BigDecimal idempresa) throws RemoteException {

		return accionContactoManager.update(dbconn, new AccionContacto(
				idaccioncontacto, accioncontacto, idtipocontacto, idcanalcontacto, 
				idmotivocontacto, null, usuarioact, null,  
				DateAndTimeUtils.getCurrentDateAsTimestamp(), idempresa));
	}

	/**
	 * Metodos para la entidad: sasresultadoscontactos Copyrigth(r) Juan Manuel
	 * Furattini Fecha de creacion: Sat Mar 08 09:30:00 ART 2013
	 */
	@Override
	public List<String[]> getSasResultadosContactosAll(long limit, long offset,
			BigDecimal idempresa) throws RemoteException {

		return resultadoContactoManager.getAll(dbconn, new ResultadoContacto(null,
				idempresa), limit, offset);
	}

	@Override
	public List<String[]> getSasResultadosContactosOcu(long limit, long offset,
			String ocurrencia, BigDecimal idempresa) throws RemoteException {

		return resultadoContactoManager.getByOcurrence(dbconn, new ResultadoContacto(
				null, idempresa), ocurrencia, limit, offset);
	}

	@Override
	public List<String[]> getSasResultadosContactosPK(BigDecimal idresultadocontacto,
			BigDecimal idempresa) throws RemoteException {

		return resultadoContactoManager.getByPK(dbconn, new ResultadoContacto(
				idresultadocontacto, idempresa));
	}

	@Override
	public List<String[]> getSasResultadosContactosLista(BigDecimal idtipo,
			BigDecimal idcanal, BigDecimal idmotivo, BigDecimal idaccion,
			BigDecimal idempresa) throws RemoteException {

			return resultadoContactoManager.getList(dbconn, new ResultadoContacto(
					null, idtipo, idcanal, idmotivo, idaccion, idempresa));
	}

	@Override
	public String sasResultadosContactosCreate(String resultadocontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, BigDecimal idaccioncontacto,
			String usuarioalt, BigDecimal idempresa) throws RemoteException {

		return resultadoContactoManager.create(dbconn, new ResultadoContacto(null,
				resultadocontacto, idtipocontacto, idcanalcontacto,
				idmotivocontacto, idaccioncontacto, usuarioalt, null, 
				DateAndTimeUtils.getCurrentDateAsTimestamp(),
				null, idempresa));
	}

	/*@Override
	public String sasResultadosContactosCreateOrUpdate(
			BigDecimal idresultadocontacto, String resultadocontacto,
			BigDecimal idtipocontacto, BigDecimal idcanalcontacto,
			BigDecimal idmotivocontacto, BigDecimal idaccioncontacto,
			String usuario, BigDecimal idempresa) throws RemoteException {
		
		return resultadoContactoManager.createOrUpdate(dbconn, new ResultadoContacto(
				idresultadocontacto, resultadocontacto, idtipocontacto, 
				idcanalcontacto, idmotivocontacto, idaccioncontacto, usuario, usuario, 
				DateAndTimeUtils.getCurrentDateAsTimestamp(), 
				DateAndTimeUtils.getCurrentDateAsTimestamp(), idempresa));
	}*/

	@Override
	public String sasResultadosContactosDelete(BigDecimal idresultadocontacto,
			BigDecimal idempresa) throws RemoteException {

		return resultadoContactoManager.delete(dbconn, new ResultadoContacto(idresultadocontacto, idempresa));
	}

	@Override
	public String sasResultadosContactosUpdate(BigDecimal idresultadocontacto,
			String resultadocontacto, BigDecimal idtipocontacto,
			BigDecimal idcanalcontacto, BigDecimal idmotivocontacto,
			BigDecimal idaccioncontacto, String usuarioact, BigDecimal idempresa)
			throws RemoteException {

		return resultadoContactoManager.update(dbconn, new ResultadoContacto(
				idresultadocontacto, resultadocontacto, idtipocontacto, 
				idcanalcontacto, idmotivocontacto, idaccioncontacto, null, usuarioact, null,  
				DateAndTimeUtils.getCurrentDateAsTimestamp(), idempresa));
	}

}
